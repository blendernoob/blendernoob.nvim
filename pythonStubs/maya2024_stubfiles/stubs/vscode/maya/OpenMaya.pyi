
'''
Stub class file for:
OpenMaya

Maya2024 Python API stub file
Vscode Version
Generated from original Maya documentation.
Autodesk Maya2024  c1997-2023 Autodesk, Inc. All rights reserved. 
'''


from typing import overload




class MaterialInputData:
    '''Phong shading parameters for an
MPxMaterialInformation instance.
The
MaterialInputData class is used to specify the phong shading parameters to be used
with an
MPxMaterialInformation instance.
'''
    def __init__(self):
        pass


class MAddRemoveAttrEdit:
    '''Class for describing edits involving attributes which are added
or removed.
This class is used to represent information about edits involving
attributes which are added or removed. Such edits occur when
attributes are added or removed from nodes in a referenced file.
When a reference is unloaded, only the node and attribute name
may be queried successfully. When the referenced file is loaded,
the node itself may also be queried.
The
MItEdits class may be used to iterate over all the edits on a given
reference or assembly.
'''
    def __init__(self):
        pass


    def node(self, ReturnStatus: MAddRemoveAttrEdit.MStatus): 
        '''
        node(self, ReturnStatus: MAddRemoveAttrEdit.MStatus) -> MAddRemoveAttrEdit.OPENMAYA_MAJOR_NAMESPACE_OPEN MObject

        Synopsis
        -----
        Returns the depend node involved in this edit. The node can only
        be returned when the related reference or assembly is loaded.
        When the reference or assembly is unloaded, only the node name
        string may be queried successfully.

        Returns: 
        ----- 
        The node involved in this edit

        Parameters:
        -----
        ReturnStatus: MAddRemoveAttrEdit.MStatus
        	[out] -> Status Code


        '''
        pass

    def attributeName(self, ReturnStatus: MAddRemoveAttrEdit.MStatus): 
        '''
        attributeName(self, ReturnStatus: MAddRemoveAttrEdit.MStatus) -> MString

        Synopsis
        -----
        Returns the name of the attribute that was added or removed.

        Returns: 
        ----- 
        The name of the attribute involved in this edit

        Parameters:
        -----
        ReturnStatus: MAddRemoveAttrEdit.MStatus
        	[out] -> Status Code


        '''
        pass

    def nodeName(self, ReturnStatus: MAddRemoveAttrEdit.MStatus): 
        '''
        nodeName(self, ReturnStatus: MAddRemoveAttrEdit.MStatus) -> MString

        Synopsis
        -----
        Returns the name of the node where the attribute was added or
        removed.

        Returns: 
        ----- 
        The name of the node involved in this edit

        Parameters:
        -----
        ReturnStatus: MAddRemoveAttrEdit.MStatus
        	[out] -> Status Code


        '''
        pass

    def isAttributeAdded(self): 
        '''
        isAttributeAdded(self) -> bool

        Synopsis
        -----
        Returns true if this edit is for an added attribute, false for a
        removed attribute.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def editType(self, ReturnStatus: MAddRemoveAttrEdit.MStatus): 
        '''
        editType(self, ReturnStatus: MAddRemoveAttrEdit.MStatus) -> MEdit.MEdit

        Synopsis
        -----
        Virtual method used to return the edit type of this edit, which
        is MEdit::kAddRemoveAttrEdit. Reimplemented from MEdit.

        Returns: 
        ----- 
        MEdit::kAddRemoveAttrEdit

        Parameters:
        -----
        ReturnStatus: MAddRemoveAttrEdit.MStatus
        	[out] -> return status


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MAngle:
    '''Manipulate Angular Data.
Methods for setting and retreiving angular data in various unit
systems
The
MAngle class provides a fundamental type for the Maya API to hold and
manipulate angular data. All API methods that require or return
angular information do so through variables of this type.
'''
    def __init__(self):
        pass


    def unit(self): 
        '''
        unit(self) -> MAngle.MAngle

        Synopsis
        -----
        Current unit. Return the units currently in effect for this
        instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def value(self): 
        '''
        value(self) -> double

        Synopsis
        -----
        Current value. Return the value of the current instance in the
        currently set units.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setUnit(self, newUnit: MAngle.MAngle): 
        '''
        setUnit(self, newUnit: MAngle.MAngle)

        Synopsis
        -----
        Set current unit. Set the unit used by this instance. This will
        not affect the current value of the MAngle.

        Returns:
        -----
        None

        Parameters:
        -----
        newUnit: MAngle.MAngle
        	[in] -> An element of the 


        '''
        pass

    def setValue(self, newValue: double): 
        '''
        setValue(self, newValue: double)

        Synopsis
        -----
        Set current value. Set the value of this instance.

        Returns:
        -----
        None

        Parameters:
        -----
        newValue: double
        	[in] -> The new value in the units currently in effect


        '''
        pass

    def as_func(self, otherUnit: MAngle.MAngle,
                        ReturnStatus: MAngle.MStatus): 
        '''
        as_func(self, otherUnit: MAngle.MAngle,
                        ReturnStatus: MAngle.MStatus) -> double

        Synopsis
        -----
        Unit conversion. Return the current value of this instance in the
        provided units.

        Returns: 
        ----- 
        The current value in the given units

        Parameters:
        -----
        otherUnit: MAngle.MAngle
        	[in] -> An element of the 

        ReturnStatus: MAngle.MStatus
        	[out] -> Return status


        '''
        pass

    def asUnits(self, otherUnit: MAngle.MAngle,
                        ReturnStatus: MAngle.MStatus): 
        '''
        asUnits(self, otherUnit: MAngle.MAngle,
                        ReturnStatus: MAngle.MStatus) -> double

        Synopsis
        -----
        Unit conversion. Return the current value of this instance in the
        provided units.

        Returns: 
        ----- 
        The current value in the given units

        Parameters:
        -----
        otherUnit: MAngle.MAngle
        	[in] -> An element of the 

        ReturnStatus: MAngle.MStatus
        	[out] -> Return status


        '''
        pass

    def asRadians(self): 
        '''
        asRadians(self) -> double

        Synopsis
        -----
        Convert to radians. Return the current value of this instance in
        radians.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asDegrees(self): 
        '''
        asDegrees(self) -> double

        Synopsis
        -----
        Convert to degrees. Return the current value of this instance in
        degrees.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asAngMinutes(self): 
        '''
        asAngMinutes(self) -> double

        Synopsis
        -----
        Convert to minutes of arc. Return the current value of this
        instance in minutes of arc.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asAngSeconds(self): 
        '''
        asAngSeconds(self) -> double

        Synopsis
        -----
        Convert to seconds of arc. Return the current value of this
        instance in seconds of arc.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def uiUnit(self): 
        '''
        uiUnit(self) -> MAngle.MAngle

        Synopsis
        -----
        Working unit. Returns the Working Units (or UI units) chosen in
        the settings of the prefs window.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setUIUnit(self, newUnit: MAngle.MAngle): 
        '''
        setUIUnit(self, newUnit: MAngle.MAngle)

        Synopsis
        -----
        Set working unit. Set the unit system to be used by the user in
        the UI. This will not change the return value of the
        MAngle::value() method of this instance of MAngle.

        Returns:
        -----
        None

        Parameters:
        -----
        newUnit: MAngle.MAngle
        	[in] -> and element of the 


        '''
        pass

    def internalUnit(self): 
        '''
        internalUnit(self) -> MAngle.MAngle

        Synopsis
        -----
        Internal unit. Returns the internal unit system used by Maya.
        This is the unit system Maya stores angles in.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def internalToUI(self, internalValue: double): 
        '''
        internalToUI(self, internalValue: double) -> double

        Synopsis
        -----
        Unit conversion. Converts a value from Maya's internal units to
        the current units used in the UI.

        Returns: 
        ----- 
        The value in UI units

        Parameters:
        -----
        internalValue: double
        	[in] -> a value in internal units


        '''
        pass

    def uiToInternal(self, uiValue: double): 
        '''
        uiToInternal(self, uiValue: double) -> double

        Synopsis
        -----
        Unit conversion. Converts a value from the units Maya is
        currently uses in the UI to the Maya internal unit system.

        Returns: 
        ----- 
        The value in internal units.

        Parameters:
        -----
        uiValue: double
        	[in] -> a value in UI units


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class Unit:
    '''Available Unit Systems. 
    Non-functional class.  Values for this enum:
    kInvalid
    kRadians
    kDegrees
    kAngMinutes
    kAngSeconds
    kLast
    '''

    def __init__(self):
        pass

    def kInvalid(self):
        '''This is an enum of Unit.
        - Description: Invalid value. 
        - Value: 0
        '''
        pass

    def kRadians(self):
        '''This is an enum of Unit.
        - Description: Radians. 
        - Value: 1
        '''
        pass

    def kDegrees(self):
        '''This is an enum of Unit.
        - Description: Degrees. 
        - Value: 2
        '''
        pass

    def kAngMinutes(self):
        '''This is an enum of Unit.
        - Description: Minutes of Arc. 
        - Value: 3
        '''
        pass

    def kAngSeconds(self):
        '''This is an enum of Unit.
        - Description: Seconds of Arc. 
        - Value: 4
        '''
        pass

    def kLast(self):
        '''This is an enum of Unit.
        - Description: Last enum value. 
        - Value: 5
        '''
        pass

class MArgDatabase:
    '''Command argument list parser.
This class extends
MArgParser by providing the ability to retrieve flag parameters, command
arguments and command objects as selection lists.
See
MArgParser for more details on how command argument parsing works in
general.
'''
    def __init__(self):
        pass


    def getFlagArgument(self, flag: char,
                        index: int,
                        result: MSelectionList): 
        '''
        getFlagArgument(self, flag: char,
                        index: int,
                        result: MSelectionList)

        Synopsis
        -----
        Gets the value of the 'index'th parameter of the given flag as an
        MSelectionList.

        Returns:
        -----
        None

        Parameters:
        -----
        flag: char
        	[in] -> flag whose parameter is being requested 

        index: int
        	[in] -> index of the parameter 

        result: MSelectionList
        	[out] -> value of the parameter as an 


        '''
        pass

    def getCommandArgument(self, index: int,
                        result: MSelectionList): 
        '''
        getCommandArgument(self, index: int,
                        result: MSelectionList)

        Synopsis
        -----
        Gets the value of the requested command argument and appends it
        to the end of the MSelectionList that is passed in.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> index of the command argument 

        result: MSelectionList
        	[out] -> value of the argument as an 


        '''
        pass

    @overload
    def getObjects(self, result: MSelectionList): 
        '''
        getObjects(self, result: MSelectionList)

        Synopsis
        -----
        Gets the list of objects passed to the command as an
        MSelectionList.

        Returns:
        -----
        None

        Parameters:
        -----
        result: MSelectionList
        	[out] -> list of objects passed to the command


        '''
        pass

    @overload
    def getObjects(self, result: MStringArray): 
        '''
        getObjects(self, result: MStringArray)

        Synopsis
        -----
        Gets the list of objects passed to the command as an array of
        strings.

        Returns:
        -----
        None

        Parameters:
        -----
        result: MStringArray
        	[out] -> the list of objects passed to the command as an 


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MArgList:
    '''Create and retrieve argument lists.
This class is used to create and retrieve argument lists that can
be passed to API class methods that require arglists.
Do not use
MArgList to parse flags for a plug-in command as the flags will not work
if the command is called from Python. Use
MArgParser or
MArgDatabase instead.
'''
    def __init__(self):
        pass


    def length(self, ReturnStatus: MArgList.MStatus): 
        '''
        length(self, ReturnStatus: MArgList.MStatus) -> int

        Synopsis
        -----
        Returns the number of arguments in the arglist.

        Returns: 
        ----- 
        The number of arguments in the arglist.

        Parameters:
        -----
        ReturnStatus: MArgList.MStatus
        	[out] -> the return status


        '''
        pass

    def asBool(self, index: int,
                        ReturnStatus: MArgList.MStatus): 
        '''
        asBool(self, index: int,
                        ReturnStatus: MArgList.MStatus) -> bool

        Synopsis
        -----
        Return the value of the argument at a given position in the
        arglist as an bool.

        Returns: 
        ----- 
        The bool value of the indicated argument.

        Parameters:
        -----
        index: int
        	[in] -> the index of the desired argument 

        ReturnStatus: MArgList.MStatus
        	[out] -> the return status


        '''
        pass

    def asInt(self, index: int,
                        ReturnStatus: MArgList.MStatus): 
        '''
        asInt(self, index: int,
                        ReturnStatus: MArgList.MStatus) -> int

        Synopsis
        -----
        Return the value of the argument at a given position in the
        arglist as an integer.

        Returns: 
        ----- 
        The integer value of the indicated argument.

        Parameters:
        -----
        index: int
        	[in] -> the index of the desired argument 

        ReturnStatus: MArgList.MStatus
        	[out] -> the return status


        '''
        pass

    def asDouble(self, index: int,
                        ReturnStatus: MArgList.MStatus): 
        '''
        asDouble(self, index: int,
                        ReturnStatus: MArgList.MStatus) -> double

        Synopsis
        -----
        Return the value of the argument at a given position in the
        arglist as a double.

        Returns: 
        ----- 
        The double value of the indicated argument.

        Parameters:
        -----
        index: int
        	[in] -> the index of the desired argument 

        ReturnStatus: MArgList.MStatus
        	[out] -> the return status


        '''
        pass

    def asString(self, index: int,
                        ReturnStatus: MArgList.MStatus): 
        '''
        asString(self, index: int,
                        ReturnStatus: MArgList.MStatus) -> MString

        Synopsis
        -----
        Return the value of the argument at a given position in the
        arglist as an MString.

        Returns: 
        ----- 
        The MString value of the indicated argument.

        Parameters:
        -----
        index: int
        	[in] -> the index of the desired argument 

        ReturnStatus: MArgList.MStatus
        	[out] -> the return status


        '''
        pass

    def asDistance(self, index: int,
                        ReturnStatus: MArgList.MStatus): 
        '''
        asDistance(self, index: int,
                        ReturnStatus: MArgList.MStatus) -> MDistance

        Synopsis
        -----
        Return the value of the argument at a given position in the
        arglist as an MDistance.

        Returns: 
        ----- 
        The MDistance value of the indicated argument.

        Parameters:
        -----
        index: int
        	[in] -> the index of the desired argument 

        ReturnStatus: MArgList.MStatus
        	[out] -> the return status


        '''
        pass

    def asAngle(self, index: int,
                        ReturnStatus: MArgList.MStatus): 
        '''
        asAngle(self, index: int,
                        ReturnStatus: MArgList.MStatus) -> MAngle

        Synopsis
        -----
        Return the value of the argument at a given position in the
        arglist as an MAngle.

        Returns: 
        ----- 
        The MAngle value of the indicated argument.

        Parameters:
        -----
        index: int
        	[in] -> the index of the desired argument 

        ReturnStatus: MArgList.MStatus
        	[out] -> the return status


        '''
        pass

    def asTime(self, index: int,
                        ReturnStatus: MArgList.MStatus): 
        '''
        asTime(self, index: int,
                        ReturnStatus: MArgList.MStatus) -> MTime

        Synopsis
        -----
        Return the value of the argument at a given position in the
        arglist as an MTime.

        Returns: 
        ----- 
        The MTime value of the indicated argument.

        Parameters:
        -----
        index: int
        	[in] -> the index of the desired argument 

        ReturnStatus: MArgList.MStatus
        	[out] -> the return status


        '''
        pass

    def asVector(self, index: int,
                        numElements: int,
                        ReturnStatus: MArgList.MStatus): 
        '''
        asVector(self, index: int,
                        numElements: int,
                        ReturnStatus: MArgList.MStatus) -> MVector

        Synopsis
        -----
        Return the value of the argument at a given position in the
        arglist as an MVector.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> 

        numElements: int
        	[in] -> 

        ReturnStatus: MArgList.MStatus
        	[in] -> 


        '''
        pass

    def asPoint(self, index: int,
                        numElements: int,
                        ReturnStatus: MArgList.MStatus): 
        '''
        asPoint(self, index: int,
                        numElements: int,
                        ReturnStatus: MArgList.MStatus) -> MPoint

        Synopsis
        -----
        Return the value of the argument at a given position in the
        arglist as an MPoint.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> 

        numElements: int
        	[in] -> 

        ReturnStatus: MArgList.MStatus
        	[in] -> 


        '''
        pass

    def asMatrix(self, index: int,
                        ret: MArgList.MStatus): 
        '''
        asMatrix(self, index: int,
                        ret: MArgList.MStatus) -> MMatrix

        Synopsis
        -----
        Get the value of the MMatrix argument at a given position in the
        arglist.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> 

        ret: MArgList.MStatus
        	[in] -> 


        '''
        pass

    def asIntArray(self, index: int,
                        ReturnStatus: MArgList.MStatus): 
        '''
        asIntArray(self, index: int,
                        ReturnStatus: MArgList.MStatus) -> MIntArray

        Synopsis
        -----
        Get the value of the MIntArray argument at a given position in
        the arglist.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> 

        ReturnStatus: MArgList.MStatus
        	[in] -> 


        '''
        pass

    def asDoubleArray(self, index: int,
                        ReturnStatus: MArgList.MStatus): 
        '''
        asDoubleArray(self, index: int,
                        ReturnStatus: MArgList.MStatus) -> MDoubleArray

        Synopsis
        -----
        Get the value of the MDoubleArray argument at a given position in
        the arglist.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> 

        ReturnStatus: MArgList.MStatus
        	[in] -> 


        '''
        pass

    def asStringArray(self, index: int,
                        ReturnStatus: MArgList.MStatus): 
        '''
        asStringArray(self, index: int,
                        ReturnStatus: MArgList.MStatus) -> const MStringArray

        Synopsis
        -----
        Get the value of the MStringArray argument at a given position in
        the arglist.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> 

        ReturnStatus: MArgList.MStatus
        	[in] -> 


        '''
        pass

    def flagIndex(self, shortFlag: char,
                        longFlag: char): 
        '''
        flagIndex(self, shortFlag: char,
                        longFlag: char) -> int

        Synopsis
        -----
        Return the index entry of the requested flag, if it has been set.

        Returns: 
        ----- 
        The unsigned int index of the indicated argument if it has been
        set, kInvalidArgIndex otherwise.

        Parameters:
        -----
        shortFlag: char
        	[in] -> the short version of the flag 

        longFlag: char
        	[in] -> the int version of the flag (if any)


        '''
        pass

    @overload
    def addArg(self, arg: bool): 
        '''
        addArg(self, arg: bool)

        Synopsis
        -----
        Add a new bool argument to the arglist.

        Returns:
        -----
        None

        Parameters:
        -----
        arg: bool
        	[in] -> the new bool argument


        '''
        pass

    @overload
    def addArg(self, arg: int): 
        '''
        addArg(self, arg: int)

        Synopsis
        -----
        Add a new integer argument to the arglist.

        Returns:
        -----
        None

        Parameters:
        -----
        arg: int
        	[in] -> the new integer argument


        '''
        pass

    @overload
    def addArg(self, arg: double): 
        '''
        addArg(self, arg: double)

        Synopsis
        -----
        Add a new double argument to the arglist.

        Returns:
        -----
        None

        Parameters:
        -----
        arg: double
        	[in] -> the new double argument


        '''
        pass

    @overload
    def addArg(self, arg: MString): 
        '''
        addArg(self, arg: MString)

        Synopsis
        -----
        Add a new MString argument to the arglist.

        Returns:
        -----
        None

        Parameters:
        -----
        arg: MString
        	[in] -> the new 


        '''
        pass

    @overload
    def addArg(self, arg: MDistance): 
        '''
        addArg(self, arg: MDistance)

        Synopsis
        -----
        Add a new MDistance argument to the arglist.

        Returns:
        -----
        None

        Parameters:
        -----
        arg: MDistance
        	[in] -> the new 


        '''
        pass

    @overload
    def addArg(self, arg: MAngle): 
        '''
        addArg(self, arg: MAngle)

        Synopsis
        -----
        Add a new MAngle argument to the arglist.

        Returns:
        -----
        None

        Parameters:
        -----
        arg: MAngle
        	[in] -> the new 


        '''
        pass

    @overload
    def addArg(self, arg: MTime): 
        '''
        addArg(self, arg: MTime)

        Synopsis
        -----
        Add a new MTime argument to the arglist.

        Returns:
        -----
        None

        Parameters:
        -----
        arg: MTime
        	[in] -> the new 


        '''
        pass

    @overload
    def addArg(self, arg: MVector): 
        '''
        addArg(self, arg: MVector)

        Synopsis
        -----
        Add a new MVector argument to the arglist.

        Returns:
        -----
        None

        Parameters:
        -----
        arg: MVector
        	[in] -> the new 


        '''
        pass

    @overload
    def addArg(self, arg: MPoint): 
        '''
        addArg(self, arg: MPoint)

        Synopsis
        -----
        Add a new MPoint argument to the arglist.

        Returns:
        -----
        None

        Parameters:
        -----
        arg: MPoint
        	[in] -> the new 


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MArgParser:
    '''Command argument list parser.
This class is used to parse and store all of the flags, arguments
and objects which are passed to a command. The
MArgParser constructor accepts an
MSyntax object, which describes the format for a command, and uses it to
parse the command arguments into a form which is easy to query.
The documentation for
MSyntax describes three types of arguments to commands:
A command may accept either
 or
, but not both.
The flag names, numbers and types of parameters accepted by each
flag, number and types of command arguments, range of objects
accepted and whether Maya's current selection can be used in
place of missing objects, are all determined by the
MSyntax object passed to
MArgParser's constructor.
In normal usage a command's
 method would create an
MArgParser object by passing it an
MSyntax object which describes the command's syntax and an
MArgList containing the command line arguments specified in the command's
invocation. A successful return status from the constructor would
mean that command invocation was syntactically correct and the
other
MArgList methods could be used to extract the values of the arguments to
the command. A failure return status would mean that the command
invocation was syntactically incorrect and the command should
return without attempting any further processing of its
arguments. Note that in the case of a failure
MArgParser will automatically display an appropriate error message in the
Script Editor so the command is freed from having to do that
itself.
The
 method can be used to find out if a particular flag argument was
provided in the command invocation.
If a flag accepts one or more parameters, the
 and
 methods can be used to return its parameters.
If the same flag appears multiple times in the command line (i.e.
it was specified with
MSyntax::makeFlagMultiUse() to allow multiple uses per command invocation) the
 and
 methods will only be able to return parameters for the first use
of the flag. However,
getFlagArgumentList() provides the ability to access any of a multi-use flag's
instances.
If the command requires
 (i.e. the
 method was used to construct the syntax object), then
 and
 methods can be used to return the values of those arguments.
If the command requires
 then the
 method can be used to return those objects as an array of
strings.
'''
    def __init__(self):
        pass


    def isFlagSet(self, flag: char,
                        ReturnStatus: MArgParser.MStatus): 
        '''
        isFlagSet(self, flag: char,
                        ReturnStatus: MArgParser.MStatus) -> bool

        Synopsis
        -----
        Queries the arguments to the command to determine if the given
        flag is set.

        Returns: 
        ----- 
        true if given flag is set  false if given flag is not set

        Parameters:
        -----
        flag: char
        	[in] -> the flag whose state is to be queried 

        ReturnStatus: MArgParser.MStatus
        	[out] -> the return status


        '''
        pass

    def isEdit(self, ReturnStatus: MArgParser.MStatus): 
        '''
        isEdit(self, ReturnStatus: MArgParser.MStatus) -> bool

        Synopsis
        -----
        Determines if the edit flag was one of the arguments to the
        command. The edit flag in its short form is "-e", and in its int
        form is "-edit".

        Returns: 
        ----- 
        true if edit flag is set  false if edit flag is not set

        Parameters:
        -----
        ReturnStatus: MArgParser.MStatus
        	[out] -> the return status


        '''
        pass

    def isQuery(self, ReturnStatus: MArgParser.MStatus): 
        '''
        isQuery(self, ReturnStatus: MArgParser.MStatus) -> bool

        Synopsis
        -----
        Determines if the query flag was one of the arguments to the
        command. The query flag in its short form is "-q", and in its int
        form is "-query".

        Returns: 
        ----- 
        true if query flag is set  false if query flag is not set

        Parameters:
        -----
        ReturnStatus: MArgParser.MStatus
        	[out] -> the return status


        '''
        pass

    def numberOfFlagsUsed(self): 
        '''
        numberOfFlagsUsed(self) -> int

        Synopsis
        -----
        Returns the number of flags given on the command line. If a given
        flag appears multiple times it is only counted once. The
        numberOfFlagUses() method can be used to determine the number of
        times that a multi-use flag appears in the command line.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def numberOfFlagUses(self, flag: char): 
        '''
        numberOfFlagUses(self, flag: char) -> int

        Synopsis
        -----
        Returns the number of times the given flag was used on the
        command line.

        Returns: 
        ----- 
        Number of times the given flag was used on the command line

        Parameters:
        -----
        flag: char
        	[in] -> the flag whose argument is being requested


        '''
        pass

    @overload
    def getFlagArgument(self, flag: char,
                        index: int,
                        result: bool): 
        '''
        getFlagArgument(self, flag: char,
                        index: int,
                        result: bool)

        Synopsis
        -----
        Gets the value of the 'index'th parameter of the given flag as a
        boolean. Python NotesThis method is not available in Python.
        Please see the flagArgumentBool() method

        Returns:
        -----
        None

        Parameters:
        -----
        flag: char
        	[in] -> flag whose parameter is being requested 

        index: int
        	[in] -> index of the parameter to retrieve 

        result: bool
        	[out] -> value of the parameter as a boolean


        '''
        pass

    @overload
    def getFlagArgument(self, flag: char,
                        index: int,
                        result: int): 
        '''
        getFlagArgument(self, flag: char,
                        index: int,
                        result: int)

        Synopsis
        -----
        Gets the value of the 'index'th parameter of the given flag as an
        int. Python NotesThis method is not available in Python. Please
        see the flagArgumentInt() method

        Returns:
        -----
        None

        Parameters:
        -----
        flag: char
        	[in] -> flag whose parameter is being requested 

        index: int
        	[in] -> index of the parameter to retrieve 

        result: int
        	[out] -> value of the parameter as an int


        '''
        pass

    @overload
    def getFlagArgument(self, flag: char,
                        index: int,
                        result: double): 
        '''
        getFlagArgument(self, flag: char,
                        index: int,
                        result: double)

        Synopsis
        -----
        Gets the value of the 'index'th parameter of the given flag as a
        double. Python NotesThis method is not available in Python.
        Please see the flagArgumentDouble() method

        Returns:
        -----
        None

        Parameters:
        -----
        flag: char
        	[in] -> flag whose parameter is being requested 

        index: int
        	[in] -> index of the parameter to retrieve 

        result: double
        	[out] -> value of the parameter as a double


        '''
        pass

    @overload
    def getFlagArgument(self, flag: char,
                        index: int,
                        result: MString): 
        '''
        getFlagArgument(self, flag: char,
                        index: int,
                        result: MString)

        Synopsis
        -----
        Gets the value of the 'index'th parameter of the given flag as an
        MString. Python NotesThis method is not available in Python.
        Please see the flagArgumentString() method

        Returns:
        -----
        None

        Parameters:
        -----
        flag: char
        	[in] -> flag whose parameter is being requested 

        index: int
        	[in] -> index of the parameter to retrieve 

        result: MString
        	[out] -> value of the parameter as an 


        '''
        pass

    @overload
    def getFlagArgument(self, flag: char,
                        index: int,
                        result: int): 
        '''
        getFlagArgument(self, flag: char,
                        index: int,
                        result: int)

        Synopsis
        -----
        Gets the value of the 'index'th parameter of the given flag as an
        unsigned int. Python NotesThis method is not available in Python.
        Please see the flagArgumentInt() method

        Returns:
        -----
        None

        Parameters:
        -----
        flag: char
        	[in] -> flag whose parameter is being requested 

        index: int
        	[in] -> index of the parameter to retrieve 

        result: int
        	[out] -> value of the parameter as an unsigned int


        '''
        pass

    @overload
    def getFlagArgument(self, flag: char,
                        index: int,
                        result: MDistance): 
        '''
        getFlagArgument(self, flag: char,
                        index: int,
                        result: MDistance)

        Synopsis
        -----
        Gets the value of the 'index'th parameter of the given flag as an
        MDistance. Python NotesThis method is not available in Python.
        Please see the flagArgumentMDistance() method

        Returns:
        -----
        None

        Parameters:
        -----
        flag: char
        	[in] -> flag whose parameter is being requested 

        index: int
        	[in] -> index of the parameter to retrieve 

        result: MDistance
        	[out] -> value of the parameter as an 


        '''
        pass

    @overload
    def getFlagArgument(self, flag: char,
                        index: int,
                        result: MAngle): 
        '''
        getFlagArgument(self, flag: char,
                        index: int,
                        result: MAngle)

        Synopsis
        -----
        Gets the value of the 'index'th parameter of the given flag as an
        MAngle. Python NotesThis method is not available in Python.
        Please see the flagArgumentMAngle() method

        Returns:
        -----
        None

        Parameters:
        -----
        flag: char
        	[in] -> flag whose parameter is being requested 

        index: int
        	[in] -> index of the parameter to retrieve 

        result: MAngle
        	[out] -> value of the parameter as an 


        '''
        pass

    @overload
    def getFlagArgument(self, flag: char,
                        index: int,
                        result: MTime): 
        '''
        getFlagArgument(self, flag: char,
                        index: int,
                        result: MTime)

        Synopsis
        -----
        Gets the value of the 'index'th parameter of the given flag as an
        MTime. Python NotesThis method is not available in Python. Please
        see the flagArgumentMTime() method

        Returns:
        -----
        None

        Parameters:
        -----
        flag: char
        	[in] -> flag whose parameter is being requested 

        index: int
        	[in] -> index of the parameter to retrieve 

        result: MTime
        	[out] -> value of the parameter as an 


        '''
        pass

    def flagArgumentBool(self, flag: char,
                        index: int,
                        ReturnStatus: MArgParser.MStatus): 
        '''
        flagArgumentBool(self, flag: char,
                        index: int,
                        ReturnStatus: MArgParser.MStatus) -> bool

        Synopsis
        -----
        Gets the value of the 'index'th parameter of the given flag as a
        boolean.

        Returns: 
        ----- 
        The value of the parameter as a boolean

        Parameters:
        -----
        flag: char
        	[in] -> flag whose parameter is being requested 

        index: int
        	[in] -> index of the parameter to retrieve 

        ReturnStatus: MArgParser.MStatus
        	[out] -> the return status


        '''
        pass

    def flagArgumentInt(self, flag: char,
                        index: int,
                        ReturnStatus: MArgParser.MStatus): 
        '''
        flagArgumentInt(self, flag: char,
                        index: int,
                        ReturnStatus: MArgParser.MStatus) -> int

        Synopsis
        -----
        Gets the value of the 'index'th parameter of the given flag as an
        int.

        Returns: 
        ----- 
        The value of the parameter as an int

        Parameters:
        -----
        flag: char
        	[in] -> flag whose parameter is being requested 

        index: int
        	[in] -> index of the parameter to retrieve 

        ReturnStatus: MArgParser.MStatus
        	[out] -> the return status


        '''
        pass

    def flagArgumentDouble(self, flag: char,
                        index: int,
                        ReturnStatus: MArgParser.MStatus): 
        '''
        flagArgumentDouble(self, flag: char,
                        index: int,
                        ReturnStatus: MArgParser.MStatus) -> double

        Synopsis
        -----
        Gets the value of the 'index'th parameter of the given flag as a
        double.

        Returns: 
        ----- 
        The value of the parameter as a double

        Parameters:
        -----
        flag: char
        	[in] -> flag whose parameter is being requested 

        index: int
        	[in] -> index of the parameter to retrieve 

        ReturnStatus: MArgParser.MStatus
        	[out] -> the return status


        '''
        pass

    def flagArgumentString(self, flag: char,
                        index: int,
                        ReturnStatus: MArgParser.MStatus): 
        '''
        flagArgumentString(self, flag: char,
                        index: int,
                        ReturnStatus: MArgParser.MStatus) -> MString

        Synopsis
        -----
        Gets the value of the 'index'th parameter of the given flag as an
        MString.

        Returns: 
        ----- 
        The value of the parameter as a string

        Parameters:
        -----
        flag: char
        	[in] -> flag whose parameter is being requested 

        index: int
        	[in] -> index of the parameter to retrieve 

        ReturnStatus: MArgParser.MStatus
        	[out] -> the return status


        '''
        pass

    def flagArgumentMDistance(self, flag: char,
                        index: int,
                        ReturnStatus: MArgParser.MStatus): 
        '''
        flagArgumentMDistance(self, flag: char,
                        index: int,
                        ReturnStatus: MArgParser.MStatus) -> MDistance

        Synopsis
        -----
        Gets the value of the 'index'th parameter of the given flag as an
        MDistance.

        Returns: 
        ----- 
        The value of the parameter as an MDistance

        Parameters:
        -----
        flag: char
        	[in] -> flag whose parameter is being requested 

        index: int
        	[in] -> index of the parameter to retrieve 

        ReturnStatus: MArgParser.MStatus
        	[out] -> the return status


        '''
        pass

    def flagArgumentMAngle(self, flag: char,
                        index: int,
                        ReturnStatus: MArgParser.MStatus): 
        '''
        flagArgumentMAngle(self, flag: char,
                        index: int,
                        ReturnStatus: MArgParser.MStatus) -> MAngle

        Synopsis
        -----
        Gets the value of the 'index'th parameter of the given flag as an
        MAngle.

        Returns: 
        ----- 
        The value of the parameter as an MAngle

        Parameters:
        -----
        flag: char
        	[in] -> flag whose parameter is being requested 

        index: int
        	[in] -> index of the parameter to retrieve 

        ReturnStatus: MArgParser.MStatus
        	[out] -> the return status


        '''
        pass

    def flagArgumentMTime(self, flag: char,
                        index: int,
                        ReturnStatus: MArgParser.MStatus): 
        '''
        flagArgumentMTime(self, flag: char,
                        index: int,
                        ReturnStatus: MArgParser.MStatus) -> MTime

        Synopsis
        -----
        Gets the value of the 'index'th parameter of the given flag as an
        MTime.

        Returns: 
        ----- 
        The value of the parameter as an MTime

        Parameters:
        -----
        flag: char
        	[in] -> flag whose parameter is being requested 

        index: int
        	[in] -> index of the parameter to retrieve 

        ReturnStatus: MArgParser.MStatus
        	[out] -> the return status


        '''
        pass

    def getFlagArgumentPosition(self, flag: char,
                        i: int,
                        position: int): 
        '''
        getFlagArgumentPosition(self, flag: char,
                        i: int,
                        position: int)

        Synopsis
        -----
        Returns the position in the command line of the i'th usage of the
        specified flag. This call is only valid if the flag has been
        marked as available for multi-usage with
        MSyntax::makeFlagMultiUse

        Returns:
        -----
        None

        Parameters:
        -----
        flag: char
        	[in] -> flag whose position is being requested 

        i: int
        	[in] -> desired instance of the flag on the command line 

        position: int
        	[out] -> position in the command line of the i'th usage of the specified flag


        '''
        pass

    def getFlagArgumentList(self, flag: char,
                        i: int,
                        args: MArgList): 
        '''
        getFlagArgumentList(self, flag: char,
                        i: int,
                        args: MArgList)

        Synopsis
        -----
        Returns an MArgList containing the parameters to the i'th usage
        of the specified flag. This call is only valid if the flag has
        been marked as available for multi-usage with
        MSyntax::makeFlagMultiUse

        Returns:
        -----
        None

        Parameters:
        -----
        flag: char
        	[in] -> the flag whose parameters are being requested 

        i: int
        	[in] -> the desired instance of the flag on the command line 

        args: MArgList
        	[out] -> the parameters to the i'th usage of the specified flag


        '''
        pass

    @overload
    def getCommandArgument(self, index: int,
                        result: bool): 
        '''
        getCommandArgument(self, index: int,
                        result: bool)

        Synopsis
        -----
        Gets the value of the requested command argument to the command
        as a boolean. Python NotesThis method is not available in Python.
        Please see the commandArgumentBool() method

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the index of the argument of the command 

        result: bool
        	[out] -> the value of the argument as a boolean


        '''
        pass

    @overload
    def getCommandArgument(self, index: int,
                        result: int): 
        '''
        getCommandArgument(self, index: int,
                        result: int)

        Synopsis
        -----
        Gets the value of the requested command argument to the command
        as an int. Python NotesThis method is not available in Python.
        Please see the commandArgumentBool() method

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the index of the argument of the command 

        result: int
        	[out] -> the value of the argument as a int


        '''
        pass

    @overload
    def getCommandArgument(self, index: int,
                        result: double): 
        '''
        getCommandArgument(self, index: int,
                        result: double)

        Synopsis
        -----
        Gets the value of the requested command argument to the command
        as a double. Python NotesThis method is not available in Python.
        Please see the commandArgumentBool() method

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the index of the argument of the command 

        result: double
        	[out] -> the value of the argument as a double


        '''
        pass

    @overload
    def getCommandArgument(self, index: int,
                        result: MString): 
        '''
        getCommandArgument(self, index: int,
                        result: MString)

        Synopsis
        -----
        Gets the value of the requested command argument to the command
        as an MString. Python NotesThis method is not available in
        Python. Please see the commandArgumentBool() method

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the index of the argument of the command 

        result: MString
        	[out] -> the value of the argument as an 


        '''
        pass

    @overload
    def getCommandArgument(self, index: int,
                        result: MDistance): 
        '''
        getCommandArgument(self, index: int,
                        result: MDistance)

        Synopsis
        -----
        Gets the value of the requested command argument to the command
        as an MDistance. Python NotesThis method is not available in
        Python. Please see the commandArgumentBool() method

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the index of the argument of the command 

        result: MDistance
        	[out] -> the value of the argument as an 


        '''
        pass

    @overload
    def getCommandArgument(self, index: int,
                        result: MAngle): 
        '''
        getCommandArgument(self, index: int,
                        result: MAngle)

        Synopsis
        -----
        Gets the value of the requested command argument to the command
        as an MAngle. Python NotesThis method is not available in Python.
        Please see the commandArgumentBool() method

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the index of the argument of the command 

        result: MAngle
        	[out] -> the value of the argument as an 


        '''
        pass

    @overload
    def getCommandArgument(self, index: int,
                        result: MTime): 
        '''
        getCommandArgument(self, index: int,
                        result: MTime)

        Synopsis
        -----
        Gets the value of the requested command argument to the command
        as an MTime. Python NotesThis method is not available in Python.
        Please see the commandArgumentBool() method

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the index of the argument of the command 

        result: MTime
        	[out] -> the value of the argument as an 


        '''
        pass

    def commandArgumentBool(self, index: int,
                        ReturnStatus: MArgParser.MStatus): 
        '''
        commandArgumentBool(self, index: int,
                        ReturnStatus: MArgParser.MStatus) -> bool

        Synopsis
        -----
        Gets the value of the requested command argument as a boolean.

        Returns: 
        ----- 
        The value of the argument as a boolean

        Parameters:
        -----
        index: int
        	[in] -> the index of the argument to the command 

        ReturnStatus: MArgParser.MStatus
        	[out] -> the return status


        '''
        pass

    def commandArgumentInt(self, index: int,
                        ReturnStatus: MArgParser.MStatus): 
        '''
        commandArgumentInt(self, index: int,
                        ReturnStatus: MArgParser.MStatus) -> int

        Synopsis
        -----
        Gets the value of the requested command argument as an int.

        Returns: 
        ----- 
        The value of the argument as an int

        Parameters:
        -----
        index: int
        	[in] -> the index of the argument to the command 

        ReturnStatus: MArgParser.MStatus
        	[out] -> the return status


        '''
        pass

    def commandArgumentDouble(self, index: int,
                        ReturnStatus: MArgParser.MStatus): 
        '''
        commandArgumentDouble(self, index: int,
                        ReturnStatus: MArgParser.MStatus) -> double

        Synopsis
        -----
        Gets the value of the requested command argument as a double.

        Returns: 
        ----- 
        The value of the argument as a double

        Parameters:
        -----
        index: int
        	[in] -> the index of the argument to the command 

        ReturnStatus: MArgParser.MStatus
        	[out] -> the return status


        '''
        pass

    def commandArgumentString(self, index: int,
                        ReturnStatus: MArgParser.MStatus): 
        '''
        commandArgumentString(self, index: int,
                        ReturnStatus: MArgParser.MStatus) -> MString

        Synopsis
        -----
        Gets the value of the requested command argument as a string.

        Returns: 
        ----- 
        The value of the argument as a string

        Parameters:
        -----
        index: int
        	[in] -> the index of the argument to the command 

        ReturnStatus: MArgParser.MStatus
        	[out] -> the return status


        '''
        pass

    def commandArgumentMDistance(self, index: int,
                        ReturnStatus: MArgParser.MStatus): 
        '''
        commandArgumentMDistance(self, index: int,
                        ReturnStatus: MArgParser.MStatus) -> MDistance

        Synopsis
        -----
        Gets the value of the requested command argument as a MDistance.

        Returns: 
        ----- 
        The value of the argument as a MDistance

        Parameters:
        -----
        index: int
        	[in] -> the index of the argument to the command 

        ReturnStatus: MArgParser.MStatus
        	[out] -> the return status


        '''
        pass

    def commandArgumentMAngle(self, index: int,
                        ReturnStatus: MArgParser.MStatus): 
        '''
        commandArgumentMAngle(self, index: int,
                        ReturnStatus: MArgParser.MStatus) -> MAngle

        Synopsis
        -----
        Gets the value of the requested command argument as a MAngle.

        Returns: 
        ----- 
        The value of the argument as a MAngle

        Parameters:
        -----
        index: int
        	[in] -> the index of the argument to the command 

        ReturnStatus: MArgParser.MStatus
        	[out] -> the return status


        '''
        pass

    def commandArgumentMTime(self, index: int,
                        ReturnStatus: MArgParser.MStatus): 
        '''
        commandArgumentMTime(self, index: int,
                        ReturnStatus: MArgParser.MStatus) -> MTime

        Synopsis
        -----
        Gets the value of the requested command argument as a MTime.

        Returns: 
        ----- 
        The value of the argument as a MTime

        Parameters:
        -----
        index: int
        	[in] -> the index of the argument to the command 

        ReturnStatus: MArgParser.MStatus
        	[out] -> the return status


        '''
        pass

    def getObjects(self, result: MStringArray): 
        '''
        getObjects(self, result: MStringArray)

        Synopsis
        -----
        Gets the list of objects passed to the command as an array of
        strings.

        Returns:
        -----
        None

        Parameters:
        -----
        result: MStringArray
        	[out] -> the list of objects passed to the command as an 


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MArrayDataBuilder:
    '''Array builder for arrays in data blocks.
An
MArrayDataBuilder is used to construct data for attributes/plugs that have an
array of data. An array builder is used with an
MArrayDataHandle for managing data.
'''
    def __init__(self):
        pass


    def addLast(self, ReturnStatus: MArrayDataBuilder.MStatus): 
        '''
        addLast(self, ReturnStatus: MArrayDataBuilder.MStatus) -> MDataHandle

        Synopsis
        -----
        Adds a new element to the end of the array. The index of the
        element will be the current highest index + 1.

        Returns: 
        ----- 
        The handle for the new element

        Parameters:
        -----
        ReturnStatus: MArrayDataBuilder.MStatus
        	[out] -> result status code


        '''
        pass

    def addElement(self, index: int,
                        ReturnStatus: MArrayDataBuilder.MStatus): 
        '''
        addElement(self, index: int,
                        ReturnStatus: MArrayDataBuilder.MStatus) -> MDataHandle

        Synopsis
        -----
        Adds a new element to the array at the given index.

        Returns: 
        ----- 
        The handle for the new element

        Parameters:
        -----
        index: int
        	[in] -> the index at which we wish to add the new element 

        ReturnStatus: MArrayDataBuilder.MStatus
        	[out] -> result status code


        '''
        pass

    def addLastArray(self, ReturnStatus: MArrayDataBuilder.MStatus): 
        '''
        addLastArray(self, ReturnStatus: MArrayDataBuilder.MStatus) -> MArrayDataHandle

        Synopsis
        -----
        Adds a new element to the end of the array. The added element is
        also an array. The index of the element will the current highest
        index + 1.

        Returns: 
        ----- 
        The handle for the new array element

        Parameters:
        -----
        ReturnStatus: MArrayDataBuilder.MStatus
        	[out] -> result status code


        '''
        pass

    def addElementArray(self, index: int,
                        ReturnStatus: MArrayDataBuilder.MStatus): 
        '''
        addElementArray(self, index: int,
                        ReturnStatus: MArrayDataBuilder.MStatus) -> MArrayDataHandle

        Synopsis
        -----
        Adds a new element to the array at the given index. The added
        element is also an array.

        Returns: 
        ----- 
        The handle for the new array element

        Parameters:
        -----
        index: int
        	[in] -> the index at which we wish to add the new element 

        ReturnStatus: MArrayDataBuilder.MStatus
        	[out] -> result status code


        '''
        pass

    def removeElement(self, index: int): 
        '''
        removeElement(self, index: int)

        Synopsis
        -----
        Removes the specified element from the array.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the element of the array to remove


        '''
        pass

    def elementCount(self, ReturnStatus: MArrayDataBuilder.MStatus): 
        '''
        elementCount(self, ReturnStatus: MArrayDataBuilder.MStatus) -> int

        Synopsis
        -----
        Returns the number of elements in the array.

        Returns: 
        ----- 
        The number of elements

        Parameters:
        -----
        ReturnStatus: MArrayDataBuilder.MStatus
        	[out] -> result status code


        '''
        pass

    def growArray(self, amount: int): 
        '''
        growArray(self, amount: int)

        Synopsis
        -----
        Grows the array storage by the given amount.

        Returns:
        -----
        None

        Parameters:
        -----
        amount: int
        	[in] -> the amount to grow the array by


        '''
        pass

    def setGrowSize(self, size: int): 
        '''
        setGrowSize(self, size: int)

        Synopsis
        -----
        Sets the grow size of the array. As elements are added to the
        array, the builder will allocate memory in chunks. This method
        tells the builder how many elements to allocate each time it
        grows the array.

        Returns:
        -----
        None

        Parameters:
        -----
        size: int
        	[in] -> the number of elements to allocate when growing the array


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MArrayDataHandle:
    '''Data block handle for array data.
An
MArrayDataHandle is a smart pointer into a data block (
MDataBlock) that handles access to array data.
MArrayDataHandle supports attributes that can have an array of data.
The array indices do not have to be continuous. The array can be
sparse. Thus, an array could have four elements with the indicies
1, 6, 8, and 10.
MArrayDataHandle methods cannot be assumed to be threadsafe. The
jumpToElement() method sets an internal pointer so definitely cannot be called
by multiple threads simultaneously.
'''
    def __init__(self):
        pass


    def inputValue(self, ReturnStatus: MArrayDataHandle.MStatus): 
        '''
        inputValue(self, ReturnStatus: MArrayDataHandle.MStatus) -> MDataHandle

        Synopsis
        -----
        Gets a handle into this data block for the current array element.
        The data represented by the handle will be valid. If the data is
        from an dirty connection, then the connection will be
        evaluated.It is important to note that you can not call
        inputValue on an element that is greater than the elementCount in
        this arrayDataHandle. That is, calls to inputValue must be
        protected by a call to elementCount to ensure the element exists.
        If this is not done, the call to inputValue will fail with an
        invalidParameter error.The data handle that this arrayDataHandle
        represents must come from a valid data block, such as one
        returned from one of the MDataBlock methods like
        MDataBlock::inputValue(). If a data handle created and returned
        from MPlug::getValue() or MPlug::asMDataHandle() is passed to
        this arrayDataHandle, then the use of this method will be invalid
        as it cannot legally trigger evaluation. See
        MArrayDataHandle::outputValue() instead.

        Returns: 
        ----- 
        Data handle for the current element's data

        Parameters:
        -----
        ReturnStatus: MArrayDataHandle.MStatus
        	[out] -> return status


        '''
        pass

    def outputValue(self, ReturnStatus: MArrayDataHandle.MStatus): 
        '''
        outputValue(self, ReturnStatus: MArrayDataHandle.MStatus) -> MDataHandle

        Synopsis
        -----
        Gets a handle into this data block for the current array element.
        The data is not guaranteed to be valid. Therefore, this handle
        should only be used for writing over the data.This method can
        also be used to retrieve handles to individual elements of non-
        datablock array handles, such as those returned by
        MPlug::getValue() and MPlug::asMDataHandle().

        Returns: 
        ----- 
        Data handle for the current element's data

        Parameters:
        -----
        ReturnStatus: MArrayDataHandle.MStatus
        	[out] -> return status


        '''
        pass

    def inputArrayValue(self, ReturnStatus: MArrayDataHandle.MStatus): 
        '''
        inputArrayValue(self, ReturnStatus: MArrayDataHandle.MStatus) -> MArrayDataHandle

        Synopsis
        -----
        Gets a handle into this data block for the current array element.
        This method should be used when the array elements are also
        arrays. The data represented by the handle will be valid. If the
        data is from an dirty connection, then the connection will be
        evailuated.It is important to note that you can not call
        inputArrayValue on an element that is greater than the
        elementCount in this arrayDataHandle. That is, calls to
        inputValue must be protected by a call to elementCount to ensure
        the element exists. If this is not done, the the call to
        inputArrayValue will fail with an invalidParameter error.The data
        handle that this arrayDataHandle represents must come from a
        valid data block, such as one returned from one of the MDataBlock
        methods like MDataBlock::inputValue(). If a data handle created
        and returned from MPlug::getValue() or MPlug::asMDataHandle() is
        passed to this arrayDataHandle, then the use of this method will
        be invalid as it cannot legally trigger evaluation. See
        MArrayDataHandle::outputValue() instead.

        Returns: 
        ----- 
        Data handle for the current element's data

        Parameters:
        -----
        ReturnStatus: MArrayDataHandle.MStatus
        	[out] -> return status


        '''
        pass

    def outputArrayValue(self, ReturnStatus: MArrayDataHandle.MStatus): 
        '''
        outputArrayValue(self, ReturnStatus: MArrayDataHandle.MStatus) -> MArrayDataHandle

        Synopsis
        -----
        Gets a handle into this data block for the current array element.
        This method should be used when the array elements are also
        arrays. The data is not guaranteed to be valid. Therefore, this
        handle should only be used for writing over the data.The data
        handle that this arrayDataHandle represents must come from a
        valid data block, such as one returned from one of the MDataBlock
        methods like MDataBlock::inputValue(). If a data handle created
        and returned from MPlug::getValue() or MPlug::asMDataHandle() is
        passed to this arrayDataHandle, then the use of this method will
        be invalid as it cannot legally trigger evaluation. See
        MArrayDataHandle::outputValue() instead.

        Returns: 
        ----- 
        Data handle for the current element's data

        Parameters:
        -----
        ReturnStatus: MArrayDataHandle.MStatus
        	[out] -> return status


        '''
        pass

    def next(self): 
        '''
        next(self)

        Synopsis
        -----
        Advance to the next element in the array. These may be sparse
        arrays so the next consecutive element may not necessarily have a
        consecutive index.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def elementCount(self, ReturnStatus: MArrayDataHandle.MStatus): 
        '''
        elementCount(self, ReturnStatus: MArrayDataHandle.MStatus) -> int

        Synopsis
        -----
        Returns the number of elements in the array.

        Returns: 
        ----- 
        The number of elements

        Parameters:
        -----
        ReturnStatus: MArrayDataHandle.MStatus
        	[out] -> return status


        '''
        pass

    def elementIndex(self, ReturnStatus: MArrayDataHandle.MStatus): 
        '''
        elementIndex(self, ReturnStatus: MArrayDataHandle.MStatus) -> int

        Synopsis
        -----
        Returns the index that we are currently at in the array. It is
        possible for the index to be invalid, in which case the return
        status will report an error. These may be sparse arrays so the
        element index returned will be a logical index.

        Returns: 
        ----- 
        The current element's logical index

        Parameters:
        -----
        ReturnStatus: MArrayDataHandle.MStatus
        	[out] -> return status


        '''
        pass

    def jumpToElement(self, index: int): 
        '''
        jumpToElement(self, index: int)

        Synopsis
        -----
        Jump to a specific element in the array. The array is sparse, so
        the indices may not be consecutive.NOTE: The index is the logical
        element index, which may be sparse.Jumping to an element is done
        through a binary search, with heuristics that improve the
        starting point for the search for simpler cases, such as:In those
        cases the search will be more likely to find the right spot in
        one or two guesses instead of always needing to search over the
        entire range. The algorithm is therefore still O(logn) in the
        worst case (as a typical binary search), but it should average
        closer to O(1) if the dataset is not very sparse and if it is
        being searched iteratively, in order.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the logical index to jump to


        '''
        pass

    def jumpToArrayElement(self, position: int): 
        '''
        jumpToArrayElement(self, position: int)

        Synopsis
        -----
        Jump to a specific array element in the array. This method can be
        used to iterate over the entire array.NOTE: Jumping to an array
        element does not require a search, since the array indices are
        non-sparse. The MArrayDataHandle::elementIndex() method can be
        used to determine the logical index related to the current array
        index.

        Returns:
        -----
        None

        Parameters:
        -----
        position: int
        	[in] -> the array position to jump to


        '''
        pass

    def setClean(self): 
        '''
        setClean(self)

        Synopsis
        -----
        Marks the data that is represented by this handle as being clean.
        This should be done after recalculating the data from the
        inputs.The data handle that this arrayDataHandle represents must
        come from a valid data block, such as one returned from one of
        the MDataBlock methods like MDataBlock::inputValue(). If a data
        handle created and returned from MPlug::getValue() or
        MPlug::asMDataHandle() is passed to this arrayDataHandle, then
        the use of this method will be invalid.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setAllClean(self): 
        '''
        setAllClean(self)

        Synopsis
        -----
        Marks every element of the array attribute represented by the
        handle as clean. This method should be used if a compute function
        is asked to compute a single element of a multi, but instead
        calculates all the elements. Calling setAllClean in this
        situation will prevent further calls to the node's compute method
        for the other elements of the multi.The data handle that this
        arrayDataHandle represents must come from a valid data block,
        such as one returned from one of the MDataBlock methods like
        MDataBlock::inputValue(). If a data handle created and returned
        from MPlug::getValue() or MPlug::asMDataHandle() is passed to
        this arrayDataHandle, then the use of this method will be
        invalid.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def builder(self, ReturnStatus: MArrayDataHandle.MStatus): 
        '''
        builder(self, ReturnStatus: MArrayDataHandle.MStatus) -> MArrayDataBuilder

        Synopsis
        -----
        Returns a builder for this handle's array so that it can be
        expanded. This method will fail if the current array does not
        support array data builders. This can be changed in a node's
        initialize routine using the setUsesArrayDataBuilder method in
        MFnAttribute.The data handle that this arrayDataHandle represents
        must come from a valid data block, such as one returned from one
        of the MDataBlock methods like MDataBlock::inputValue(). If a
        data handle created and returned from MPlug::getValue() or
        MPlug::asMDataHandle() is passed to this arrayDataHandle, then
        the use of this method will be invalid.

        Returns: 
        ----- 
        The builder object

        Parameters:
        -----
        ReturnStatus: MArrayDataHandle.MStatus
        	[out] -> return status


        '''
        pass

    def set(self, builder: MArrayDataBuilder): 
        '''
        set(self, builder: MArrayDataBuilder)

        Synopsis
        -----
        Sets the data for this array from the data in the builder object.
        The data handle that this arrayDataHandle represents must come
        from a valid data block, such as one returned from one of the
        MDataBlock methods like MDataBlock::inputValue(). If a data
        handle created and returned from MPlug::getValue() or
        MPlug::asMDataHandle() is passed to this arrayDataHandle, then
        the use of this method will be invalid.

        Returns:
        -----
        None

        Parameters:
        -----
        builder: MArrayDataBuilder
        	[in] -> the builder object


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MAttributeIndex:
    '''The index information for an attribute specification.
Class that provides access to the index part of an attribute
specification (
MAttributeSpec).
See
MAttributeSpec for more information.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MAttributeIndex.MAttributeIndex

        Synopsis
        -----
        Returns the type of attribute index. Valid index types are
        kInteger and kFloat.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def hasRange(self): 
        '''
        hasRange(self) -> bool

        Synopsis
        -----
        Return true if a range was specified. Note: false will be
        returned for an unbounded range which can be tested using the
        hasBound method.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def hasValidRange(self): 
        '''
        hasValidRange(self) -> bool

        Synopsis
        -----
        Return true if upper value is greater than lower value.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def hasLowerBound(self): 
        '''
        hasLowerBound(self) -> bool

        Synopsis
        -----
        Return true if if there is a lower bound specified.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def hasUpperBound(self): 
        '''
        hasUpperBound(self) -> bool

        Synopsis
        -----
        Return true if if there is an upper bound specified.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def getLower(self, value: int): 
        '''
        getLower(self, value: int)

        Synopsis
        -----
        Return the lower bound for this object or false if 1) the type
        does not match the argument type or 2) there is no lower bound.
        (both of which can be tested for using other methods on this
        class).

        Returns:
        -----
        None

        Parameters:
        -----
        value: int
        	[out] -> lower bound value is returned through this parameter.


        '''
        pass

    @overload
    def getLower(self, value: double): 
        '''
        getLower(self, value: double)

        Synopsis
        -----
        Return the lower bound for this object or false if 1) the type
        does not match the argument type or 2) there is no lower bound.
        (both of which can be tested for using other methods on this
        class).

        Returns:
        -----
        None

        Parameters:
        -----
        value: double
        	[out] -> lower bound value is returned through this parameter.


        '''
        pass

    @overload
    def getUpper(self, value: int): 
        '''
        getUpper(self, value: int)

        Synopsis
        -----
        Return the upper bound for this object or false if 1) the type
        does not match the argument type or 2) there is no upper bound.
        (both of which can be tested for using other methods on this
        class).

        Returns:
        -----
        None

        Parameters:
        -----
        value: int
        	[out] -> upper bound value is returned through this parameter.


        '''
        pass

    @overload
    def getUpper(self, value: double): 
        '''
        getUpper(self, value: double)

        Synopsis
        -----
        Return the upper bound for this object or false if 1) the type
        does not match the argument type or 2) there is no upper bound.
        (both of which can be tested for using other methods on this
        class).

        Returns:
        -----
        None

        Parameters:
        -----
        value: double
        	[out] -> upper bound value is returned through this parameter.


        '''
        pass

    def isBounded(self): 
        '''
        isBounded(self) -> bool

        Synopsis
        -----
        Returns true if this object is bounded.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def getValue(self, value: int): 
        '''
        getValue(self, value: int)

        Synopsis
        -----
        Return the current value of the index or false if 1) the type
        does not match the argument type or 2) the index is a range or 3)
        the index is unbounded.

        Returns:
        -----
        None

        Parameters:
        -----
        value: int
        	[out] -> value of the index is returned through this parameter.


        '''
        pass

    @overload
    def getValue(self, value: double): 
        '''
        getValue(self, value: double)

        Synopsis
        -----
        Return the current value of the index or false if 1) the type
        does not match the argument type or 2) the index is a range or 3)
        the index is unbounded.

        Returns:
        -----
        None

        Parameters:
        -----
        value: double
        	[out] -> value of the index is returned through this parameter.


        '''
        pass

    def setType(self, type: MAttributeIndex.MAttributeIndex): 
        '''
        setType(self, type: MAttributeIndex.MAttributeIndex)

        Synopsis
        -----
        Sets the type of attribute index. Valid index types are kInteger
        and kFloat.

        Returns:
        -----
        None

        Parameters:
        -----
        type: MAttributeIndex.MAttributeIndex
        	[in] -> the index type to set


        '''
        pass

    @overload
    def setValue(self, value: int): 
        '''
        setValue(self, value: int)

        Synopsis
        -----
        Sets the index value of this object.

        Returns:
        -----
        None

        Parameters:
        -----
        value: int
        	[in] -> the value to set


        '''
        pass

    @overload
    def setValue(self, value: double): 
        '''
        setValue(self, value: double)

        Synopsis
        -----
        Sets the index value of this object.

        Returns:
        -----
        None

        Parameters:
        -----
        value: double
        	[in] -> the value to set


        '''
        pass

    @overload
    def setLower(self, value: int): 
        '''
        setLower(self, value: int)

        Synopsis
        -----
        Sets the lower bounds of this object.

        Returns:
        -----
        None

        Parameters:
        -----
        value: int
        	[in] -> the value to set


        '''
        pass

    @overload
    def setLower(self, value: double): 
        '''
        setLower(self, value: double)

        Synopsis
        -----
        Sets the lower bounds of this object.

        Returns:
        -----
        None

        Parameters:
        -----
        value: double
        	[in] -> the value to set


        '''
        pass

    @overload
    def setUpper(self, value: int): 
        '''
        setUpper(self, value: int)

        Synopsis
        -----
        Sets the upper bounds of this object.

        Returns:
        -----
        None

        Parameters:
        -----
        value: int
        	[in] -> the value to set


        '''
        pass

    @overload
    def setUpper(self, value: double): 
        '''
        setUpper(self, value: double)

        Synopsis
        -----
        Sets the upper bounds of this object.

        Returns:
        -----
        None

        Parameters:
        -----
        value: double
        	[in] -> the value to set


        '''
        pass

    def __eq__(self, other: MAttributeIndex): 
        '''
        __eq__(self, other: MAttributeIndex) -> bool

        Synopsis
        -----
        Equality operator.

        Returns: 
        ----- 
        Boolean indicating whether the objects are same.

        Parameters:
        -----
        other: MAttributeIndex
        	[in] -> object to compare with.


        '''
        pass

    def __neq__(self, other: MAttributeIndex): 
        '''
        __neq__(self, other: MAttributeIndex) -> bool

        Synopsis
        -----
        Inequality operator.

        Returns: 
        ----- 
        Boolean indicating whether the objects are same.

        Parameters:
        -----
        other: MAttributeIndex
        	[in] -> object to compare with.


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MIndexType:
    '''Data types for attribute indices. 
    Non-functional class.  Values for this enum:
    kInteger
    kFloat
    '''

    def __init__(self):
        pass

    def kInteger(self):
        '''This is an enum of MIndexType.
        - Description: Integer index (e.g. mesh.cp[5]) 
        - Value: 0
        '''
        pass

    def kFloat(self):
        '''This is an enum of MIndexType.
        - Description: Floating-poing index (e.g. curve.u[1.3]) 
        - Value: 1
        '''
        pass

class MAttributePattern:
    '''The pattern of an attribute tree that can be applied to nodes or
node classes.
Class that provides a pattern of attributes to be applied to
nodes as dynamic attributes or to node classes as extension
attributes.
An attribute pattern is a pattern describing an attribute tree.
In the simplest implementation it can just store an internal copy
of the tree to be applied. The code to apply the attribute
patterns will use the
rootAttr() and
rootAttrCount() methods to iterate through the list of top level attributes to
be applied. It presumes that if they are compounds then their
children will already be parented properly.
When creating the pattern from inside
MPxAttributePatternFactory you add only the root level attributes, i.e. the attributes
without parents. As a simple example if your pattern factory has
data that specifies creating a pattern with one integer attribute
and one compound with three float children the code would like
something like this.
'''
    def __init__(self):
        pass


    def __eq__(self, rhs: MAttributePattern): 
        '''
        __eq__(self, rhs: MAttributePattern) -> bool

        Synopsis
        -----
        Determine equality between two attribute patterns.

        Returns: 
        ----- 
        true if they both point to the same underlying Maya pattern

        Parameters:
        -----
        rhs: MAttributePattern
        	[in] -> Pattern to be compared 


        '''
        pass

    def attrPatternCount(self): 
        '''
        attrPatternCount(self) -> int

        Synopsis
        -----
        Get the number of patterns currently known.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def name(self, ReturnStatus: MAttributePattern.MStatus): 
        '''
        name(self, ReturnStatus: MAttributePattern.MStatus) -> MString

        Synopsis
        -----
        Get the name of this pattern.

        Returns: 
        ----- 
        Name of this pattern.

        Parameters:
        -----
        ReturnStatus: MAttributePattern.MStatus
        	[out] -> Did the operation return valid data?


        '''
        pass

    def rootAttrCount(self, ReturnStatus: MAttributePattern.MStatus): 
        '''
        rootAttrCount(self, ReturnStatus: MAttributePattern.MStatus) -> int

        Synopsis
        -----
        Get the number of top level attributes present in this pattern.

        Returns: 
        ----- 
        Number of root attributes present in this pattern

        Parameters:
        -----
        ReturnStatus: MAttributePattern.MStatus
        	[out] -> Did the operation return valid data?


        '''
        pass

    def rootAttr(self, idx: int,
                        ReturnStatus: MAttributePattern.MStatus): 
        '''
        rootAttr(self, idx: int,
                        ReturnStatus: MAttributePattern.MStatus) -> MObject

        Synopsis
        -----
        Get a single root-level attribute from this pattern.

        Returns: 
        ----- 
        The idx'th root attribute present in the pattern.

        Parameters:
        -----
        idx: int
        	[in] -> Index of the root-level attribute in the pattern's list. 

        ReturnStatus: MAttributePattern.MStatus
        	[out] -> Did the operation return valid data?


        '''
        pass

    @overload
    def removeRootAttr(self, idx: int): 
        '''
        removeRootAttr(self, idx: int)

        Synopsis
        -----
        Remove a single root attribute and its children from the pattern
        by index.

        Returns:
        -----
        None

        Parameters:
        -----
        idx: int
        	[in] -> Index of the root attribute to be removed


        '''
        pass

    @overload
    def removeRootAttr(self, attr: MObject): 
        '''
        removeRootAttr(self, attr: MObject)

        Synopsis
        -----
        Remove a single root attribute and its children from the pattern
        by attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        attr: MObject
        	[in] -> The attribute to be removed


        '''
        pass

    def addRootAttr(self, attr: MObject): 
        '''
        addRootAttr(self, attr: MObject)

        Synopsis
        -----
        Add a new root attribute to the pattern.

        Returns:
        -----
        None

        Parameters:
        -----
        attr: MObject
        	[in] -> Attribute to be added to this pattern.


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MAttributePatternArray:
    '''Indexable Array of attribute patterns.
Provides methods for manipulating arrays of attribute patterns.
Arrays of attribute patterns are used when constructing pattern
lists from a string or file description. Since there's no way of
knowing in advance how many will be created from a given
description this general purpose array was needed.
The length of the array adjusts automatically.
'''
    def __init__(self):
        pass


    @overload
    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> const MAttributePattern&

        Synopsis
        -----
        Retrieves the read-only attribute pattern which is at the
        specified index in the array.

        Returns: 
        ----- 
        Attribute pattern at the specified index

        Parameters:
        -----
        index: int
        	[in] -> Zero-based index to the array


        '''
        pass

    def set(self, element: MAttributePattern,
                        index: int): 
        '''
        set(self, element: MAttributePattern,
                        index: int)

        Synopsis
        -----
        Sets an element of the array to the given attribute pattern.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MAttributePattern
        	[in] -> New attribute pattern to be set on the indicated element 

        index: int
        	[in] -> Zero-based index to the array


        '''
        pass

    def setLength(self, length: int): 
        '''
        setLength(self, length: int)

        Synopsis
        -----
        Set the length of the array. This will grow and shrink the array
        as desired. Elements that are grown have uninitialized values,
        while those which are shrunk will lose the data contained in the
        deleted elements (ie. it will release the memory).

        Returns:
        -----
        None

        Parameters:
        -----
        length: int
        	[in] -> the new size of the array 


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Determines the number of elements in the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Removes the attribute pattern which is at the specified index in
        the array.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> Zero-based index to the array


        '''
        pass

    def insert(self, element: MAttributePattern,
                        index: int): 
        '''
        insert(self, element: MAttributePattern,
                        index: int)

        Synopsis
        -----
        Inserts the given attribute pattern at the specified index in the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MAttributePattern
        	[in] -> attribute pattern to be inserted 

        index: int
        	[in] -> Zero-based index to the array


        '''
        pass

    def append(self, element: MAttributePattern): 
        '''
        append(self, element: MAttributePattern)

        Synopsis
        -----
        Appends the given attribute pattern to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MAttributePattern
        	[in] -> attribute pattern to be appended


        '''
        pass

    def copy(self, source: MAttributePatternArray): 
        '''
        copy(self, source: MAttributePatternArray)

        Synopsis
        -----
        Copy the contents of the source array to this array.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MAttributePatternArray
        	[in] -> array to copy from


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clears this array. Length of the array becomes zero.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setSizeIncrement(self, newIncrement: int): 
        '''
        setSizeIncrement(self, newIncrement: int)

        Synopsis
        -----
        Set the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        newIncrement: int
        	[in] -> the new increment 


        '''
        pass

    def sizeIncrement(self): 
        '''
        sizeIncrement(self) -> int

        Synopsis
        -----
        Return the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> MAttributePattern

        Synopsis
        -----
        Retrieves the attribute pattern which is at the specified index
        in the array.

        Returns: 
        ----- 
        Attribute pattern at the specified index

        Parameters:
        -----
        index: int
        	[in] -> Zero-based index to the array


        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MAttributePatternArray.MAttributePatternArray

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MAttributePatternArray.MAttributePatternArray

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MAttributePatternArray.MAttributePatternArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MAttributePatternArray.MAttributePatternArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MAttributePatternArray.MAttributePatternArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MAttributePatternArray.MAttributePatternArray

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MAttributeSpec:
    '''An attribute specification.
Class that encapsulates component/attribute information for
generating selection items.
This class is used by
MPxSurfaceShape::matchComponent for validating attributes specified as strings and converting
that specification to a component object.
The attribute specification ".foo.bar[3].x" would be expressed
like this (using a pseudo-structure description):
'''
    def __init__(self):
        pass


    def name(self): 
        '''
        name(self) -> const MString

        Synopsis
        -----
        Returns the attribute name part of the specification.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def dimensions(self): 
        '''
        dimensions(self) -> int

        Synopsis
        -----
        Returns the dimension of the attribute specification. For array
        attributes the dimension is > 0.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setName(self, name: MString): 
        '''
        setName(self, name: MString)

        Synopsis
        -----
        Set the attribute name part of the specification.

        Returns:
        -----
        None

        Parameters:
        -----
        name: MString
        	[in] -> the name to be set 


        '''
        pass

    def setDimensions(self, value: int): 
        '''
        setDimensions(self, value: int)

        Synopsis
        -----
        Set the dimension of the attribute specification. Array attribute
        dimensions are > 0.

        Returns:
        -----
        None

        Parameters:
        -----
        value: int
        	[in] -> the dimension value to be set 


        '''
        pass

    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> const MAttributeIndex

        Synopsis
        -----
        Returns an attribute index object for the specified element.

        Returns: 
        ----- 
        The MAttributeIndex associated with the given index.

        Parameters:
        -----
        index: int
        	[in] -> attribute index to return


        '''
        pass

    def __eq__(self, other: MAttributeSpec): 
        '''
        __eq__(self, other: MAttributeSpec) -> bool

        Synopsis
        -----
        Comparison operator.

        Returns: 
        ----- 
        The boolean indicating whether the object are same or not.

        Parameters:
        -----
        other: MAttributeSpec
        	[in] -> attribute specifier to be compared


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MAttributeSpecArray:
    '''An attribute specification array.
Array class for
MAttributeSpec.
See
MAttributeSpec for more information.
'''
    def __init__(self):
        pass


    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> MAttributeSpec

        Synopsis
        -----
        Index operator. Returns the value of the element at the given
        index. Valid indices are 0 to length()-1.

        Returns: 
        ----- 
        A reference to the specified element

        Parameters:
        -----
        index: int
        	[in] -> the index of the element to return


        '''
        pass

    def set(self, element: MAttributeSpec,
                        index: int): 
        '''
        set(self, element: MAttributeSpec,
                        index: int)

        Synopsis
        -----
        Sets the value of the specified element to the given attribute
        spec.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MAttributeSpec
        	[in] -> the new value for the specified element 

        index: int
        	[in] -> the index of the element to be set


        '''
        pass

    def setLength(self, length: int): 
        '''
        setLength(self, length: int)

        Synopsis
        -----
        Set the length of the array. This will grow and shrink the array
        as desired. Elements that are grown have uninitialized values,
        while those which are shrunk will lose the data contained in the
        deleted elements (ie. it will release the memory).

        Returns:
        -----
        None

        Parameters:
        -----
        length: int
        	[in] -> the new size of the array


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Returns the number of elements in the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Removes the element in the array at the given index.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the index of the element to removed


        '''
        pass

    def insert(self, element: MAttributeSpec,
                        index: int): 
        '''
        insert(self, element: MAttributeSpec,
                        index: int)

        Synopsis
        -----
        Inserts a new value into the array at the given index. The
        initial element at that index, and all following elements, are
        shifted towards the last.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MAttributeSpec
        	[in] -> the new value to insert into the array 

        index: int
        	[in] -> the index of the element to set


        '''
        pass

    def append(self, element: MAttributeSpec): 
        '''
        append(self, element: MAttributeSpec)

        Synopsis
        -----
        Adds a new element to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MAttributeSpec
        	[in] -> the value for the new last element


        '''
        pass

    def copy(self, source: MAttributeSpecArray): 
        '''
        copy(self, source: MAttributeSpecArray)

        Synopsis
        -----
        Copy the contents of the source array to this array.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MAttributeSpecArray
        	[in] -> array to copy from


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clear the contents of the array. After this operation the length
        method will return 0. This does not change the amount of memory
        allocated to the array, only the number of valid elements in it.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setSizeIncrement(self, newIncrement: int): 
        '''
        setSizeIncrement(self, newIncrement: int)

        Synopsis
        -----
        Set the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        newIncrement: int
        	[in] -> the new increment 


        '''
        pass

    def sizeIncrement(self): 
        '''
        sizeIncrement(self) -> int

        Synopsis
        -----
        Return the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MAttributeSpecArray.MAttributeSpecArray

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MAttributeSpecArray.MAttributeSpecArray

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MAttributeSpecArray.MAttributeSpecArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MAttributeSpecArray.MAttributeSpecArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MAttributeSpecArray.MAttributeSpecArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MAttributeSpecArray.MAttributeSpecArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MBoundingBox:
    '''Implementation of a 3D bounding box.
This class provides an implementation of a bounding box. A
bounding box describes a volume in space that bounds a piece of
geometry. The box is defined by two points which describe the
minimum and maximum corners of the box.
'''
    def __init__(self):
        pass


    def transformUsing(self, matrix: MMatrix): 
        '''
        transformUsing(self, matrix: MMatrix)

        Synopsis
        -----
        Apply the given transformation to this bounding box.

        Returns:
        -----
        None

        Parameters:
        -----
        matrix: MMatrix
        	[in] -> transformation matrix 


        '''
        pass

    @overload
    def expand(self, point: MPoint): 
        '''
        expand(self, point: MPoint)

        Synopsis
        -----
        Expand the bounding box to include the given point.

        Returns:
        -----
        None

        Parameters:
        -----
        point: MPoint
        	[in] -> new point to include in the bounding box. 


        '''
        pass

    @overload
    def expand(self, box: MBoundingBox): 
        '''
        expand(self, box: MBoundingBox)

        Synopsis
        -----
        Expand the bounding box to include a second bounding box.

        Returns:
        -----
        None

        Parameters:
        -----
        box: MBoundingBox
        	[in] -> bounding box to include in this bounding box. 


        '''
        pass

    def contains(self, point: MPoint): 
        '''
        contains(self, point: MPoint) -> bool

        Synopsis
        -----
        Returns true if the bounding box contains the given point.

        Returns: 
        ----- 
        true if the point is contained in this bounding box

        Parameters:
        -----
        point: MPoint
        	[in] -> point to check for inclusion in this bounding box


        '''
        pass

    def intersects(self, box: MBoundingBox,
                        tol: double): 
        '''
        intersects(self, box: MBoundingBox,
                        tol: double) -> bool

        Synopsis
        -----
        Returns true if the bounding box intersects another given
        bounding box.

        Returns: 
        ----- 
        true if the bounding boxes intersect

        Parameters:
        -----
        box: MBoundingBox
        	[in] -> bounding box to check for intersection 

        tol: double
        	[in] -> tolerance of the intersection check


        '''
        pass

    def width(self): 
        '''
        width(self) -> double

        Synopsis
        -----
        Returns the width of the bounding box.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def height(self): 
        '''
        height(self) -> double

        Synopsis
        -----
        Returns the height of the bounding box.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def depth(self): 
        '''
        depth(self) -> double

        Synopsis
        -----
        Returns the depth of the bounding box.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def center(self): 
        '''
        center(self) -> MPoint

        Synopsis
        -----
        Returns the center of the bounding box.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def min(self): 
        '''
        min(self) -> MPoint

        Synopsis
        -----
        Returns the minimum point for the bounding box. That is the point
        whose x, y, and z components represent the bounding box's minimum
        value in each dimension.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def max(self): 
        '''
        max(self) -> MPoint

        Synopsis
        -----
        Returns the maximum point for the bounding box. That is the point
        whose x, y, and z components represent the bounding box's maximum
        value in each dimension.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MCacheConfigRuleRegistry:
    '''Class for configuring the caching rules
When partitioning the evaluation graph, the Evaluation Manager
uses a set of caching rules in order to determine what gets
cached.
These rules are made of a pair of one filter and one action. The
following pseudocode highlights the role of cache configuration
rules, at scheduling time:
for each node for each rule if filter(node) is True Then call
action(node) endif
Once registered, filters can be used to create new rules through
the cacheEvaluator command
'''
    def __init__(self):
        pass


    def registerFilter(self, filterName: MString,
                        creatorFunction: MCacheConfigRuleRegistry.MCreateCacheConfigRuleFilterFunction): 
        '''
        registerFilter(self, filterName: MString,
                        creatorFunction: MCacheConfigRuleRegistry.MCreateCacheConfigRuleFilterFunction)

        Synopsis
        -----
        Registers a new filter that can be later used in rules to
        configure caching through the cacheEvaluator command.

        Returns:
        -----
        None

        Parameters:
        -----
        filterName: MString
        	[in] -> the name of the filter to register. Must be unique. 

        creatorFunction: MCacheConfigRuleRegistry.MCreateCacheConfigRuleFilterFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from 


        '''
        pass

    def unregisterFilter(self, filterName: MString): 
        '''
        unregisterFilter(self, filterName: MString)

        Synopsis
        -----
        Unregisters a filter from the cache configuration. Note:
        unregistering a filter will clear the current cache configuration
        and disable caching

        Returns:
        -----
        None

        Parameters:
        -----
        filterName: MString
        	[in] -> the name of the filter to unregister.


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MCacheFormatDescription:
    '''Cache format description.
The
MCacheFormatDescription is a utility class used by
MPxCacheFormat when implementing custom cache plug-ins that define their own
handling of the cache format (usually provided by Maya's own xml
format).
'''
    def __init__(self):
        pass


    def setDistribution(self, distribution: MCacheFormatDescription.CacheFileDistribution): 
        '''
        setDistribution(self, distribution: MCacheFormatDescription.CacheFileDistribution)

        Synopsis
        -----
        Set up the cache format when reading the description file. Set
        the distribution.

        Returns:
        -----
        None

        Parameters:
        -----
        distribution: MCacheFormatDescription.CacheFileDistribution
        	[in] -> the distribution to set 


        '''
        pass

    def setTimePerFrame(self, timePerFrame: MTime): 
        '''
        setTimePerFrame(self, timePerFrame: MTime)

        Synopsis
        -----
        Set the time per frame.

        Returns:
        -----
        None

        Parameters:
        -----
        timePerFrame: MTime
        	[in] -> the time per frame to set 


        '''
        pass

    def addDescriptionInfo(self, info: MString): 
        '''
        addDescriptionInfo(self, info: MString)

        Synopsis
        -----
        Add a descriptive string.

        Returns:
        -----
        None

        Parameters:
        -----
        info: MString
        	[in] -> the string to add 


        '''
        pass

    def addChannel(self, channelName: MString,
                        interpretation: MString,
                        dataType: MCacheFormatDescription.CacheDataType,
                        samplingType: MCacheFormatDescription.CacheSamplingType,
                        samplingRate: MTime,
                        startTime: MTime,
                        endTime: MTime,
                        status: MCacheFormatDescription.MStatus): 
        '''
        addChannel(self, channelName: MString,
                        interpretation: MString,
                        dataType: MCacheFormatDescription.CacheDataType,
                        samplingType: MCacheFormatDescription.CacheSamplingType,
                        samplingRate: MTime,
                        startTime: MTime,
                        endTime: MTime,
                        status: MCacheFormatDescription.MStatus) -> int

        Synopsis
        -----
        Add a channel.

        Returns: 
        ----- 
        The index of the added channel.

        Parameters:
        -----
        channelName: MString
        	[in] -> the new channel's name 

        interpretation: MString
        	[in] -> the new channel's interpretation 

        dataType: MCacheFormatDescription.CacheDataType
        	[in] -> the new channel's data type 

        samplingType: MCacheFormatDescription.CacheSamplingType
        	[in] -> the new channel's sampling type 

        samplingRate: MTime
        	[in] -> the new channel's sampling rate 

        startTime: MTime
        	[in] -> the new channel's start time 

        endTime: MTime
        	[in] -> the new channel's end time 

        status: MCacheFormatDescription.MStatus
        	[out] -> the return status


        '''
        pass

    def getDistribution(self): 
        '''
        getDistribution(self) -> MCacheFormatDescription.MCacheFormatDescription

        Synopsis
        -----
        Get information about the format in order to write the
        description file. Get the distribution.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getTimePerFrame(self): 
        '''
        getTimePerFrame(self) -> MTime

        Synopsis
        -----
        Get the time per frame.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getStartAndEndTimes(self, startTime: MTime,
                        endTime: MTime): 
        '''
        getStartAndEndTimes(self, startTime: MTime,
                        endTime: MTime)

        Synopsis
        -----
        Get the start and end times.

        Returns:
        -----
        None

        Parameters:
        -----
        startTime: MTime
        	[out] -> the start time 

        endTime: MTime
        	[out] -> the end time 


        '''
        pass

    def getDescriptionInfo(self): 
        '''
        getDescriptionInfo(self) -> MStringArray

        Synopsis
        -----
        Get the descriptive strings.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getNumChannels(self): 
        '''
        getNumChannels(self) -> int

        Synopsis
        -----
        Get the number of channels.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getChannelName(self, channelIndex: int): 
        '''
        getChannelName(self, channelIndex: int) -> MString

        Synopsis
        -----
        Get a channel's name.

        Returns: 
        ----- 
        the channel's name

        Parameters:
        -----
        channelIndex: int
        	[in] -> the index of the channel to be queried


        '''
        pass

    def getChannelInterpretation(self, channelIndex: int): 
        '''
        getChannelInterpretation(self, channelIndex: int) -> MString

        Synopsis
        -----
        Get a channel's intepretation.

        Returns: 
        ----- 
        the channel's intepretation

        Parameters:
        -----
        channelIndex: int
        	[in] -> the index of the channel to be queried


        '''
        pass

    def getChannelDataType(self, channelIndex: int): 
        '''
        getChannelDataType(self, channelIndex: int) -> MCacheFormatDescription.MCacheFormatDescription

        Synopsis
        -----
        Get a channel's data type.

        Returns: 
        ----- 
        the channel's data type

        Parameters:
        -----
        channelIndex: int
        	[in] -> the index of the channel to be queried


        '''
        pass

    def getChannelSamplingType(self, channelIndex: int): 
        '''
        getChannelSamplingType(self, channelIndex: int) -> MCacheFormatDescription.MCacheFormatDescription

        Synopsis
        -----
        Get a channel's sampling type.

        Returns: 
        ----- 
        the channel's sampling type

        Parameters:
        -----
        channelIndex: int
        	[in] -> the index of the channel to be queried


        '''
        pass

    def getChannelSamplingRate(self, channelIndex: int): 
        '''
        getChannelSamplingRate(self, channelIndex: int) -> MTime

        Synopsis
        -----
        Get a channel's sampling rate.

        Returns: 
        ----- 
        the channel's sampling rate

        Parameters:
        -----
        channelIndex: int
        	[in] -> the index of the channel to be queried


        '''
        pass

    def getChannelStartTime(self, channelIndex: int): 
        '''
        getChannelStartTime(self, channelIndex: int) -> MTime

        Synopsis
        -----
        Get a channel's start time.

        Returns: 
        ----- 
        the channel's start time

        Parameters:
        -----
        channelIndex: int
        	[in] -> the index of the channel to be queried


        '''
        pass

    def getChannelEndTime(self, channelIndex: int): 
        '''
        getChannelEndTime(self, channelIndex: int) -> MTime

        Synopsis
        -----
        Get a channel's end time.

        Returns: 
        ----- 
        the channel's end time

        Parameters:
        -----
        channelIndex: int
        	[in] -> the index of the channel to be queried


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class CacheFileDistribution:
    '''Cache file distribution types. 
    Non-functional class.  Values for this enum:
    kNoFile
    kOneFile
    kOneFilePerFrame
    '''

    def __init__(self):
        pass

    def kNoFile(self):
        '''This is an enum of CacheFileDistribution.
        - Description: just memory cache 
        - Value: 0
        '''
        pass

    def kOneFile(self):
        '''This is an enum of CacheFileDistribution.
        - Description: one file for all frames 
        - Value: 1
        '''
        pass

    def kOneFilePerFrame(self):
        '''This is an enum of CacheFileDistribution.
        - Description: one file per frame 
        - Value: 2
        '''
        pass

class CacheDataType:
    '''Cache file data types. 
    Non-functional class.  Values for this enum:
    kUnknownData
    kDouble
    kDoubleArray
    kDoubleVectorArray
    kInt32Array
    kFloatArray
    kFloatVectorArray
    '''

    def __init__(self):
        pass

    def kUnknownData(self):
        '''This is an enum of CacheDataType.
        - Description: unknown data 
        - Value: 0
        '''
        pass

    def kDouble(self):
        '''This is an enum of CacheDataType.
        - Description: a single double value 
        - Value: 1
        '''
        pass

    def kDoubleArray(self):
        '''This is an enum of CacheDataType.
        - Description: an array of double values 
        - Value: 2
        '''
        pass

    def kDoubleVectorArray(self):
        '''This is an enum of CacheDataType.
        - Description: an array of double vector values 
        - Value: 3
        '''
        pass

    def kInt32Array(self):
        '''This is an enum of CacheDataType.
        - Description: an array of int32 values 
        - Value: 4
        '''
        pass

    def kFloatArray(self):
        '''This is an enum of CacheDataType.
        - Description: an array of float values 
        - Value: 5
        '''
        pass

    def kFloatVectorArray(self):
        '''This is an enum of CacheDataType.
        - Description: an array of float vector values 
        - Value: 6
        '''
        pass

class CacheSamplingType:
    '''Cache file sampling types. 
    Non-functional class.  Values for this enum:
    kRegular
    kIrregular
    '''

    def __init__(self):
        pass

    def kRegular(self):
        '''This is an enum of CacheSamplingType.
        - Description: regular sampling 
        - Value: 0
        '''
        pass

    def kIrregular(self):
        '''This is an enum of CacheSamplingType.
        - Description: irregular sampling 
        - Value: 1
        '''
        pass

class MCallbackIdArray:
    '''Array of MCallbackId data type.
This class implements an array of MCallbackId. Common convenience
functions are available, and the implementation is compatible
with the internal Maya implementation so that it can be passed
efficiently between plugins and internal maya data structures.
'''
    def __init__(self):
        pass


    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> MCallbackId

        Synopsis
        -----
        Index operator. Returns the value of the element at the given
        index. No range checking is done - valid indices are 0 to
        length()-1.

        Returns: 
        ----- 
        The value of the indicated element.

        Parameters:
        -----
        index: int
        	[in] -> the index of the element whose value is to be returned


        '''
        pass

    def set(self, element: MCallbackId,
                        index: int): 
        '''
        set(self, element: MCallbackId,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated value.
        NOTE: This method does not grow the array if the index is out of
        bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MCallbackId
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    def setLength(self, length: int): 
        '''
        setLength(self, length: int)

        Synopsis
        -----
        Set the length of the array. This will grow and shrink the array
        as desired. Elements that are grown have uninitialized values,
        while those which are shrunk will lose the data contained in the
        deleted elements (ie. it will release the memory).

        Returns:
        -----
        None

        Parameters:
        -----
        length: int
        	[in] -> the new size of the array 


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Returns the number of elements in the instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Remove the array element at the given index. All array elements
        following the removed element are shifted toward the first
        element.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> index of the element to be removed


        '''
        pass

    def insert(self, element: MCallbackId,
                        index: int): 
        '''
        insert(self, element: MCallbackId,
                        index: int)

        Synopsis
        -----
        Inserts a new value into the array at the given index. The
        initial element at that index, and all following elements, are
        shifted towards the last. If the array cannot be expanded in size
        by 1 element, then the insert will fail and the existing array
        will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MCallbackId
        	[in] -> the new value to insert into the array 

        index: int
        	[in] -> the index of the element to set to the new value


        '''
        pass

    def append(self, element: MCallbackId): 
        '''
        append(self, element: MCallbackId)

        Synopsis
        -----
        Adds a new element to the end of the array. If the array cannot
        be expanded in size by 1 element, then the append will fail and
        the existing array will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MCallbackId
        	[in] -> the value for the new last element


        '''
        pass

    def copy(self, source: MCallbackIdArray): 
        '''
        copy(self, source: MCallbackIdArray)

        Synopsis
        -----
        Copy the contents of the source array to this array.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MCallbackIdArray
        	[in] -> array to copy from


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clear the contents of the array. After this operation the length
        method will return 0. This does not change the amount of memory
        allocated to the array, only the number of valid elements in it.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setSizeIncrement(self, newIncrement: int): 
        '''
        setSizeIncrement(self, newIncrement: int)

        Synopsis
        -----
        Set the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        newIncrement: int
        	[in] -> the new increment 


        '''
        pass

    def sizeIncrement(self): 
        '''
        sizeIncrement(self) -> int

        Synopsis
        -----
        Return the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MCallbackIdArray.MCallbackIdArray

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MCallbackIdArray.MCallbackIdArray

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MCallbackIdArray.MCallbackIdArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MCallbackIdArray.MCallbackIdArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MCallbackIdArray.MCallbackIdArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MCallbackIdArray.MCallbackIdArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MCameraMessage:
    '''Dependency node messages.
This class is used to register callbacks for dependency node
messages of specific dependency nodes.
There are 2 add callback methods which will add callbacks for the
following messages
Camera manipulation is triggered by:
The first parameter passed to each of the add callback methods is
the cameraShape node that will trigger the callback.
Each method returns an id which is used to remove the callback.
To remove a callback use
MMessage::removeCallback. All callbacks that are registered by a plug-in must be removed
by that plug-in when it is unloaded. Failure to do so will result
in a fatal error.
'''
    def __init__(self):
        pass


    def addBeginManipulationCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MCameraMessage.MStatus): 
        '''
        addBeginManipulationCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MCameraMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        Registers callbacks for camera manipulation beginning messages.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MObject
        	[in] -> the set to register the callback for 

        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data that will be passed to the callback function 

        ReturnStatus: MCameraMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addEndManipulationCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MCameraMessage.MStatus): 
        '''
        addEndManipulationCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MCameraMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        Registers callbacks for camera manipulation ending messages.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MObject
        	[in] -> the set to register the callback for 

        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data that will be passed to the callback function 

        ReturnStatus: MCameraMessage.MStatus
        	[out] -> status code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MCameraSetMessage:
    '''CameraSet messages.
This class is used to register callbacks with cameraSet specific
event types.
Using the addCallback() methods, a function can be registered
that will be executed whenever the specific message/event occurs.
To remove a callback, use
MMessage::removeCallback(). All callbacks that are registered by a plug-in must be removed
by that plug-in when it is unloaded. Failure to do so will result
in a fatal error.
'''
    def __init__(self):
        pass


    def addCameraLayerCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MCameraSetMessage.MStatus): 
        '''
        addCameraLayerCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MCameraSetMessage.MStatus) -> MCameraSetMessage.OPENMAYA_MAJOR_NAMESPACE_OPENMCallbackId

        Synopsis
        -----
        Registers callbacks for adding and removing camera layeres.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> user data that will be passed to the callback function 

        ReturnStatus: MCameraSetMessage.MStatus
        	[out] -> Status code


        '''
        pass

    def addCameraChangedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MCameraSetMessage.MStatus): 
        '''
        addCameraChangedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MCameraSetMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        Registers callbacks for camera assignment changes to a camera
        layer.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> user data that will be passed to the callback function 

        ReturnStatus: MCameraSetMessage.MStatus
        	[out] -> Status code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MColor:
    '''A color math class.
This class is used to store values of color attributes. Right
now, this class provides no more functionality than the
MFltVector class, but it is used because Rendering plans to
employ more advanced color models in the future. In these models,
colors cannot necessarily be represented as an RGB triple.
'''
    def __init__(self):
        pass


    def __getitem__(self, i: int): 
        '''
        __getitem__(self, i: int) -> float

        Synopsis
        -----
        Index operator. Accessor to one component of the color.

        Returns: 
        ----- 
        A reference to the appropriate component of the color:  Reference
        to the red channel when argument is 0.  Reference to the green
        channel when argument is 1.  Reference to the blue channel when
        argument is 2.  Reference to the alpha channel otherwise.

        Parameters:
        -----
        i: int
        	[in] -> Value indicating which component to return.


        '''
        pass

    def __rdiv__(self, scalar: float): 
        '''
        __rdiv__(self, scalar: float) -> MColor

        Synopsis
        -----
        In place divide operator.

        Returns: 
        ----- 
        A reference to the color whose value was modified.

        Parameters:
        -----
        scalar: float
        	[in] -> Color division factor.


        '''
        pass

    def __div__(self, scalar: float): 
        '''
        __div__(self, scalar: float) -> MColor

        Synopsis
        -----
        Divide operator.

        Returns: 
        ----- 
        A new MColor object representing the color divided by the scalar.

        Parameters:
        -----
        scalar: float
        	[in] -> Color division factor.


        '''
        pass

    def __radd__(self, other: MColor): 
        '''
        __radd__(self, other: MColor) -> MColor

        Synopsis
        -----
        In place add operator.

        Returns: 
        ----- 
        A reference to the color whose value was modified.

        Parameters:
        -----
        other: MColor
        	[in] -> Color to be added to this color.


        '''
        pass

    def __add__(self, other: MColor): 
        '''
        __add__(self, other: MColor) -> MColor

        Synopsis
        -----
        Add operator.

        Returns: 
        ----- 
        A new MColor object representing the sum of this color and the
        specified color.

        Parameters:
        -----
        other: MColor
        	[in] -> Color to be added to this color.


        '''
        pass

    @overload
    def __sub__(self): 
        '''
        __sub__(self) -> MColor

        Synopsis
        -----
        Unary minus operator. Negates the value of each of the red, green
        and blue components of the color.Transparency is set to opaque.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def __sub__(self, other: MColor): 
        '''
        __sub__(self, other: MColor) -> MColor

        Synopsis
        -----
        Subtraction operator.

        Returns: 
        ----- 
        A new MColor object representing this color minus the specified
        other color.

        Parameters:
        -----
        other: MColor
        	[in] -> Color to be subtracted from this color.


        '''
        pass

    def __eq__(self, other: MColor): 
        '''
        __eq__(self, other: MColor) -> bool

        Synopsis
        -----
        Equality operator. Compares the r, g, and b components of two
        color.

        Returns: 
        ----- 
        A bool value:  true if the colors are identical  false otherwise

        Parameters:
        -----
        other: MColor
        	[in] -> Color to which this color will be compared.


        '''
        pass

    def __neq__(self, other: MColor): 
        '''
        __neq__(self, other: MColor) -> bool

        Synopsis
        -----
        Inequality operator. Compares the r, g, and b components of two
        color.

        Returns: 
        ----- 
        A bool value:  false if the colors are identical  true otherwise

        Parameters:
        -----
        other: MColor
        	[in] -> Color to which this color will be compared.


        '''
        pass

    @overload
    def get(self, d: float3): 
        '''
        get(self, d: float3) -> bool

        Synopsis
        -----
        Color component accessor. Extracts the r, g, and b components of
        the color and places them in elements 0, 1, and 2 of the float
        array passed.

        Returns: 
        ----- 
        Always returns bool true.

        Parameters:
        -----
        d: float3
        	[out] -> The array of 3 floats into which the results are placed.


        '''
        pass

    @overload
    def get(self, colorModel: MColor.MColorType,
                        c1: float,
                        c2: float,
                        c3: float): 
        '''
        get(self, colorModel: MColor.MColorType,
                        c1: float,
                        c2: float,
                        c3: float) -> bool

        Synopsis
        -----
        Color component accessor. Retrieves the values of 3 components of
        the color using the specified color model.

        Returns: 
        ----- 
        Always returns bool true.

        Parameters:
        -----
        colorModel: MColor.MColorType
        	[in] -> The color model. 

        c1: float
        	[out] -> Storage for the first component of color. 

        c2: float
        	[out] -> Storage for the second component of color. 

        c3: float
        	[out] -> Storage for the third component of color.


        '''
        pass

    @overload
    def get(self, colorModel: MColor.MColorType,
                        c1: float,
                        c2: float,
                        c3: float,
                        alpha: float): 
        '''
        get(self, colorModel: MColor.MColorType,
                        c1: float,
                        c2: float,
                        c3: float,
                        alpha: float) -> bool

        Synopsis
        -----
        Color component accessor. Retrieves the values of 4 components of
        the color using the specified color model.

        Returns: 
        ----- 
        Always returns bool true.

        Parameters:
        -----
        colorModel: MColor.MColorType
        	[in] -> The color model. 

        c1: float
        	[out] -> Storage for the first component of color. 

        c2: float
        	[out] -> Storage for the second component of color. 

        c3: float
        	[out] -> Storage for the third component of color. 

        alpha: float
        	[out] -> Storage for the alpha component of color.


        '''
        pass

    def set(self, colorModel: MColor.MColorType,
                        c1: float,
                        c2: float,
                        c3: float,
                        alpha: float): 
        '''
        set(self, colorModel: MColor.MColorType,
                        c1: float,
                        c2: float,
                        c3: float,
                        alpha: float) -> bool

        Synopsis
        -----
        Color component assigment. Sets the values of the color
        components using the specified color model.

        Returns: 
        ----- 
        Always returns bool true.

        Parameters:
        -----
        colorModel: MColor.MColorType
        	[in] -> The color model. 

        c1: float
        	[in] -> First component of color. 

        c2: float
        	[in] -> Second component of color. 

        c3: float
        	[in] -> Third component of color. 

        alpha: float
        	[in] -> Alpha component of color.


        '''
        pass

class MColorType:
    '''Defines color space. 
    Non-functional class.  Values for this enum:
    kRGB
    kHSV
    kCMY
    kCMYK
    '''

    def __init__(self):
        pass

    def kRGB(self):
        '''This is an enum of MColorType.
        - Description: Red, Green, Blue. 
        - Value: 0
        '''
        pass

    def kHSV(self):
        '''This is an enum of MColorType.
        - Description: Hue, Saturation, Value. 
        - Value: 1
        '''
        pass

    def kCMY(self):
        '''This is an enum of MColorType.
        - Description: Cyan, Magenta, Yellow. 
        - Value: 2
        '''
        pass

    def kCMYK(self):
        '''This is an enum of MColorType.
        - Description: Cyan, Magenta, Yellow, Black. 
        - Value: 3
        '''
        pass

class MColorArray:
    '''Array of
MColor data type.
This class implements an array of
MColor's. Common convenience functions are available, and the
implementation is compatible with the internal Maya
implementation so that it can be passed efficiently between
plugins and internal maya data structures.
'''
    def __init__(self):
        pass


    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> const MColor&

        Synopsis
        -----
        Index operator. Returns the value of the element at the given
        index. No range checking is done - valid indices are 0 to
        length()-1.

        Returns: 
        ----- 
        The value of the indicated element.

        Parameters:
        -----
        index: int
        	[in] -> the index of the element whose value is to be returned


        '''
        pass

    @overload
    def set(self, element: MColor,
                        index: int): 
        '''
        set(self, element: MColor,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated value.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MColor
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    @overload
    def set(self, index: int,
                        r: float,
                        g: float,
                        b: float,
                        a: float): 
        '''
        set(self, index: int,
                        r: float,
                        g: float,
                        b: float,
                        a: float)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated values.
        The r component of the element is set to r, the g component to g,
        the b component to b, and the a component to a.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the index of the element that is to be set to the the new value 

        r: float
        	[in] -> the new value for the r component 

        g: float
        	[in] -> the new value for the g component 

        b: float
        	[in] -> the new value for the b component 

        a: float
        	[in] -> the new value for the a component,defaulted to 1


        '''
        pass

    @overload
    def set(self, val: float4,
                        index: int): 
        '''
        set(self, val: float4,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated value.
        The r component of the element is set to val[0], the g component
        to val[1], the b component to val[2], and the a component to
        val[3].

        Returns:
        -----
        None

        Parameters:
        -----
        val: float4
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    @overload
    def set(self, elements: float,
                        size: int): 
        '''
        set(self, elements: float,
                        size: int)

        Synopsis
        -----
        Resets the values of the color components. The length of the
        passed in C++ array should be same as the length of the
        ColorArray to which we are setting the values.

        Returns:
        -----
        None

        Parameters:
        -----
        elements: float
        	[in] -> C++ array of float arrays of length four. 

        size: int
        	[in] -> the number of elements in the array.


        '''
        pass

    @overload
    def set(self, elements: double,
                        size: int): 
        '''
        set(self, elements: double,
                        size: int)

        Synopsis
        -----
        Resets the values of the color components. The length of the
        passed in C++ array should be same as the length of the
        ColorArray to which we are setting the values.

        Returns:
        -----
        None

        Parameters:
        -----
        elements: double
        	[in] -> C++ array of double arrays of length four. 

        size: int
        	[in] -> the number of elements in the array.


        '''
        pass

    def setLength(self, length: int): 
        '''
        setLength(self, length: int)

        Synopsis
        -----
        Set the length of the array. This will grow and shrink the array
        as desired. Elements that are grown have uninitialized values,
        while those which are shrunk will lose the data contained in the
        deleted elements (ie. it will release the memory).

        Returns:
        -----
        None

        Parameters:
        -----
        length: int
        	[in] -> the new size of the array


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Returns the number of elements in the instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Remove the array element at the given index. All array elements
        following the removed element are shifted toward the first
        element.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> index of the element to be removed


        '''
        pass

    def insert(self, element: MColor,
                        index: int): 
        '''
        insert(self, element: MColor,
                        index: int)

        Synopsis
        -----
        Inserts a new value into the array at the given index. The
        initial element at that index, and all following elements, are
        shifted towards the last. If the array cannot be expanded in size
        by 1 element, then the insert will fail and the existing array
        will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MColor
        	[in] -> the new value to insert into the array 

        index: int
        	[in] -> the index of the element to set to the the new value


        '''
        pass

    @overload
    def append(self, element: MColor): 
        '''
        append(self, element: MColor)

        Synopsis
        -----
        Adds a new element to the end of the array. If the array cannot
        be expanded in size by 1 element, then the append will fail and
        the existing array will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MColor
        	[in] -> the value for the new last element


        '''
        pass

    @overload
    def append(self, x: float,
                        y: float,
                        z: float,
                        w: float): 
        '''
        append(self, x: float,
                        y: float,
                        z: float,
                        w: float)

        Synopsis
        -----
        Adds a new element to the end of the array. The appended element
        has the indicated values for its x,y,z and w components. The x
        component of the element is set to x, the y component to y, the z
        component to z, and the w component to w.If the array cannot be
        expanded in size by 1 element, then the append will fail and the
        existing array will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        x: float
        	[in] -> the value for the x component 

        y: float
        	[in] -> the value for the y component 

        z: float
        	[in] -> the value for the z component, defaulted to 0 

        w: float
        	[in] -> the value for the w component, defaulted to 1


        '''
        pass

    def copy(self, source: MColorArray): 
        '''
        copy(self, source: MColorArray)

        Synopsis
        -----
        Copy the contents of the source array to this array.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MColorArray
        	[in] -> array to copy from


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clear the contents of the array. After this operation the length
        method will return 0. This does not change the amount of memory
        allocated to the array, only the number of valid elements in it.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def get(self, dest: float): 
        '''
        get(self, dest: float)

        Synopsis
        -----
        Copy the elements of the array into the C++ array of float
        arrays. No checking is done to ensure that the destination C++
        array of float arrays is large enough to hold all the elements of
        the instance.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: float
        	[out] -> the array to populate


        '''
        pass

    def setSizeIncrement(self, newIncrement: int): 
        '''
        setSizeIncrement(self, newIncrement: int)

        Synopsis
        -----
        Set the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        newIncrement: int
        	[in] -> the new increment 


        '''
        pass

    def sizeIncrement(self): 
        '''
        sizeIncrement(self) -> int

        Synopsis
        -----
        Return the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MColorArray.MColorArray

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MColorArray.MColorArray

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MColorArray.MColorArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MColorArray.MColorArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MColorArray.MColorArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MColorArray.MColorArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MCommandMessage:
    '''Helper class to handle MEL output.
This class is used to register for a callback for when certain
MEL command related messages are generated.
The add callback method returns an id which is used to remove the
callback.
To remove a callback use
MMessage::removeCallback.
All callbacks that are registered by a plug-in must be removed by
that plug-in when it is unloaded. Failure to do so will result in
a fatal error.
'''
    def __init__(self):
        pass


    def addCommandCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MCommandMessage.MStatus): 
        '''
        addCommandCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MCommandMessage.MStatus) -> MCommandMessage.OPENMAYA_MAJOR_NAMESPACE_OPENMCallbackId

        Synopsis
        -----
        This method registers a callback for command messages that are
        issued every time a MEL command is executed. It is only called
        when actual commands are executed and not when scripts are
        executed.The callback function will be passed the any client data
        that was provided when the callback was registered.NOTE: Setting
        up a callback using this method will degrade the performance of
        Maya since the installed callback will be invoked repeatedly as
        MEL operations are processed.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> The callback function. 

        clientData: void
        	[in] -> User defined data that will be passed to the callback function. 

        ReturnStatus: MCommandMessage.MStatus
        	[out] -> Status code.


        '''
        pass

    def addCommandOutputCallback(self, func: MCommandMessage.MCommandMessage,
                        clientData: void,
                        ReturnStatus: MCommandMessage.MStatus): 
        '''
        addCommandOutputCallback(self, func: MCommandMessage.MCommandMessage,
                        clientData: void,
                        ReturnStatus: MCommandMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback for whenever commands generate
        output such as that which is printed into the command window. The
        callback function will be passed the any client data that was
        provided when the callback was registered.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MCommandMessage.MCommandMessage
        	[in] -> The callback function. 

        clientData: void
        	[in] -> User defined data that will be passed to the callback function. 

        ReturnStatus: MCommandMessage.MStatus
        	[out] -> Status code.


        '''
        pass

    def addCommandOutputFilterCallback(self, func: MCommandMessage.MCommandMessage,
                        clientData: void,
                        ReturnStatus: MCommandMessage.MStatus): 
        '''
        addCommandOutputFilterCallback(self, func: MCommandMessage.MCommandMessage,
                        clientData: void,
                        ReturnStatus: MCommandMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback for whenever commands generate
        output such as that which is printed into the command window.
        This callback includes a boolean filter option which allows the
        callback to prevent the output of the message to the script
        editor and command line output. Setting the 'filterOutput'
        parameter to true, inside your callback will filter the output
        from the script editor and command line output.The callback
        function will be passed the any client data that was provided
        when the callback was registered.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MCommandMessage.MCommandMessage
        	[in] -> The callback function. 

        clientData: void
        	[in] -> User defined data that will be passed to the callback function. 

        ReturnStatus: MCommandMessage.MStatus
        	[out] -> Status code.


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def addProcCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MCommandMessage.MStatus): 
        '''
        addProcCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MCommandMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is executed every time a
        MEL procedure is run. The callback will be executed once when the
        procedure is about to be executed, and again when it has exited.
        If a non-existent procedure is called the callback will be called
        once for entry but there will be no call on exit.The callback
        function should have the following parameters:func(const MString&
        procName, unsigned int procID, bool isProcEntry, unsigned int
        type, void* clientData)Where: procName will be the name of the
        procedure being invoked procID is the ID for the procedure's
        invocation isProcEntry is true if the procedure is being entered,
        false otherwise type is an MCommandMessage::ProcType value, and
        denotes the type of call this is, a MEL Proc, or MEL Command
        clientData is a pointer to an unsigned integer which is the
        invocation ID of the procedureThe callback cannot be registered
        multiple times. To register a new callback function for this,
        please de-register the original callback first.NOTE: Setting up a
        callback using this method can potentially degrade the
        performance of Maya since the installed callback will be invoked
        repeatedly as MEL procedures are executed.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> The callback function. 

        clientData: void
        	[in] -> User defined data that will be passed to the callback function. 

        ReturnStatus: MCommandMessage.MStatus
        	[out] -> Status code.


        '''
        pass

class MessageType:
    '''Types of output messages. 
    Non-functional class.  Values for this enum:
    kHistory
    kDisplay
    kInfo
    kWarning
    kError
    kResult
    kStackTrace
    '''

    def __init__(self):
        pass

    def kHistory(self):
        '''This is an enum of MessageType.
        - Description: Command history. 
        - Value: 0
        '''
        pass

    def kDisplay(self):
        '''This is an enum of MessageType.
        - Description: String to display unmodified. 
        - Value: 1
        '''
        pass

    def kInfo(self):
        '''This is an enum of MessageType.
        - Description: General information. 
        - Value: 2
        '''
        pass

    def kWarning(self):
        '''This is an enum of MessageType.
        - Description: Warning message. 
        - Value: 3
        '''
        pass

    def kError(self):
        '''This is an enum of MessageType.
        - Description: Error message. 
        - Value: 4
        '''
        pass

    def kResult(self):
        '''This is an enum of MessageType.
        - Description: Result from a command execution in the command window. 
        - Value: 5
        '''
        pass

    def kStackTrace(self):
        '''This is an enum of MessageType.
        - Description: Stack trace. 
        - Value: 6
        '''
        pass

class MCommandResult:
    '''Result returned from executing a command.
MCommandResult collects the result returned by
MGlobal::executeCommand. It can either be an int or an array of int or a double or an
array of double or a string or an array of string. Use resultType
to find out its type and use the appropriate getResult method to
retrieve the result.
'''
    def __init__(self):
        pass


    def resultType(self, ReturnStatus: MCommandResult.MStatus): 
        '''
        resultType(self, ReturnStatus: MCommandResult.MStatus) -> MCommandResult.MCommandResult

        Synopsis
        -----
        Returns the type of the result.

        Returns: 
        ----- 
        MCommandResult::kInt  MCommandResult::kIntArray
        MCommandResult::kDouble  MCommandResult::kDoubleArray
        MCommandResult::kString  MCommandResult::kStringArray
        MCommandResult::kVector  MCommandResult::kVectorArray
        MCommandResult::kMatrix  MCommandResult::kInvalid

        Parameters:
        -----
        ReturnStatus: MCommandResult.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def getResult(self, result: int): 
        '''
        getResult(self, result: int)

        Synopsis
        -----
        Retrieves an integer result as a 32-bit int. Results too big to
        fit in a 32-bit int will be truncated to their least significant
        32 bits.

        Returns:
        -----
        None

        Parameters:
        -----
        result: int
        	[out] -> Storage for the command result


        '''
        pass

    @overload
    def getResult(self, result: MCommandResult.MInt64): 
        '''
        getResult(self, result: MCommandResult.MInt64)

        Synopsis
        -----
        Retrieves an integer command result as a 64-bit int.

        Returns:
        -----
        None

        Parameters:
        -----
        result: MCommandResult.MInt64
        	[out] -> Storage for the command result


        '''
        pass

    @overload
    def getResult(self, result: MIntArray): 
        '''
        getResult(self, result: MIntArray)

        Synopsis
        -----
        Retrieves the command result which is an int array.

        Returns:
        -----
        None

        Parameters:
        -----
        result: MIntArray
        	[out] -> Storage for the command result


        '''
        pass

    @overload
    def getResult(self, result: MInt64Array): 
        '''
        getResult(self, result: MInt64Array)

        Synopsis
        -----
        Retrieves the command result which is an MInt64Array.

        Returns:
        -----
        None

        Parameters:
        -----
        result: MInt64Array
        	[out] -> Storage for the command result


        '''
        pass

    @overload
    def getResult(self, result: double): 
        '''
        getResult(self, result: double)

        Synopsis
        -----
        Retrieves the command result which is a double.

        Returns:
        -----
        None

        Parameters:
        -----
        result: double
        	[out] -> Storage for the command result


        '''
        pass

    @overload
    def getResult(self, result: MDoubleArray): 
        '''
        getResult(self, result: MDoubleArray)

        Synopsis
        -----
        Retrieves the command result which is a double array.

        Returns:
        -----
        None

        Parameters:
        -----
        result: MDoubleArray
        	[out] -> Storage for the command result


        '''
        pass

    def stringResult(self, ReturnStatus: MCommandResult.MStatus): 
        '''
        stringResult(self, ReturnStatus: MCommandResult.MStatus) -> MString

        Synopsis
        -----
        Retrieves the command result which is a string.

        Returns: 
        ----- 
        The command result

        Parameters:
        -----
        ReturnStatus: MCommandResult.MStatus
        	[out] -> Optional status code. See below.


        '''
        pass

    @overload
    def getResult(self, result: MStringArray): 
        '''
        getResult(self, result: MStringArray)

        Synopsis
        -----
        Retrieves the command result which is a string array.

        Returns:
        -----
        None

        Parameters:
        -----
        result: MStringArray
        	[out] -> Storage for the command result


        '''
        pass

    @overload
    def getResult(self, result: MVector): 
        '''
        getResult(self, result: MVector)

        Synopsis
        -----
        Retrieves the command result which is a vector.

        Returns:
        -----
        None

        Parameters:
        -----
        result: MVector
        	[out] -> Storage for the command result


        '''
        pass

    @overload
    def getResult(self, result: MVectorArray): 
        '''
        getResult(self, result: MVectorArray)

        Synopsis
        -----
        Retrieves the command result which is a vector array.

        Returns:
        -----
        None

        Parameters:
        -----
        result: MVectorArray
        	[out] -> Storage for the command result


        '''
        pass

    @overload
    def getResult(self, result: MDoubleArray,
                        numRows: int,
                        numColumns: int): 
        '''
        getResult(self, result: MDoubleArray,
                        numRows: int,
                        numColumns: int)

        Synopsis
        -----
        Retrieves the command result which is a matrix.

        Returns:
        -----
        None

        Parameters:
        -----
        result: MDoubleArray
        	[out] -> Storage for the content of the matrix (row-based) 

        numRows: int
        	[out] -> The number of rows in the matrix 

        numColumns: int
        	[out] -> The number of columns in the matrix


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class Type:
    '''The types of results that MEL commands can return. 
    Non-functional class.  Values for this enum:
    kInvalid
    kInt
    kInt64
    kIntArray
    kInt64Array
    kDouble
    kDoubleArray
    kString
    kStringArray
    kVector
    kVectorArray
    kMatrix
    kMatrixArray
    '''

    def __init__(self):
        pass

    def kInvalid(self):
        '''This is an enum of Type.
        - Description:  
        - Value: 0
        '''
        pass

    def kInt(self):
        '''This is an enum of Type.
        - Description:  
        - Value: 1
        '''
        pass

    def kInt64(self):
        '''This is an enum of Type.
        - Description:  
        - Value: 2
        '''
        pass

    def kIntArray(self):
        '''This is an enum of Type.
        - Description:  
        - Value: 3
        '''
        pass

    def kInt64Array(self):
        '''This is an enum of Type.
        - Description:  
        - Value: 4
        '''
        pass

    def kDouble(self):
        '''This is an enum of Type.
        - Description:  
        - Value: 5
        '''
        pass

    def kDoubleArray(self):
        '''This is an enum of Type.
        - Description:  
        - Value: 6
        '''
        pass

    def kString(self):
        '''This is an enum of Type.
        - Description:  
        - Value: 7
        '''
        pass

    def kStringArray(self):
        '''This is an enum of Type.
        - Description:  
        - Value: 8
        '''
        pass

    def kVector(self):
        '''This is an enum of Type.
        - Description:  
        - Value: 9
        '''
        pass

    def kVectorArray(self):
        '''This is an enum of Type.
        - Description:  
        - Value: 10
        '''
        pass

    def kMatrix(self):
        '''This is an enum of Type.
        - Description:  
        - Value: 11
        '''
        pass

    def kMatrixArray(self):
        '''This is an enum of Type.
        - Description:  
        - Value: 12
        '''
        pass

class MComputation:
    '''Interupt monitor for long computations.
An
MComputation allows long computations to check for user interrupts. It is
very simple to use. Create a new
 object and call the
 method at the beginning of the computation and call the
 method when you finish. Then, during the computation, use the
 method to check if the user has requested that the computation
terminate.
 (of a simple traversal)
An alternate form of computation with a progress indicator is
supported. In this case, the
 method is called along with the progress methods.
 (of a simple progressive traversal)
'''
    def __init__(self):
        pass


    def beginComputation(self, showProgressBar: bool,
                        isInterruptable: bool,
                        useWaitCursor: bool): 
        '''
        beginComputation(self, showProgressBar: bool,
                        isInterruptable: bool,
                        useWaitCursor: bool)

        Synopsis
        -----
        Mark the beginning of a long computation. The application will
        begin looking for user interupts.

        Returns:
        -----
        None

        Parameters:
        -----
        showProgressBar: bool
        	[in] -> if true a progress bar is displayed 

        isInterruptable: bool
        	[in] -> ESC can be used in conjunction with the 

        useWaitCursor: bool
        	[in] -> if true, cursor goes busy during computation 


        '''
        pass

    def isInterruptRequested(self): 
        '''
        isInterruptRequested(self) -> bool

        Synopsis
        -----
        Query whether a user-interrupt has occurred.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def endComputation(self): 
        '''
        endComputation(self)

        Synopsis
        -----
        Mark the ending of a long computation. The application will stop
        looking for user interupts.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setProgressRange(self, minValue: int,
                        maxValue: int): 
        '''
        setProgressRange(self, minValue: int,
                        maxValue: int)

        Synopsis
        -----
        Sets the range (minValue, maxValue) of the progress indicator.
        When the progress value is set to a value of minValue, the
        progress bar is displayed as empty. When the progress value is
        set to a value of maxValue, the progress bar is displayed as
        full. Intermediate progress values are displayed as intermediate
        positions of the progress bar.

        Returns:
        -----
        None

        Parameters:
        -----
        minValue: int
        	[in] -> Minimum progress value 

        maxValue: int
        	[in] -> Maximum progress value


        '''
        pass

    def progressMin(self, ReturnStatus: MComputation.MStatus): 
        '''
        progressMin(self, ReturnStatus: MComputation.MStatus) -> int

        Synopsis
        -----
        Get the minimum progress value.

        Returns: 
        ----- 
        Minimum progress value. Returns -1 if query fails.

        Parameters:
        -----
        ReturnStatus: MComputation.MStatus
        	[out] -> Status code


        '''
        pass

    def progressMax(self, ReturnStatus: MComputation.MStatus): 
        '''
        progressMax(self, ReturnStatus: MComputation.MStatus) -> int

        Synopsis
        -----
        Get the maximum progress value.

        Returns: 
        ----- 
        Maximum progress value. Returns -1 if query fails.

        Parameters:
        -----
        ReturnStatus: MComputation.MStatus
        	[out] -> Status code


        '''
        pass

    def setProgress(self, amount: int): 
        '''
        setProgress(self, amount: int)

        Synopsis
        -----
        Sets the progress value. Advancing the progress value updates the
        progress bar to show the new amount of progress.

        Returns:
        -----
        None

        Parameters:
        -----
        amount: int
        	[in] -> New progress value


        '''
        pass

    def progress(self, ReturnStatus: MComputation.MStatus): 
        '''
        progress(self, ReturnStatus: MComputation.MStatus) -> int

        Synopsis
        -----
        Get the progress value.

        Returns: 
        ----- 
        Progress value. Returns -1 if query fails.

        Parameters:
        -----
        ReturnStatus: MComputation.MStatus
        	[out] -> Status code


        '''
        pass

    def setProgressStatus(self, progressString: MString): 
        '''
        setProgressStatus(self, progressString: MString)

        Synopsis
        -----
        Sets the progress status string. For example, you could use this
        to display the percentage of the computation which has been
        completed.

        Returns:
        -----
        None

        Parameters:
        -----
        progressString: MString
        	[in] -> New status string


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MConditionMessage:
    '''Condition change messages.
This class is used to register callbacks for changes to specific
conditions.
The addConditionCallback method will add callback a callback for
condition changed messages.
The first parameter passed to the addConditionCallback method is
the name of the condition that will trigger the callback. The
list of available condition names can be retrieved by calling the
getConditionNames method or by using the -listConditions flag on
the
 command.
Callbacks that are registered for conditions will be passed a
bool value as a parameter. This value indicates the new state of
the condition.
The addConditionCallback method returns an id which is used to
remove the callback.
To remove a callback use
MMessage::removeCallback.
All callbacks that are registered by a plug-in must be removed by
that plug-in when it is unloaded. Failure to do so will result in
a fatal error.
The getConditionState method is used to return the current state
of the specified condition.
'''
    def __init__(self):
        pass


    def addConditionCallback(self, conditionName: MString,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MConditionMessage.MStatus): 
        '''
        addConditionCallback(self, conditionName: MString,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MConditionMessage.MStatus) -> MConditionMessage.OPENMAYA_MAJOR_NAMESPACE_OPENMCallbackId

        Synopsis
        -----
        This method registers a callback for condition changed messages.
        The callback function will be passed the new state of the
        condition and any client data that the user wishes to pass
        in.Example callback ( prints out a message when a condition
        changes ) :

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        conditionName: MString
        	[in] -> the condition to register the callback for 

        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data that will be passed to the callback function 

        ReturnStatus: MConditionMessage.MStatus
        	[out] -> status code


        '''
        pass

    def getConditionNames(self, names: MStringArray): 
        '''
        getConditionNames(self, names: MStringArray)

        Synopsis
        -----
        This method returns the list of available condition names.

        Returns:
        -----
        None

        Parameters:
        -----
        names: MStringArray
        	[out] -> set to the array of available condition names.


        '''
        pass

    def getConditionState(self, name: MString,
                        ReturnStatus: MConditionMessage.MStatus): 
        '''
        getConditionState(self, name: MString,
                        ReturnStatus: MConditionMessage.MStatus) -> bool

        Synopsis
        -----
        This method returns the current state of a condition.

        Returns: 
        ----- 
        The current state of the condition.

        Parameters:
        -----
        name: MString
        	[in] -> the name of the condition. 

        ReturnStatus: MConditionMessage.MStatus
        	[out] -> status code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MConnectDisconnectAttrEdit:
    '''Class for describing connection and disconnection edits.
This class is used to query information about connection and
disconnection edits. Such edits occur when a file reference or
assembly is loaded and connections are made or broken to
attributes within the loaded nodes.
Please note that when a reference or assembly is unloaded, plugs
related to operations cannot be returned since the plugs
themselves do not exist. Thus for unloaded references, only the
plug names may be queried successfully.
The
MItEdits class may be used to iterate over all the edits on a given
reference or assembly.
'''
    def __init__(self):
        pass


    def srcPlug(self, ReturnStatus: MConnectDisconnectAttrEdit.MStatus): 
        '''
        srcPlug(self, ReturnStatus: MConnectDisconnectAttrEdit.MStatus) -> MConnectDisconnectAttrEdit.OPENMAYA_MAJOR_NAMESPACE_OPEN MPlug

        Synopsis
        -----
        Returns the source plug that was connected or disconnected for
        this edit. The plug can only be returned when the related
        reference or assembly is loaded. When the reference or assembly
        is unloaded, only the plug name string can be queried.

        Returns: 
        ----- 
        The source plug for this edit

        Parameters:
        -----
        ReturnStatus: MConnectDisconnectAttrEdit.MStatus
        	[out] -> Status Code


        '''
        pass

    def dstPlug(self, ReturnStatus: MConnectDisconnectAttrEdit.MStatus): 
        '''
        dstPlug(self, ReturnStatus: MConnectDisconnectAttrEdit.MStatus) -> MPlug

        Synopsis
        -----
        Returns the destination plug that was connected or disconnected
        for this edit. The plug can only be returned when the related
        reference or assembly is loaded. When the reference or assembly
        is unloaded, only the plug name string can be queried.

        Returns: 
        ----- 
        The destination plug for this edit

        Parameters:
        -----
        ReturnStatus: MConnectDisconnectAttrEdit.MStatus
        	[out] -> Status Code


        '''
        pass

    def srcPlugName(self, ReturnStatus: MConnectDisconnectAttrEdit.MStatus): 
        '''
        srcPlugName(self, ReturnStatus: MConnectDisconnectAttrEdit.MStatus) -> MString

        Synopsis
        -----
        Returns the name of the source plug that was connected or
        disconnected.

        Returns: 
        ----- 
        The name of the source plug

        Parameters:
        -----
        ReturnStatus: MConnectDisconnectAttrEdit.MStatus
        	[out] -> Status Code


        '''
        pass

    def dstPlugName(self, ReturnStatus: MConnectDisconnectAttrEdit.MStatus): 
        '''
        dstPlugName(self, ReturnStatus: MConnectDisconnectAttrEdit.MStatus) -> MString

        Synopsis
        -----
        Returns the name of the destination plug that was connected or
        disconnected.

        Returns: 
        ----- 
        The name of the destination plug

        Parameters:
        -----
        ReturnStatus: MConnectDisconnectAttrEdit.MStatus
        	[out] -> Status Code


        '''
        pass

    def isConnection(self): 
        '''
        isConnection(self) -> bool

        Synopsis
        -----
        Returns true if this edit is for a connection, false for a
        disconnection.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def editType(self, ReturnStatus: MConnectDisconnectAttrEdit.MStatus): 
        '''
        editType(self, ReturnStatus: MConnectDisconnectAttrEdit.MStatus) -> MEdit.MEdit

        Synopsis
        -----
        Virtual method used to return the edit type of this edit, which
        is MEdit::kConnectDisconnectEdit. Reimplemented from MEdit.

        Returns: 
        ----- 
        MEdit::kConnectDisconnectEdit

        Parameters:
        -----
        ReturnStatus: MConnectDisconnectAttrEdit.MStatus
        	[out] -> return status


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MContainerMessage:
    '''Container-related messages.
The container node in Maya bundles together a group of related
nodes. The user can then publish attribute names to the
container, and bind attributes from nodes in the container to the
published names.
MContainerMessage class allows the API user to register callbacks that inform them
about changes to published attributes on containers.
To remove a callback use
MMessage::removeCallback. All callbacks that are registered by a plug-in must be removed
by that plug-in when it is unloaded. Failure to do so will result
in a fatal error.
'''
    def __init__(self):
        pass


    def addPublishAttrCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MContainerMessage.MStatus): 
        '''
        addPublishAttrCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MContainerMessage.MStatus) -> MContainerMessage.OPENMAYA_MAJOR_NAMESPACE_OPENMCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever an
        attribute is published or unpublished from a container.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MContainerMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addBoundAttrCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MContainerMessage.MStatus): 
        '''
        addBoundAttrCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MContainerMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever an
        attribute is bound or unbound on a container.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MContainerMessage.MStatus
        	[out] -> status code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MCurveAttribute:
    '''Create and manipulate curve attributes.
A curve attribute consists of a set of entries describing a 3rd
degree NURBS curve which is used to map an input value onto an
output value. Each entry consists of an input
 ranging from 0 to 1, an output
 that position maps onto. The (position, value) pairs form a
control vertex for the NURBS curve.
The preferred way of creating a curve attribute is to use the
 or
 methods. Once created, curve widgets can be created for those
attributes using the
 or
 MEL commands.
A curve must always have at least four control vertices since it
is a third degree NURBS curve.
'''
    def __init__(self):
        pass


    def getNumEntries(self, ReturnStatus: MCurveAttribute.MStatus): 
        '''
        getNumEntries(self, ReturnStatus: MCurveAttribute.MStatus) -> int

        Synopsis
        -----
        Gets the number of entries in the curve attribute.

        Returns: 
        ----- 
        The number of entries in the curve attribute

        Parameters:
        -----
        ReturnStatus: MCurveAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def getEntries(self, indices: MIntArray,
                        positions: MFloatArray,
                        values: MFloatArray,
                        ReturnStatus: MCurveAttribute.MStatus): 
        '''
        getEntries(self, indices: MIntArray,
                        positions: MFloatArray,
                        values: MFloatArray,
                        ReturnStatus: MCurveAttribute.MStatus)

        Synopsis
        -----
        Gets all the entries in a curve attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        indices: MIntArray
        	[out] -> unique values that specify each entry in the curve 

        positions: MFloatArray
        	[out] -> the positions of each entry (can range from 0 to 1) 

        values: MFloatArray
        	[out] -> the values of the entries at each position (can range from 0 to 1) 

        ReturnStatus: MCurveAttribute.MStatus
        	[out] -> Status code.


        '''
        pass

    def addEntries(self, positions: MFloatArray,
                        values: MFloatArray,
                        ReturnStatus: MCurveAttribute.MStatus): 
        '''
        addEntries(self, positions: MFloatArray,
                        values: MFloatArray,
                        ReturnStatus: MCurveAttribute.MStatus)

        Synopsis
        -----
        Adds entries into a curve attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        positions: MFloatArray
        	[in] -> the positions of the new entries (can range from 0 to 1) 

        values: MFloatArray
        	[in] -> the values of the new entry at each position 

        ReturnStatus: MCurveAttribute.MStatus
        	[out] -> Status code.


        '''
        pass

    def deleteEntries(self, indices: MIntArray,
                        ReturnStatus: MCurveAttribute.MStatus): 
        '''
        deleteEntries(self, indices: MIntArray,
                        ReturnStatus: MCurveAttribute.MStatus)

        Synopsis
        -----
        Deletes entries in the curve attribute. If any one of the indices
        is incorrect, then this function will not delete any of the
        entries.A curve attribute must always have at least one entry.
        Any attempt to delete the last remaining entry will fail.

        Returns:
        -----
        None

        Parameters:
        -----
        indices: MIntArray
        	[in] -> the entries that need to be deleted 

        ReturnStatus: MCurveAttribute.MStatus
        	[out] -> Status code.


        '''
        pass

    def setValueAtIndex(self, value: float,
                        index: int,
                        ReturnStatus: MCurveAttribute.MStatus): 
        '''
        setValueAtIndex(self, value: float,
                        index: int,
                        ReturnStatus: MCurveAttribute.MStatus)

        Synopsis
        -----
        Sets the value of a given entry. If there is no entry at the
        given index, then this method will return a failure.

        Returns:
        -----
        None

        Parameters:
        -----
        value: float
        	[in] -> the new value for the entry 

        index: int
        	[in] -> index of entry to change 

        ReturnStatus: MCurveAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def setPositionAtIndex(self, position: float,
                        index: int,
                        ReturnStatus: MCurveAttribute.MStatus): 
        '''
        setPositionAtIndex(self, position: float,
                        index: int,
                        ReturnStatus: MCurveAttribute.MStatus)

        Synopsis
        -----
        Sets the position of a given entry. If there is no entry at the
        given index, then this method will return a failure.

        Returns:
        -----
        None

        Parameters:
        -----
        position: float
        	[in] -> the new position for the entry 

        index: int
        	[in] -> index of entry to change 

        ReturnStatus: MCurveAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def getValuesAtPositions(self, positions: MFloatArray,
                        values: MFloatArray,
                        ReturnStatus: MCurveAttribute.MStatus): 
        '''
        getValuesAtPositions(self, positions: MFloatArray,
                        values: MFloatArray,
                        ReturnStatus: MCurveAttribute.MStatus)

        Synopsis
        -----
        Gets the values (y-axis) at the given positions (x-axis) If this
        curve is empty, then this method will return a failure. If any
        position is out of range, either the start or end value will be
        returned at the corresponding index in the value array.

        Returns:
        -----
        None

        Parameters:
        -----
        positions: MFloatArray
        	[in] -> the desired x-axis positions 

        values: MFloatArray
        	[in] -> the y-axis values at the positions 

        ReturnStatus: MCurveAttribute.MStatus
        	[out] -> Status code


        '''
        pass

    def getValueAtPosition(self, position: float,
                        value: float,
                        ReturnStatus: MCurveAttribute.MStatus): 
        '''
        getValueAtPosition(self, position: float,
                        value: float,
                        ReturnStatus: MCurveAttribute.MStatus)

        Synopsis
        -----
        Gets the value (y-axis) at the given position (x-axis) x If this
        curve is empty, then this method will return a failure. If the
        position is out of range, either the start or end value will be
        returned.

        Returns:
        -----
        None

        Parameters:
        -----
        position: float
        	[in] -> the desired position (x-axis) 

        value: float
        	[out] -> the y-axis value at the position 

        ReturnStatus: MCurveAttribute.MStatus
        	[out] -> Status code


        '''
        pass

    def sampleValueCurve(self, numberOfSamples: int,
                        values: MFloatArray,
                        ReturnStatus: MCurveAttribute.MStatus): 
        '''
        sampleValueCurve(self, numberOfSamples: int,
                        values: MFloatArray,
                        ReturnStatus: MCurveAttribute.MStatus)

        Synopsis
        -----
        Perform a linear sampling of this curve ramp and return the
        results. If this curve is empty, then this method will return a
        failure. If the number of samples is less than two this method
        will return a failure.

        Returns:
        -----
        None

        Parameters:
        -----
        numberOfSamples: int
        	[in] -> The number of times to sample the ramp 

        values: MFloatArray
        	[out] -> The returned ramp samples 

        ReturnStatus: MCurveAttribute.MStatus
        	[out] -> Status code


        '''
        pass

    def hasIndex(self, index: int,
                        ReturnStatus: MCurveAttribute.MStatus): 
        '''
        hasIndex(self, index: int,
                        ReturnStatus: MCurveAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this curve attribute has an entry defined with a
        given index.

        Returns: 
        ----- 
        True if the index exists, false otherwise.

        Parameters:
        -----
        index: int
        	[in] -> Index to query. 

        ReturnStatus: MCurveAttribute.MStatus
        	[out] -> Status code


        '''
        pass

    def sort(self, ascending: bool): 
        '''
        sort(self, ascending: bool)

        Synopsis
        -----
        Sort the curve attribute entries by position in ascending or
        descending order, other arrays are sorted accordingly. Indices
        are also compressed during the operation.

        Returns:
        -----
        None

        Parameters:
        -----
        ascending: bool
        	[in] -> Option for sorting in ascending (default) or descending order.


        '''
        pass

    def pack(self): 
        '''
        pack(self)

        Synopsis
        -----
        Change the indices numbering by re-ordering them from 0.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setCurve(self, values: MFloatArray,
                        positions: MFloatArray): 
        '''
        setCurve(self, values: MFloatArray,
                        positions: MFloatArray)

        Synopsis
        -----
        Sets this curve attribute with entries defined from a set of
        float, position value arrays. Existing entries are deleted before
        the new ones are added.

        Returns:
        -----
        None

        Parameters:
        -----
        values: MFloatArray
        	[in] -> Array of float value. 

        positions: MFloatArray
        	[in] -> Array of desired positions.


        '''
        pass

    def createCurveAttr(self, attrLongName: MString,
                        attrShortName: MString,
                        ReturnStatus: MCurveAttribute.MStatus): 
        '''
        createCurveAttr(self, attrLongName: MString,
                        attrShortName: MString,
                        ReturnStatus: MCurveAttribute.MStatus) -> MObject

        Synopsis
        -----
        This function creates the curve attribute.

        Returns: 
        ----- 
        Curve ramp attribute, returned as MObject.

        Parameters:
        -----
        attrLongName: MString
        	[in] -> Long name of the curve attribute 

        attrShortName: MString
        	[in] -> Short name of the curve attribute 

        ReturnStatus: MCurveAttribute.MStatus
        	[out] -> Return status


        '''
        pass

    def createCurve(self, attrLongName: MString,
                        attrShortName: MString,
                        node: MObject,
                        values: MFloatArray,
                        positions: MFloatArray,
                        ReturnStatus: MCurveAttribute.MStatus): 
        '''
        createCurve(self, attrLongName: MString,
                        attrShortName: MString,
                        node: MObject,
                        values: MFloatArray,
                        positions: MFloatArray,
                        ReturnStatus: MCurveAttribute.MStatus) -> MObject

        Synopsis
        -----
        Creates a new curve attribute initialized with entries defined
        from a set of float, position value arrays.

        Returns:
        -----
        None

        Parameters:
        -----
        attrLongName: MString
        	[in] -> Long name of the new curve attribute 

        attrShortName: MString
        	[in] -> Short name of the new curve attribute 

        node: MObject
        	[in] -> The node to which the new attribute will be added 

        values: MFloatArray
        	[in] -> Array of float value. 

        positions: MFloatArray
        	[in] -> Array of desired positions. 

        ReturnStatus: MCurveAttribute.MStatus
        	[out] -> Status code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MDagMessage:
    '''DAG messages.
This class is used to register callbacks for DAG messages.
There are 6 types of add callback methods which will add
callbacks for the following messages
Methods exist to register callbacks for every time any DAG node
is affected as well as methods that work on specific nodes. Each
method returns an id which is used to remove the callback.
To remove a callback use
MMessage::removeCallback. All callbacks that are registered by a plug-in must be removed
by that plug-in when it is unloaded. Failure to do so will result
in a fatal error.
NOTE: It is possible to get Parent Added and Child Added messages
before the node name has been set. This can happen if the node is
newly created. Additionally, the
MDagPath string path names passed to the callback may not be set as yet
if the node has not been added to the model. Accessing objects
that are newly created or calling commands that access such
objects from a callback may produce unknown results.
'''
    def __init__(self):
        pass


    def addParentAddedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addParentAddedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MDagMessage.OPENMAYA_MAJOR_NAMESPACE_OPENMCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever a parent
        is added in the DAG. Please see the note in the Description
        section about this callback.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addParentAddedDagPathCallback(self, node: MDagPath,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addParentAddedDagPathCallback(self, node: MDagPath,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever a parent
        is added to the specified DAG node. Please see the note in the
        Description section about this callback.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MDagPath
        	[in] -> The DAG node to register the callback for 

        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addParentRemovedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addParentRemovedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever a parent
        is removed in the DAG.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addParentRemovedDagPathCallback(self, node: MDagPath,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addParentRemovedDagPathCallback(self, node: MDagPath,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever a parent
        is removed from the specified DAG node.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MDagPath
        	[in] -> The DAG node to register the callback for 

        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addChildAddedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addChildAddedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever a child
        is added in the DAG. Please see the note in the Description
        section about this callback.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addChildAddedDagPathCallback(self, node: MDagPath,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addChildAddedDagPathCallback(self, node: MDagPath,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever a child
        is added to the specified DAG node. Please see the note in the
        Description section about this callback.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MDagPath
        	[in] -> The DAG node to register the callback for 

        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addChildRemovedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addChildRemovedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever a child
        is removed in the DAG.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addChildRemovedDagPathCallback(self, node: MDagPath,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addChildRemovedDagPathCallback(self, node: MDagPath,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever a child
        is removed from the specified DAG node.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MDagPath
        	[in] -> The DAG node to register the callback for 

        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addChildReorderedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addChildReorderedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever a child
        is reordered in the DAG.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addChildReorderedDagPathCallback(self, node: MDagPath,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addChildReorderedDagPathCallback(self, node: MDagPath,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever a child
        of the specified DAG node is reordered.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MDagPath
        	[in] -> The DAG node to register the callback for 

        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addDagCallback(self, msgType: MDagMessage.DagMessage,
                        func: MDagMessage.MDagMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addDagCallback(self, msgType: MDagMessage.DagMessage,
                        func: MDagMessage.MDagMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called for specified DAG
        changes on all nodes. The callback will also receive the
        DagMessage.Please see the note in the Description section about
        this callback if Parent Added or Child Added messages are being
        used.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        msgType: MDagMessage.DagMessage
        	[in] -> The type of DAG change to trigger the callback 

        func: MDagMessage.MDagMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addDagDagPathCallback(self, node: MDagPath,
                        msgType: MDagMessage.DagMessage,
                        func: MDagMessage.MDagMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addDagDagPathCallback(self, node: MDagPath,
                        msgType: MDagMessage.DagMessage,
                        func: MDagMessage.MDagMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called for specified a
        DAG change is made to the specified DAG path. The callback
        receives the DagMessage as well.Please see the note in the
        Description section about this callback if Parent Added or Child
        Added messages are being used.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MDagPath
        	[in] -> The DAG node to register the callback for. 

        msgType: MDagMessage.DagMessage
        	[in] -> The type of DAG change to trigger the callback. 

        func: MDagMessage.MDagMessage
        	[in] -> The callback function.

        clientData: void
        	[in] -> User defined data passed to the callback function. 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> Status code.


        '''
        pass

    def addAllDagChangesCallback(self, func: MDagMessage.MDagMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addAllDagChangesCallback(self, func: MDagMessage.MDagMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever any DAG
        change is made to any DAG node. Please see the note in the
        Description section about this callback if Parent Added or Child
        Added messages are being used.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MDagMessage.MDagMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addAllDagChangesDagPathCallback(self, node: MDagPath,
                        func: MDagMessage.MDagMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addAllDagChangesDagPathCallback(self, node: MDagPath,
                        func: MDagMessage.MDagMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever a DAG
        change is made to the specified DAG path.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MDagPath
        	[in] -> The DAG node to register the callback for. 

        func: MDagMessage.MDagMessage
        	[in] -> The callback function.

        clientData: void
        	[in] -> User defined data passed to the callback function. 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> Status code.


        '''
        pass

    def addInstanceAddedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addInstanceAddedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever any node
        in the DAG is instanced.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addInstanceAddedDagPathCallback(self, node: MDagPath,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addInstanceAddedDagPathCallback(self, node: MDagPath,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever the
        specified node is instanced.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MDagPath
        	[in] -> The DAG node to register the callback for. 

        func: MMessage.MMessage
        	[in] -> The callback function.

        clientData: void
        	[in] -> User defined data passed to the callback function. 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> Status code.


        '''
        pass

    def addInstanceRemovedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addInstanceRemovedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever an
        instance of any DAG node is removed or deleted.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addInstanceRemovedDagPathCallback(self, node: MDagPath,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addInstanceRemovedDagPathCallback(self, node: MDagPath,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever an
        instance of the specified node is removed.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MDagPath
        	[in] -> The DAG node to register the callback for. 

        func: MMessage.MMessage
        	[in] -> The callback function.

        clientData: void
        	[in] -> User defined data passed to the callback function. 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> Status code.


        '''
        pass

    def addMatrixModifiedCallback(self, affectedNode: MDagPath,
                        func: MDagMessage.MDagMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addMatrixModifiedCallback(self, affectedNode: MDagPath,
                        func: MDagMessage.MDagMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called when the local
        matrix on the specified DAG node changes. If the node's
        transformation is already dirty (i.e. it has not been evaluated
        since it was last changed) then the callback will not be
        triggered. So if the node's transformation is modified multiple
        times between evaluations, only the first one will result in the
        callback being called.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        affectedNode: MDagPath
        	[in] -> The DAG node to register the callback for. 

        func: MDagMessage.MDagMessage
        	[in] -> The callback function. 

        clientData: void
        	[in] -> User defined data passed to the callback function. 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> Status code.


        '''
        pass

    def addWorldMatrixModifiedCallback(self, affectedNode: MDagPath,
                        func: MDagMessage.MDagMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus): 
        '''
        addWorldMatrixModifiedCallback(self, affectedNode: MDagPath,
                        func: MDagMessage.MDagMessage,
                        clientData: void,
                        ReturnStatus: MDagMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called when a parent
        matrix of the specified DAG node changes. Since a node's
        worldMatrix is affected by the transforms of its ancestors in the
        DAG, it's possible for there to be two different nodes involved:
        the "trigger" node, whose transform has changed, and the
        "affected" node, whose worldMatrix is affected by the change to
        the trigger.The callback is placed on the affected node, but it
        is the trigger node which is passed to the callback.If the
        trigger node's transformation is already dirty (i.e. it has not
        been evaluated since it was last changed) then the callback will
        not be triggered. So if the trigger node's transformation is
        modified multiple times between evaluations, only the first one
        will result in the callback being called.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        affectedNode: MDagPath
        	[in] -> The DAG node to register the callback for. 

        func: MDagMessage.MDagMessage
        	[in] -> The callback function. 

        clientData: void
        	[in] -> User defined data passed to the callback function. 

        ReturnStatus: MDagMessage.MStatus
        	[out] -> Status code.


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class DagMessage:
    '''The type of DAG changed messages that have occurred. 
    Non-functional class.  Values for this enum:
    kInvalidMsg
    kParentAdded
    kParentRemoved
    kChildAdded
    kChildRemoved
    kChildReordered
    kInstanceAdded
    kInstanceRemoved
    kLast
    '''

    def __init__(self):
        pass

    def kInvalidMsg(self):
        '''This is an enum of DagMessage.
        - Description: an invalid message was used. 
        - Value: -1
        '''
        pass

    def kParentAdded(self):
        '''This is an enum of DagMessage.
        - Description: a parent was added to a DAG node 
        - Value: 0
        '''
        pass

    def kParentRemoved(self):
        '''This is an enum of DagMessage.
        - Description: a parent was removed from a DAG node 
        - Value: 1
        '''
        pass

    def kChildAdded(self):
        '''This is an enum of DagMessage.
        - Description: a child was added to a DAG node 
        - Value: 2
        '''
        pass

    def kChildRemoved(self):
        '''This is an enum of DagMessage.
        - Description: a child was removed from a DAG node 
        - Value: 3
        '''
        pass

    def kChildReordered(self):
        '''This is an enum of DagMessage.
        - Description: a child of a DAG node was reordered 
        - Value: 4
        '''
        pass

    def kInstanceAdded(self):
        '''This is an enum of DagMessage.
        - Description: a DAG node was instanced 
        - Value: 5
        '''
        pass

    def kInstanceRemoved(self):
        '''This is an enum of DagMessage.
        - Description: a DAG node instance was removed 
        - Value: 6
        '''
        pass

    def kLast(self):
        '''This is an enum of DagMessage.
        - Description: a dummy value (used for looping through the message types) 
        - Value: 7
        '''
        pass

class MatrixModifiedFlags:
    '''Indicates which parts of a matrix have been modified. 
    Non-functional class.  Values for this enum:
    kScaleX
    kScaleY
    kScaleZ
    kShearXY
    kShearXZ
    kShearYZ
    kRotateX
    kRotateY
    kRotateZ
    kTranslateX
    kTranslateY
    kTranslateZ
    kScalePivotX
    kScalePivotY
    kScalePivotZ
    kRotatePivotX
    kRotatePivotY
    kRotatePivotZ
    kScaleTransX
    kScaleTransY
    kScaleTransZ
    kRotateTransX
    kRotateTransY
    kRotateTransZ
    kRotateOrientX
    kRotateOrientY
    kRotateOrientZ
    kRotateOrder
    kAll
    kScale
    kShear
    kRotation
    kTranslation
    kScalePivot
    kRotatePivot
    kScalePivotTrans
    kRotatePivotTrans
    kRotateOrient
    '''

    def __init__(self):
        pass

    def kScaleX(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Scale in the X axis. 
        - Value: 1
        '''
        pass

    def kScaleY(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Scale in the Y axis. 
        - Value: 2
        '''
        pass

    def kScaleZ(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Scale in the Z axis. 
        - Value: 4
        '''
        pass

    def kShearXY(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Shear in the XY plane. 
        - Value: 8
        '''
        pass

    def kShearXZ(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Shear in the XZ plane. 
        - Value: 16
        '''
        pass

    def kShearYZ(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Shear in the YZ plane. 
        - Value: 32
        '''
        pass

    def kRotateX(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Rotate around the X axis. 
        - Value: 64
        '''
        pass

    def kRotateY(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Rotate around the Y axis. 
        - Value: 128
        '''
        pass

    def kRotateZ(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Rotate around the Z axis. 
        - Value: 256
        '''
        pass

    def kTranslateX(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Translate along the X axis. 
        - Value: 512
        '''
        pass

    def kTranslateY(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Translate along the Y axis. 
        - Value: 1024
        '''
        pass

    def kTranslateZ(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Translate along the Z axis. 
        - Value: 2048
        '''
        pass

    def kScalePivotX(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Scale pivot X position. 
        - Value: 4096
        '''
        pass

    def kScalePivotY(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Scale pivot Y position. 
        - Value: 8192
        '''
        pass

    def kScalePivotZ(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Scale pivot Z position. 
        - Value: 16384
        '''
        pass

    def kRotatePivotX(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Rotate pivot X position. 
        - Value: 32768
        '''
        pass

    def kRotatePivotY(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Rotate pivot Y position. 
        - Value: 65536
        '''
        pass

    def kRotatePivotZ(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Rotate pivot Z position. 
        - Value: 131072
        '''
        pass

    def kScaleTransX(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Scale pivot translation along X axis. 
        - Value: 262144
        '''
        pass

    def kScaleTransY(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Scale pivot translation along Y axis. 
        - Value: 524288
        '''
        pass

    def kScaleTransZ(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Scale pivot translation along Z axis. 
        - Value: 1048576
        '''
        pass

    def kRotateTransX(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Rotate pivot translation along X axis. 
        - Value: 2097152
        '''
        pass

    def kRotateTransY(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Rotate pivot translation along Y axis. 
        - Value: 4194304
        '''
        pass

    def kRotateTransZ(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Rotate pivot translation along Z axis. 
        - Value: 8388608
        '''
        pass

    def kRotateOrientX(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Rotation orientation around the X axis. 
        - Value: 16777216
        '''
        pass

    def kRotateOrientY(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Rotation orientation around the Y axis. 
        - Value: 33554432
        '''
        pass

    def kRotateOrientZ(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Rotation orientation around the Z axis. 
        - Value: 67108864
        '''
        pass

    def kRotateOrder(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Rotation order. 
        - Value: 134217728
        '''
        pass

    def kAll(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: All. 
        - Value: 268435455
        '''
        pass

    def kScale(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Scale in all axis. 
        - Value: 7
        '''
        pass

    def kShear(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Shear in all axis. 
        - Value: 56
        '''
        pass

    def kRotation(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Rotation around all axis. 
        - Value: 448
        '''
        pass

    def kTranslation(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Translation along all axis. 
        - Value: 3584
        '''
        pass

    def kScalePivot(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Scale pivot in all axis. 
        - Value: 28672
        '''
        pass

    def kRotatePivot(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Rotate pivot in all axis. 
        - Value: 229376
        '''
        pass

    def kScalePivotTrans(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Scale pivot translation for all axis. 
        - Value: 1835008
        '''
        pass

    def kRotatePivotTrans(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Rotate pivot translation for all axis. 
        - Value: 14680064
        '''
        pass

    def kRotateOrient(self):
        '''This is an enum of MatrixModifiedFlags.
        - Description: Rotation orientation around all axis. 
        - Value: 117440512
        '''
        pass

class MDagModifier:
    '''Dependency graph modifier.
An
MDagModifier is used to change the structure of the DAG. This includes adding
nodes, making new connections, and removing existing connections.
To perform operations using an
MDagModifier, register all of the changes that are to be made and then call
the doIt method to make the changes. Undo is provided through the
undoIt method.
'''
    def __init__(self):
        pass


    @overload
    def createNode(self, typeId: MTypeId,
                        parent: MObject,
                        ReturnStatus: MDagModifier.MStatus): 
        '''
        createNode(self, typeId: MTypeId,
                        parent: MObject,
                        ReturnStatus: MDagModifier.MStatus) -> MObject

        Synopsis
        -----
        This method adds an operation to this DAG modifier that will add
        a new node of the given type to the DAG. This method may not be
        used to construct new dependency graph nodes that are not in the
        DAG. Use MDGModifier for that purpose.When createNode is called,
        the new node is created and the MObject handle for it is
        returned. It should be noted that the node will not be added to
        the DAG until the doIt method is called.It is legal to pass in a
        null object as the parent. When this occurs, the new object gets
        parented under the world node.Note that nodes cannot exist in the
        DAG unless they are under a transform. This method will
        automatically create a transform if one is required. If a
        transform is created, then the MObject for the transform will be
        returned instead of the one for the node.If a node is created
        with this method, but the operation is undone, then the
        MDagModifier will take responsibility for freeing the node. This
        will be done when the MDagModifier is destructed.

        Returns: 
        ----- 
        A handle for the new node, or the transform above if one is
        created as a parent.

        Parameters:
        -----
        typeId: MTypeId
        	[in] -> type of the node to create 

        parent: MObject
        	[in] -> parent object in the DAG 

        ReturnStatus: MDagModifier.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def createNode(self, type: MString,
                        parent: MObject,
                        ReturnStatus: MDagModifier.MStatus): 
        '''
        createNode(self, type: MString,
                        parent: MObject,
                        ReturnStatus: MDagModifier.MStatus) -> MObject

        Synopsis
        -----
        This method adds an operation to this DAG modifier that will add
        a new node of the given type to the DAG. This method may not be
        used to construct new dependency graph nodes that are not in the
        DAG. Use MDGModifier for that purpose.When createNode is called,
        the new node is created and the MObject handle for it is
        returned. It should be noted that the node will not be added to
        the DAG until the doIt method is called.It is legal to pass in a
        null object as the parent. When this occurs, the new object gets
        parented under the world node.Note that nodes cannot exist in the
        DAG unless they are under a transform. This method will
        automatically create a transform if one is required. If a
        transform is created, then the MObject for the transform will be
        returned instead of the one for the node.If a node is created
        with this method, but the operation is undone, then the
        MDagModifier will take responsibility for freeing the node. This
        will be done when the MDagModifier is destructed.

        Returns: 
        ----- 
        A handle for the new node, or the transform above if one is
        created as a parent.

        Parameters:
        -----
        type: MString
        	[in] -> type of the node to create 

        parent: MObject
        	[in] -> parent object in the DAG 

        ReturnStatus: MDagModifier.MStatus
        	[out] -> return status


        '''
        pass

    def reparentNode(self, node: MObject,
                        newParent: MObject): 
        '''
        reparentNode(self, node: MObject,
                        newParent: MObject)

        Synopsis
        -----
        This method adds an operation to this DAG modifier that will
        reparent a node in the DAG. If the parent passed in is NULL, then
        the node will be reparented under the world.

        Returns:
        -----
        None

        Parameters:
        -----
        node: MObject
        	[in] -> node to reparent 

        newParent: MObject
        	[out] -> new parent for the node


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MDagPath:
    '''DAG Path.
Provides methods for obtaining one or all Paths to a specified
DAG Node, determining if a Path is valid and if two Paths are
equivalent, obtaining the length, transform, and inclusive and
exclusive matrices of a Path, as well as performing Path to Path
assignment.
DAG Paths may be used as parameters to some methods in the DAG
Node Function Set (
MFnDagNode).
It is often useful to combine DAG Paths into DAG Path arrays (
MDagPathArray).
Use this DAG Path Class to obtain and query Paths to DAG Nodes. A
DAG path is a path from the world node to a particular object in
the DAG.
If a DAG object is instanced, then an
MDagPath is required to identify a particular instance. DAG paths are
also required when doing world space transformations.
Use this class in conjunction with the DAG Iterator (
MItDag), DAG Node Function Set (
MFnDagNode) and DAG Path Array class (
MDagPathArray) to query and edit the DAG.
'''
    def __init__(self):
        pass


    def getAllPathsTo(self, node: MObject,
                        pathArray: MDagPathArray): 
        '''
        getAllPathsTo(self, node: MObject,
                        pathArray: MDagPathArray)

        Synopsis
        -----
        Determines all Paths to the specified DAG Node.

        Returns:
        -----
        None

        Parameters:
        -----
        node: MObject
        	[in] -> DAG Node for which Paths are determined 

        pathArray: MDagPathArray
        	[out] -> Array containing all DAG Paths to the specified Node (implicit return)


        '''
        pass

    def getAPathTo(self, node: MObject,
                        path: MDagPath): 
        '''
        getAPathTo(self, node: MObject,
                        path: MDagPath)

        Synopsis
        -----
        Determines the Path to the specified DAG Node. The Path returned
        is rooted at the World. If the object is instanced and has
        multiple paths, then the first one that is found is returned.

        Returns:
        -----
        None

        Parameters:
        -----
        node: MObject
        	[in] -> DAG Node for which Paths are determined 

        path: MDagPath
        	[out] -> reference to the path of the specified DAG Node


        '''
        pass

    def matchTransform(self, source: MDagPath,
                        target: MDagPath,
                        relative: MDagPath,
                        transformationMatrix: MTransformationMatrix,
                        preserveOffsetParentMatrix: bool,
                        preservePivot: bool,
                        preservePivotOffset: bool): 
        '''
        matchTransform(self, source: MDagPath,
                        target: MDagPath,
                        relative: MDagPath,
                        transformationMatrix: MTransformationMatrix,
                        preserveOffsetParentMatrix: bool,
                        preservePivot: bool,
                        preservePivotOffset: bool)

        Synopsis
        -----
        Introduced in 2022.0 Calculates the transformationMatrix which,
        when applied to the source, object will bring the source object
        to the location of the target object.A relative object can be
        provided if we want to specify an alternate parent of source
        object for the calculations. An empty MDagPath means we want to
        use the current parent.A number of flags can be used to specify
        whether we want to preserve the current offsetParentMatrix and/or
        pivot locations or whether we want to calculate the
        transformationMatrix as if they were initialized to identity.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MDagPath
        	[in] -> 

        target: MDagPath
        	[in] -> 

        relative: MDagPath
        	[in] -> 

        transformationMatrix: MTransformationMatrix
        	[in] -> 

        preserveOffsetParentMatrix: bool
        	[in] -> 

        preservePivot: bool
        	[in] -> 

        preservePivotOffset: bool
        	[in] -> 


        '''
        pass

    def getAllPathsBelow(self, pathArray: MDagPathArray): 
        '''
        getAllPathsBelow(self, pathArray: MDagPathArray)

        Synopsis
        -----
        Return all paths to leaf objects below this path excluding
        transforms.

        Returns:
        -----
        None

        Parameters:
        -----
        pathArray: MDagPathArray
        	[out] -> Array containing all DAG Paths below this path excluding transforms.


        '''
        pass

    def hasFn(self, type: MFn.MFn,
                        ReturnStatus: MDagPath.MStatus): 
        '''
        hasFn(self, type: MFn.MFn,
                        ReturnStatus: MDagPath.MStatus) -> bool

        Synopsis
        -----
        Returns true if the object at the end of this DAG path supports
        the given function set. If the object at the end of this DAG path
        is a transform node and has a child that is a shape, then that
        node will be checked as well. All function sets that take an
        MDagPath

        Returns: 
        ----- 
        Boolean value indicating whether the function set is supported

        Parameters:
        -----
        type: MFn.MFn
        	[in] -> function set type to check 

        ReturnStatus: MDagPath.MStatus
        	[out] -> status code


        '''
        pass

    def apiType(self, ReturnStatus: MDagPath.MStatus): 
        '''
        apiType(self, ReturnStatus: MDagPath.MStatus) -> MFn.MFn

        Synopsis
        -----
        Returns the type of the object at the end of the path.

        Returns: 
        ----- 
        Type of the object

        Parameters:
        -----
        ReturnStatus: MDagPath.MStatus
        	[out] -> status code


        '''
        pass

    def isValid(self, ReturnStatus: MDagPath.MStatus): 
        '''
        isValid(self, ReturnStatus: MDagPath.MStatus) -> bool

        Synopsis
        -----
        Determines if Path is valid.

        Returns: 
        ----- 
        True if valid

        Parameters:
        -----
        ReturnStatus: MDagPath.MStatus
        	[out] -> status code


        '''
        pass

    def node(self, ReturnStatus: MDagPath.MStatus): 
        '''
        node(self, ReturnStatus: MDagPath.MStatus) -> MObject

        Synopsis
        -----
        Retrieves the DAG Node for this DAG Path.

        Returns: 
        ----- 
        DAG Node for this DAG Path

        Parameters:
        -----
        ReturnStatus: MDagPath.MStatus
        	[out] -> Status Code


        '''
        pass

    def transform(self, ReturnStatus: MDagPath.MStatus): 
        '''
        transform(self, ReturnStatus: MDagPath.MStatus) -> MObject

        Synopsis
        -----
        Retrieves the lowest Transform in the DAG Path.

        Returns: 
        ----- 
        Lowest Transform for this DAG Path

        Parameters:
        -----
        ReturnStatus: MDagPath.MStatus
        	[out] -> Status Code


        '''
        pass

    def length(self, ReturnStatus: MDagPath.MStatus): 
        '''
        length(self, ReturnStatus: MDagPath.MStatus) -> int

        Synopsis
        -----
        Determines the number of DAG Nodes in the Path not including the
        root.

        Returns: 
        ----- 
        Number of DAG Nodes not including the root

        Parameters:
        -----
        ReturnStatus: MDagPath.MStatus
        	[out] -> status code


        '''
        pass

    def extendToShape(self): 
        '''
        extendToShape(self)

        Synopsis
        -----
        If the object at the end of this path is a transform and there is
        a shape node directly beneath it in the hierarchy, then the path
        is extended to that geometry node. NOTE: This method will fail if
        there multiple shapes below the transform.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def extendToShapeDirectlyBelow(self, index: int): 
        '''
        extendToShapeDirectlyBelow(self, index: int)

        Synopsis
        -----
        This method is used if the end of the path is a transform and
        there are shapes directly below the transform. The shape to
        extend to is set by passing in an appropriate index parameter.Use
        the numberOfShapesDirectlyBelow() method to determine how many
        shapes are below

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> contains the index of the shape to extend the path to


        '''
        pass

    def numberOfShapesDirectlyBelow(self, num: int): 
        '''
        numberOfShapesDirectlyBelow(self, num: int)

        Synopsis
        -----
        If the object at the end of this path is a transform, this method
        will return the number of shapes directly below the transform.

        Returns:
        -----
        None

        Parameters:
        -----
        num: int
        	[out] -> on success, this parameter will be set to the number of shapes directly underneath the transform


        '''
        pass

    def push(self, child: MObject): 
        '''
        push(self, child: MObject)

        Synopsis
        -----
        Push an object onto the end of the path. The object must be a
        child of the object that is currently at the end of the path.

        Returns:
        -----
        None

        Parameters:
        -----
        child: MObject
        	[in] -> child object to push onto the path


        '''
        pass

    def pop(self, num: int): 
        '''
        pop(self, num: int)

        Synopsis
        -----
        Pop the given number of objects off of the end of the path.

        Returns:
        -----
        None

        Parameters:
        -----
        num: int
        	[in] -> number of objects to pop off of the path


        '''
        pass

    def childCount(self, ReturnStatus: MDagPath.MStatus): 
        '''
        childCount(self, ReturnStatus: MDagPath.MStatus) -> int

        Synopsis
        -----
        Return the number of children that the object at the end of the
        path has.

        Returns: 
        ----- 
        The number of children

        Parameters:
        -----
        ReturnStatus: MDagPath.MStatus
        	[out] -> status code


        '''
        pass

    def child(self, index: int,
                        ReturnStatus: MDagPath.MStatus): 
        '''
        child(self, index: int,
                        ReturnStatus: MDagPath.MStatus) -> MObject

        Synopsis
        -----
        Return the child object at the given index, where the parent is
        the object at the end of the path.

        Returns: 
        ----- 
        A handle to the child

        Parameters:
        -----
        index: int
        	[in] -> child's index 

        ReturnStatus: MDagPath.MStatus
        	[out] -> status code


        '''
        pass

    def inclusiveMatrix(self, ReturnStatus: MDagPath.MStatus): 
        '''
        inclusiveMatrix(self, ReturnStatus: MDagPath.MStatus) -> MMatrix

        Synopsis
        -----
        Determines the inclusive matrix of the Path.

        Returns: 
        ----- 
        The matrix for all Transforms in the Path including the the end
        Node in the Path if it is a Transform

        Parameters:
        -----
        ReturnStatus: MDagPath.MStatus
        	[out] -> status code


        '''
        pass

    def exclusiveMatrix(self, ReturnStatus: MDagPath.MStatus): 
        '''
        exclusiveMatrix(self, ReturnStatus: MDagPath.MStatus) -> MMatrix

        Synopsis
        -----
        Determines the exclusive matrix of the Path.

        Returns: 
        ----- 
        The matrix for all transforms in the Path excluding the end Node
        in the Path if it is Transform

        Parameters:
        -----
        ReturnStatus: MDagPath.MStatus
        	[out] -> status code


        '''
        pass

    def inclusiveMatrixInverse(self, ReturnStatus: MDagPath.MStatus): 
        '''
        inclusiveMatrixInverse(self, ReturnStatus: MDagPath.MStatus) -> MMatrix

        Synopsis
        -----
        Determines the inverse inclusive matrix of the Path.

        Returns: 
        ----- 
        The inverse of the matrix for all Transforms in the Path
        including the end Node in the Path if it is a Transform

        Parameters:
        -----
        ReturnStatus: MDagPath.MStatus
        	[out] -> status code


        '''
        pass

    def exclusiveMatrixInverse(self, ReturnStatus: MDagPath.MStatus): 
        '''
        exclusiveMatrixInverse(self, ReturnStatus: MDagPath.MStatus) -> MMatrix

        Synopsis
        -----
        Determines the inverse exclusive matrix of the Path.

        Returns: 
        ----- 
        The inverse of the matrix for all transforms in the Path
        excluding the end Node in the Path if it is Transform

        Parameters:
        -----
        ReturnStatus: MDagPath.MStatus
        	[out] -> status code


        '''
        pass

    def __eq__(self, src: MDagPath): 
        '''
        __eq__(self, src: MDagPath) -> bool

        Synopsis
        -----
        Determines if the DAG Path on the LHS of the operator is equal to
        the DAG Path on the RHS.

        Returns: 
        ----- 
        True is the objects are equal

        Parameters:
        -----
        src: MDagPath
        	[in] -> The path to be compared.


        '''
        pass

    def set(self, src: MDagPath): 
        '''
        set(self, src: MDagPath)

        Synopsis
        -----
        Sets this DAG Path equal to the specified DAG Path.

        Returns:
        -----
        None

        Parameters:
        -----
        src: MDagPath
        	[in] -> DAG Path to be copied.


        '''
        pass

    def pathCount(self, ReturnStatus: MDagPath.MStatus): 
        '''
        pathCount(self, ReturnStatus: MDagPath.MStatus) -> int

        Synopsis
        -----
        Return the number of paths which make up this path.

        Returns: 
        ----- 
        The path count

        Parameters:
        -----
        ReturnStatus: MDagPath.MStatus
        	[out] -> status code


        '''
        pass

    def getPath(self, path: MDagPath,
                        i: int): 
        '''
        getPath(self, path: MDagPath,
                        i: int)

        Synopsis
        -----
        Return the i'th path. The zero'th path is the top-most path and
        must be rooted by the world. Additional paths are paths in the
        underworld of the object at the end of the previous path (path
        i-1).

        Returns:
        -----
        None

        Parameters:
        -----
        path: MDagPath
        	[out] -> reference to the destination path 

        i: int
        	[in] -> the index of the path to retrieve


        '''
        pass

    def fullPathName(self, ReturnStatus: MDagPath.MStatus): 
        '''
        fullPathName(self, ReturnStatus: MDagPath.MStatus) -> MString

        Synopsis
        -----
        Return a string representing the full path from the root of the
        dag to this object.

        Returns: 
        ----- 
        The full path name

        Parameters:
        -----
        ReturnStatus: MDagPath.MStatus
        	[out] -> status code


        '''
        pass

    def partialPathName(self, ReturnStatus: MDagPath.MStatus): 
        '''
        partialPathName(self, ReturnStatus: MDagPath.MStatus) -> MString

        Synopsis
        -----
        Return a string representing the partial path from the root of
        the dag to this object. The partial path is the minimum path that
        is still unique. This string may contain wildcards.

        Returns: 
        ----- 
        The partial path name

        Parameters:
        -----
        ReturnStatus: MDagPath.MStatus
        	[out] -> status code


        '''
        pass

    def isInstanced(self, ReturnStatus: MDagPath.MStatus): 
        '''
        isInstanced(self, ReturnStatus: MDagPath.MStatus) -> bool

        Synopsis
        -----
        Returns true if the object at the end of the DAG path is
        instanced. It is instanced if there is more than one path to the
        node from the top of the DAG. Each instance of the node will be
        drawn separately in the view, but the geometry will be shared.

        Returns: 
        ----- 
        True if the DAG node at the end of the path is instanced

        Parameters:
        -----
        ReturnStatus: MDagPath.MStatus
        	[out] -> status code


        '''
        pass

    def instanceNumber(self, ReturnStatus: MDagPath.MStatus): 
        '''
        instanceNumber(self, ReturnStatus: MDagPath.MStatus) -> int

        Synopsis
        -----
        For an instanced object, this returns the instance number that
        this path represents in the DAG. The instance number can be used
        to determine which element of the world space array attributes of
        a DAG node to connect to get information regarding this instance.

        Returns: 
        ----- 
        The instance number represented by this path

        Parameters:
        -----
        ReturnStatus: MDagPath.MStatus
        	[out] -> status code


        '''
        pass

    def isVisible(self, ReturnStatus: MDagPath.MStatus): 
        '''
        isVisible(self, ReturnStatus: MDagPath.MStatus) -> bool

        Synopsis
        -----
        Returns true if the DAG Node at the end of the path is visible to
        the viewport. This method does not account for any viewport
        specific filtering.If the object is not in the current render
        layer then it is not visible.If the value of the visibility
        attribute is false for any DAG Node along the path, the object is
        invisible. Also, the object is invisible if it or its ancestor is
        in an invisible display layer. Additionally, intermediate objects
        are considered invisible as are objects which have the display
        geometry flag toggled to off (see the 'toggle' command).

        Returns: 
        ----- 
        True if the DAG node at the end of the path is visible

        Parameters:
        -----
        ReturnStatus: MDagPath.MStatus
        	[out] -> status code


        '''
        pass

    def isTemplated(self, ReturnStatus: MDagPath.MStatus): 
        '''
        isTemplated(self, ReturnStatus: MDagPath.MStatus) -> bool

        Synopsis
        -----
        Returns true if the DAG Node at the end of the path is templated.
        If the value of the template attribute is true for any DAG Node
        along the path, this method will return true. If the display
        override for any DAG node along the path is template, this method
        will return true. Finally, this method will return true if any
        DAG node along the path is in a templated display layer.

        Returns: 
        ----- 
        True if the DAG node at the end of the path is templated

        Parameters:
        -----
        ReturnStatus: MDagPath.MStatus
        	[out] -> status code


        '''
        pass

    def getDrawOverrideInfo(self): 
        '''
        getDrawOverrideInfo(self) -> MDAGDrawOverrideInfo

        Synopsis
        -----
        Get the draw override information for the given path. It will
        check from the bottom object of this path, then go upwards to
        find the first enabled draw override and record that information.
        If no enabled draw override is found, a default draw override
        information will be given with draw override disabled inside it.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MDagPathArray:
    '''Indexable Array of DAG Paths.
Provides methods for manipulating arrays of DAG Paths.
Arrays of DAG Paths are useful for storing and manipluating
multiple Paths to a particular DAG Node. The DAG Path method
MDagPath::getAllPathsTo() and DAG Node Function Set method
MFnDagNode::getAllPaths() implicitly return an array of DAG Paths.
These arrays may also be used to manage Paths for a number of
different Nodes.
DAG Path arrays are used in conjunction with DAG Paths (
MDagPath) and individual elements of the arrays can be parameters to some
methods of the DAG Node Function Set (
MFnDagNode).
Use this DAG Path Array Class to create and manipulate arrays of
DAG Paths, for either a particular DAG Node or a number of
different DAG Nodes.
The length of the array adjusts automatically.
'''
    def __init__(self):
        pass


    @overload
    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> const MDagPath&

        Synopsis
        -----
        Retrieves the read-only DAG Path which is at the specified index
        in the array.

        Returns: 
        ----- 
        DAG Path at the specified index

        Parameters:
        -----
        index: int
        	[in] -> Zero-based index to the array


        '''
        pass

    def set(self, element: MDagPath,
                        index: int): 
        '''
        set(self, element: MDagPath,
                        index: int)

        Synopsis
        -----
        Sets an element of the array to the given DAG path.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MDagPath
        	[in] -> New DAG path to be set on the indicated element 

        index: int
        	[in] -> Zero-based index to the array


        '''
        pass

    def setLength(self, length: int): 
        '''
        setLength(self, length: int)

        Synopsis
        -----
        Set the length of the array. This will grow and shrink the array
        as desired. Elements that are grown have uninitialized values,
        while those which are shrunk will lose the data contained in the
        deleted elements (ie. it will release the memory).

        Returns:
        -----
        None

        Parameters:
        -----
        length: int
        	[in] -> the new size of the array 


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Determines the number of elements in the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Removes the DAG Path which is at the specified index in the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> Zero-based index to the array


        '''
        pass

    def insert(self, element: MDagPath,
                        index: int): 
        '''
        insert(self, element: MDagPath,
                        index: int)

        Synopsis
        -----
        Inserts the given DAG Path at the specified index in the array.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MDagPath
        	[in] -> DAG Path to be inserted 

        index: int
        	[in] -> Zero-based index to the array


        '''
        pass

    def append(self, element: MDagPath): 
        '''
        append(self, element: MDagPath)

        Synopsis
        -----
        Appends the given DAG Path to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MDagPath
        	[in] -> DAG Path to be appended


        '''
        pass

    def copy(self, source: MDagPathArray): 
        '''
        copy(self, source: MDagPathArray)

        Synopsis
        -----
        Copy the contents of the source array to this array.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MDagPathArray
        	[in] -> array to copy from


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clears this array. Length of the array becomes zero.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setSizeIncrement(self, newIncrement: int): 
        '''
        setSizeIncrement(self, newIncrement: int)

        Synopsis
        -----
        Set the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        newIncrement: int
        	[in] -> the new increment 


        '''
        pass

    def sizeIncrement(self): 
        '''
        sizeIncrement(self) -> int

        Synopsis
        -----
        Return the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> MDagPath

        Synopsis
        -----
        Retrieves the DAG Path which is at the specified index in the
        array.

        Returns: 
        ----- 
        DAG Path at the specified index

        Parameters:
        -----
        index: int
        	[in] -> Zero-based index to the array


        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MDagPathArray.MDagPathArray

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MDagPathArray.MDagPathArray

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MDagPathArray.MDagPathArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MDagPathArray.MDagPathArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MDagPathArray.MDagPathArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MDagPathArray.MDagPathArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MDataBlock:
    '''Dependency node data block.
An
MDataBlock provides storage for the data being received by or sent by the
node. It is the data for the plugs and attributes of the node.
The data block is only valid during the compute method of the
depend node. Pointers to the data block should not be retained
after the compute method.
Access to the data in an
MDataBlock is done using an
MDataHandle or an
MArrayDataHandle.
'''
    def __init__(self):
        pass


    @overload
    def inputValue(self, plug: MPlug,
                        ReturnStatus: MDataBlock.MStatus): 
        '''
        inputValue(self, plug: MPlug,
                        ReturnStatus: MDataBlock.MStatus) -> MDataHandle

        Synopsis
        -----
        Gets a handle to this data block for the given plug's data. The
        data represented by the handle is guaranteed to be valid for
        reading. If the data is from a dirty connection, then the
        connection will be evaluated. If no connection is present, then
        the value that the plug has been set to will be returned. If the
        plug has not been set to a particular value, then the default
        value will be returned.

        Returns: 
        ----- 
        Data handle for the given plug's data

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug whose data you wish to access 

        ReturnStatus: MDataBlock.MStatus
        	[out] -> the return status


        '''
        pass

    @overload
    def inputValue(self, attribute: MObject,
                        ReturnStatus: MDataBlock.MStatus): 
        '''
        inputValue(self, attribute: MObject,
                        ReturnStatus: MDataBlock.MStatus) -> MDataHandle

        Synopsis
        -----
        Gets a handle to this data block for the given attribute's data.
        The data represented by the handle is guaranteed to be valid for
        reading. If the data is from a dirty connection, then the
        connection will be evaluated. If no connection is present, then
        the value that the attribute has been set to will be returned. If
        the attribute has not been set to a particular value, then the
        default value will be returned.

        Returns: 
        ----- 
        Data handle for the given attribute's data

        Parameters:
        -----
        attribute: MObject
        	[in] -> the attribute of the node that you want to access 

        ReturnStatus: MDataBlock.MStatus
        	[out] -> the return status


        '''
        pass

    @overload
    def outputValue(self, plug: MPlug,
                        ReturnStatus: MDataBlock.MStatus): 
        '''
        outputValue(self, plug: MPlug,
                        ReturnStatus: MDataBlock.MStatus) -> MDataHandle

        Synopsis
        -----
        Gets a handle to this data block for the given plug's data. The
        data is not guaranteed to be valid. No dependency graph
        evaluations will be done. Therefore, this handle should be used
        only for writing.

        Returns: 
        ----- 
        Data handle for the given plug's data

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug whose data you wish to access 

        ReturnStatus: MDataBlock.MStatus
        	[out] -> the return status


        '''
        pass

    @overload
    def outputValue(self, attribute: MObject,
                        ReturnStatus: MDataBlock.MStatus): 
        '''
        outputValue(self, attribute: MObject,
                        ReturnStatus: MDataBlock.MStatus) -> MDataHandle

        Synopsis
        -----
        Gets a handle to this data block for the given attribute's data.
        The data is not guaranteed to be valid. No dependency graph
        evaluations will be done. Therefore, this handle should be used
        only for writing.

        Returns: 
        ----- 
        Data handle for the given attribute's data

        Parameters:
        -----
        attribute: MObject
        	[in] -> the attribute of the node that you want to access 

        ReturnStatus: MDataBlock.MStatus
        	[out] -> the return status


        '''
        pass

    @overload
    def inputArrayValue(self, plug: MPlug,
                        ReturnStatus: MDataBlock.MStatus): 
        '''
        inputArrayValue(self, plug: MPlug,
                        ReturnStatus: MDataBlock.MStatus) -> MArrayDataHandle

        Synopsis
        -----
        Gets an array handle to this data block for the given plug's
        data. This is only valid if the given plug has array data. The
        data represented by the handle will be valid. If the data is from
        a dirty connection, then the connection will be evaluated. If no
        connection is present, then the value that the plug has been set
        to will be returned. If the plug has not been set to a particular
        value, then the default value will be returned.

        Returns: 
        ----- 
        Array data handle for the given plug's data

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug whose data you wish to access 

        ReturnStatus: MDataBlock.MStatus
        	[out] -> the return status


        '''
        pass

    @overload
    def inputArrayValue(self, attribute: MObject,
                        ReturnStatus: MDataBlock.MStatus): 
        '''
        inputArrayValue(self, attribute: MObject,
                        ReturnStatus: MDataBlock.MStatus) -> MArrayDataHandle

        Synopsis
        -----
        Gets an array handle to this data block for the given attribute's
        data. This is only valid if the given attribute has array data.
        The data represented by the handle will be valid. If the data is
        from a dirty connection, then the connection will be evaluated.
        If no connection is present, then the value that the attribute
        has been set to will be returned. If the attribute has not been
        set to a particular value, then the default value will be
        returned.

        Returns: 
        ----- 
        Array data handle for the given attribute's data

        Parameters:
        -----
        attribute: MObject
        	[in] -> The attribute whose data you wish to access 

        ReturnStatus: MDataBlock.MStatus
        	[out] -> The return status


        '''
        pass

    @overload
    def outputArrayValue(self, plug: MPlug,
                        ReturnStatus: MDataBlock.MStatus): 
        '''
        outputArrayValue(self, plug: MPlug,
                        ReturnStatus: MDataBlock.MStatus) -> MArrayDataHandle

        Synopsis
        -----
        Gets a handle to this data block for the given plug. No
        dependency graph evaluations will be done, and therefore the data
        is not guaranteed to be valid (i.e. it may be dirty). Typically,
        this method is used to get the handle during compute in order to
        write output data to it.Another usage of this method is to access
        an input array attribute without evaluating any of its array
        elements. One can then use MArrayDataHandle::jumpToElement to get
        to the particular element of interest, and evaluate its value
        using MArrayDataHandle::inputValue.

        Returns: 
        ----- 
        Array data handle for the given plug's data

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug whose data you wish to access 

        ReturnStatus: MDataBlock.MStatus
        	[out] -> the return status


        '''
        pass

    @overload
    def outputArrayValue(self, attribute: MObject,
                        ReturnStatus: MDataBlock.MStatus): 
        '''
        outputArrayValue(self, attribute: MObject,
                        ReturnStatus: MDataBlock.MStatus) -> MArrayDataHandle

        Synopsis
        -----
        Gets a handle to this data block for the given attribute's data.
        The data is not guaranteed to be valid. No dependency graph
        evaluations will be done. Therefore, this handle should be used
        only for writing.

        Returns: 
        ----- 
        Array data handle for the given attribute's data

        Parameters:
        -----
        attribute: MObject
        	[in] -> the attribute of the node that you want to access 

        ReturnStatus: MDataBlock.MStatus
        	[out] -> the return status


        '''
        pass

    @overload
    def setClean(self, plug: MPlug): 
        '''
        setClean(self, plug: MPlug)

        Synopsis
        -----
        Tells the dependency graph that the given plug has been updated
        and is now clean. This should be called after the data in the
        plug has been recalculated from the inputs of the node.

        Returns:
        -----
        None

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug that is to be marked clean


        '''
        pass

    @overload
    def setClean(self, attribute: MObject): 
        '''
        setClean(self, attribute: MObject)

        Synopsis
        -----
        Tells the dependency graph that the given attribute has been
        updated and is now clean. This should be called after the data in
        the plug has been recalculated from the inputs of the node.

        Returns:
        -----
        None

        Parameters:
        -----
        attribute: MObject
        	[in] -> the attribute that we have updated the data for


        '''
        pass

    @overload
    def isClean(self, plug: MPlug): 
        '''
        isClean(self, plug: MPlug) -> bool

        Synopsis
        -----
        Queries the dependency graph to see whether the given plug is
        clean.

        Returns: 
        ----- 
        Result boolean code, true if plug is clean, false otherwise.

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug that is to be query


        '''
        pass

    @overload
    def isClean(self, attribute: MObject,
                        ReturnStatus: MDataBlock.MStatus): 
        '''
        isClean(self, attribute: MObject,
                        ReturnStatus: MDataBlock.MStatus) -> bool

        Synopsis
        -----
        Queries the dependency graph to see whether the given attribute
        is clean.

        Returns: 
        ----- 
        true if the attribute is clean, false otherwise.

        Parameters:
        -----
        attribute: MObject
        	[in] -> The attribute to query. 

        ReturnStatus: MDataBlock.MStatus
        	[out] -> Status code.


        '''
        pass

    def context(self, ReturnStatus: MDataBlock.MStatus): 
        '''
        context(self, ReturnStatus: MDataBlock.MStatus) -> MDGContext

        Synopsis
        -----
        Returns a copy of the dependecy graph context for which this data
        block was created. The context is used to specify how a
        dependency node is going to be evaluated.

        Returns: 
        ----- 
        The dependency graph context

        Parameters:
        -----
        ReturnStatus: MDataBlock.MStatus
        	[out] -> Status code


        '''
        pass

    def setContext(self, ctx: MDGContext): 
        '''
        setContext(self, ctx: MDGContext)

        Synopsis
        -----
        Set the dependency graph context for this data block. The context
        is used to specify how a dependency node is going to be
        evaluated, thus replacing the context for the given datablock.
        This does not modify the dirty state of the datablock so that
        they apply to the new context.This function should not be used
        for timed evaluation.

        Returns:
        -----
        None

        Parameters:
        -----
        ctx: MDGContext
        	[in] -> the dependency graph context


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MDataHandle:
    '''Data handle for information contained in a data block.
An
MDataHandle is a smart pointer into a data block (
MDataBlock). A data handle corresponds to the data for a particular
attribute or plug. For array data (eg CVs of a curve) use an
MArrayDataHandle. To get a data handle, request it from the data block.
Some simple numeric data is handled directly by the dependency
graph. If the data is more complicated (eg surface geometry),
then the data handle can supply a pointer that should be given to
the appropriate data function set.
MDataHandle allows the manipulation and setting of generic attributes as
created by the
MFnGenericAttribute class. It is possible to create numeric generic attributes using
two scenarios. A plug-in may request that the generic attribute
support singleton types such as
MFnNumericData::kFloat or kChar. Or a plug-in may request array types such as
MFnNumericData::k2Float k2Double. In the singleton case, getting and setting the
attribute using
MDataHandle is done with the asGeneric*() or setGeneric*() methods. In the
case of the array types, the
MDataHandle.data() method can be used to retrieve the
MObject for the attribute and to initialize the
MFnNumericData function set. A call to MDataHandle::setData() on the updated
attribute must be made to pass the information back to Maya.
NOTE: It is not possible to distinguish the singleton generic
types from one another. There is no method that can be called to
return if the singleton generic attribute is a float, char etc.
MDataHandle methods cannot be assumed to be threadsafe.
'''
    def __init__(self):
        pass


    def isNumeric(self): 
        '''
        isNumeric(self) -> bool

        Synopsis
        -----
        Returns true if this handle is for simple numeric data. That
        means that the numeric data is directly accessible through the
        non-generic as*() and set*() methods of this handle. For example,
        depending on handle initialization, the asBool() may be called
        but the asGenericBool() should not be called.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isGeneric(self, isNumeric: bool,
                        isNull: bool): 
        '''
        isGeneric(self, isNumeric: bool,
                        isNull: bool) -> MDataHandle.OPENMAYA_NAMESPACE_CLOSEOPENMAYA_MAJOR_NAMESPACE_OPENbool

        Synopsis
        -----
        Returns true if this handle is for generic data. There are 2
        forms of generic data. The first is for simple data and is used
        if the isNumeric parameter returns true. In this case, the
        asGeneric*() and setGeneric*() methods of this class are used to
        query and set values. The second form of generic data is for more
        complex attribute types. As a result the type of the object must
        be checked and an appropriate attribute function set initialized
        with the object.

        Returns: 
        ----- 
        True will be returned if this handle points to a generic
        attribute

        Parameters:
        -----
        isNumeric: bool
        	[out] -> returns true if this handle is for simple generic numeric data 

        isNull: bool
        	[out] -> returns true if this handle is not set


        '''
        pass

    def numericType(self): 
        '''
        numericType(self) -> MFnNumericData.MFnNumericData

        Synopsis
        -----
        Returns the type of data represented by this handle. This method
        is only valid for data handles of simple numeric types.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def type(self): 
        '''
        type(self) -> MFnData.MFnData

        Synopsis
        -----
        Returns the type of data represented by this handle.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def typeId(self): 
        '''
        typeId(self) -> MTypeId

        Synopsis
        -----
        Returns the type of data represented by this handle as a type id.
        A type id is a four character code that is used to identify the
        data type. If no data exists for this handle, the type id will be
        0x0.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def acceptedTypeIds(self, typids: MUintArray): 
        '''
        acceptedTypeIds(self, typids: MUintArray)

        Synopsis
        -----
        This method returns an array of MTypeId ids that the data handle
        can accept. The MTypeId can be reconstructed using the unsigned
        int in id.

        Returns:
        -----
        None

        Parameters:
        -----
        typids: MUintArray
        	[out] -> an unsigned int array to copy the ids to


        '''
        pass

    def data(self): 
        '''
        data(self) -> MObject

        Synopsis
        -----
        Returns the data object from this handle. The object returned
        should be used with the appropriate data function set. This
        method is not valid for simple numeric types.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def copy(self, src: MDataHandle): 
        '''
        copy(self, src: MDataHandle)

        Synopsis
        -----
        Copies the attribute from the src attribute to the attribute
        referenced by this handle. This is the only method which can
        completely copy a compound attribute from one handle to another.
        The construct outputHandle.set (inputHandle.data()) will not work
        for compound or multi attributes.When this method successfully
        copies data into the data bock it also marks the data block
        clean.

        Returns:
        -----
        None

        Parameters:
        -----
        src: MDataHandle
        	[in] -> the handle to the attribute to copy


        '''
        pass

    def copyWritable(self, src: MDataHandle): 
        '''
        copyWritable(self, src: MDataHandle)

        Synopsis
        -----
        Copies the attribute from the src attribute to the attribute
        referenced by this handle. When the copy is made it ensures that
        the data in this handle is writable. That is, if the src handle
        has a writable copy of the data then it will be duplicated,
        otherwise this handle will claim the writer status for the
        data.When this method successfully copies data into the data bock
        it also marks the data block clean.

        Returns:
        -----
        None

        Parameters:
        -----
        src: MDataHandle
        	[in] -> the handle to the attribute to copy


        '''
        pass

    def attribute(self): 
        '''
        attribute(self) -> MObject

        Synopsis
        -----
        Introduced in 2020.0 Returns the data attribute from this
        handle.The object returned should be used with the appropriate
        attribute function set.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setClean(self): 
        '''
        setClean(self)

        Synopsis
        -----
        Marks the data that is represented by this handle as being clean.
        This should be done after recalculating the data from the inputs.
        MDataHandle::setClean() does not clean the children of array
        attributes. For example, it cannot clean
        myNode.output[0].outputAttrX. One workaround is to call
        MDataBlock::setClean() to clean the datablock using the plug of
        outputAttrX.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asBool(self): 
        '''
        asBool(self) -> bool

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asChar(self): 
        '''
        asChar(self) -> char

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asUChar(self): 
        '''
        asUChar(self) -> char

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asShort(self): 
        '''
        asShort(self) -> short

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asInt(self): 
        '''
        asInt(self) -> int

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asInt64(self): 
        '''
        asInt64(self) -> MDataHandle.MInt64

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asAddr(self): 
        '''
        asAddr(self) -> void*&

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asFloat(self): 
        '''
        asFloat(self) -> float

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asDouble(self): 
        '''
        asDouble(self) -> double

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asDistance(self): 
        '''
        asDistance(self) -> MDistance

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asAngle(self): 
        '''
        asAngle(self) -> MAngle

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asTime(self): 
        '''
        asTime(self) -> MTime

        Synopsis
        -----
        Returns the data represented by this handle in the data block.
        Even though this method does not return a reference to an MTime,
        modifications to the MTime instance will update the contents of
        the handle in the data block. The method MDataHandle::setClean
        should be called after the data block has been modified.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asShort2(self): 
        '''
        asShort2(self) -> short2

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asInt2(self): 
        '''
        asInt2(self) -> int2

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asFloat2(self): 
        '''
        asFloat2(self) -> float2

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asDouble2(self): 
        '''
        asDouble2(self) -> double2

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asShort3(self): 
        '''
        asShort3(self) -> short3

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asInt3(self): 
        '''
        asInt3(self) -> int3

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asFloat3(self): 
        '''
        asFloat3(self) -> float3

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asDouble3(self): 
        '''
        asDouble3(self) -> double3

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asDouble4(self): 
        '''
        asDouble4(self) -> double4

        Synopsis
        -----
        Introduced in 2019.0 Returns the data represented by this handle
        in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asVector(self): 
        '''
        asVector(self) -> MVector

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asFloatVector(self): 
        '''
        asFloatVector(self) -> MFloatVector

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asMatrix(self): 
        '''
        asMatrix(self) -> MMatrix

        Synopsis
        -----
        Returns the data represented by this handle in the data block.
        This method is only valid for attributes created using the
        MFnMatrixAttribute function set.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asFloatMatrix(self): 
        '''
        asFloatMatrix(self) -> MFloatMatrix

        Synopsis
        -----
        Returns the data represented by this handle in the data block.
        This method is only valid for attributes created using the
        MFnMatrixAttribute function set.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asString(self): 
        '''
        asString(self) -> MString

        Synopsis
        -----
        Returns the data represented by this handle in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asNurbsCurve(self): 
        '''
        asNurbsCurve(self) -> MObject

        Synopsis
        -----
        Returns the data represented by this handle in the data block.
        The object returned by this call may be used directly with the
        nurbs curve function set and iterator. Even though this method
        does not return a reference to an MObject, modifications to the
        MObject instance will update the contents of the handle in the
        data block. The method MDataHandle::setClean should be called
        after the data block has been modified.The curve returned by this
        method will be in local space even if the connection is supplying
        world space geometry. This occurs mostly for efficiency reasons.
        In the case of a world space geometry connection, the MObject
        returned by this method will also contain the world space
        transformation matrix. This means that world space operations may
        be performed on this object using the nurbs curve function set
        and iterator.It is possible to get the matrix that defines the
        local to world transformation for this geometry using the
        MDataHandle::geometryTransformMatrix() method.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asNurbsSurface(self): 
        '''
        asNurbsSurface(self) -> MObject

        Synopsis
        -----
        Returns the data represented by this handle in the data block.
        The object returned by this call may be used directly with the
        nurbs surface function set and iterator. Even though this method
        does not return a reference to an MObject, modifications to the
        MObject instance will update the contents of the handle in the
        data block. The method MDataHandle::setClean should be called
        after the data block has been modified.The surface returned by
        this method will be in local space even if the connection is
        supplying world space geometry. This occurs mostly for efficiency
        reasons. In the case of a world space geometry connection, the
        MObject returned by this method will also contain the world space
        transformation matrix. This means that world space operations may
        be performed on this object using the nurbs surface function set
        and iterator.It is possible to get the matrix that defines the
        local to world transformation for this geometry using the
        MDataHandle::geometryTransformMatrix() method.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asMesh(self): 
        '''
        asMesh(self) -> MObject

        Synopsis
        -----
        Returns the data represented by this handle in the data block.
        The object returned by this call may be used directly with the
        mesh function set and iterators. Even though this method does not
        return a reference to an MObject, modifications to the MObject
        instance will update the contents of the handle in the data
        block. The method MDataHandle::setClean should be called after
        the data block has been modified.The surface returned by this
        method will be in local space even if the connection is supplying
        world space geometry. This occurs mostly for efficiency reasons.
        In the case of a world space geometry connection, the MObject
        returned by this method will also contain the world space
        transformation matrix. This means that world space operations may
        be performed on this object using the mesh function set and
        iterators.It is possible to get the matrix that defines the local
        to world transformation for this geometry using the
        MDataHandle::geometryTransformMatrix() method.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asSubdSurface(self): 
        '''
        asSubdSurface(self) -> MObject

        Synopsis
        -----
        Returns the data represented by this handle in the data block.
        The object returned by this call may be used directly with the
        subdivision surface function set and iterator. Even though this
        method does not return a reference to an MObject, modifications
        to the MObject instance will update the contents of the handle in
        the data block. The method MDataHandle::setClean should be called
        after the data block has been modified.The subdivision surface
        returned by this method will be in local space even if the
        connection is supplying world space geometry. This occurs mostly
        for efficiency reasons. In the case of a world space geometry
        connection, the MObject returned by this method will also contain
        the world space transformation matrix. This means that world
        space operations may be performed on this object using the
        subdivision surface function set and iterator.It is possible to
        get the matrix that defines the local to world transformation for
        this geometry using the MDataHandle::geometryTransformMatrix()
        method.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asNurbsCurveTransformed(self): 
        '''
        asNurbsCurveTransformed(self) -> MObject

        Synopsis
        -----
        Returns the data represented by this handle in the data block.
        The object returned by this call may be used directly with the
        nurbs curve function set (MFnNurbsCurve) or the nurbs curve CV
        iterator (MItCurveCV).If the incoming curve comes with world
        space transformation data, then it will be applied to the data
        that is returned. In other words, the curve that is returned will
        be the curve as it exists in world space.The curve that is
        returned from this method should not be modified. This method is
        only provided to make it easier to take world space geometry as
        input.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asNurbsSurfaceTransformed(self): 
        '''
        asNurbsSurfaceTransformed(self) -> MObject

        Synopsis
        -----
        Returns the data represented by this handle in the data block.
        The object returned by this call may be used directly with the
        nurbs surface function set (MFnNurbsSurface) or the nurbs surface
        CV iterator (MItSurfaceCV).If the incoming surface comes with
        world space transformation data, then it will be applied to the
        data that is returned. In other words, the surface that is
        returned will be the surface as it exists in world space.The
        surface that is returned from this method should not be modified.
        This method is only provided to make it easier to take world
        space geometry as input.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asMeshTransformed(self): 
        '''
        asMeshTransformed(self) -> MObject

        Synopsis
        -----
        Returns the data represented by this handle in the data block.
        The object returned by this call may be used directly with the
        mesh function set (MFnMesh) or any of the mesh iterators.If the
        incoming mesh comes with world space transformation data, then it
        will be applied to the data that is returned. In other words, the
        mesh that is returned will be the mesh as it exists in world
        space.The mesh that is returned from this method should not be
        modified. This method is only provided to make it easier to take
        world space geometry as input.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asSubdSurfaceTransformed(self): 
        '''
        asSubdSurfaceTransformed(self) -> MObject

        Synopsis
        -----
        Returns the data represented by this handle in the data block.
        The object returned by this call may be used directly with the
        subdivision surface function set (MFnSubdSurface) or the
        subdivision surface iterators (MItSubdVertex, MItSubdFace,
        MItSubdEdge).If the incoming surface comes with world space
        transformation data, then it will be applied to the data that is
        returned. In other words, the surface that is returned will be
        the surface as it exists in world space.The surface that is
        returned from this method should not be modified. This method is
        only provided to make it easier to take world space geometry as
        input.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asFalloffFunction(self): 
        '''
        asFalloffFunction(self) -> MObject

        Synopsis
        -----
        Introduced in 2022.0

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def geometryTransformMatrix(self): 
        '''
        geometryTransformMatrix(self) -> const MMatrix&

        Synopsis
        -----
        This method returns a reference to the local-to-world
        transformation matrix that can accompany a geometry data object.
        Only use this method on handles to geometry data (curves,
        surfaces, and meshes).If no local-to-world transformation
        information has been provided then this will be an identity
        matrix.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setBool(self, val: bool): 
        '''
        setBool(self, val: bool)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val: bool
        	[in] -> the new value 


        '''
        pass

    def setChar(self, val: char): 
        '''
        setChar(self, val: char)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val: char
        	[in] -> the new value 


        '''
        pass

    def setShort(self, val: short): 
        '''
        setShort(self, val: short)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val: short
        	[in] -> the new value 


        '''
        pass

    def setInt(self, val: int): 
        '''
        setInt(self, val: int)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val: int
        	[in] -> the new value 


        '''
        pass

    def setInt64(self, val: MDataHandle.MInt64): 
        '''
        setInt64(self, val: MDataHandle.MInt64)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val: MDataHandle.MInt64
        	[in] -> the new value 


        '''
        pass

    def setFloat(self, val: float): 
        '''
        setFloat(self, val: float)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val: float
        	[in] -> the new value 


        '''
        pass

    def setDouble(self, val: double): 
        '''
        setDouble(self, val: double)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val: double
        	[in] -> the new value 


        '''
        pass

    def setMMatrix(self, val: MMatrix): 
        '''
        setMMatrix(self, val: MMatrix)

        Synopsis
        -----
        Set the data that this handle represents in the data block. This
        method is only valid for attributes created using the
        MFnMatrixAttribute function set.

        Returns:
        -----
        None

        Parameters:
        -----
        val: MMatrix
        	[in] -> the new value 


        '''
        pass

    def setMFloatMatrix(self, val: MFloatMatrix): 
        '''
        setMFloatMatrix(self, val: MFloatMatrix)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val: MFloatMatrix
        	[in] -> the new value 


        '''
        pass

    def setMVector(self, val: MVector): 
        '''
        setMVector(self, val: MVector)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val: MVector
        	[in] -> the new value 


        '''
        pass

    def setMFloatVector(self, val: MFloatVector): 
        '''
        setMFloatVector(self, val: MFloatVector)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val: MFloatVector
        	[in] -> the new value 


        '''
        pass

    def setMDistance(self, val: MDistance): 
        '''
        setMDistance(self, val: MDistance)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val: MDistance
        	[in] -> the new value 


        '''
        pass

    def setMAngle(self, val: MAngle): 
        '''
        setMAngle(self, val: MAngle)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val: MAngle
        	[in] -> the new value 


        '''
        pass

    def setMTime(self, val: MTime): 
        '''
        setMTime(self, val: MTime)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val: MTime
        	[in] -> the new value 


        '''
        pass

    def set2Short(self, val1: short,
                        val2: short): 
        '''
        set2Short(self, val1: short,
                        val2: short)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: short
        	[in] -> the first value in the two element array 

        val2: short
        	[in] -> the second value in the two element array 


        '''
        pass

    def set2Int(self, val1: int,
                        val2: int): 
        '''
        set2Int(self, val1: int,
                        val2: int)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: int
        	[in] -> the first value in the two element array 

        val2: int
        	[in] -> the second value in the two element array 


        '''
        pass

    def set2Float(self, val1: float,
                        val2: float): 
        '''
        set2Float(self, val1: float,
                        val2: float)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: float
        	[in] -> the first value in the two element array 

        val2: float
        	[in] -> the second value in the two element array 


        '''
        pass

    def set2Double(self, val1: double,
                        val2: double): 
        '''
        set2Double(self, val1: double,
                        val2: double)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: double
        	[in] -> the first value in the two element array 

        val2: double
        	[in] -> the second value in the two element array 


        '''
        pass

    def set3Short(self, val1: short,
                        val2: short,
                        val3: short): 
        '''
        set3Short(self, val1: short,
                        val2: short,
                        val3: short)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: short
        	[in] -> the first value in the three element array 

        val2: short
        	[in] -> the second value in the three element array 

        val3: short
        	[in] -> the third value in the three element array 


        '''
        pass

    def set3Int(self, val1: int,
                        val2: int,
                        val3: int): 
        '''
        set3Int(self, val1: int,
                        val2: int,
                        val3: int)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: int
        	[in] -> the first value in the three element array 

        val2: int
        	[in] -> the second value in the three element array 

        val3: int
        	[in] -> the third value in the three element array 


        '''
        pass

    def set3Float(self, val1: float,
                        val2: float,
                        val3: float): 
        '''
        set3Float(self, val1: float,
                        val2: float,
                        val3: float)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: float
        	[in] -> the first value in the three element array 

        val2: float
        	[in] -> the second value in the three element array 

        val3: float
        	[in] -> the third value in the three element array 


        '''
        pass

    def set3Double(self, val1: double,
                        val2: double,
                        val3: double): 
        '''
        set3Double(self, val1: double,
                        val2: double,
                        val3: double)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: double
        	[in] -> the first value in the three element array 

        val2: double
        	[in] -> the second value in the three element array 

        val3: double
        	[in] -> the third value in the three element array 


        '''
        pass

    def set4Double(self, val1: double,
                        val2: double,
                        val3: double,
                        val4: double): 
        '''
        set4Double(self, val1: double,
                        val2: double,
                        val3: double,
                        val4: double)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: double
        	[in] -> the first value in the four element array 

        val2: double
        	[in] -> the second value in the four element array 

        val3: double
        	[in] -> the third value in the four element array 

        val4: double
        	[in] -> the fourth value in the four element array 


        '''
        pass

    def setString(self, val: MString): 
        '''
        setString(self, val: MString)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        val: MString
        	[in] -> the new string value 


        '''
        pass

    def setMObject(self, data: MObject): 
        '''
        setMObject(self, data: MObject)

        Synopsis
        -----
        Set the data that this handle represents in the data block. This
        method assumes that the MObject is a dependency graph data
        object. These objects can be created using the appropriate
        MFn..Data function set. Note that this method cannot be used to
        copy compound or multi attributes from one handle to another via
        the construct outputHandle.set (inputHandle.data()). To copy
        these user defined attributes, the method MDataHandle::copy must
        be used.

        Returns:
        -----
        None

        Parameters:
        -----
        data: MObject
        	[in] -> the data object


        '''
        pass

    def setMPxData(self, data: MPxData): 
        '''
        setMPxData(self, data: MPxData)

        Synopsis
        -----
        Set the data that this handle represents in the data block. This
        method takes a pointer to a user defined data object. The data
        block will become the new owner of the data object that you pass
        in. Do not delete it.

        Returns:
        -----
        None

        Parameters:
        -----
        data: MPxData
        	[in] -> the data object


        '''
        pass

    def asGenericBool(self): 
        '''
        asGenericBool(self) -> bool

        Synopsis
        -----
        Returns the generic data represented by this handle in the data
        block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asGenericChar(self): 
        '''
        asGenericChar(self) -> char

        Synopsis
        -----
        Returns the generic data represented by this handle in the data
        block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asGenericDouble(self): 
        '''
        asGenericDouble(self) -> double

        Synopsis
        -----
        Returns the generic data represented by this handle in the data
        block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asGenericFloat(self): 
        '''
        asGenericFloat(self) -> float

        Synopsis
        -----
        Returns the generic data represented by this handle in the data
        block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asGenericShort(self): 
        '''
        asGenericShort(self) -> short

        Synopsis
        -----
        Returns the generic data represented by this handle in the data
        block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asGenericInt(self): 
        '''
        asGenericInt(self) -> int

        Synopsis
        -----
        Returns the generic data represented by this handle in the data
        block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asGenericInt64(self): 
        '''
        asGenericInt64(self) -> MDataHandle.MInt64

        Synopsis
        -----
        Returns the generic data represented by this handle in the data
        block.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setGenericBool(self, value: bool,
                        force: bool): 
        '''
        setGenericBool(self, value: bool,
                        force: bool)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        value: bool
        	[in] -> the new bool value 

        force: bool
        	[in] -> force the new type of the attribute to be bool 


        '''
        pass

    def setGenericChar(self, value: char,
                        force: bool): 
        '''
        setGenericChar(self, value: char,
                        force: bool)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        value: char
        	[in] -> the new char value 

        force: bool
        	[in] -> force the new type of the attribute to be char 


        '''
        pass

    def setGenericDouble(self, value: double,
                        force: bool): 
        '''
        setGenericDouble(self, value: double,
                        force: bool)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        value: double
        	[in] -> the new double value 

        force: bool
        	[in] -> force the new type of the attribute to be double 


        '''
        pass

    def setGenericFloat(self, value: float,
                        force: bool): 
        '''
        setGenericFloat(self, value: float,
                        force: bool)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        value: float
        	[in] -> the new float value 

        force: bool
        	[in] -> force the new type of the attribute to be float 


        '''
        pass

    def setGenericShort(self, value: short,
                        force: bool): 
        '''
        setGenericShort(self, value: short,
                        force: bool)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        value: short
        	[in] -> the new short value 

        force: bool
        	[in] -> force the new type of the attribute to be short 


        '''
        pass

    def setGenericInt(self, value: int,
                        force: bool): 
        '''
        setGenericInt(self, value: int,
                        force: bool)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        value: int
        	[in] -> the new int value 

        force: bool
        	[in] -> force the new type of the attribute to be int 


        '''
        pass

    def setGenericInt64(self, value: MDataHandle.MInt64,
                        force: bool): 
        '''
        setGenericInt64(self, value: MDataHandle.MInt64,
                        force: bool)

        Synopsis
        -----
        Set the data that this handle represents in the data block.

        Returns:
        -----
        None

        Parameters:
        -----
        value: MDataHandle.MInt64
        	[in] -> the new 64-bit int value 

        force: bool
        	[in] -> force the new type of the attribute to be 64-bit int 


        '''
        pass

    @overload
    def child(self, plug: MPlug): 
        '''
        child(self, plug: MPlug) -> MDataHandle

        Synopsis
        -----
        Get a handle to a child of this handle. This is used if you have
        a handle to a compound attribute.

        Returns: 
        ----- 
        The data handle for the child

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug of the child


        '''
        pass

    @overload
    def child(self, attribute: MObject): 
        '''
        child(self, attribute: MObject) -> MDataHandle

        Synopsis
        -----
        Get a handle to a child of this handle. This is used if you have
        a handle to a compound attribute.

        Returns: 
        ----- 
        The data handle for the child

        Parameters:
        -----
        attribute: MObject
        	[in] -> the attribute of the child


        '''
        pass

    def datablock(self, ReturnStatus: MDataHandle.MStatus): 
        '''
        datablock(self, ReturnStatus: MDataHandle.MStatus) -> MDataBlock

        Synopsis
        -----
        Returns the datablock associated with this data handle.

        Returns: 
        ----- 
        The MDatablock representing the datablock associated with this
        data handle.

        Parameters:
        -----
        ReturnStatus: MDataHandle.MStatus
        	[out] -> Status Code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MDistance:
    '''Manipulate Linear Data.
The
MDistance class provides a fundamental type for the Maya API to hold and
manipulate linear data. All API methods that require or return
distance information do so through variables of this type.
'''
    def __init__(self):
        pass


    def unit(self): 
        '''
        unit(self) -> MDistance.MDistance

        Synopsis
        -----
        Return the units currently in effect for this instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def value(self): 
        '''
        value(self) -> double

        Synopsis
        -----
        Return the value of the current instance in the currently set
        units.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setUnit(self, newUnit: MDistance.MDistance): 
        '''
        setUnit(self, newUnit: MDistance.MDistance)

        Synopsis
        -----
        Set the units used by this instance.

        Returns:
        -----
        None

        Parameters:
        -----
        newUnit: MDistance.MDistance
        	[in] -> an element of the 


        '''
        pass

    def setValue(self, newValue: double): 
        '''
        setValue(self, newValue: double)

        Synopsis
        -----
        Set the value of this instance.

        Returns:
        -----
        None

        Parameters:
        -----
        newValue: double
        	[in] -> the new value in the units currently in effect


        '''
        pass

    def as_func(self, otherUnit: MDistance.MDistance,
                        ReturnStatus: MDistance.MStatus): 
        '''
        as_func(self, otherUnit: MDistance.MDistance,
                        ReturnStatus: MDistance.MStatus) -> double

        Synopsis
        -----
        Return the current value of this instance in the provided units.

        Returns: 
        ----- 
        The current value in the given units

        Parameters:
        -----
        otherUnit: MDistance.MDistance
        	[in] -> an element of the 

        ReturnStatus: MDistance.MStatus
        	[out] -> return status


        '''
        pass

    def asUnits(self, otherUnit: MDistance.MDistance,
                        ReturnStatus: MDistance.MStatus): 
        '''
        asUnits(self, otherUnit: MDistance.MDistance,
                        ReturnStatus: MDistance.MStatus) -> double

        Synopsis
        -----
        Return the current value of this instance in the provided units.

        Returns: 
        ----- 
        The current value in the given units

        Parameters:
        -----
        otherUnit: MDistance.MDistance
        	[in] -> an element of the 

        ReturnStatus: MDistance.MStatus
        	[out] -> return status


        '''
        pass

    def asInches(self): 
        '''
        asInches(self) -> double

        Synopsis
        -----
        Return the current value of this instance in inches.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asFeet(self): 
        '''
        asFeet(self) -> double

        Synopsis
        -----
        Return the current value of this instance in feet.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asYards(self): 
        '''
        asYards(self) -> double

        Synopsis
        -----
        Return the current value of this instance in yards.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asMiles(self): 
        '''
        asMiles(self) -> double

        Synopsis
        -----
        Return the current value of this instance in miles.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asMillimeters(self): 
        '''
        asMillimeters(self) -> double

        Synopsis
        -----
        Return the current value of this instance in millimeters.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asCentimeters(self): 
        '''
        asCentimeters(self) -> double

        Synopsis
        -----
        Return the current value of this instance in centimeters.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asKilometers(self): 
        '''
        asKilometers(self) -> double

        Synopsis
        -----
        Return the current value of this instance in kilometers.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asMeters(self): 
        '''
        asMeters(self) -> double

        Synopsis
        -----
        Return the current value of this instance in meters.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def uiUnit(self): 
        '''
        uiUnit(self) -> MDistance.MDistance

        Synopsis
        -----
        Returns the Working Units (or UI units) chosen in the settings of
        the prefs window.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setUIUnit(self, newUnit: MDistance.MDistance): 
        '''
        setUIUnit(self, newUnit: MDistance.MDistance)

        Synopsis
        -----
        Set the unit system to be used by the user in the UI.

        Returns:
        -----
        None

        Parameters:
        -----
        newUnit: MDistance.MDistance
        	[in] -> and element of the 


        '''
        pass

    def internalUnit(self): 
        '''
        internalUnit(self) -> MDistance.MDistance

        Synopsis
        -----
        Returns the internal unit system.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def internalToUI(self, internalValue: double): 
        '''
        internalToUI(self, internalValue: double) -> double

        Synopsis
        -----
        Converts a value from internal units to UI units.

        Returns: 
        ----- 
        The value in UI units

        Parameters:
        -----
        internalValue: double
        	[in] -> a value in internal units


        '''
        pass

    def uiToInternal(self, uiValue: double): 
        '''
        uiToInternal(self, uiValue: double) -> double

        Synopsis
        -----
        Converts a value from UI units to internal units.

        Returns: 
        ----- 
        The value in internal units.

        Parameters:
        -----
        uiValue: double
        	[in] -> a value in UI units


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class Unit:
    '''Available Unit Systems. 
    Non-functional class.  Values for this enum:
    kInches
    kFeet
    kYards
    kMiles
    kMillimeters
    kCentimeters
    kKilometers
    kMeters
    '''

    def __init__(self):
        pass

    def kInches(self):
        '''This is an enum of Unit.
        - Description: Inches. 
        - Value: 1
        '''
        pass

    def kFeet(self):
        '''This is an enum of Unit.
        - Description: Feet. 
        - Value: 2
        '''
        pass

    def kYards(self):
        '''This is an enum of Unit.
        - Description: Yards. 
        - Value: 3
        '''
        pass

    def kMiles(self):
        '''This is an enum of Unit.
        - Description: Miles. 
        - Value: 4
        '''
        pass

    def kMillimeters(self):
        '''This is an enum of Unit.
        - Description: Millimeters. 
        - Value: 5
        '''
        pass

    def kCentimeters(self):
        '''This is an enum of Unit.
        - Description: Centimeters. 
        - Value: 6
        '''
        pass

    def kKilometers(self):
        '''This is an enum of Unit.
        - Description: Kilometers. 
        - Value: 7
        '''
        pass

    def kMeters(self):
        '''This is an enum of Unit.
        - Description: Meters. 
        - Value: 8
        '''
        pass

class MDoubleArray:
    '''Array of doubles data type.
This class implements an array of doubles. Common convenience
functions are available, and the implementation is compatible
with the internal Maya implementation so that it can be passed
efficiently between plugins and internal maya data structures.
Methods that query the array are threadsafe. Writing to different
array elements at the same time with the
set() method is threadsafe. Methods that modify the array length,
namely
append(),
insert(),
remove() and
setLength() are not threadsafe.
'''
    def __init__(self):
        pass


    @overload
    def set(self, element: double,
                        index: int): 
        '''
        set(self, element: double,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated double
        value. NOTE: This method does not grow the array if the index is
        out of bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        element: double
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    @overload
    def set(self, element: float,
                        index: int): 
        '''
        set(self, element: float,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated float
        value. NOTE: This method does not grow the array if the index is
        out of bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        element: float
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    def setLength(self, length: int): 
        '''
        setLength(self, length: int)

        Synopsis
        -----
        Set the length of the array. This will grow and shrink the array
        as desired. Elements that are grown have uninitialized values,
        while those which are shrunk will lose the data contained in the
        deleted elements (ie. it will release the memory).

        Returns:
        -----
        None

        Parameters:
        -----
        length: int
        	[in] -> the new size of the array 


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Returns the number of elements in the instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Remove the array element at the given index. All array elements
        following the removed element are shifted toward the first
        element.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> index of the element to be removed


        '''
        pass

    def insert(self, element: double,
                        index: int): 
        '''
        insert(self, element: double,
                        index: int)

        Synopsis
        -----
        Inserts a new value into the array at the given index. The
        initial element at that index, and all following elements, are
        shifted towards the last. If the array cannot be expanded in size
        by 1 element, then the insert will fail and the existing array
        will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: double
        	[in] -> the new value to insert into the array 

        index: int
        	[in] -> the index of the element to set to the the new value


        '''
        pass

    def append(self, element: double): 
        '''
        append(self, element: double)

        Synopsis
        -----
        Adds a new element to the end of the array. If the array cannot
        be expanded in size by 1 element, then the append will fail and
        the existing array will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: double
        	[in] -> the value for the new last element


        '''
        pass

    def copy(self, source: MDoubleArray): 
        '''
        copy(self, source: MDoubleArray)

        Synopsis
        -----
        Copy the contents of the source array to this array.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MDoubleArray
        	[in] -> array to copy from


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clear the contents of the array. After this operation the length
        method will return 0. This does not change the amount of memory
        allocated to the array, only the number of valid elements in it.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def get(self, array: double): 
        '''
        get(self, array: double)

        Synopsis
        -----
        Copy the elements of the array into the given C++ array of
        doubles. No checking is done to ensure that the destination C++
        array of doubles is large enough to hold all the elements of the
        instance.

        Returns:
        -----
        None

        Parameters:
        -----
        array: double
        	[out] -> the array to populate


        '''
        pass

    @overload
    def get(self, array: float): 
        '''
        get(self, array: float)

        Synopsis
        -----
        Copy the elements of the array into the given C++ array of
        floats. No checking is done to ensure that the destination C++
        array of floats is large enough to hold all the elements of the
        instance.

        Returns:
        -----
        None

        Parameters:
        -----
        array: float
        	[out] -> the array to populate


        '''
        pass

    def setSizeIncrement(self, newIncrement: int): 
        '''
        setSizeIncrement(self, newIncrement: int)

        Synopsis
        -----
        Set the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        newIncrement: int
        	[in] -> the new increment 


        '''
        pass

    def sizeIncrement(self): 
        '''
        sizeIncrement(self) -> int

        Synopsis
        -----
        Return the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MDoubleArray.MDoubleArray

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MDoubleArray.MDoubleArray

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MDoubleArray.MDoubleArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MDoubleArray.MDoubleArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MDoubleArray.MDoubleArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MDoubleArray.MDoubleArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MDAGDrawOverrideInfo:
    '''A data structure to store the per path draw override information.
A simple draw override data structure. Draw override is per DAG
path information. It checks starting from current object and
upwards until an enabled draw override is found.
'''
    def __init__(self):
        pass


class DrawOverrideDisplayType:
    '''Draw override type. 
    Non-functional class.  Values for this enum:
    kDisplayTypeNormal
    kDisplayTypeReference
    kDisplayTypeTemplate
    '''

    def __init__(self):
        pass

    def kDisplayTypeNormal(self):
        '''This is an enum of DrawOverrideDisplayType.
        - Description: Display as normal. 
        - Value: 0
        '''
        pass

    def kDisplayTypeReference(self):
        '''This is an enum of DrawOverrideDisplayType.
        - Description: Display as reference. 
        - Value: 1
        '''
        pass

    def kDisplayTypeTemplate(self):
        '''This is an enum of DrawOverrideDisplayType.
        - Description: Display as templated(not selectable, only show as wireframe) 
        - Value: 2
        '''
        pass

class DrawOverrideLOD:
    '''Draw override LOD. 
    Non-functional class.  Values for this enum:
    kLODFull
    kLODBoundingBox
    '''

    def __init__(self):
        pass

    def kLODFull(self):
        '''This is an enum of DrawOverrideLOD.
        - Description: Display all render items like shaded, wireframe as full detailed. 
        - Value: 0
        '''
        pass

    def kLODBoundingBox(self):
        '''This is an enum of DrawOverrideLOD.
        - Description: Display only a bounding box, nothing else. 
        - Value: 1
        '''
        pass

class MDGContext:
    '''Dependency graph (DG) context class.
Control the way in which dependency nodes are evaluated.
DG contexts are used to define the way in which a dependency node
is going to be evaluated. Examples of such contexts include
"normal", "at a given time, "for a specific instance", etc.
MDGContext is mainly used in two places; within methods that trigger
evaluations, to define what kind of evaluate is being requested,
and within data blocks (
MDataBlock), to identify how the data was created.
There is always the notion of the "current evaluation context".
That's the one that will be used when no context is specifically
mentioned, and is the normal state of evaluation.
'''
    def __init__(self):
        pass


    def isNormal(self, ReturnStatus: MDGContext.MStatus): 
        '''
        isNormal(self, ReturnStatus: MDGContext.MStatus) -> bool

        Synopsis
        -----
        Determines if this context is that of "normal" evaluation.

        Returns: 
        ----- 
        true this context is normal  false this context is not normal

        Parameters:
        -----
        ReturnStatus: MDGContext.MStatus
        	[out] -> Status code


        '''
        pass

    def getTime(self, timeVal: MTime): 
        '''
        getTime(self, timeVal: MTime)

        Synopsis
        -----
        Return the single time for which this context is valid. The
        context must be a timed context, i.e. not a normal one.

        Returns:
        -----
        None

        Parameters:
        -----
        timeVal: MTime
        	[out] -> Storage for the time


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def current(self): 
        '''
        current(self) -> const MDGContext

        Synopsis
        -----
        Extract the current context being used for evaluation.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isCurrent(self, ReturnStatus: MDGContext.MStatus): 
        '''
        isCurrent(self, ReturnStatus: MDGContext.MStatus) -> bool

        Synopsis
        -----
        Determines if this context is the one currently being used for
        evaluation.

        Returns: 
        ----- 
        true this context is currently being used for evaluation  false
        this context is not currently being used for evaluation

        Parameters:
        -----
        ReturnStatus: MDGContext.MStatus
        	[out] -> Status code


        '''
        pass

    def makeCurrent(self, ReturnStatus: MDGContext.MStatus): 
        '''
        makeCurrent(self, ReturnStatus: MDGContext.MStatus) -> const MDGContext

        Synopsis
        -----
        Set the context to be the current evaluation context.

        Returns: 
        ----- 
        Previous current evaluation context

        Parameters:
        -----
        ReturnStatus: MDGContext.MStatus
        	[out] -> Status code


        '''
        pass

class MDGContextGuard:
    '''Scope object used to modify current evaluation context in a code
block.
Some API methods can have a context passed in to them. In those
cases the current context will be temporarily changed to the
passed context for evaluation purposes.
A better method for longer sequences of evaluation in an
alterative context is to create a guard in a block of code that
makes a bunch of calls, and then use the context-free methods.
This is equivalent to:
'''
    def __init__(self):
        pass


class MDGMessage:
    '''Dependency graph messages.
This class is used to register callbacks for dependency graph
messages.
There are 4 add callback methods which will add callbacks for the
following messages
A filter can be specified for node added/removed messages. The
default node type is "dependNode" which matches all nodes. Each
method returns an id which is used to remove the callback.
To remove a callback use
MMessage::removeCallback. All callbacks that are registered by a plug-in must be removed
by that plug-in when it is unloaded. Failure to do so will result
in a fatal error.
'''
    def __init__(self):
        pass


    def addTimeChangeCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDGMessage.MStatus): 
        '''
        addTimeChangeCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDGMessage.MStatus) -> MDGMessage.OPENMAYA_MAJOR_NAMESPACE_OPENMCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever the time
        changes in the dependency graph.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDGMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addDelayedTimeChangeCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDGMessage.MStatus): 
        '''
        addDelayedTimeChangeCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDGMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever the time
        changes in the dependency graph, but after the time changed
        callback.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDGMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addDelayedTimeChangeRunupCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDGMessage.MStatus): 
        '''
        addDelayedTimeChangeRunupCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDGMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever the time
        changes in the dependency graph, but after the other time changed
        callbacks which can be used to invoke a dynamics solve or runup
        if needed.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDGMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addForceUpdateCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDGMessage.MStatus): 
        '''
        addForceUpdateCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDGMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called after the time
        changes. Note that receiving this callback does not guarantee if
        nodes have been evaluated in the dependency graph regardless of
        evaluation method in use.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDGMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addNodeAddedCallback(self, func: MMessage.MMessage,
                        nodeType: MString,
                        clientData: void,
                        ReturnStatus: MDGMessage.MStatus): 
        '''
        addNodeAddedCallback(self, func: MMessage.MMessage,
                        nodeType: MString,
                        clientData: void,
                        ReturnStatus: MDGMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever a new
        node is added to the dependency graph. The nodeType argument
        allows you to specify the type of nodes that will trigger the
        callback. The default node type is "dependNode" which matches all
        nodes.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function 

        nodeType: MString
        	[in] -> Type of node that will trigger the callback 

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDGMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addNodeRemovedCallback(self, func: MMessage.MMessage,
                        nodeType: MString,
                        clientData: void,
                        ReturnStatus: MDGMessage.MStatus): 
        '''
        addNodeRemovedCallback(self, func: MMessage.MMessage,
                        nodeType: MString,
                        clientData: void,
                        ReturnStatus: MDGMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever a new
        node is removed from the dependency graph. The nodeType argument
        allows you to specify the type of nodes that will trigger the
        callback. The default node type is "dependNode" which matches all
        nodes.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function 

        nodeType: MString
        	[in] -> Type of node that will trigger the callback 

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDGMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addConnectionCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDGMessage.MStatus): 
        '''
        addConnectionCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDGMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever a
        connection is made or broken in the dependency graph. This
        callback is triggered after the given connection has been made or
        broken, unlike the addPreConnectionCallback which is triggered
        before the operation.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDGMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addPreConnectionCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDGMessage.MStatus): 
        '''
        addPreConnectionCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDGMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever any
        connection is made or broken in the dependency graph. This
        callback is triggered before the given connection has been made
        or broken, unlike the addConnectionCallback which is triggered
        after the operation.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDGMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addNodeChangeUuidCheckCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDGMessage.MStatus): 
        '''
        addNodeChangeUuidCheckCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MDGMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called whenever a node
        may have its UUID changed. Possible causes include the 'rename'
        command, and the UUID for a node being read from a file during
        file I/O.Note that nodes are assigned a UUID when they are
        created; this does not invoke this callback. During file I/O the
        stored UUID is applied as a separate step after creation (which
        does invoke this callback).Depending on the situation Maya may or
        may not use the new UUID by default. For example, when importing
        a file, Maya reads the UUID from the file but does not use it.
        The boolean argument to the callback function lets the callback
        know whether Maya is intending to use the UUID or not.The
        callback returns a MMessage::Action enum: In any case, the
        callback may leave the new uuid as is, or may provide a new uuid
        of its own choosing to be used instead.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MDGMessage.MStatus
        	[out] -> status code


        '''
        pass

class MDGModifier:
    '''Dependency graph modifier.
An
MDGModifier is used to change the structure of the dependency graph. This
includes adding nodes, making new connections, and removing
existing connections. To perform operations using an
MDGModifier, register all of the changes that are to be made and then call
the doIt method to make the changes. Undo is provided through the
undoIt method.
Under some situations, a
doIt() call may be required to separate some of the operations. The
specific case of interest involves performing a
disconnect() and a
deleteNode() on the same node within the stack of operations.
Assuming that the Maya model has a connected node that was going
to be deleted, do the following:
Then
undoIt() can be implemented as:
MDGModifier does not understanding the hierarchical relationship between DAG
nodes. When performing DG operations on DAG nodes
MDagModifier should be used instead. In some cases
MDagModifier may even be required when operating on non-DAG nodes. For
example, a container node is a non-DAG node but it may contain
DAG nodes. When the container is deleted its members will be
deleted as well. Since some of those members may be DAG nodes an
MDagModifier should be used to delete the container node.
'''
    def __init__(self):
        pass


    @overload
    def createNode(self, typeId: MTypeId,
                        ReturnStatus: MDGModifier.MStatus): 
        '''
        createNode(self, typeId: MTypeId,
                        ReturnStatus: MDGModifier.MStatus) -> MObject

        Synopsis
        -----
        This method adds an operation to this dependency graph modifier
        that will add a new dependency graph node of the given type to
        the dependency graph. This method may not be used to construct
        new DAG nodes. Use MDagModifier for that purpose.When createNode
        is called, the new node is created and the MObject handle for it
        is returned. It should be noted that the node will not be added
        to the dependency graph until the doIt method is called.If a node
        is created with this method, but the operation is undone, then
        the MDGModifier will take responsibility for freeing the node.
        This will be done when the MDGModifier is destructed.

        Returns: 
        ----- 
        A handle for the new node

        Parameters:
        -----
        typeId: MTypeId
        	[in] -> type of the node to create 

        ReturnStatus: MDGModifier.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def createNode(self, type: MString,
                        ReturnStatus: MDGModifier.MStatus): 
        '''
        createNode(self, type: MString,
                        ReturnStatus: MDGModifier.MStatus) -> MObject

        Synopsis
        -----
        This method adds an operation to this dependency graph modifier
        that will add a new dependency graph node of the given type to
        the dependency graph. This method may not be used to construct
        new DAG nodes. Use MDagModifier for that purpose.When createNode
        is called, the new node is created and the MObject handle for it
        is returned. It should be noted that the node will not be added
        to the dependency graph until the doIt method is called.If a node
        is created with this method, but the operation is undone, then
        the MDGModifier will take responsibility for freeing the node.
        This will be done when the MDGModifier is destructed.

        Returns: 
        ----- 
        A handle for the new node

        Parameters:
        -----
        type: MString
        	[in] -> type name of the node to create 

        ReturnStatus: MDGModifier.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def deleteNode(self, node: MObject): 
        '''
        deleteNode(self, node: MObject)

        Synopsis
        -----
        This method adds an operation to this dependency graph modifier
        that will delete a dependency graph node from the dependency
        graph. The deleteNode method will perform some operations
        immediately like removing connections and removing DAG nodes from
        the model. However, it is still necessary to call doIt to
        complete the delete operation.Special care must be taken when
        combining other operations with delete in the same MDGModifier
        and you should call doIt before and after deleteNode. Sample code
        showing how to disconnect and delete a node using a single
        MDGModifier can be found in the class description.Note: The
        default behaviour when deleting a DAG node is to also include
        empty parents of the DAG node in the delete operation. If you do
        not want this behaviour use the other deleteNode method and pass
        false for the second (includeParents) argument.

        Returns:
        -----
        None

        Parameters:
        -----
        node: MObject
        	[in] -> node to delete


        '''
        pass

    @overload
    def deleteNode(self, node: MObject,
                        includeParents: bool): 
        '''
        deleteNode(self, node: MObject,
                        includeParents: bool)

        Synopsis
        -----
        Introduced in 2022.0 This method adds an operation to this
        dependency graph modifier that will delete a dependency graph
        node from the dependency graph.The deleteNode method will perform
        some operations immediately like removing connections and
        removing DAG nodes from the model. However, it is still necessary
        to call doIt to complete the delete operation.Special care must
        be taken when combining other operations with delete in the same
        MDGModifier and you should call doIt before and after deleteNode.
        Sample code showing how to disconnect and delete a node using a
        single MDGModifier can be found in the class description.Note: If
        includeParents is true then empty parents of the DAG node will be
        included in the delete operation. Pass false to only delete this
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        node: MObject
        	[in] -> node to delete 

        includeParents: bool
        	[in] -> delete empty DAG node parents


        '''
        pass

    def renameNode(self, node: MObject,
                        newName: MString): 
        '''
        renameNode(self, node: MObject,
                        newName: MString)

        Synopsis
        -----
        This method adds an operation to this dependency graph modifier
        that will rename a dependency graph node.

        Returns:
        -----
        None

        Parameters:
        -----
        node: MObject
        	[in] -> node to rename 

        newName: MString
        	[in] -> new name for the node


        '''
        pass

    def setNodeLockState(self, node: MObject,
                        newState: bool): 
        '''
        setNodeLockState(self, node: MObject,
                        newState: bool)

        Synopsis
        -----
        This method adds an operation to this dependency graph modifier
        that will set the lock state of the node.

        Returns:
        -----
        None

        Parameters:
        -----
        node: MObject
        	[in] -> node to toggle lock state 

        newState: bool
        	[in] -> new lock state


        '''
        pass

    @overload
    def connect(self, sourceNode: MObject,
                        sourceAttr: MObject,
                        destNode: MObject,
                        destAttr: MObject): 
        '''
        connect(self, sourceNode: MObject,
                        sourceAttr: MObject,
                        destNode: MObject,
                        destAttr: MObject)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that connects
        two attributes of two nodes in the dependency graph. The value of
        the destination attribute is supplied by the value of the source
        attribute once they are connected.It is the users responsibility
        to ensure that the source and destination attributes are of
        compatible types. For instance, if the source attribute is a
        nurbs surface then the destination must also be a nurbs
        surface.To connect array attributes use the other version of
        connect which takes MPlugs as parameters.

        Returns:
        -----
        None

        Parameters:
        -----
        sourceNode: MObject
        	[in] -> the source node in the connection 

        sourceAttr: MObject
        	[in] -> the attribute of the source node that is to be connected 

        destNode: MObject
        	[in] -> the destination node in the connection 

        destAttr: MObject
        	[in] -> the attribute of the destination node that is to be connected


        '''
        pass

    @overload
    def disconnect(self, sourceNode: MObject,
                        sourceAttr: MObject,
                        destNode: MObject,
                        destAttr: MObject): 
        '''
        disconnect(self, sourceNode: MObject,
                        sourceAttr: MObject,
                        destNode: MObject,
                        destAttr: MObject)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that
        disconnects two attributes of two nodes in the dependency graph.

        Returns:
        -----
        None

        Parameters:
        -----
        sourceNode: MObject
        	[in] -> the source node in the connection 

        sourceAttr: MObject
        	[in] -> the attribute of the source node that is connected 

        destNode: MObject
        	[in] -> the destination node in the connection 

        destAttr: MObject
        	[in] -> the attribute of the destination node that is connected


        '''
        pass

    @overload
    def connect(self, source: MPlug,
                        dest: MPlug): 
        '''
        connect(self, source: MPlug,
                        dest: MPlug)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that connects
        two plugs in the dependency graph. The value of the destination
        plug is supplied by the value of the source plug once they are
        connected.It is the users responsibility to ensure that the
        source and destination attributes are of compatible types. For
        instance, if the source attribute is a nurbs surface then the
        destination must also be a nurbs surface.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MPlug
        	[in] -> the source plug in the connection 

        dest: MPlug
        	[in] -> the destination plug in the connection


        '''
        pass

    @overload
    def disconnect(self, source: MPlug,
                        dest: MPlug): 
        '''
        disconnect(self, source: MPlug,
                        dest: MPlug)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that
        disconnects two plugs in the dependency graph.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MPlug
        	[in] -> the source plug in the connection 

        dest: MPlug
        	[in] -> the destination plug in the connection


        '''
        pass

    def addAttribute(self, node: MObject,
                        attribute: MObject): 
        '''
        addAttribute(self, node: MObject,
                        attribute: MObject)

        Synopsis
        -----
        Add a new dynamic attribute to the given dependency node. This
        method also adds all children of the attribute if it is a
        compound. So, if a compound attribute is being added to a node,
        then only the parent attribute needs to be added using this
        method.

        Returns:
        -----
        None

        Parameters:
        -----
        node: MObject
        	[in] -> node to which to add the attribute 

        attribute: MObject
        	[in] -> attribute to add


        '''
        pass

    def removeAttribute(self, node: MObject,
                        attribute: MObject): 
        '''
        removeAttribute(self, node: MObject,
                        attribute: MObject)

        Synopsis
        -----
        Removes a dynamic attribute from the given dependency node. This
        method also removes all children of the attribute if it is a
        compound.Note: After a successful call to this method, the
        MObject passed to it that contains the attribute will have been
        reset to MObject::kNullObj because the attribute it referenced no
        longer exists. Thus no function sets, such as MFnAttribute,
        should be attached to the MObject at the time this call is made.

        Returns:
        -----
        None

        Parameters:
        -----
        node: MObject
        	[in] -> node to add an attribute to 

        attribute: MObject
        	[in] -> attribute to add


        '''
        pass

    def renameAttribute(self, node: MObject,
                        attribute: MObject,
                        shortName: MString,
                        longName: MString): 
        '''
        renameAttribute(self, node: MObject,
                        attribute: MObject,
                        shortName: MString,
                        longName: MString)

        Synopsis
        -----
        Renames a dynamic attribute on the given dependency node.

        Returns:
        -----
        None

        Parameters:
        -----
        node: MObject
        	[in] -> The node to which the attribute belongs 

        attribute: MObject
        	[in] -> The attribute to rename 

        shortName: MString
        	[in] -> The new short name 

        longName: MString
        	[in] -> The new long name


        '''
        pass

    def addExtensionAttribute(self, nodeClass: MNodeClass,
                        attribute: MObject): 
        '''
        addExtensionAttribute(self, nodeClass: MNodeClass,
                        attribute: MObject)

        Synopsis
        -----
        Add a new extension attribute to the given dependency node class.
        This method also adds all children of the attribute if it is a
        compound. So, if a compound attribute is being added to a node
        type, then only the parent attribute needs to be added using this
        method.

        Returns:
        -----
        None

        Parameters:
        -----
        nodeClass: MNodeClass
        	[in] -> class of node to which to add the attribute 

        attribute: MObject
        	[in] -> attribute to add


        '''
        pass

    def removeExtensionAttribute(self, nodeClass: MNodeClass,
                        attribute: MObject): 
        '''
        removeExtensionAttribute(self, nodeClass: MNodeClass,
                        attribute: MObject)

        Synopsis
        -----
        Removes an extension attribute from the given dependency node
        type. This method also removes all children of the attribute if
        it is a compound.Note: After a successful call to this method,
        the MObject passed to it that contains the attribute will have
        been reset to MObject::kNullObj because the attribute it
        referenced may no longer exist. Thus no function sets, such as
        MFnAttribute, should be attached to the MObject at the time this
        call is made.

        Returns:
        -----
        None

        Parameters:
        -----
        nodeClass: MNodeClass
        	[in] -> class of node from which to remove the attribute 

        attribute: MObject
        	[in] -> attribute to remove


        '''
        pass

    def removeExtensionAttributeIfUnset(self, nodeClass: MNodeClass,
                        attribute: MObject): 
        '''
        removeExtensionAttributeIfUnset(self, nodeClass: MNodeClass,
                        attribute: MObject)

        Synopsis
        -----
        Removes an extension attribute from the given dependency node
        type but only if there are no nodes in the graph with non-default
        values for this attribute. This method also removes all children
        of the attribute if it is a compound.Note: After a successful
        call to this method, the MObject passed to it that contains the
        attribute may have been reset to MObject::kNullObj because the
        attribute it referenced may no longer exist. Thus no function
        sets, such as MFnAttribute, should be attached to the MObject at
        the time this call is made.

        Returns:
        -----
        None

        Parameters:
        -----
        nodeClass: MNodeClass
        	[in] -> class of node from which to remove the attribute 

        attribute: MObject
        	[in] -> attribute to remove


        '''
        pass

    def linkExtensionAttributeToPlugin(self, mPlugin: MObject,
                        mAttribute: MObject): 
        '''
        linkExtensionAttributeToPlugin(self, mPlugin: MObject,
                        mAttribute: MObject)

        Synopsis
        -----
        The plugin calls this to indicate that the extension attribute
        defines part of the plugin, regardless of the node type to which
        it attaches itself. This requirement is used when the plugin is
        checked to see if it is in use or if is able to be unloaded or if
        it is required as part of a stored file.This should only be
        called once for root attributes (i.e. those with no parent). It
        is an error to call it with a child attribute. All children and
        ancestors are recursively tested. Forcing it to be called only on
        the root keeps the calling code simple and avoids duplicate
        calls.

        Returns:
        -----
        None

        Parameters:
        -----
        mPlugin: MObject
        	[in] -> plugin to which the attribute is to be tied 

        mAttribute: MObject
        	[in] -> attribute to associate with the plugin, must not have a parent


        '''
        pass

    def unlinkExtensionAttributeFromPlugin(self, mPlugin: MObject,
                        mAttribute: MObject): 
        '''
        unlinkExtensionAttributeFromPlugin(self, mPlugin: MObject,
                        mAttribute: MObject)

        Synopsis
        -----
        Tells a plugin that it no longer requires an extension attribute
        for operation. This requirement is used when the plugin is
        checked to see if it is in use or if is able to be unloaded.This
        should only be called once for root attributes (i.e. those with
        no parent). It is an error to call it with a child attribute. All
        children and ancestors are recursively removed. Forcing it to be
        called only on the root keeps the calling code simple and avoids
        duplicate calls.

        Returns:
        -----
        None

        Parameters:
        -----
        mPlugin: MObject
        	[in] -> plugin from which the attribute is to be released 

        mAttribute: MObject
        	[in] -> attribute to disassociate with the plugin, must not have a parent


        '''
        pass

    def commandToExecute(self, command: MString): 
        '''
        commandToExecute(self, command: MString)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that executes
        a MEL command. The command should be fully undoable, otherwise
        unpredictable behaviour may result. For example, assume that the
        command is a MEL procedure which contains some undoable commands
        and some non-undoable commands. When doIt() is first called, the
        procedure will be executed and all of its commands will take
        effect. If undoIt() is subsequently called, only the undoable
        portions of the script will be undone, which may leave Maya in an
        unstable or inconsistent state. Any subsequent calls to doIt()
        will only redo the commands which were undone, the non-undoable
        portions will not be re-executed.If the command contains no
        undoable portions whatsoever, the call to doIt() may fail (it
        depends upon the state of the MDGModifier at the time), but only
        after executing the command.NOTE: It is best to use multiple
        commandToExecute() calls rather than batching multiple commands
        into one call to commandToExecute(). Using one command per call
        to commandToExecute() will simplify the undo stack which is
        important in case of command failure.

        Returns:
        -----
        None

        Parameters:
        -----
        command: MString
        	[in] -> the command that will be executed (should be undoable)


        '''
        pass

    def pythonCommandToExecute(self, command: MString): 
        '''
        pythonCommandToExecute(self, command: MString)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that executes
        a Python command/script. As noted for commandToExecute(), the
        specified command should be fully undoable, otherwise
        unpredictable behaviour may result. However, this is even more
        true for a Python command/script because it has access to the
        Maya API. Most Maya commands which modify the scene are undoable,
        but modifications made through the API are not.For example,
        assume that the script uses the 'polySphere' command to create a
        mesh sphere, but then modifies its shape using API calls. When
        the MDGModifier's doIt() is first called, everything will work as
        planned and a modified sphere will result. When undoIt() is
        called, only the undoable 'polySphere' command will be done, not
        modifications made through the API. That's no loss since the
        sphere is being deleted. However, if doIt() is now called a
        second time, only those the undoable actions will be redone, so
        the 'polySphere' command will be redone, but the API calls to
        modify it will not, leaving an unmodified sphere. Variants on the
        same thing can end up corrupting your model and even crashing
        Maya.If the command contains no undoable portions whatsoever, the
        call to doIt() may fail (it depends upon the state of the
        MDGModifier at the time), but only after executing the
        command.Python NotesIn Python this method can also be passed a
        Python callable which will be passed no arguments when it is
        executed.

        Returns:
        -----
        None

        Parameters:
        -----
        command: MString
        	[in] -> the command that will be executed (should be undoable)


        '''
        pass

    def newPlugValue(self, plug: MPlug,
                        plugValue: MObject): 
        '''
        newPlugValue(self, plug: MPlug,
                        plugValue: MObject)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that sets a
        plug value. Plug values can be created with the MFnNumericData
        class.

        Returns:
        -----
        None

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug to set 

        plugValue: MObject
        	[in] -> the value to set


        '''
        pass

    def newPlugValueBool(self, plug: MPlug,
                        plugValue: bool): 
        '''
        newPlugValueBool(self, plug: MPlug,
                        plugValue: bool)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that sets a
        plug to a boolean value.

        Returns:
        -----
        None

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug to set 

        plugValue: bool
        	[in] -> the value to set


        '''
        pass

    def newPlugValueChar(self, plug: MPlug,
                        plugValue: char): 
        '''
        newPlugValueChar(self, plug: MPlug,
                        plugValue: char)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that sets a
        plug to a char value.

        Returns:
        -----
        None

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug to set 

        plugValue: char
        	[in] -> the value to set


        '''
        pass

    def newPlugValueDouble(self, plug: MPlug,
                        plugValue: double): 
        '''
        newPlugValueDouble(self, plug: MPlug,
                        plugValue: double)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that sets a
        plug to a double value.

        Returns:
        -----
        None

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug to set 

        plugValue: double
        	[in] -> the value to set


        '''
        pass

    def newPlugValueFloat(self, plug: MPlug,
                        plugValue: float): 
        '''
        newPlugValueFloat(self, plug: MPlug,
                        plugValue: float)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that sets a
        plug to a float value.

        Returns:
        -----
        None

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug to set 

        plugValue: float
        	[in] -> the value to set


        '''
        pass

    def newPlugValueInt(self, plug: MPlug,
                        plugValue: int): 
        '''
        newPlugValueInt(self, plug: MPlug,
                        plugValue: int)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that sets a
        plug to an int value.

        Returns:
        -----
        None

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug to set 

        plugValue: int
        	[in] -> the value to set


        '''
        pass

    def newPlugValueInt64(self, plug: MPlug,
                        plugValue: MDGModifier.MInt64): 
        '''
        newPlugValueInt64(self, plug: MPlug,
                        plugValue: MDGModifier.MInt64)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that sets a
        plug to a 64-bit int value.

        Returns:
        -----
        None

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug to set 

        plugValue: MDGModifier.MInt64
        	[in] -> the value to set


        '''
        pass

    def newPlugValueMAngle(self, plug: MPlug,
                        plugValue: MAngle): 
        '''
        newPlugValueMAngle(self, plug: MPlug,
                        plugValue: MAngle)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that sets a
        plug to an MAngle value.

        Returns:
        -----
        None

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug to set 

        plugValue: MAngle
        	[in] -> the value to set


        '''
        pass

    def newPlugValueMDistance(self, plug: MPlug,
                        plugValue: MDistance): 
        '''
        newPlugValueMDistance(self, plug: MPlug,
                        plugValue: MDistance)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that sets a
        plug to an MDistance value.

        Returns:
        -----
        None

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug to set 

        plugValue: MDistance
        	[in] -> the value to set


        '''
        pass

    def newPlugValueMTime(self, plug: MPlug,
                        plugValue: MTime): 
        '''
        newPlugValueMTime(self, plug: MPlug,
                        plugValue: MTime)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that sets a
        plug to an MTime value.

        Returns:
        -----
        None

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug to set 

        plugValue: MTime
        	[in] -> the value to set


        '''
        pass

    def newPlugValueShort(self, plug: MPlug,
                        plugValue: short): 
        '''
        newPlugValueShort(self, plug: MPlug,
                        plugValue: short)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that sets a
        plug to a short value.

        Returns:
        -----
        None

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug to set 

        plugValue: short
        	[in] -> the value to set


        '''
        pass

    def newPlugValueString(self, plug: MPlug,
                        plugValue: MString): 
        '''
        newPlugValueString(self, plug: MPlug,
                        plugValue: MString)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that sets a
        plug to a string value.

        Returns:
        -----
        None

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug to set 

        plugValue: MString
        	[in] -> the value to set


        '''
        pass

    def removeMultiInstance(self, plug: MPlug,
                        breakConnections: bool): 
        '''
        removeMultiInstance(self, plug: MPlug,
                        breakConnections: bool)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that removes
        an element of a multi (array) plug. If breakConnections is true,
        all connections to the attribute will be broken before the
        element is removed. If false, then the operation will fail if the
        element is connected.

        Returns:
        -----
        None

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug to remove 

        breakConnections: bool
        	[in] -> whether to break connections before removing the element


        '''
        pass

    def setMetadata(self, node: MObject,
                        metadata: adsk.Data): 
        '''
        setMetadata(self, node: MObject,
                        metadata: adsk.Data)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that replaces
        metadata on a specific node.

        Returns:
        -----
        None

        Parameters:
        -----
        node: MObject
        	[in] -> The node to receive the metadata 

        metadata: adsk.Data
        	[in] -> The metadata values it will receive


        '''
        pass

    def deleteMetadata(self, node: MObject): 
        '''
        deleteMetadata(self, node: MObject)

        Synopsis
        -----
        Adds an operation to this dependency graph modifier that deletes
        all metadata from a node.

        Returns:
        -----
        None

        Parameters:
        -----
        node: MObject
        	[in] -> the node from which the metadata is to be removed


        '''
        pass

    def doIt(self): 
        '''
        doIt(self)

        Synopsis
        -----
        Executes all of the operations that have been given to this
        modifier. It is only valid to call this method after all of the
        operations have been specified. This method may also be called
        after undoIt to redo the operations.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def undoIt(self): 
        '''
        undoIt(self)

        Synopsis
        -----
        Undoes all of the operations that have been given to this
        modifier. It is only valid to call this method after the doIt
        method has been called.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MEdit:
    '''Base class for representing information about edits.
MEdit serves as the base class for representing information about
edits that are made to certain types of entities, specifically
references and assemblies. An edit is any operation that modifies
a member of the entity. Examples of such modifications include
changing attribute values, connections, parenting and so on.
In the case of references, edits are the changes that occur to
referenced nodes.
In the case of assemblies, edits are the changes that occur to
assembly members.
Derived classes implement specific types of edits, allowing them
to be queried depending on the type of operation.
'''
    def __init__(self):
        pass


    def editType(self, ReturnStatus: MEdit.MStatus): 
        '''
        editType(self, ReturnStatus: MEdit.MStatus) -> MEdit.MEdit

        Synopsis
        -----
        Returns the enum related to the type of the current edit.
        Reimplemented in MConnectDisconnectAttrEdit, MAddRemoveAttrEdit,
        MParentingEdit, MSetAttrEdit, and MFcurveEdit.

        Returns: 
        ----- 
        The current reference or assembly edit type or kNullEdit if there
        is no current edit

        Parameters:
        -----
        ReturnStatus: MEdit.MStatus
        	[out] -> return status


        '''
        pass

    def getString(self, ReturnStatus: MEdit.MStatus): 
        '''
        getString(self, ReturnStatus: MEdit.MStatus) -> MString

        Synopsis
        -----
        Returns the ASCII string related to the current edit.

        Returns: 
        ----- 
        The ASCII string related to the current edit

        Parameters:
        -----
        ReturnStatus: MEdit.MStatus
        	[out] -> return status


        '''
        pass

    def isApplied(self, ReturnStatus: MEdit.MStatus): 
        '''
        isApplied(self, ReturnStatus: MEdit.MStatus) -> bool

        Synopsis
        -----
        Query if we attempted to apply the edit. For example, as far as
        assemblies are concerned, edits are unapplied if you switch to a
        representation that can't accept edits, like the cache rep. As
        for references, edits are unapplied if references are unloaded.It
        does not mean the edit was applied successfully. To query
        success/failure, please use MEdit::isFailed.

        Returns: 
        ----- 
        true We attempted to apply the edit.  false We did not attempt to
        apply the edit yet.

        Parameters:
        -----
        ReturnStatus: MEdit.MStatus
        	[out] -> return status


        '''
        pass

    def isFailed(self, ReturnStatus: MEdit.MStatus): 
        '''
        isFailed(self, ReturnStatus: MEdit.MStatus) -> bool

        Synopsis
        -----
        Query if the edit is applied successfully. One common cause of
        failed edit is it cannot find the node to apply the edit. They
        could be caused by the node name change or the node is not in the
        scene at the moment.

        Returns: 
        ----- 
        true The edit was applied successfully.  false The edit failed to
        be applied.

        Parameters:
        -----
        ReturnStatus: MEdit.MStatus
        	[out] -> return status


        '''
        pass

    def isTopLevel(self, ReturnStatus: MEdit.MStatus): 
        '''
        isTopLevel(self, ReturnStatus: MEdit.MStatus) -> bool

        Synopsis
        -----
        Query if the edit was made from the top-level. Edits that were
        made from the top-level can be removed. But edits that were made
        in nested references/assemblies cannot be removed since they are
        part of another file.

        Returns: 
        ----- 
        true The edit was made from the top-level.  false The edit was
        made in a nested reference/assembly.

        Parameters:
        -----
        ReturnStatus: MEdit.MStatus
        	[out] -> return status


        '''
        pass

    def hasEditData(self): 
        '''
        hasEditData(self) -> bool

        Synopsis
        -----
        Query if the edit has any user-defined editData associated with
        it. See also matches().

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def matches(self, editData: MPxEditData): 
        '''
        matches(self, editData: MPxEditData) -> bool

        Synopsis
        -----
        Query if the edit has user-defined editData associated with it
        that matches the given editData object. See also hasEditData().

        Returns: 
        ----- 
        true The edit has matching associated editData  false The edit
        does not have matching associated editData

        Parameters:
        -----
        editData: MPxEditData
        	[in] -> An editData object to compare with this object


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class EditType:
    '''Type of edit. 
    Non-functional class.  Values for this enum:
    kNullEdit
    kSetAttrEdit
    kConnectDisconnectEdit
    kAddRemoveAttrEdit
    kParentEdit
    kFcurveEdit
    '''

    def __init__(self):
        pass

    def kNullEdit(self):
        '''This is an enum of EditType.
        - Description: Null edit. 
        - Value: 0
        '''
        pass

    def kSetAttrEdit(self):
        '''This is an enum of EditType.
        - Description: Edit indicating a change in plug value. 
        - Value: 1
        '''
        pass

    def kConnectDisconnectEdit(self):
        '''This is an enum of EditType.
        - Description: Edit indicating a connection or disconnection. 
        - Value: 2
        '''
        pass

    def kAddRemoveAttrEdit(self):
        '''This is an enum of EditType.
        - Description: Edit indicating an attribute added or removed. 
        - Value: 3
        '''
        pass

    def kParentEdit(self):
        '''This is an enum of EditType.
        - Description: Edit indicating a parenting operation. 
        - Value: 4
        '''
        pass

    def kFcurveEdit(self):
        '''This is an enum of EditType.
        - Description: Edit indicating an fcurve modification. 
        - Value: 5
        '''
        pass

class MEulerRotation:
    '''Euler Rotation Math.
This class provides methods for working with euler angle
rotations. Euler angles are described by rotations in radians
around the x, y, and z axes, and the order in which those
rotations occur.
'''
    def __init__(self):
        pass


    @overload
    def setValue(self, v: MVector,
                        ord: MEulerRotation.MEulerRotation): 
        '''
        setValue(self, v: MVector,
                        ord: MEulerRotation.MEulerRotation) -> MEulerRotation

        Synopsis
        -----
        Sets the euler rotation to the values contained in the vector and
        with the specified rotation order.

        Returns: 
        ----- 
        A reference to the euler rotation whose value has been set

        Parameters:
        -----
        v: MVector
        	[in] -> vector from which to set the x, y, and z rotation components 

        ord: MEulerRotation.MEulerRotation
        	[in] -> the rotation order; the default rotation order is XYZ


        '''
        pass

    @overload
    def setValue(self, xx: double,
                        yy: double,
                        zz: double,
                        ord: MEulerRotation.MEulerRotation): 
        '''
        setValue(self, xx: double,
                        yy: double,
                        zz: double,
                        ord: MEulerRotation.MEulerRotation) -> MEulerRotation

        Synopsis
        -----
        Sets the euler rotation to the x, y, and z rotation components
        with the specified rotation order.

        Returns: 
        ----- 
        A reference to the euler rotation whose value has been set

        Parameters:
        -----
        xx: double
        	[in] -> the x component of the rotation 

        yy: double
        	[in] -> the y component of the rotation 

        zz: double
        	[in] -> the z component of the rotation 

        ord: MEulerRotation.MEulerRotation
        	[in] -> the rotation order; the default rotation order is XYZ


        '''
        pass

    def asQuaternion(self): 
        '''
        asQuaternion(self) -> MQuaternion

        Synopsis
        -----
        Converts an euler rotation to a quaternion.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asMatrix(self): 
        '''
        asMatrix(self) -> MMatrix

        Synopsis
        -----
        Converts an euler rotation to a rotation matrix.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asVector(self): 
        '''
        asVector(self) -> MVector

        Synopsis
        -----
        Converts an euler rotation to a vector. The rotation order
        component is dropped.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def __getitem__(self, i: int): 
        '''
        __getitem__(self, i: int) -> double

        Synopsis
        -----
        The index operator. If its argument is 0 it will return the x
        component of the euler rotation. If its argument is 1 it will
        return the y component of the euler rotation. If its argument is
        2 it will return the z component of the euler rotation.

        Returns: 
        ----- 
        The component of the euler rotation corresponding to the index

        Parameters:
        -----
        i: int
        	[in] -> value indicating which component to return


        '''
        pass

    def __add__(self, other: MEulerRotation): 
        '''
        __add__(self, other: MEulerRotation) -> MEulerRotation

        Synopsis
        -----
        The euler rotation addition operator.

        Returns: 
        ----- 
        The sum of the two euler rotations

        Parameters:
        -----
        other: MEulerRotation
        	[in] -> the euler rotation to be added to this euler rotation


        '''
        pass

    def __radd__(self, other: MEulerRotation): 
        '''
        __radd__(self, other: MEulerRotation) -> MEulerRotation

        Synopsis
        -----
        The in place euler rotation addition operator.

        Returns: 
        ----- 
        A reference the euler rotation which has been added to the other
        euler rotation

        Parameters:
        -----
        other: MEulerRotation
        	[in] -> the euler rotation to be added with this euler rotation


        '''
        pass

    @overload
    def __sub__(self, other: MEulerRotation): 
        '''
        __sub__(self, other: MEulerRotation) -> MEulerRotation

        Synopsis
        -----
        The euler rotation subtraction operator.

        Returns: 
        ----- 
        The euler rotation that results from the subtraction

        Parameters:
        -----
        other: MEulerRotation
        	[in] -> the euler rotation to be subtracted from this euler rotation


        '''
        pass

    def __rsub__(self, other: MEulerRotation): 
        '''
        __rsub__(self, other: MEulerRotation) -> MEulerRotation

        Synopsis
        -----
        The in place euler rotation subtraction operator.

        Returns: 
        ----- 
        A reference the euler rotation which has had the other euler
        rotation subtracted from it

        Parameters:
        -----
        other: MEulerRotation
        	[in] -> the euler rotation to be subtracted from this euler rotation


        '''
        pass

    @overload
    def __sub__(self): 
        '''
        __sub__(self) -> MEulerRotation

        Synopsis
        -----
        The unary minus operator. Negates the value of each of the x, y,
        and z components of the euler rotation. The order remains the
        same.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def __eq__(self, other: MEulerRotation): 
        '''
        __eq__(self, other: MEulerRotation) -> bool

        Synopsis
        -----
        The euler rotation equality operator.

        Returns: 
        ----- 
        true the euler rotations are identical  false the euler rotations
        are not identical

        Parameters:
        -----
        other: MEulerRotation
        	[in] -> the euler rotation to be compared with this euler rotation


        '''
        pass

    def __neq__(self, other: MEulerRotation): 
        '''
        __neq__(self, other: MEulerRotation) -> bool

        Synopsis
        -----
        The euler rotation inequality operator.

        Returns: 
        ----- 
        true the euler rotations are not identical  false the euler
        rotations are identical

        Parameters:
        -----
        other: MEulerRotation
        	[in] -> the euler rotation to be compared with this euler rotation


        '''
        pass

    def isEquivalent(self, other: MEulerRotation,
                        tolerance: double): 
        '''
        isEquivalent(self, other: MEulerRotation,
                        tolerance: double) -> bool

        Synopsis
        -----
        This method returns true if this euler rotation is equivalent,
        within some given tolerance, to the other euler rotation.
        'tolerance' defaults to kEulerRotationEpsilon which is 1.0e-10

        Returns: 
        ----- 
        true the euler rotations are equivalent  false the euler
        rotations are not equivalent

        Parameters:
        -----
        other: MEulerRotation
        	[in] -> the euler rotation to be compared with this euler rotation 

        tolerance: double
        	[in] -> the amount of variation allowed for equivalency


        '''
        pass

    def isZero(self, tolerance: double): 
        '''
        isZero(self, tolerance: double) -> bool

        Synopsis
        -----
        This method returns true if this euler rotation is zero, within
        some given tolerance. 'tolerance' defaults to
        kEulerRotationEpsilon which is 1.0e-10

        Returns: 
        ----- 
        true the rotation is zero  false the rotation is not zero

        Parameters:
        -----
        tolerance: double
        	[in] -> the amount of variation allowed for equivalency to zero


        '''
        pass

    def incrementalRotateBy(self, axis: MVector,
                        angle: double): 
        '''
        incrementalRotateBy(self, axis: MVector,
                        angle: double) -> MEulerRotation

        Synopsis
        -----
        Perform an incremental rotation by the specified axis and angle.
        The rotation is broken down and performed in smaller steps so
        that the angles update properly.

        Returns: 
        ----- 
        A reference to the euler rotation that has been incrementally
        rotated

        Parameters:
        -----
        axis: MVector
        	[in] -> the axis to rotate around 

        angle: double
        	[in] -> the angle by which to rotate around the axis


        '''
        pass

    def inverse(self): 
        '''
        inverse(self) -> MEulerRotation

        Synopsis
        -----
        Returns the inverse of this euler rotation. The rotation order
        will be reversed.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def invertIt(self): 
        '''
        invertIt(self) -> MEulerRotation

        Synopsis
        -----
        Performs an in place inversion of this euler rotation. The
        rotation order will be reversed.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def reorder(self, ord: MEulerRotation.MEulerRotation): 
        '''
        reorder(self, ord: MEulerRotation.MEulerRotation) -> MEulerRotation

        Synopsis
        -----
        Returns the reordering of this euler rotation, such that the
        euler rotation will have the specified rotation order.

        Returns: 
        ----- 
        Euler rotation that is the reordering of this euler rotation

        Parameters:
        -----
        ord: MEulerRotation.MEulerRotation
        	[in] -> the new rotation order of the euler rotation


        '''
        pass

    def reorderIt(self, ord: MEulerRotation.MEulerRotation): 
        '''
        reorderIt(self, ord: MEulerRotation.MEulerRotation) -> MEulerRotation

        Synopsis
        -----
        Performs an in place reordering of this euler rotation, such that
        the euler rotation will have the specified rotation order.

        Returns: 
        ----- 
        A reference to the euler rotation that has been reordered

        Parameters:
        -----
        ord: MEulerRotation.MEulerRotation
        	[in] -> the new rotation order of the euler rotation


        '''
        pass

    def bound(self): 
        '''
        bound(self) -> MEulerRotation

        Synopsis
        -----
        Returns the result of bounding this rotation to be within +/- PI.
        Bounding a rotation to be within +/- PI is defined to be the
        result of offsetting the rotation by +/- 2nPI (term by term) such
        that the offset is within +/- PI.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def boundIt(self, src: MEulerRotation): 
        '''
        boundIt(self, src: MEulerRotation) -> MEulerRotation

        Synopsis
        -----
        Sets this euler rotation to be the input rotation that has been
        bound to be within +/- PI. Bounding a rotation to be within +/-
        PI is defined to be the result of offsetting the rotation by +/-
        2nPI (term by term) such that the offset is within +/- PI.

        Returns: 
        ----- 
        A reference to the euler rotation that has been set to the bound
        input rotation

        Parameters:
        -----
        src: MEulerRotation
        	[in] -> the input rotation that will be bound


        '''
        pass

    @overload
    def boundIt(self): 
        '''
        boundIt(self) -> MEulerRotation

        Synopsis
        -----
        Bounds this rotation to be within +/- PI. Bounding a rotation to
        be within +/- PI is defined to be the result of offsetting the
        rotation by +/- 2nPI (term by term) such that the offset is
        within +/- PI.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def alternateSolution(self): 
        '''
        alternateSolution(self) -> MEulerRotation

        Synopsis
        -----
        Returns an alternate solution to this rotation. The resulting
        rotation will be bound between +/- PI, and the rotation order
        will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def setToAlternateSolution(self, src: MEulerRotation): 
        '''
        setToAlternateSolution(self, src: MEulerRotation) -> MEulerRotation

        Synopsis
        -----
        Sets this euler rotation to an alternate solution of the input
        rotation. The resulting rotation will be bound between +/- PI,
        and the rotation order will remain unchanged.

        Returns: 
        ----- 
        A reference to the euler rotation that has been set to an
        alternate solution

        Parameters:
        -----
        src: MEulerRotation
        	[in] -> the rotation to compute an alternate solution to


        '''
        pass

    @overload
    def setToAlternateSolution(self): 
        '''
        setToAlternateSolution(self) -> MEulerRotation

        Synopsis
        -----
        Sets this euler rotation to an alternate solution of this
        rotation. The resulting rotation will be bound between +/- PI,
        and the rotation order will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def closestSolution(self, dst: MEulerRotation): 
        '''
        closestSolution(self, dst: MEulerRotation) -> MEulerRotation

        Synopsis
        -----
        Returns the euler rotation that is the closest solution to the
        "dst" euler rotation.

        Returns: 
        ----- 
        The closest solution to the "dst" rotation

        Parameters:
        -----
        dst: MEulerRotation
        	[in] -> the euler rotation to which the solution should be closest


        '''
        pass

    @overload
    def setToClosestSolution(self, src: MEulerRotation,
                        dst: MEulerRotation): 
        '''
        setToClosestSolution(self, src: MEulerRotation,
                        dst: MEulerRotation) -> MEulerRotation

        Synopsis
        -----
        Sets this euler rotation to the euler rotation that is the
        closest solution of the "src" euler rotation to the "dst" euler
        rotation.

        Returns: 
        ----- 
        A reference to the euler rotation that has been set to the
        closest solution

        Parameters:
        -----
        src: MEulerRotation
        	[in] -> the euler rotation whose closest solution will be calculated 

        dst: MEulerRotation
        	[in] -> the euler rotation to which the solution should be closest


        '''
        pass

    @overload
    def setToClosestSolution(self, dst: MEulerRotation): 
        '''
        setToClosestSolution(self, dst: MEulerRotation) -> MEulerRotation

        Synopsis
        -----
        Sets this euler rotation to the euler rotation that is the
        closest solution to the "dst" euler rotation.

        Returns: 
        ----- 
        A reference to the euler rotation that has been set to the
        closest solution

        Parameters:
        -----
        dst: MEulerRotation
        	[in] -> the euler rotation to which the solution should be closest


        '''
        pass

    def closestCut(self, dst: MEulerRotation): 
        '''
        closestCut(self, dst: MEulerRotation) -> MEulerRotation

        Synopsis
        -----
        Returns the closest cut of this rotation to "dst". The closest
        cut of rotation A to rotation B is defined to be the rotation
        that is +/- 2nPI to rotation A (term by term) and within +/- PI
        to rotation B.

        Returns: 
        ----- 
        The closest cut of this rotation

        Parameters:
        -----
        dst: MEulerRotation
        	[in] -> the range of the closest cut


        '''
        pass

    @overload
    def setToClosestCut(self, src: MEulerRotation,
                        dst: MEulerRotation): 
        '''
        setToClosestCut(self, src: MEulerRotation,
                        dst: MEulerRotation) -> MEulerRotation

        Synopsis
        -----
        Sets this rotation to be the closest cut of "src" to "dst". The
        closest cut of rotation A to rotation B is defined to be the
        rotation that is +/- 2nPI to rotation A (term by term) and within
        +/- PI to rotation B.

        Returns: 
        ----- 
        A reference to the euler rotation that has been set to the
        closest cut

        Parameters:
        -----
        src: MEulerRotation
        	[in] -> the euler rotation whose terms will be offset by +/- 2nPI 

        dst: MEulerRotation
        	[in] -> the range of the closest cut


        '''
        pass

    @overload
    def setToClosestCut(self, dst: MEulerRotation): 
        '''
        setToClosestCut(self, dst: MEulerRotation) -> MEulerRotation

        Synopsis
        -----
        Sets this rotation to be the closest cut to "dst". The closest
        cut of rotation A to rotation B is defined to be the rotation
        that is +/- 2nPI to rotation A (term by term) and within +/- PI
        to rotation B.

        Returns: 
        ----- 
        A reference to the euler rotation that has been set to the
        closest cut

        Parameters:
        -----
        dst: MEulerRotation
        	[in] -> the range of the closest cut


        '''
        pass

    def decompose(self, matrix: MMatrix,
                        ord: MEulerRotation.MEulerRotation): 
        '''
        decompose(self, matrix: MMatrix,
                        ord: MEulerRotation.MEulerRotation) -> MEulerRotation

        Synopsis
        -----
        Decompose a rotation matrix into the desired euler angles with
        the specified order.

        Returns: 
        ----- 
        The euler rotation that has been decomposed from the rotation
        matrix

        Parameters:
        -----
        matrix: MMatrix
        	[in] -> the matrix that will be decomposed into an euler rotation with the specified order 

        ord: MEulerRotation.MEulerRotation
        	[in] -> the order which the euler rotation will have


        '''
        pass

class RotationOrder:
    '''Valid rotaton orders. 
    Non-functional class.  Values for this enum:
    kXYZ
    kYZX
    kZXY
    kXZY
    kYXZ
    kZYX
    '''

    def __init__(self):
        pass

    def kXYZ(self):
        '''This is an enum of RotationOrder.
        - Description:  
        - Value: 0
        '''
        pass

    def kYZX(self):
        '''This is an enum of RotationOrder.
        - Description:  
        - Value: 1
        '''
        pass

    def kZXY(self):
        '''This is an enum of RotationOrder.
        - Description:  
        - Value: 2
        '''
        pass

    def kXZY(self):
        '''This is an enum of RotationOrder.
        - Description:  
        - Value: 3
        '''
        pass

    def kYXZ(self):
        '''This is an enum of RotationOrder.
        - Description:  
        - Value: 4
        '''
        pass

    def kZYX(self):
        '''This is an enum of RotationOrder.
        - Description:  
        - Value: 5
        '''
        pass

class MEvaluationManager:
    '''Class for working with Maya's Evaluation Manager.
The Evaluation Manager is used to evaluate the scene without
dirty propagation. Its evaluation graph capabilities decouples
the data model and evaluation.
The Evaluation Manager can execute graph evaluation in serial or
parallel. Parallel execution uses a scheduling graph to provide
parallelized computation of depend nodes.
Unless specified, the methods in this class are threadsafe and
can be performed safely from worker threads.
'''
    def __init__(self):
        pass


    def graphConstructionActive(self): 
        '''
        graphConstructionActive(self) -> MEvaluationManager.OPENMAYA_MAJOR_NAMESPACE_OPENbool

        Synopsis
        -----
        Determine if the evaluation graph is currently being constructed.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def evaluationManagerActive(self, context: MDGContext): 
        '''
        evaluationManagerActive(self, context: MDGContext) -> bool

        Synopsis
        -----
        Determine if the evaluation manager is active on given context.

        Returns: 
        ----- 
        True if the evaluation manager is active on the given context,
        otherwise false.

        Parameters:
        -----
        context: MDGContext
        	[in] -> Evaluation context for status test.


        '''
        pass

    def evaluationInExecution(self, context: MDGContext): 
        '''
        evaluationInExecution(self, context: MDGContext) -> bool

        Synopsis
        -----
        Determine if the evaluation manager is currently evaluating given
        context.

        Returns: 
        ----- 
        True if the evaluation manager is evaluating given context,
        otherwise false.

        Parameters:
        -----
        context: MDGContext
        	[in] -> Evaluation context for status test.


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MEvaluationNode:
    '''Provides access to Evaluation Manager node information.
An evaluation node and the connections between them form an
evaluation graph. Each evaluation context uses a unique
evaluation graph with its own set of evaluation nodes. Evaluation
graphs are scheduled to speed up the operations within Maya.
This class contains methods for querying which attributes or
plugs on a node will be set dirty prior to evaluation by the
evaluation manager.
It is sometimes necessary to know the dirty state of
plugs/attributes if your node is handling custom information.
This handling would be done in the
MPxNode preEvaluation()/postEvaluation() methods.
If you need to access the list of dirty plugs in the evaluation
node then use the internal iterator:
for(
MEvaluationNodeIterator nodeIt = theNode.iterator(); ! nodeIt.isDone(); nodeIt.next() )
{ doSomePlugThing( nodeIt.plug() ); }
'''
    def __init__(self):
        pass


    def parentCount(self): 
        '''
        parentCount(self) -> int

        Synopsis
        -----
        Returns the number of parent nodes this evaluation node has.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def parent(self, index: int): 
        '''
        parent(self, index: int) -> MEvaluationNode

        Synopsis
        -----
        Returns the parent node of this evaluation node at given index.

        Returns: 
        ----- 
        The MEvaluationNode parent object at given index.

        Parameters:
        -----
        index: int
        	[in] -> Index of the parent evaluation node to access. No bound check is done so respect parentCount.


        '''
        pass

    def childCount(self): 
        '''
        childCount(self) -> int

        Synopsis
        -----
        Returns the number of children nodes this evaluation node has.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def child(self, index: int): 
        '''
        child(self, index: int) -> MEvaluationNode

        Synopsis
        -----
        Returns the child node of this evaluation node at given index.

        Returns: 
        ----- 
        The MEvaluationNode child object at given index.

        Parameters:
        -----
        index: int
        	[in] -> Index of the child evaluation node to access. No bound check is done so respect childCount.


        '''
        pass

    def iterator(self, ReturnStatus: MEvaluationNode.MStatus): 
        '''
        iterator(self, ReturnStatus: MEvaluationNode.MStatus) -> MEvaluationNodeIterator

        Synopsis
        -----
        Returns an iterator at the beginning of the dirty plug list.

        Returns: 
        ----- 
        Iterator positioned at the beginning of the evaluation node's
        dirty plug list

        Parameters:
        -----
        ReturnStatus: MEvaluationNode.MStatus
        	[out] -> Status Code


        '''
        pass

    def dirtyPlugExists(self, attribute: MObject,
                        ReturnStatus: MEvaluationNode.MStatus): 
        '''
        dirtyPlugExists(self, attribute: MObject,
                        ReturnStatus: MEvaluationNode.MStatus) -> bool

        Synopsis
        -----
        Returns true if the specified attribute has a dirty plug. This
        call should be made from MPxNode::preEvaluation() and
        MPxNode::postEvaluation() to verify which plugs are going to be
        dirty and computed.

        Returns: 
        ----- 
        True if the attribute exists in the dirty plug list, otherwise
        false.

        Parameters:
        -----
        attribute: MObject
        	[in] -> Attribute whose root plug is to be checked for membership in the dirty plug list 

        ReturnStatus: MEvaluationNode.MStatus
        	[out] -> Status Code


        '''
        pass

    def dirtyPlug(self, attribute: MObject,
                        ReturnStatus: MEvaluationNode.MStatus): 
        '''
        dirtyPlug(self, attribute: MObject,
                        ReturnStatus: MEvaluationNode.MStatus) -> MPlug

        Synopsis
        -----
        Returns the top-most plug for the specified attribute if the
        attribute has dirty plugs. This call should be made from
        MPxNode::preEvaluation() and MPxNode::postEvaluation() to access
        a networked plug which is going to be dirty and computed.

        Returns: 
        ----- 
        The top-most dirty plug for the specified attribute if it exists,
        a null plug otherwise.

        Parameters:
        -----
        attribute: MObject
        	[in] -> Attribute whose root plug is returned if it is in the dirty plug list 

        ReturnStatus: MEvaluationNode.MStatus
        	[out] -> Status Code


        '''
        pass

    def dependencyNode(self, ReturnStatus: MEvaluationNode.MStatus): 
        '''
        dependencyNode(self, ReturnStatus: MEvaluationNode.MStatus) -> MObject

        Synopsis
        -----
        Returns the dependency node this evaluation node represents.

        Returns: 
        ----- 
        The MObject representing the dependency node for this evaluation
        node.

        Parameters:
        -----
        ReturnStatus: MEvaluationNode.MStatus
        	[out] -> Status Code


        '''
        pass

    def datablock(self, ReturnStatus: MEvaluationNode.MStatus): 
        '''
        datablock(self, ReturnStatus: MEvaluationNode.MStatus) -> MDataBlock

        Synopsis
        -----
        Returns the datablock for this node.

        Returns: 
        ----- 
        The MDatablock representing the datablock for this evaluation
        node.

        Parameters:
        -----
        ReturnStatus: MEvaluationNode.MStatus
        	[out] -> Status Code


        '''
        pass

    def connect(self, child: MEvaluationNode,
                        ReturnStatus: MEvaluationNode.MStatus): 
        '''
        connect(self, child: MEvaluationNode,
                        ReturnStatus: MEvaluationNode.MStatus)

        Synopsis
        -----
        Introduced in 2019.0 Connect two generic evaluation nodes.Generic
        evaluation nodes are explicitly created by topology evaluators to
        override topology of base layer evaluation nodes claimed by
        topology cluster nodes.

        Returns:
        -----
        None

        Parameters:
        -----
        child: MEvaluationNode
        	[in] -> Generic evaluation node to connect as a child 

        ReturnStatus: MEvaluationNode.MStatus
        	[out] -> Status Code


        '''
        pass

    def skipEvaluation(self, attribute: MObject,
                        allowSingleDownstreamDependency: bool,
                        ReturnStatus: MEvaluationNode.MStatus): 
        '''
        skipEvaluation(self, attribute: MObject,
                        allowSingleDownstreamDependency: bool,
                        ReturnStatus: MEvaluationNode.MStatus)

        Synopsis
        -----
        Introduced in 2022.0 Hint the Evaluation Manager that the
        attribute can be skipped for the current evaluation.This method
        tries to mark the attribute for the Evaluation Manager to skip
        its evaluation.Attributes can be marked for their evaluation to
        be skipped if it's safe to do so. If the attribute is skipped, it
        will not be evaluated but will be left dirty so that subsequent
        pull evaluation will trigger evaluation and report the right
        value.If the attribute is animated and driving more than one
        connected node, it is never safe to skip its evaluation, because
        the downstream nodes could trigger concurrent, and unsafe, pull
        evaluation. Therefore, this method does not have an effect if the
        attribute has more than one downstream dependency.If the
        attribute has a single downstream dependency, it is potentially
        safe. Only a single node can pull on this attribute, but other
        nodes might be pulling on other attributes on the same node,
        which could result in a race condition. If the attribute is the
        only one skipped, the skipEvaluation method can allow a single
        connection through the allowSingleDownstreamDependency
        parameter.If this attribute is not set, the skipEvaluation method
        will have the safest possible behavior of only skipping the
        evaluation if there are no downstream dependencies for the
        attribute to skip.

        Returns:
        -----
        None

        Parameters:
        -----
        attribute: MObject
        	[in] -> Attribute whose root plug is to be marked for skipping 

        allowSingleDownstreamDependency: bool
        	[in] -> True to allow one downstream dependency, false for the safest behavior of allowing none. 

        ReturnStatus: MEvaluationNode.MStatus
        	[out] -> Status Code


        '''
        pass

    def skippingEvaluation(self, attribute: MObject,
                        ReturnStatus: MEvaluationNode.MStatus): 
        '''
        skippingEvaluation(self, attribute: MObject,
                        ReturnStatus: MEvaluationNode.MStatus) -> bool

        Synopsis
        -----
        Introduced in 2022.0 Returns true if the attribute was marked to
        be skipped.

        Returns:
        -----
        None

        Parameters:
        -----
        attribute: MObject
        	[in] -> Attribute whose root plug is to be checked for skipping 

        ReturnStatus: MEvaluationNode.MStatus
        	[out] -> Status Code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MEvaluationNodeIterator:
    '''Provides access to the Evaluation Manager node dirty plug list.
If you need to access the list of dirty plugs in an
MEvaluationNode node then use the internal iterator:
'''
    def __init__(self):
        pass


    def plug(self): 
        '''
        plug(self) -> MPlug

        Synopsis
        -----
        Returns the dirty plug at the current iterator position. Returns
        an empty plug if the iterator is illegal.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isDone(self): 
        '''
        isDone(self) -> bool

        Synopsis
        -----
        Checks to see if the iterator has reached the end of the
        iteration.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MEventMessage:
    '''Event messages.
This class is used to register callbacks for specific events.
The first parameter passed to the add callback method is the name
of the event that will trigger the callback. The list of
available event names can be retrieved by calling the
getEventNames method or by using the -listEvents flag on the
 command.
The add callback method returns an id which is used to remove the
callback.
To remove a callback use
MMessage::removeCallback.
All callbacks that are registered by a plug-in must be removed by
that plug-in when it is unloaded. Failure to do so will result in
a fatal error.
Idle event callbacks should be removed immediately after running.
Otherwise they will continue to use up CPU resources. They will
also prevent idleVeryLow event callbacks from running - which are
required for Maya to function properly.
'''
    def __init__(self):
        pass


    def addEventCallback(self, eventName: MString,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MEventMessage.MStatus): 
        '''
        addEventCallback(self, eventName: MString,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MEventMessage.MStatus) -> MEventMessage.OPENMAYA_MAJOR_NAMESPACE_OPENMCallbackId

        Synopsis
        -----
        This method registers a callback for event occurred messages. The
        callback function will be passed the any client data that was
        provided when the callback was registered.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        eventName: MString
        	[in] -> the event to register the callback for 

        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data that will be passed to the callback function 

        ReturnStatus: MEventMessage.MStatus
        	[out] -> status code


        '''
        pass

    def getEventNames(self, names: MStringArray): 
        '''
        getEventNames(self, names: MStringArray)

        Synopsis
        -----
        This method returns the list of available event names.

        Returns:
        -----
        None

        Parameters:
        -----
        names: MStringArray
        	[out] -> set to the array of available event names.


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MExternalContentInfoTable:
    '''This is a table of all the external content for a given
MPxNode.
External content is defined as any data that is not stored with
the node and that is needed by the node to perform its work. It
can be texture files, other scenes, audio files, etc.
Each node that references external content should report it
through
MPxNode::getExternalContent so that a complete list of external content can be saved with
the scene in a way that makes it easy to inspect and edit
offline.
'''
    def __init__(self):
        pass


    def addResolvedEntry(self, key: MString,
                        unresolvedLocation: MString,
                        resolvedLocation: MString,
                        contextNodeFullName: MString,
                        roles: MStringArray): 
        '''
        addResolvedEntry(self, key: MString,
                        unresolvedLocation: MString,
                        resolvedLocation: MString,
                        contextNodeFullName: MString,
                        roles: MStringArray)

        Synopsis
        -----
        Add an entry in the table.

        Returns:
        -----
        None

        Parameters:
        -----
        key: MString
        	[in] -> An arbitrary string defined by the caller. This will typically be an attribute name for situations where the content location is stored verbatim in a plug's value.

        unresolvedLocation: MString
        	[in] -> Path as stored in the node (i.e. without any token replacement performed).

        resolvedLocation: MString
        	[in] -> Full path to the content if it exists at the time of creation of this object.

        contextNodeFullName: MString
        	[in] -> The fullname of the URI owner (node) if it applies, an empty string otherwise.

        roles: MStringArray
        	[in] -> An enumeration of all roles this content plays in the context of the node. The actual strings are not rigidly defined as of this writing. This is mostly for offline browsing of the content info: to assist in sorting content by role. A better content type system may be introduced later on to formalize this.


        '''
        pass

    def addUnresolvedEntry(self, key: MString,
                        unresolvedLocation: MString,
                        contextNodeFullName: MString,
                        roles: MStringArray): 
        '''
        addUnresolvedEntry(self, key: MString,
                        unresolvedLocation: MString,
                        contextNodeFullName: MString,
                        roles: MStringArray)

        Synopsis
        -----
        Add an entry in the table. The resolved location will be inferred
        from the application's built-in file resolving for the specified
        file type. This will automatically add entries into the roles
        vector that correspond to the search rules for this file type.

        Returns:
        -----
        None

        Parameters:
        -----
        key: MString
        	[in] -> See documentation for 

        unresolvedLocation: MString
        	[in] -> See documentation for 

        contextNodeFullName: MString
        	[in] -> See documentation for 

        roles: MStringArray
        	[in] -> See documentation for 


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Retrieves the number of entries in the table.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MExternalContentLocationTable:
    '''This is a table of the all the external content locations for a
given
MPxNode.
It is a subset of the information contained in
MExternalContentInfo: it has as many entries, but each entry only
states the key and location.
While
MExternalContentInfoTable is meant to query external content from a
MPxNode,
MExternalContentLocationTable is meant to pass modified locations back to the
MPxNode.
Key: Same as for
MExternalContentInfoTable.
Value: New location of the content for this entry (path, URI,
...).
'''
    def __init__(self):
        pass


    def addEntry(self, key: MString,
                        location: MString): 
        '''
        addEntry(self, key: MString,
                        location: MString)

        Synopsis
        -----
        Adds an external content location and its key to the table.

        Returns:
        -----
        None

        Parameters:
        -----
        key: MString
        	[in] -> An arbitrary string defined by the node. This will typically be an attribute name for situations where the content location is stored verbatim in a plug's value. 

        location: MString
        	[in] -> Full path to the content referenced by the key.


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Retrieves the number of entries in the table.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MFcurveEdit:
    '''Class for describing fcurve edits.
This class is used to return information about fcurve edits. Such
edits occur when a file is referenced and changes are made to
fcurves within the file reference. When a reference is unloaded,
not all the queries on this method will work. In particular, the
fcurve node itself cannot be returned since it no longer exists
in Maya.
The
MItEdits class may be used to iterate over all the edits on a given
reference or assembly.
'''
    def __init__(self):
        pass


    def fcurve(self, ReturnStatus: MFcurveEdit.MStatus): 
        '''
        fcurve(self, ReturnStatus: MFcurveEdit.MStatus) -> MFcurveEdit.OPENMAYA_MAJOR_NAMESPACE_OPEN MObject

        Synopsis
        -----
        Returns the fcurve node that was modified for this edit. The node
        can only be returned when the related reference is loaded. When
        the reference or assembly is unloaded, only the fcurve name
        string can be queried.

        Returns: 
        ----- 
        The fcurve that was modified for this edit

        Parameters:
        -----
        ReturnStatus: MFcurveEdit.MStatus
        	[out] -> Status Code


        '''
        pass

    def fcurveName(self, ReturnStatus: MFcurveEdit.MStatus): 
        '''
        fcurveName(self, ReturnStatus: MFcurveEdit.MStatus) -> MString

        Synopsis
        -----
        Returns the name of the fcurve that was modified in this edit.

        Returns: 
        ----- 
        The name of the fcurve node that was modified in this edit

        Parameters:
        -----
        ReturnStatus: MFcurveEdit.MStatus
        	[out] -> Status Code


        '''
        pass

    def editType(self, ReturnStatus: MFcurveEdit.MStatus): 
        '''
        editType(self, ReturnStatus: MFcurveEdit.MStatus) -> MEdit.MEdit

        Synopsis
        -----
        Virtual method used to return the edit type of this edit, which
        is MEdit::kFcurveEdit. Reimplemented from MEdit.

        Returns: 
        ----- 
        MEdit::kFcurveEdit

        Parameters:
        -----
        ReturnStatus: MFcurveEdit.MStatus
        	[out] -> return status


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MFileIO:
    '''I/O operations on scene files.
Methods for opening, saving, importing, exporting and referencing
files.
The
MFileIO class provides a set of global functions that can be used to
load and store scene elements into maya files. Methods are also
provided to import elements from other files into the current
scene, and export elements of the current scene into files. As
well, references to other files can be created and removed.
This class implements only the most common operations from the
full set possible with the MEL command "file." See the
documentation of this command for a complete listing of all the
possiblities. If more control is required than provided by this
class, a MEL command can be constructed according to the
instructions for the "file" command, and issued via the
executeCommand method of the
MGlobal class.
Note: Be cautious about using
MFileIO::importFile, MFileIO::Save, MFIleIO::saveAs
MFileIO::open,
MFileIO::newFile and
MFileIO::reference methods while any of
MFileIO::isReadingFile,
MFileIO::isWritingFile,
MFileIO::isOpeningFile,
MFileIO::isNewingFile,
MFileIO::isSavingReference,
MFileIO::isImportingFile or
MFileIO::isReferencingFile are returning true as it might lead to inconsitent scenes or
unpredictable results.
'''
    def __init__(self):
        pass


    def currentFile(self): 
        '''
        currentFile(self) -> MString

        Synopsis
        -----
        Return the name of the currently active scene.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setCurrentFile(self, fileName: MString): 
        '''
        setCurrentFile(self, fileName: MString)

        Synopsis
        -----
        Set the name of the current active scene.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> the name of the new active scene.


        '''
        pass

    def fileType(self): 
        '''
        fileType(self) -> MString

        Synopsis
        -----
        Return the type of the current active scene.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getFileTypes(self, types: MStringArray): 
        '''
        getFileTypes(self, types: MStringArray)

        Synopsis
        -----
        Returns an array of all the valid type names that Maya currently
        supports. Only elements from this list are valid arguments for
        the type arguments to open, saveAs, import, exportSelected, and
        exportAll.It should be noted that the results of this function
        will change as file translators that are implemented as plugins
        are loaded or unloaded.The file types mayaAscii and mayaBinary
        will always be available.

        Returns:
        -----
        None

        Parameters:
        -----
        types: MStringArray
        	[out] -> a reference to an 


        '''
        pass

    def newFile(self, force: bool): 
        '''
        newFile(self, force: bool)

        Synopsis
        -----
        Set everything back to a new file state. Do not call this method
        while MFileIO::isNewingFile is returning true

        Returns:
        -----
        None

        Parameters:
        -----
        force: bool
        	[in] -> succeed even if there are unsaved changes


        '''
        pass

    def open(self, fileName: MString,
                        type: char,
                        force: bool,
                        refMode: MFileIO.ReferenceMode,
                        ignoreVersion: bool): 
        '''
        open(self, fileName: MString,
                        type: char,
                        force: bool,
                        refMode: MFileIO.ReferenceMode,
                        ignoreVersion: bool)

        Synopsis
        -----
        Open the given file, and set the current active scene to this
        file. If there are unsaved changes in the current scene, this
        operation will fail unless the force flag is set to true.Do not
        call this method while MFileIO::isReadingFile or
        MFileIO::isOpeningFile is returning true.  Calling this method
        while MFileIO::isReferencingFile is returning true may lead to
        unpredictable results

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> name of the file to open 

        type: char
        	[in] -> if NULL, Maya will try to deduce the type of the file. if not NULL, it contains a file type to use when opening the file. 

        force: bool
        	[in] -> succeed even if there are unsaved changes 

        refMode: MFileIO.ReferenceMode
        	[in] -> specify whether to load all references, no references, or the references that were loaded when the scene was saved. 

        ignoreVersion: bool
        	[in] -> if true, then Maya will ignore the version number when opening the file


        '''
        pass

    def save(self, force: bool): 
        '''
        save(self, force: bool)

        Synopsis
        -----
        Save the contents of the current scene. If there have been no
        changes to the scene since the last save, then this operation
        will succeed, but not actually rewrite the save file unless the
        force flag is set to true.Calling this method while any of:
        MFileIO::isWritingFile, MFileIO::isNewingFile,
        MFileIO::isImportingFile or MFileIO::isReferencingFile are
        returning true may lead to unpredictable results

        Returns:
        -----
        None

        Parameters:
        -----
        force: bool
        	[in] -> succeed even if there have been no changes


        '''
        pass

    def saveAs(self, fileName: MString,
                        type: char,
                        force: bool): 
        '''
        saveAs(self, fileName: MString,
                        type: char,
                        force: bool)

        Synopsis
        -----
        Save the contents of the current scene to the given file. If
        there have been no changes to the scene since the last save, then
        this operation will succeed, but not actually rewrite the save
        file unless the force flag is set to true.Calling this method
        while any of: MFileIO::isWritingFile, MFileIO::isNewingFile,
        MFileIO::isImportingFile or MFileIO::isReferencingFile are
        returning true may lead to unpredictable results

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> name of the file to write to 

        type: char
        	[in] -> if NULL, Maya will write the file in mayaAscii format. if not NULL, it contains a file type to use when writing the file. 

        force: bool
        	[in] -> succeed even if there have been no changes since the last save operation


        '''
        pass

    def importFile(self, fileName: MString,
                        type: char,
                        preserveReferences: bool,
                        nameSpace: char,
                        ignoreVersion: bool): 
        '''
        importFile(self, fileName: MString,
                        type: char,
                        preserveReferences: bool,
                        nameSpace: char,
                        ignoreVersion: bool)

        Synopsis
        -----
        Import the scene elements from the given file into the current
        scene. This operation is similar to open, but instead of
        replacing the current scene with the one from the new file, it
        adds the elements from that file to the existing ones in the
        current scene.Calling this method while
        MFileIO::isReferencingFile may lead to unpredictable results if
        the imported file contains references

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> name of the file from which to import objects 

        type: char
        	[in] -> if NULL, Maya will try to deduce the type of the file. If not NULL, it must contain a file type to use when importing the file. 

        preserveReferences: bool
        	[in] -> Boolean to indicate whether the references need to be preserved. 

        nameSpace: char
        	[in] -> optional name of the namespace to use when importing objects. Use NULL for default of no namespace. 

        ignoreVersion: bool
        	[in] -> Boolean to control whether to ignore version when importing a file. 


        '''
        pass

    def exportSelected(self, fileName: MString,
                        type: char,
                        preserveReferences: bool): 
        '''
        exportSelected(self, fileName: MString,
                        type: char,
                        preserveReferences: bool)

        Synopsis
        -----
        Export all currently selected scene elements to the given file.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> name of the file to which to export the objects 

        type: char
        	[in] -> if NULL, Maya will write the file in mayaAscii format. if not NULL, it contains a file type to use when writing the file. 

        preserveReferences: bool
        	[in] -> Boolean to indicate whether the references need to be preserved.


        '''
        pass

    def exportAll(self, fileName: MString,
                        type: char,
                        preserveReferences: bool): 
        '''
        exportAll(self, fileName: MString,
                        type: char,
                        preserveReferences: bool)

        Synopsis
        -----
        Export the current scene to the given file.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> name of the file to which to export the objects 

        type: char
        	[in] -> if NULL, Maya will write the file in mayaAscii format. if not NULL, it contains a file type to use when writing the file. 

        preserveReferences: bool
        	[in] -> Boolean to indicate whether the references need to be preserved.


        '''
        pass

    @overload
    def exportAnimFromReference(self, fileName: MString,
                        type: char): 
        '''
        exportAnimFromReference(self, fileName: MString,
                        type: char)

        Synopsis
        -----
        Export the animation from reference, to the specified file.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> name of the file to which the animation will be exported. 

        type: char
        	[in] -> if NULL, Maya will write the file in mayaAscii format. if not NULL, it contains a file type to use when writing the file.


        '''
        pass

    @overload
    def exportAnimFromReference(self, fileName: MString,
                        refNodeName: MString,
                        type: char): 
        '''
        exportAnimFromReference(self, fileName: MString,
                        refNodeName: MString,
                        type: char)

        Synopsis
        -----
        Export the animation from the specified reference node, to the
        specified file.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> name of the file to which the animation will be exported. 

        refNodeName: MString
        	[in] -> name of the reference whose animation will be exported. 

        type: char
        	[in] -> if NULL, Maya will write the file in mayaAscii format. if not NULL, it contains a file type to use when writing the file.


        '''
        pass

    @overload
    def exportSelectedAnimFromReference(self, fileName: MString,
                        type: char): 
        '''
        exportSelectedAnimFromReference(self, fileName: MString,
                        type: char)

        Synopsis
        -----
        Export the selected animation from reference, to the specified
        file.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> name of the file to which the animation will be exported. 

        type: char
        	[in] -> if NULL, Maya will write the file in mayaAscii format. if not NULL, it contains a file type to use when writing the file.


        '''
        pass

    @overload
    def exportSelectedAnimFromReference(self, fileName: MString,
                        refNodeName: MString,
                        type: char): 
        '''
        exportSelectedAnimFromReference(self, fileName: MString,
                        refNodeName: MString,
                        type: char)

        Synopsis
        -----
        Export the selected animation from reference, to the specified
        file.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> name of the file to which the animation will be exported. 

        refNodeName: MString
        	[in] -> name of the reference whose animation will be exported. 

        type: char
        	[in] -> if NULL, Maya will write the file in mayaAscii format. if not NULL, it contains a file type to use when writing the file.


        '''
        pass

    def exportAnim(self, fileName: MString,
                        type: char): 
        '''
        exportAnim(self, fileName: MString,
                        type: char)

        Synopsis
        -----
        Export animation to the specified file.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> name of the file to which the animation will be exported. 

        type: char
        	[in] -> if NULL, Maya will write the file in mayaAscii format. if not NULL, it contains a file type to use when writing the file.


        '''
        pass

    def exportSelectedAnim(self, fileName: MString,
                        type: char): 
        '''
        exportSelectedAnim(self, fileName: MString,
                        type: char)

        Synopsis
        -----
        Export selected animation to the specified file.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> name of the file to which the animation will be exported. 

        type: char
        	[in] -> if NULL, Maya will write the file in mayaAscii format. if not NULL, it contains a file type to use when writing the file.


        '''
        pass

    def exportAsReference(self, fileName: MString,
                        type: char): 
        '''
        exportAsReference(self, fileName: MString,
                        type: char)

        Synopsis
        -----
        Export the selected objects into a reference file.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> name of the file to which the selected objects will be exported as reference. 

        type: char
        	[in] -> if NULL, Maya will write the file in mayaAscii format. if not NULL, it contains a file type to use when writing the file.


        '''
        pass

    def getReferences(self, references: MStringArray,
                        wantUnresolvedNames: bool): 
        '''
        getReferences(self, references: MStringArray,
                        wantUnresolvedNames: bool)

        Synopsis
        -----
        Return an array of all the files referenced from the currently
        active scene.

        Returns:
        -----
        None

        Parameters:
        -----
        references: MStringArray
        	[out] -> a reference to an 

        wantUnresolvedNames: bool
        	[in] -> specify if unresolved file names should be returned. Default is false.


        '''
        pass

    def getFiles(self, files: MStringArray,
                        wantUnresolvedNames: bool,
                        wantReferencesOnly: bool): 
        '''
        getFiles(self, files: MStringArray,
                        wantUnresolvedNames: bool,
                        wantReferencesOnly: bool)

        Synopsis
        -----
        Return an array of all the files used by the currently active
        scene. Includes file references, file textures, cache files,
        image planes etc.

        Returns:
        -----
        None

        Parameters:
        -----
        files: MStringArray
        	[out] -> a reference to an 

        wantUnresolvedNames: bool
        	[in] -> specify if unresolved file names should be returned. Default is false. 

        wantReferencesOnly: bool
        	[in] -> specify if only file references should be returned. Setting this to true makes this function equivalent to 


        '''
        pass

    @overload
    def getReferenceNodes(self, fileName: MString,
                        nodes: MStringArray): 
        '''
        getReferenceNodes(self, fileName: MString,
                        nodes: MStringArray)

        Synopsis
        -----
        Return an array of all the nodes referenced by the given
        filename. The names returned will not include any dag paths.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> an 

        nodes: MStringArray
        	[out] -> a reference to an 


        '''
        pass

    @overload
    def getReferenceNodes(self, fileName: MString,
                        nodes: MStringArray,
                        dagPath: bool): 
        '''
        getReferenceNodes(self, fileName: MString,
                        nodes: MStringArray,
                        dagPath: bool)

        Synopsis
        -----
        Introduced in 2023.0 Return an array of all the nodes referenced
        by the given filename.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> An 

        nodes: MStringArray
        	[out] -> A reference to an 

        dagPath: bool
        	[in] -> If true then the names of any dag objects returned will include as much of the dag path as is necessary to make the names unique. If false then the names returned will not include any dag paths.


        '''
        pass

    @overload
    def getReferenceNodes(self, fileName: MString,
                        list: MSelectionList): 
        '''
        getReferenceNodes(self, fileName: MString,
                        list: MSelectionList)

        Synopsis
        -----
        Return an array of all the nodes referenced by the given
        filename.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> an 

        list: MSelectionList
        	[out] -> a reference to an 


        '''
        pass

    def getReferenceConnectionsMade(self, fileName: MString,
                        connections: MStringArray): 
        '''
        getReferenceConnectionsMade(self, fileName: MString,
                        connections: MStringArray)

        Synopsis
        -----
        Return an array of attribute pairs representing connections made
        to nodes in the given referenced file. The first element of the
        pair is the source attribute in the connection, and the second is
        the destination. These pairs correspond to the "connectAttr"
        statements in a scene file where changes to the referenced file
        occur after the referenced file has been opened.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> an 

        connections: MStringArray
        	[out] -> a reference to an 


        '''
        pass

    @overload
    def getReferenceConnectionsBroken(self, fileName: MString,
                        connections: MStringArray): 
        '''
        getReferenceConnectionsBroken(self, fileName: MString,
                        connections: MStringArray)

        Synopsis
        -----
        Return an array of attribute pairs representing connections
        broken to nodes in the given referenced file. The first element
        of the pair is the source attribute in the connection, and the
        second is the destination. These pairs correspond to the
        "disconnectAttr" statements in a scene file where changes to the
        referenced file occur after the referenced file has been opened.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> an 

        connections: MStringArray
        	[out] -> a reference to an 


        '''
        pass

    @overload
    def getReferenceConnectionsBroken(self, fileName: MString,
                        srcPlugs: MPlugArray,
                        destPlugs: MPlugArray): 
        '''
        getReferenceConnectionsBroken(self, fileName: MString,
                        srcPlugs: MPlugArray,
                        destPlugs: MPlugArray)

        Synopsis
        -----
        Returns the source and destination plugs corresponding to all the
        connections broken between nodes in the given referenced file.
        These pairs correspond to the "disconnectAttr" statements in a
        scene file where changes to the referenced file occur after the
        referenced file has been opened.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> an 

        srcPlugs: MPlugArray
        	[out] -> an 

        destPlugs: MPlugArray
        	[out] -> an 


        '''
        pass

    @overload
    def getReferenceConnectionsBroken(self, node: MObject,
                        connections: MStringArray,
                        append: bool,
                        removeDuplicates: bool): 
        '''
        getReferenceConnectionsBroken(self, node: MObject,
                        connections: MStringArray,
                        append: bool,
                        removeDuplicates: bool)

        Synopsis
        -----
        Returns an array of plug name pairs corresponding to the broken
        connections from referenced files, where those connections
        involved the specified node. To put it another way, if a
        referenced file contained a connection to the specified node when
        it was loaded, and that connection was later broken in the main
        scene, then the names of source and destination plugs for that
        connection will be returned.The first element of the pair is the
        source plug in the connection, and the second is the destination.
        These pairs correspond to the "disconnectAttr" statements in a
        scene file where changes to the referenced file occur after the
        referenced file has been opened.

        Returns:
        -----
        None

        Parameters:
        -----
        node: MObject
        	[in] -> the node whose broken reference connections will be returned. 

        connections: MStringArray
        	[out] -> a reference to an 

        append: bool
        	[in] -> If true, the connection strings will be appended to the existing contents of the 

        removeDuplicates: bool
        	[in] -> If true then any connections which are already in the 


        '''
        pass

    @overload
    def getReferenceConnectionsBroken(self, node: MObject,
                        srcPlugs: MPlugArray,
                        destPlugs: MPlugArray,
                        append: bool,
                        removeDuplicates: bool): 
        '''
        getReferenceConnectionsBroken(self, node: MObject,
                        srcPlugs: MPlugArray,
                        destPlugs: MPlugArray,
                        append: bool,
                        removeDuplicates: bool)

        Synopsis
        -----
        Returns arrays of source and destination plugs corresponding to
        the broken connections from referenced files, where those
        connections involved the specified node. To put it another way,
        if a referenced file contained a connection to the specified node
        when it was loaded, and that connection was later broken in the
        main scene, then the source and destination plugs for that
        connection will be returned.

        Returns:
        -----
        None

        Parameters:
        -----
        node: MObject
        	[in] -> the node whose broken connections should be returned.

        srcPlugs: MPlugArray
        	[out] -> an 

        destPlugs: MPlugArray
        	[out] -> an 

        append: bool
        	[in] -> if true, then 

        removeDuplicates: bool
        	[in] -> if the 


        '''
        pass

    def reference(self, fileName: MString,
                        deferReference: bool,
                        lockReference: bool,
                        nameSpace: MString): 
        '''
        reference(self, fileName: MString,
                        deferReference: bool,
                        lockReference: bool,
                        nameSpace: MString)

        Synopsis
        -----
        Add the given filename as a reference from the current file. When
        a new file is opened, the contents of any files it references are
        read into the scene, however maya remembers that the elements
        came from the referenced file, and does not write them during a
        save operation. Instead the reference is written so the contents
        of the referenced file (which might have changed) will be read
        again when the scene is reloaded.Calling this method while
        MFileIO::isReferencingFile is returning true may have unexpected
        results

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> name of the file to add as a reference. 

        deferReference: bool
        	[in] -> boolean to indicate whether loading has to be deferred. 

        lockReference: bool
        	[in] -> If true, all nodes and attributes from the referenced file will be locked. 

        nameSpace: MString
        	[in] -> name space to add the contents of the referenced file to. If no namespace is provided, name-clashes will be resolved by prefixing with the filename.


        '''
        pass

    def removeReference(self, fileName: MString,
                        namespaceMergeMethod: MFileIO.NamespaceMergeMethod): 
        '''
        removeReference(self, fileName: MString,
                        namespaceMergeMethod: MFileIO.NamespaceMergeMethod)

        Synopsis
        -----
        Remove the named file as a reference from the current file.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> name of the file to remove as a reference 

        namespaceMergeMethod: MFileIO.NamespaceMergeMethod
        	[in] -> what to do with objects remaining in the namespace after the file is removed: merge with parent namespace, merge with root namespace, delete all objects, or keep objects in the namespace (default). Merge with parent/root and delete all objects cannot be used if the reference resides in the root namespace.


        '''
        pass

    def isReadingFile(self): 
        '''
        isReadingFile(self) -> bool

        Synopsis
        -----
        Determine if Maya is currently in the middle of a file read
        operation. File import operations and file reference operations
        are both also file read operations.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isWritingFile(self): 
        '''
        isWritingFile(self) -> bool

        Synopsis
        -----
        Determine if Maya is currently in the middle of a file write
        operation.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isOpeningFile(self): 
        '''
        isOpeningFile(self) -> bool

        Synopsis
        -----
        Determine if Maya is currently performing a file open operation.
        This condition differs from isReadingFile() which is only true
        when were are actually reading the contents of the file from
        disk. In contrast, isOpeningFile() will be true during the pre-
        read operations such as the new operation to delete the current
        scene contents as well as post read-operations.The
        isOpeningFile() method can be used in conjunction with
        isNewingFile() to determine if a "new" operation is currently
        being performed on behalf of an "open" operation.Maya performs
        two types of "new" operations: 1) explicit "new" on account of a
        File>New or "file -new", and 2) implicit "new" due to file open.
        The isOpeningFile() method can be used in conjunction with
        isNewingFile() to determine if a "new" operation is currently
        being performed on behalf of an "open" operation. The following
        table lists how the isNewingFile() and isOpeningFile() methods
        can be used to determine the current state: Based on the above
        table, it is easy to see how the four distinct states can easily
        be detected.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isNewingFile(self): 
        '''
        isNewingFile(self) -> bool

        Synopsis
        -----
        Determine if Maya is currently performing a "new" operation. Maya
        performs two types of "new" operations: 1) explicit "new" on
        account of a File>New or "file -new", and 2) implicit "new" due
        to file open. The isOpeningFile() method can be used in
        conjunction with isNewingFile() to determine if a "new" operation
        is currently being performed on behalf of an "open" operation.
        The following table lists how the isNewingFile() and
        isOpeningFile() methods can be used to determine the current
        state: Based on the above table, it is easy to see how the four
        distinct states can easily be detected.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isSavingReference(self): 
        '''
        isSavingReference(self) -> bool

        Synopsis
        -----
        Determine if Maya is currently in the middle of a save reference
        operation. i.e. When you do File > Save Reference Edits from the
        Reference Editor or `file -saveReference`.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def mustRenameToSave(self, ReturnStatus: MFileIO.MStatus): 
        '''
        mustRenameToSave(self, ReturnStatus: MFileIO.MStatus) -> bool

        Synopsis
        -----
        Scenes may be flagged as needing to be renamed before saving. The
        purpose is to prevent overwriting the original file, which may
        have had a significant change. Users will need to use save as to
        save the scene with a different file name.This method returns
        true if the scene must be renamed before it can be saved.

        Returns: 
        ----- 
        true if this file must be renamed before saving.

        Parameters:
        -----
        ReturnStatus: MFileIO.MStatus
        	[out] -> The status.


        '''
        pass

    def setMustRenameToSave(self, rename: bool): 
        '''
        setMustRenameToSave(self, rename: bool)

        Synopsis
        -----
        This method enabled or disables a state where the current Maya
        scene must save to a different file name. This can be used to
        prevent a user from overwriting the original scene if a
        particularly dangerous or experimental change was made.If
        enabled, the user must use save as to save the scene to a
        different name.Once the file is renamed, this state is cleared
        and the file may be saved.

        Returns:
        -----
        None

        Parameters:
        -----
        rename: bool
        	[in] -> true, if the scene should be saved to a different name.


        '''
        pass

    def mustRenameToSaveMsg(self, ReturnStatus: MFileIO.MStatus): 
        '''
        mustRenameToSaveMsg(self, ReturnStatus: MFileIO.MStatus) -> MString

        Synopsis
        -----
        This method returns a string that is displayed when a user
        attempts to save a scene that was set to not overwrite itself.
        See the MFileIO::setMustRenameToSave() documentation.If a custom
        message was not set, this method will return an empty string.

        Returns: 
        ----- 
        The error message to display.

        Parameters:
        -----
        ReturnStatus: MFileIO.MStatus
        	[out] -> status


        '''
        pass

    def setMustRenameToSaveMsg(self, errorMsg: MString): 
        '''
        setMustRenameToSaveMsg(self, errorMsg: MString)

        Synopsis
        -----
        This method sets a string that is displayed when a user attempts
        to save a scene that was set to not overwrite itself. See the
        MFileIO::setMustRenameToSave() documentation.To use the default
        error message, pass an empty string to this method.

        Returns:
        -----
        None

        Parameters:
        -----
        errorMsg: MString
        	[in] -> The message to display when attempting a file save.


        '''
        pass

    def beforeOpenFilename(self, ReturnStatus: MFileIO.MStatus): 
        '''
        beforeOpenFilename(self, ReturnStatus: MFileIO.MStatus) -> MString

        Synopsis
        -----
        Retrieves the name of the file requested to be opened. This name
        can be retrieved from within the beforeOpenCheck and beforeOpen
        callback functions (that must be registered using
        MSceneMessage::addCallback() before the file is attempted to be
        opened). If called outside of these two callback functions the
        results are undefined.

        Returns: 
        ----- 
        The name of the file to be opened

        Parameters:
        -----
        ReturnStatus: MFileIO.MStatus
        	[out] -> Status code


        '''
        pass

    def beforeImportFilename(self, ReturnStatus: MFileIO.MStatus): 
        '''
        beforeImportFilename(self, ReturnStatus: MFileIO.MStatus) -> MString

        Synopsis
        -----
        Retrieves the name of the file requested to be imported. This
        name can be retrieved from within the beforeImportCheck and
        beforeImport callback functions (that must be registered using
        MSceneMessage::addCallback() before the file is attempted to be
        imported). If called outside of these two callback functions the
        results are undefined.

        Returns: 
        ----- 
        The name of the file to be imported

        Parameters:
        -----
        ReturnStatus: MFileIO.MStatus
        	[out] -> Status code


        '''
        pass

    def beforeSaveFilename(self, ReturnStatus: MFileIO.MStatus): 
        '''
        beforeSaveFilename(self, ReturnStatus: MFileIO.MStatus) -> MString

        Synopsis
        -----
        Retrieves the name of the file requested to be saved. This name
        can be retrieved from within the beforeSaveCheck and beforeSave
        callback functions (that must be registered using
        MSceneMessage::addCallback() before the file is attempted to be
        saved). If called outside of these two callback functions the
        results are undefined.

        Returns: 
        ----- 
        The name of the file to be saved

        Parameters:
        -----
        ReturnStatus: MFileIO.MStatus
        	[out] -> Status code


        '''
        pass

    def beforeExportFilename(self, ReturnStatus: MFileIO.MStatus): 
        '''
        beforeExportFilename(self, ReturnStatus: MFileIO.MStatus) -> MString

        Synopsis
        -----
        Retrieves the name of the file requested to be exported. This
        name can be retrieved from within the beforeExportCheck and
        beforeExport callback functions (that must be registered using
        MSceneMessage::addCallback() before the file is attempted to be
        exported). If called outside of these two callback functions the
        results are undefined.

        Returns: 
        ----- 
        The name of the file to be exported

        Parameters:
        -----
        ReturnStatus: MFileIO.MStatus
        	[out] -> Status code


        '''
        pass

    def beforeReferenceFilename(self, ReturnStatus: MFileIO.MStatus): 
        '''
        beforeReferenceFilename(self, ReturnStatus: MFileIO.MStatus) -> MString

        Synopsis
        -----
        Retrieves the name of the file requested to be referenced. This
        name can be retrieved from within the beforeRefenceCheck and
        beforeRefence callback functions (that must be registered using
        MSceneMessage::addCallback() before the file is attempted to be
        referenced). If called outside of these two callback functions
        the results are undefined.

        Returns: 
        ----- 
        The name of the file to be referenced

        Parameters:
        -----
        ReturnStatus: MFileIO.MStatus
        	[out] -> Status code


        '''
        pass

    def exportType(self, ReturnStatus: MFileIO.MStatus): 
        '''
        exportType(self, ReturnStatus: MFileIO.MStatus) -> MFileIO.MFileIO

        Synopsis
        -----
        Returns the type of export currently in progress. The result is
        valid from the start of the kBeforeExportCheck callback through
        to the end of the kAfterExport callback, and for any callbacks
        which occur between them. See MSceneMessage for more information
        on these callbacks.

        Returns: 
        ----- 
        The type of export currently in progress.

        Parameters:
        -----
        ReturnStatus: MFileIO.MStatus
        	[out] -> Status code


        '''
        pass

    def getLastTempFile(self, ReturnStatus: MFileIO.MStatus): 
        '''
        getLastTempFile(self, ReturnStatus: MFileIO.MStatus) -> MString

        Synopsis
        -----
        Returns the temp file used during file save.

        Returns: 
        ----- 
        The name of the temp file

        Parameters:
        -----
        ReturnStatus: MFileIO.MStatus
        	[out] -> Status code


        '''
        pass

    def getErrorStatus(self, ReturnStatus: MFileIO.MStatus): 
        '''
        getErrorStatus(self, ReturnStatus: MFileIO.MStatus) -> bool

        Synopsis
        -----
        Returns the error status of the last file read. Returns true if
        any error occurred during the last file read, else false is
        returned.

        Returns: 
        ----- 
        Boolean value indicating the error status.

        Parameters:
        -----
        ReturnStatus: MFileIO.MStatus
        	[out] -> Status code


        '''
        pass

    def resetError(self): 
        '''
        resetError(self)

        Synopsis
        -----
        Resets the error.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setError(self): 
        '''
        setError(self)

        Synopsis
        -----
        Sets the internal errorIO flag. Setting this flag will trigger
        the display of the standard Maya file IO pop-up after a read or
        write operation. This method can be called during the
        MSceneMessage::kAfterFileRead callback.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def loadReference(self, referenceFileName: MString,
                        returnStatus: MFileIO.MStatus): 
        '''
        loadReference(self, referenceFileName: MString,
                        returnStatus: MFileIO.MStatus) -> MString

        Synopsis
        -----
        Loads the reference, referenced by the given reference node name
        and file name.

        Returns: 
        ----- 
        The name of the loaded reference file

        Parameters:
        -----
        referenceFileName: MString
        	[in] -> MString

        returnStatus: MFileIO.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def loadReferenceByNode(self, referenceNodeName: MString,
                        returnStatus: MFileIO.MStatus): 
        '''
        loadReferenceByNode(self, referenceNodeName: MString,
                        returnStatus: MFileIO.MStatus) -> MString

        Synopsis
        -----
        Loads the reference, referenced by the given reference node name.

        Returns: 
        ----- 
        The name of the loaded reference file

        Parameters:
        -----
        referenceNodeName: MString
        	[in] -> MString

        returnStatus: MFileIO.MStatus
        	[out] -> Status of the operation.


        '''
        pass

    @overload
    def loadReferenceByNode(self, referenceNode: MObject,
                        returnStatus: MFileIO.MStatus): 
        '''
        loadReferenceByNode(self, referenceNode: MObject,
                        returnStatus: MFileIO.MStatus) -> MString

        Synopsis
        -----
        Loads the reference, referenced by the given reference node
        object.

        Returns: 
        ----- 
        The name of the loaded reference file

        Parameters:
        -----
        referenceNode: MObject
        	[in] -> MObject

        returnStatus: MFileIO.MStatus
        	[out] -> Status of the operation.


        '''
        pass

    def unloadReference(self, referenceFileName: MString,
                        returnStatus: MFileIO.MStatus): 
        '''
        unloadReference(self, referenceFileName: MString,
                        returnStatus: MFileIO.MStatus) -> MString

        Synopsis
        -----
        Unloads the reference, referenced by the given reference node and
        file.

        Returns: 
        ----- 
        The name of the unloaded reference file

        Parameters:
        -----
        referenceFileName: MString
        	[in] -> MString

        returnStatus: MFileIO.MStatus
        	[out] -> Status of the operation.


        '''
        pass

    @overload
    def unloadReferenceByNode(self, referenceNodeName: MString,
                        returnStatus: MFileIO.MStatus): 
        '''
        unloadReferenceByNode(self, referenceNodeName: MString,
                        returnStatus: MFileIO.MStatus) -> MString

        Synopsis
        -----
        Unloads the reference, referenced by the given reference node.

        Returns: 
        ----- 
        The name of the unloaded reference file

        Parameters:
        -----
        referenceNodeName: MString
        	[in] -> MString

        returnStatus: MFileIO.MStatus
        	[out] -> Status of the operation.


        '''
        pass

    @overload
    def unloadReferenceByNode(self, referenceNode: MObject,
                        returnStatus: MFileIO.MStatus): 
        '''
        unloadReferenceByNode(self, referenceNode: MObject,
                        returnStatus: MFileIO.MStatus) -> MString

        Synopsis
        -----
        Unloads the reference, referenced by the given reference node.

        Returns: 
        ----- 
        The name of the unloaded reference file

        Parameters:
        -----
        referenceNode: MObject
        	[in] -> MObject

        returnStatus: MFileIO.MStatus
        	[out] -> Status of the operation.


        '''
        pass

    def getReferenceFileByNode(self, referenceNode: MObject,
                        returnStatus: MFileIO.MStatus): 
        '''
        getReferenceFileByNode(self, referenceNode: MObject,
                        returnStatus: MFileIO.MStatus) -> MString

        Synopsis
        -----
        Returns the name of the reference file, which contains the given
        reference node.

        Returns: 
        ----- 
        The name of the reference file, containing the given node.

        Parameters:
        -----
        referenceNode: MObject
        	[in] -> MObject

        returnStatus: MFileIO.MStatus
        	[out] -> Status of the operation.


        '''
        pass

    def cleanReference(self, referenceNodeName: MString,
                        editCommand: char,
                        returnStatus: MFileIO.MStatus): 
        '''
        cleanReference(self, referenceNodeName: MString,
                        editCommand: char,
                        returnStatus: MFileIO.MStatus)

        Synopsis
        -----
        This function removes the edits from the passed in reference
        node. The reference must be in an unloaded state.

        Returns:
        -----
        None

        Parameters:
        -----
        referenceNodeName: MString
        	[in] -> Name of the reference node. 

        editCommand: char
        	[in] -> Name of the edit command to be cleaned. 

        returnStatus: MFileIO.MStatus
        	[out] -> Status of the operation.


        '''
        pass

    def saveReference(self, referenceFileName: MString,
                        returnStatus: MFileIO.MStatus): 
        '''
        saveReference(self, referenceFileName: MString,
                        returnStatus: MFileIO.MStatus)

        Synopsis
        -----
        This function saves reference node edits and connections to
        reference file.

        Returns:
        -----
        None

        Parameters:
        -----
        referenceFileName: MString
        	[in] -> Name of the reference file. 

        returnStatus: MFileIO.MStatus
        	[out] -> Status of the operation.


        '''
        pass

    def fileCurrentlyLoading(self): 
        '''
        fileCurrentlyLoading(self) -> MString

        Synopsis
        -----
        Return the name of the file currently being loaded.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isImportingFile(self): 
        '''
        isImportingFile(self) -> bool

        Synopsis
        -----
        Determine if Maya is currently in the middle of a file import
        operation. File import operations are a subset of file reading
        operations.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isReferencingFile(self): 
        '''
        isReferencingFile(self) -> bool

        Synopsis
        -----
        Determine if Maya is currently in the middle of a file reference
        operation. File reference operations are a subset of file reading
        operations.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def currentlyReadingFileVersion(self): 
        '''
        currentlyReadingFileVersion(self) -> int

        Synopsis
        -----
        Each Maya file format version has a unique integer identifier.
        Identifiers go up sequentially with each new file format.This
        method returns the identifier for the version of the file that is
        currently being read into Maya.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def latestMayaFileVersion(self): 
        '''
        latestMayaFileVersion(self) -> int

        Synopsis
        -----
        Each Maya file format version has a unique integer identifier.
        This method returns the identifier for the file format version
        that will be saved by this version of Maya.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class ReferenceMode:
    '''Specifies which references to load. 
    Non-functional class.  Values for this enum:
    kLoadDefault
    kLoadAllReferences
    kLoadNoReferences
    '''

    def __init__(self):
        pass

    def kLoadDefault(self):
        '''This is an enum of ReferenceMode.
        - Description: Load references that were loaded when scene was saved. 
        - Value: 0
        '''
        pass

    def kLoadAllReferences(self):
        '''This is an enum of ReferenceMode.
        - Description: Load all references in the scene. 
        - Value: 1
        '''
        pass

    def kLoadNoReferences(self):
        '''This is an enum of ReferenceMode.
        - Description: Don't load any references. 
        - Value: 2
        '''
        pass

class NamespaceMergeMethod:
    '''Specifies what to do with objects remaining in the file reference's namespace, when the file reference is removed. 
    Non-functional class.  Values for this enum:
    kRemoveNamespaceIfEmpty
    kMergeNamespaceWithRootNamespace
    kMergeNamespaceWithParentNamespace
    kForceDeleteNamespaceContent
    '''

    def __init__(self):
        pass

    def kRemoveNamespaceIfEmpty(self):
        '''This is an enum of NamespaceMergeMethod.
        - Description: If the reference is alone in its namespace, remove the namespace. Else, keep the objects and the namespace. 
        - Value: 0
        '''
        pass

    def kMergeNamespaceWithRootNamespace(self):
        '''This is an enum of NamespaceMergeMethod.
        - Description: Move remaining objects to root namespace, and delete namespace. Cannot be used if the reference resides in the root namespace. 
        - Value: 1
        '''
        pass

    def kMergeNamespaceWithParentNamespace(self):
        '''This is an enum of NamespaceMergeMethod.
        - Description: Move remaining objects to parent namespace, and delete namespace. Cannot be used if the reference resides in the root namespace. 
        - Value: 2
        '''
        pass

    def kForceDeleteNamespaceContent(self):
        '''This is an enum of NamespaceMergeMethod.
        - Description: Delete all namespace content, and delete namespace. Cannot be used if the reference resides in the root namespace. 
        - Value: 3
        '''
        pass

class ExportType:
    '''Types of export operation. 
    Non-functional class.  Values for this enum:
    kExportTypeAll
    kExportTypeSelected
    kExportTypeAnim
    kExportTypeAnimFromReference
    kExportTypeAsReference
    kExportTypeEdits
    kExportTypePrefObjects
    '''

    def __init__(self):
        pass

    def kExportTypeAll(self):
        '''This is an enum of ExportType.
        - Description: Export all. 
        - Value: 0
        '''
        pass

    def kExportTypeSelected(self):
        '''This is an enum of ExportType.
        - Description: Export selected. 
        - Value: 1
        '''
        pass

    def kExportTypeAnim(self):
        '''This is an enum of ExportType.
        - Description: Export anim. 
        - Value: 2
        '''
        pass

    def kExportTypeAnimFromReference(self):
        '''This is an enum of ExportType.
        - Description: Export anim from reference. 
        - Value: 3
        '''
        pass

    def kExportTypeAsReference(self):
        '''This is an enum of ExportType.
        - Description: Export as reference. 
        - Value: 4
        '''
        pass

    def kExportTypeEdits(self):
        '''This is an enum of ExportType.
        - Description: Export edits. 
        - Value: 5
        '''
        pass

    def kExportTypePrefObjects(self):
        '''This is an enum of ExportType.
        - Description: Export pref objects. 
        - Value: 6
        '''
        pass

class MFileObject:
    '''Manipulate filenames and search paths.
The
MFileObject class implements an object that contains both a filename and a
search path. The search path is specified by a single string in
which multiple elements are separated by ':' characters. As well
this string can contain Unix environment variables, specified as
$VARNAME,
Filenames can be produced by the class by combining the path
element with the filename element of the
MFileObject. As well, methods are available to test for the existance of the
files produced.
'''
    def __init__(self):
        pass


    def setRawName(self, fileName: MString): 
        '''
        setRawName(self, fileName: MString)

        Synopsis
        -----
        Set the unresolved filename element of the MFileObject instance.
        This name should not contain any '/' characters, it should
        indicate simply the name of a file. The directories in which this
        name will be searched for are specified by setRawPath.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> The filename to set.


        '''
        pass

    def setRawPath(self, pathName: MString): 
        '''
        setRawPath(self, pathName: MString)

        Synopsis
        -----
        Set the unresolved path element of the MFileObject instance. This
        should contain a list of directories, each separated by a single
        ':' character. The pathnames can contain Unix environment
        variables in the form $VARNAME. These will be expanded when paths
        to actual filenames are constructed.Note that if the specified
        pathName is relative, contains environment variables, or does not
        exist, the paths returned by MFileObject::resolvedPath() and
        MFileObject::expandedPath() may not match the rawPath. See the
        description of MFileObject::resolvedPath() and
        MFileObject::expandedPath() for more information.

        Returns:
        -----
        None

        Parameters:
        -----
        pathName: MString
        	[in] -> The path string.


        '''
        pass

    def setRawFullName(self, fullFileName: MString): 
        '''
        setRawFullName(self, fullFileName: MString)

        Synopsis
        -----
        This method combines the functions of the setRawName and
        setRawPath methods in that it sets both the path and filename
        from the given name. If any '/' characters appear in the given
        name then the path element of the MFileObject is set to
        everything in name up to, but not including the last '/'. The
        filename is set to the part of name after the final '/'.If no '/'
        characters appear in the given name then the path element is set
        to "." and the filename is set to the given name.Note that if the
        specified fullFileName is relative, contains environment
        variables, or does not exist, the full names returned by
        MFileObject::resolvedFullName() and
        MFileObject::expandedFullName() may not match the fullFileName.
        See the description of MFileObject::resolvedFullName() and
        MFileObject::expandedFullName() for more information.Also note
        that for URI-based file paths (e.g. "arrow:uri_path_to_file"),
        setRawFullName will not call setRawName and setRawPath (raw name
        and path will remain empty). Use resolvedName and resolvedPath to
        retrieve the resolved file path, or rawFullName to retrieve the
        unresolved file path.

        Returns:
        -----
        None

        Parameters:
        -----
        fullFileName: MString
        	[in] -> the string used to initialize the path and filename.


        '''
        pass

    @overload
    def setRawURI(self, uri: MString): 
        '''
        setRawURI(self, uri: MString)

        Synopsis
        -----
        Set the unresolved URI of the MFileObject instance from a string.
        This is equivalent to constructing an MURI from the string and
        calling the other form of setRawURI().See the description of MURI
        for information on URIs.

        Returns:
        -----
        None

        Parameters:
        -----
        uri: MString
        	[in] -> The URI string.


        '''
        pass

    @overload
    def setRawURI(self, uri: MURI): 
        '''
        setRawURI(self, uri: MURI)

        Synopsis
        -----
        Set the unresolved URI of the MFileObject instance. See the
        description of MURI for information on URIs.

        Returns:
        -----
        None

        Parameters:
        -----
        uri: MURI
        	[in] -> The URI object.


        '''
        pass

    def overrideResolvedFullName(self, fullFileName: MString,
                        reresolveType: bool): 
        '''
        overrideResolvedFullName(self, fullFileName: MString,
                        reresolveType: bool)

        Synopsis
        -----
        Normally when a raw file name is set, Maya will perform a series
        of operations on it in an attempt to resolve it to a valid file
        name. This final resolved file name can be accessed through the
        MFileObject::resolvedName(), MFileObject::resolvedPath(), and
        MFileObject::resolvedFullFileName() methods and can be quite
        different from the originally specified raw file name.This method
        will override the normal Maya path resolution process and
        explicitly set the resolved file name. This path does not have to
        be a valid file path, but if any '/' characters appear in the
        given name then the resolved path element of the MFileObject is
        set to everything in name up to, but not including the last '/'.
        The resolved filename is set to the part of name after the final
        '/'.Once the resolved file name is set, it is only guaranteed to
        be retained in the MFileObject so long as the raw file path is
        not updated. Once MFileObject::setRawPath(),
        MFileObject::setRawName(), or MFileObject::setRawFullName() is
        called, the normal Maya path resolution process will be re-
        invoked and the resolved path and filename will be updated.Should
        the override name point to a file of a different file type,
        setting reresolveType to true will request Maya to reresolve the
        file extension against its registered translators.

        Returns:
        -----
        None

        Parameters:
        -----
        fullFileName: MString
        	[in] -> the string used to override the path and filename. 

        reresolveType: bool
        	[in] -> if Maya should re-resolve the file type/translator.


        '''
        pass

    def rawName(self): 
        '''
        rawName(self) -> MString

        Synopsis
        -----
        Returns the unresolved filename element of the MFileObject.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def rawPath(self): 
        '''
        rawPath(self) -> MString

        Synopsis
        -----
        Returns the path element of the MFileObject with all environment
        variables unexpanded.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def rawFullName(self): 
        '''
        rawFullName(self) -> MString

        Synopsis
        -----
        Returns the unresolved full file name (path plus filename) of the
        MFileObject with all environment variables unexpanded. This
        routine differs from MFileObject::expandedFullName() in that it
        returns the unexpanded instead of expanded values.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def rawURI(self): 
        '''
        rawURI(self) -> MURI

        Synopsis
        -----
        Returns the unresolved URI of the MFileObject, if any. This will
        be empty if the MFileObject was not resolved from a URI.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def expandedPath(self): 
        '''
        expandedPath(self) -> MString

        Synopsis
        -----
        Returns the raw path element of the unresolved MFileObject with
        all environment variables expanded. In the case that the path
        expands to multiple paths, the first expanded path will be
        returned.After expanding environment variables Maya may perform
        additional modifications to the path in order to resolve it to a
        valid location on disk. This resolved path can be accessed
        through MFileObject::resolvedPath().

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def expandedFullName(self): 
        '''
        expandedFullName(self) -> MString

        Synopsis
        -----
        Returns the pathname of a file constructed from the unresolved
        MFileObject values. The file name will consist of the the
        expanded raw path and raw name elements. All variables in the
        path element are expanded, and the first path (the part before
        the first separator (':') in the path) is prepended to the
        filename element to construct the fullName.After expanding
        environment variables Maya may perform additional modifications
        to the full file name in order to resolve it to a valid location
        on disk. This resolved full file name can be accessed through
        MFileObject::resolvedFullName().This routine differs from
        MFileObject::rawFullName() in that it returns the expanded
        instead of unexpanded values.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def resolvedName(self): 
        '''
        resolvedName(self) -> MString

        Synopsis
        -----
        Returns the resolved filename element of the MFileObject.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def resolvedPath(self): 
        '''
        resolvedPath(self) -> MString

        Synopsis
        -----
        Returns the resolved path element of the MFileObject. In order to
        build the resolved path, Maya first expands all environment
        variables and then may perform additional modifications, such as
        prepending directories to a relative path name, in order to
        resolve the path to a valid location on disk.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def resolvedFullName(self): 
        '''
        resolvedFullName(self) -> MString

        Synopsis
        -----
        Returns the first pathname of a file constructed from the path
        and filename elements. All variables in the path element are
        expanded, and the first path (the part before the first ':' in
        the path) is prepended to the filename element. After expanding
        all environment variables Maya may then perform additional
        modifications, such as prepending directories to a relative path
        name, in order to resolve the path to a valid location on
        disk.The resolution is performed using the ResolveMethod of the
        MFileObject. By default, this will be set to MFileObject::kNone.
        While this is suitable in many situations, it may not be
        appropriate if the file is expected to exist. Refer to
        MFileObject::MFileResolveMethod for more information about how
        the resolution mode is used.Failure to resolve the path according
        to the specifications of the MFileObject will result in an empty
        return value.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def pathCount(self): 
        '''
        pathCount(self) -> int

        Synopsis
        -----
        Returns the number of paths in the path element of the
        MFileObject. This will be equal to one more than the number of
        ':' characters specified by the setRawPath method.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def ithPath(self, index: int): 
        '''
        ithPath(self, index: int) -> MString

        Synopsis
        -----
        Returns the indicated portion of the path element of the
        MFileObject. All variables in the path element are expanded, and
        the portion indicated by the argument is extracted and returned.

        Returns: 
        ----- 
        The path element.

        Parameters:
        -----
        index: int
        	[in] -> the index of the desired path portion.


        '''
        pass

    def ithFullName(self, index: int): 
        '''
        ithFullName(self, index: int) -> MString

        Synopsis
        -----
        Returns the pathname of a file constructed from the indicated
        portion of the path element and filename element. All variables
        in the path element are expanded, and the indicated path portion
        is prepended to the filename element to construct the fullName.

        Returns: 
        ----- 
        The pathname.

        Parameters:
        -----
        index: int
        	[in] -> the index of the desired path portion.


        '''
        pass

    @overload
    def exists(self): 
        '''
        exists(self) -> bool

        Synopsis
        -----
        Checks to see if the file returned by the fullName method exists
        and is readable.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def exists(self, index: int): 
        '''
        exists(self, index: int) -> bool

        Synopsis
        -----
        Checks to see if the file constructed from the indicated portion
        of the path element and filename element exists and is readable.

        Returns: 
        ----- 
        true if the file exists and is readable, false otherwise.

        Parameters:
        -----
        index: int
        	[in] -> Index of the path element to be used in searching for the file.


        '''
        pass

    def isSet(self): 
        '''
        isSet(self) -> bool

        Synopsis
        -----
        Checks to see if both file and path elements of the MFileObject
        have been set.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setResolveMethod(self, method: MFileObject.MFileResolveMethod): 
        '''
        setResolveMethod(self, method: MFileObject.MFileResolveMethod)

        Synopsis
        -----
        Set the steps that should be used to resolve this file path.

        Returns:
        -----
        None

        Parameters:
        -----
        method: MFileObject.MFileResolveMethod
        	[in] -> Structure indicating how to resolve the file path. 


        '''
        pass

    def resolveMethod(self): 
        '''
        resolveMethod(self) -> MFileObject.MFileObject

        Synopsis
        -----
        Returns the file-path resolution steps this object will use.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isAbsolutePath(self, fileName: MString): 
        '''
        isAbsolutePath(self, fileName: MString) -> bool

        Synopsis
        -----
        Utility method which checks a file path string and determines if
        it represents an absolute file path. An absolute path can
        uniquely identify a directory or file.

        Returns: 
        ----- 
        True if fileName is an absolute path

        Parameters:
        -----
        fileName: MString
        	[in] -> the string used to check if it is absolute


        '''
        pass

    @overload
    def getResolvedFullName(self, rawFullName: MString): 
        '''
        getResolvedFullName(self, rawFullName: MString) -> MString

        Synopsis
        -----
        This is a static convenience method for performing a
        straightforward resolve of a file path. This is the simplest
        version of this overloaded method. Another version provides
        additional arguments to the call.The caller specifies the
        rawFullName of the unresolved file path, and the resolved name is
        returned.Use of this method is suitable when the requirement is
        simply to convert an unresolved path to a resolved path using the
        default settings and when the calling code does not require
        access to the instance of the MFileObject before the resolution
        for additional setup, or after the resolution for subsequent
        operations.Note: internally the resolution is performed using the
        default ResolveMethod of MFileObject::kNone. While this is
        suitable in many situations, it may not be appropriate if the
        file is expected to exist. The overloaded version of this method
        provides more control over the resolve method that is used. Refer
        to MFileObject::MFileResolveMethod for more information about how
        the resolution mode is used.Failure to resolve the path according
        to the specifications will result in an empty return value.

        Returns: 
        ----- 
        The full path to the resolved file, or an empty string if the
        resolution was unsuccessful.

        Parameters:
        -----
        rawFullName: MString
        	[in] -> The fully specified unresolved path


        '''
        pass

    @overload
    def getResolvedFullName(self, rawFullName: MString,
                        exists: bool,
                        resolveMethod: MFileObject.MFileObject): 
        '''
        getResolvedFullName(self, rawFullName: MString,
                        exists: bool,
                        resolveMethod: MFileObject.MFileObject) -> MString

        Synopsis
        -----
        This is a static convenience method for performing a
        straightforward resolve of a file path. This overloaded version
        of the method provides additional options to the resolution call
        than the simpler version above.The caller specifies the
        rawFullName of the unresolved file path, and the resolved name is
        returned. The method will also perform a check to determine
        whether or not the file exists and will return the result. The
        optional resolveMethod argument can be set by the caller to
        override the resolution mode if desired; by default the setting
        is MFileObject::kNone which will resolve the file path, but not
        require the file to exist to resolve successfully. If the file is
        to be used for input, the resolve setting should generally be set
        to a mode that will check its existence - the most common mode
        for input is MFileObject::kInputFile. Refer to
        MFileObject::MFileResolveMethod for more information about how
        the resolution mode is used.Use of this method is suitable when
        the requirement is simply to convert an unresolved path to a
        resolved path and when the calling code does not require access
        to the instance of the MFileObject before the resolution for
        additional setup, or after the resolution for subsequent
        operations.Failure to resolve the path according to the
        specifications will result in an empty return value.

        Returns: 
        ----- 
        The full path to the resolved file, or an empty string if the
        resolution was unsuccessful.

        Parameters:
        -----
        rawFullName: MString
        	[in] -> The fully specified unresolved path 

        exists: bool
        	[out] -> Set on return to indicate if the resolved path exists or not 

        resolveMethod: MFileObject.MFileObject
        	[in] -> (optional) set by caller to override the resolve method used (default 


        '''
        pass

class MFileResolveMethod:
    '''Options to be used when resolving a file path. 
    Non-functional class.  Values for this enum:
    kNone
    kExact
    kDirMap
    kReferenceMappings
    kRelative
    kBaseName
    kInputFile
    kInputReference
    kStrict
    '''

    def __init__(self):
        pass

    def kNone(self):
        '''This is an enum of MFileResolveMethod.
        - Description: (Default) The resolved path is simply the resulting path after converting the raw value to its expanded form. If the path contains environment variables, the resolved value will be the first path returned from their expansion. Relative paths will be considered to be relative to root of the current project. The resolution algorithm will not check if this file actually exists - the resolution will be considered successful whether it exists or not. With this mode, the resolver will not continue on to attempt to resolve using any other resolve method. The user must explicitly check MFileObject::exists() to determine if it is an existing path. 
        - Value: 1
        '''
        pass

    def kExact(self):
        '''This is an enum of MFileResolveMethod.
        - Description: Checks if expanded paths exist. If paths are relative, assume it's relative to the current workspace (so check workspace current directory, file-rule directory and root directory) 
        - Value: 2
        '''
        pass

    def kDirMap(self):
        '''This is an enum of MFileResolveMethod.
        - Description: Checks path against mappings defined with the dirmap command. Only for absolute paths. 
        - Value: 4
        '''
        pass

    def kReferenceMappings(self):
        '''This is an enum of MFileResolveMethod.
        - Description: Check path against any previously re-mapped reference locations. If kRelative/kBaseName are set, then even if we have an absolute path, convert to relative and/or baseName and look for them in directories provided to the missing reference dialog. 
        - Value: 8
        '''
        pass

    def kRelative(self):
        '''This is an enum of MFileResolveMethod.
        - Description: Strips away the project directory, and treats path as relative. Relative to the current workspace, that is. So look in the workspace current directory, file-rules directory and the root directory 
        - Value: 16
        '''
        pass

    def kBaseName(self):
        '''This is an enum of MFileResolveMethod.
        - Description: Strips away everything but the base file name and look in the current workspace. 
        - Value: 32
        '''
        pass

    def kInputFile(self):
        '''This is an enum of MFileResolveMethod.
        - Description: This mode is the default on file open and import, and is suitable for files that are to be used as input files. The file will be checked for existence. 
        - Value: 54
        '''
        pass

    def kInputReference(self):
        '''This is an enum of MFileResolveMethod.
        - Description: This mode is the default on file reference. In addition to the checks done for a regular input file, it will also check the reference mappings. 
        - Value: 62
        '''
        pass

    def kStrict(self):
        '''This is an enum of MFileResolveMethod.
        - Description: Equivalent to the file -strict flag. 
        - Value: 6
        '''
        pass

class MFloatArray:
    '''Array of floats data type.
This class implements an array of floats. Common convenience
functions are available, and the implementation is compatible
with the internal Maya implementation so that it can be passed
efficiently between plugins and internal maya data structures.
Methods that query the array are threadsafe. Writing to different
array elements at the same time with the
set() method is threadsafe. Methods that modify the array length,
namely
append(),
insert(),
remove() and
setLength() are not threadsafe.
'''
    def __init__(self):
        pass


    @overload
    def set(self, element: float,
                        index: int): 
        '''
        set(self, element: float,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated float
        value. NOTE: This method does not grow the array if the index is
        out of bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        element: float
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    @overload
    def set(self, element: double,
                        index: int): 
        '''
        set(self, element: double,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated double
        value. NOTE: This method does not grow the array if the index is
        out of bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        element: double
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    def setLength(self, length: int): 
        '''
        setLength(self, length: int)

        Synopsis
        -----
        Set the length of the array. This will grow and shrink the array
        as desired. Elements that are grown have uninitialized values,
        while those which are shrunk will lose the data contained in the
        deleted elements (ie. it will release the memory).

        Returns:
        -----
        None

        Parameters:
        -----
        length: int
        	[in] -> the new size of the array 


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Returns the number of elements in the instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Remove the array element at the given index. All array elements
        following the removed element are shifted toward the first
        element.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> index of the element to be removed


        '''
        pass

    def insert(self, element: float,
                        index: int): 
        '''
        insert(self, element: float,
                        index: int)

        Synopsis
        -----
        Inserts a new value into the array at the given index. The
        initial element at that index, and all following elements, are
        shifted towards the last. If the array cannot be expanded in size
        by 1 element, then the insert will fail and the existing array
        will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: float
        	[in] -> the new value to insert into the array 

        index: int
        	[in] -> the index of the element to set to the the new value


        '''
        pass

    def append(self, element: float): 
        '''
        append(self, element: float)

        Synopsis
        -----
        Adds a new element to the end of the array. If the array cannot
        be expanded in size by 1 element, then the append will fail and
        the existing array will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: float
        	[in] -> the value for the new last element


        '''
        pass

    def copy(self, source: MFloatArray): 
        '''
        copy(self, source: MFloatArray)

        Synopsis
        -----
        Copy the contents of the source array to this array.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MFloatArray
        	[in] -> array to copy from


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clear the contents of the array. After this operation the length
        method will return 0. This does not change the amount of memory
        allocated to the array, only the number of valid elements in it.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def get(self, array: float): 
        '''
        get(self, array: float)

        Synopsis
        -----
        Copy the elements of the array into the given C++ array of
        floats. No checking is done to ensure that the destination C++
        array of floats is large enough to hold all the elements of the
        instance.

        Returns:
        -----
        None

        Parameters:
        -----
        array: float
        	[out] -> the array to populate


        '''
        pass

    @overload
    def get(self, array: double): 
        '''
        get(self, array: double)

        Synopsis
        -----
        Copy the elements of the array into the given C++ array of
        doubles. No checking is done to ensure that the destination C++
        array of doubles is large enough to hold all the elements of the
        instance.

        Returns:
        -----
        None

        Parameters:
        -----
        array: double
        	[out] -> the array to populate


        '''
        pass

    def setSizeIncrement(self, newIncrement: int): 
        '''
        setSizeIncrement(self, newIncrement: int)

        Synopsis
        -----
        Set the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        newIncrement: int
        	[in] -> the new increment 


        '''
        pass

    def sizeIncrement(self): 
        '''
        sizeIncrement(self) -> int

        Synopsis
        -----
        Return the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MFloatArray.MFloatArray

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MFloatArray.MFloatArray

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MFloatArray.MFloatArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MFloatArray.MFloatArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MFloatArray.MFloatArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MFloatArray.MFloatArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MFloatMatrix:
    '''A matrix math class for 4x4 matrices of floats.
This class provides access to Maya's internal matrix math library
allowing matrices to be handled easily, and in a manner
compatible with internal Maya data structures.
'''
    def __init__(self):
        pass


    def __getitem__(self, row: int): 
        '''
        __getitem__(self, row: int) -> float*

        Synopsis
        -----
        Index operator. Returns an entire row of the matrix as an array
        of floats.

        Returns: 
        ----- 
        float array containing the values of the specified row

        Parameters:
        -----
        row: int
        	[in] -> index of the row to access


        '''
        pass

    @overload
    def get(self, dest: double4): 
        '''
        get(self, dest: double4)

        Synopsis
        -----
        Fill a 4x4 matrix of doubles with the elements from the instance.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: double4
        	[out] -> the 4x4 matrix of doubles to populate


        '''
        pass

    @overload
    def get(self, dest: float4): 
        '''
        get(self, dest: float4)

        Synopsis
        -----
        Fill a 4x4 matrix of floats with the elements from the instance.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: float4
        	[out] -> The 4x4 matrix of floats to populate.


        '''
        pass

    def transpose(self): 
        '''
        transpose(self) -> MFloatMatrix

        Synopsis
        -----
        Compute and return the transpose of this instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setToIdentity(self): 
        '''
        setToIdentity(self) -> MFloatMatrix

        Synopsis
        -----
        Set this instance to the 4x4 identity matrix.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setToProduct(self, left: MFloatMatrix,
                        right: MFloatMatrix): 
        '''
        setToProduct(self, left: MFloatMatrix,
                        right: MFloatMatrix) -> MFloatMatrix

        Synopsis
        -----
        Set this instance to the inner product of the two argument
        matrices.

        Returns: 
        ----- 
        A reference to the result.

        Parameters:
        -----
        left: MFloatMatrix
        	[in] -> The left hand matrix for the operation 

        right: MFloatMatrix
        	[in] -> The right hand matrix for the operation 


        '''
        pass

    def __radd__(self, right: MFloatMatrix): 
        '''
        __radd__(self, right: MFloatMatrix) -> MFloatMatrix

        Synopsis
        -----
        The in place matrix addition operator.

        Returns: 
        ----- 
        A reference to the result.

        Parameters:
        -----
        right: MFloatMatrix
        	[in] -> Matrix to add. 


        '''
        pass

    def __add__(self, right: MFloatMatrix): 
        '''
        __add__(self, right: MFloatMatrix) -> MFloatMatrix

        Synopsis
        -----
        The matrix addition operator.

        Returns: 
        ----- 
        Sum of both matrices.

        Parameters:
        -----
        right: MFloatMatrix
        	[in] -> Matrix to add. 


        '''
        pass

    def __rsub__(self, right: MFloatMatrix): 
        '''
        __rsub__(self, right: MFloatMatrix) -> MFloatMatrix

        Synopsis
        -----
        The in place matrix subtraction operator.

        Returns: 
        ----- 
        A reference to the result.

        Parameters:
        -----
        right: MFloatMatrix
        	[in] -> Matrix to subtract. 


        '''
        pass

    def __sub__(self, right: MFloatMatrix): 
        '''
        __sub__(self, right: MFloatMatrix) -> MFloatMatrix

        Synopsis
        -----
        The matrix subtraction operator.

        Returns: 
        ----- 
        Difference of both matrices.

        Parameters:
        -----
        right: MFloatMatrix
        	[in] -> Matrix to subtract. 


        '''
        pass

    def __eq__(self, other: MFloatMatrix): 
        '''
        __eq__(self, other: MFloatMatrix) -> bool

        Synopsis
        -----
        The matrix equality operator.

        Returns: 
        ----- 
        True is the matrices are identical.

        Parameters:
        -----
        other: MFloatMatrix
        	[in] -> Matrix to test with. 


        '''
        pass

    def __neq__(self, other: MFloatMatrix): 
        '''
        __neq__(self, other: MFloatMatrix) -> bool

        Synopsis
        -----
        The matrix inequality operator.

        Returns: 
        ----- 
        True is the matrices are not identical.

        Parameters:
        -----
        other: MFloatMatrix
        	[in] -> Matrix to test with. 


        '''
        pass

    def inverse(self): 
        '''
        inverse(self) -> MFloatMatrix

        Synopsis
        -----
        Compute and return the inverse of this instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def adjoint(self): 
        '''
        adjoint(self) -> MFloatMatrix

        Synopsis
        -----
        Compute and return the adjoint of this instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def homogenize(self): 
        '''
        homogenize(self) -> MFloatMatrix

        Synopsis
        -----
        Compute and return a homogenized version of this instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def det4x4(self): 
        '''
        det4x4(self) -> float

        Synopsis
        -----
        Compute and return the determinant of this instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def det3x3(self): 
        '''
        det3x3(self) -> float

        Synopsis
        -----
        Compute and return the determinant of the upper left 3x3
        submatrix of this instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isEquivalent(self, other: MFloatMatrix,
                        tolerance: float): 
        '''
        isEquivalent(self, other: MFloatMatrix,
                        tolerance: float) -> bool

        Synopsis
        -----
        Determine if the given matrix is equivalent to this instance
        within the specified tolerance.

        Returns: 
        ----- 
        True if the matrices are equivalent and false otherwise

        Parameters:
        -----
        other: MFloatMatrix
        	[in] -> the matrix to compare to 

        tolerance: float
        	[in] -> the tolerance to use during the comparison


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MFloatPoint:
    '''Implementation of a point.
This class provides an implementation of a point in float.
Numerous convienence operators are provided to help with the
manipulation of points. This includes operators that work with
the
MFloatVector and
MFloatMatrix classes.
All methods that query the point are threadsafe, all methods that
modify the point are not threadsafe.
'''
    def __init__(self):
        pass


    @overload
    def get(self, dest: double4): 
        '''
        get(self, dest: double4)

        Synopsis
        -----
        Copy the values of x, y, z, and w from the instance to the four
        elements of the given array of doubles.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: double4
        	[out] -> the four element array of doubles


        '''
        pass

    @overload
    def get(self, dest: float4): 
        '''
        get(self, dest: float4)

        Synopsis
        -----
        Copy the values of x, y, z, and w from the instance to the four
        elements of the given array of floats.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: float4
        	[out] -> the four element array of floats


        '''
        pass

    @overload
    def setCast(self, srcpt: MPoint): 
        '''
        setCast(self, srcpt: MPoint)

        Synopsis
        -----
        Copy the values of x, y, z, and w from srcpt to the instance.

        Returns:
        -----
        None

        Parameters:
        -----
        srcpt: MPoint
        	[in] -> the point to copy the x, y, z and w values from.


        '''
        pass

    @overload
    def setCast(self, src: MVector): 
        '''
        setCast(self, src: MVector)

        Synopsis
        -----
        Copy the values of x, y, z, and w from src to the instance.

        Returns:
        -----
        None

        Parameters:
        -----
        src: MVector
        	[in] -> the vector to copy the x, y, z and w values from.


        '''
        pass

    @overload
    def setCast(self, d: double4): 
        '''
        setCast(self, d: double4)

        Synopsis
        -----
        Copy the values of x, y, z, and w to the instance from the four
        elements of the given array of doubles.

        Returns:
        -----
        None

        Parameters:
        -----
        d: double4
        	[in] -> the four element array of doubles


        '''
        pass

    def __getitem__(self, i: int): 
        '''
        __getitem__(self, i: int) -> float

        Synopsis
        -----
        The index operator.

        Returns: 
        ----- 
        The value of the indicated component of the instance.

        Parameters:
        -----
        i: int
        	[in] -> value indicating which component to return


        '''
        pass

    @overload
    def __sub__(self, other: MFloatPoint): 
        '''
        __sub__(self, other: MFloatPoint) -> MFloatVector

        Synopsis
        -----
        The subtraction operator for two MFloatPoints. The result is the
        MFloatVector from the other point to this instance.

        Returns: 
        ----- 
        MFloatVector from the other point to this point.

        Parameters:
        -----
        other: MFloatPoint
        	[in] -> The point to subtract.


        '''
        pass

    def __add__(self, other: MFloatVector): 
        '''
        __add__(self, other: MFloatVector) -> MFloatPoint

        Synopsis
        -----
        The operator for adding an MFloatVector to an MFloatPoint. A new
        point is returned whose position is that of the original point
        translated by the vector.

        Returns:
        -----
        None

        Parameters:
        -----
        other: MFloatVector
        	[in] -> The vector to add. 


        '''
        pass

    @overload
    def __sub__(self, other: MFloatVector): 
        '''
        __sub__(self, other: MFloatVector) -> MFloatPoint

        Synopsis
        -----
        The operator for subtracting an MFloatVector from an MFloatPoint.
        A new point is returned whose position is that of the original
        point translated by the inverse of the vector.

        Returns:
        -----
        None

        Parameters:
        -----
        other: MFloatVector
        	[in] -> The vector to subtract. 


        '''
        pass

    def __radd__(self, vector: MFloatVector): 
        '''
        __radd__(self, vector: MFloatVector) -> MFloatPoint

        Synopsis
        -----
        The in-place addition operator for adding an MFloatVector to an
        MFloatPoint. The current instance is translated from its original
        position by the vector.

        Returns:
        -----
        None

        Parameters:
        -----
        vector: MFloatVector
        	[in] -> The vector to add. 


        '''
        pass

    def __rsub__(self, vector: MFloatVector): 
        '''
        __rsub__(self, vector: MFloatVector) -> MFloatPoint

        Synopsis
        -----
        The in-place subtraction operator for subtracting an MFloatVector
        from an MFloatPoint. The current instance is translated from its
        original position by the inverse of the vector.

        Returns:
        -----
        None

        Parameters:
        -----
        vector: MFloatVector
        	[in] -> The vector to subtract. 


        '''
        pass

    def __div__(self, scale: float): 
        '''
        __div__(self, scale: float) -> MFloatPoint

        Synopsis
        -----
        The division operator that allows the vector to by scaled by the
        given float parameter. The x, y, and z components are each
        divided by the parameter. The w component remains unchanged.

        Returns: 
        ----- 
        Scaled point.

        Parameters:
        -----
        scale: float
        	[in] -> The scale parameter.


        '''
        pass

    def __eq__(self, other: MFloatPoint): 
        '''
        __eq__(self, other: MFloatPoint) -> bool

        Synopsis
        -----
        The equality operator. Returns true if all of the x, y, z, and w
        components of the two points are identical.

        Returns:
        -----
        None

        Parameters:
        -----
        other: MFloatPoint
        	[in] -> The point to compare with. 


        '''
        pass

    def __neq__(self, other: MFloatPoint): 
        '''
        __neq__(self, other: MFloatPoint) -> bool

        Synopsis
        -----
        The inequality operator. Returns true if any of the x, y, z, and
        w components of the two points are not identical.

        Returns:
        -----
        None

        Parameters:
        -----
        other: MFloatPoint
        	[in] -> The point to compare with. 


        '''
        pass

    def cartesianize(self): 
        '''
        cartesianize(self) -> MFloatPoint

        Synopsis
        -----
        If this point instance is of the form P(W*x, W*y, W*z, W), for
        some scale factor W != 0, then it is reset to be P(x, y, z, 1).
        This will only work correctly if the point is in homogenous form
        or cartesian form. If the point is in rational form, the results
        are not defined.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def rationalize(self): 
        '''
        rationalize(self) -> MFloatPoint

        Synopsis
        -----
        If this point instance is of the form P(W*x, W*y, W*z, W) (ie. is
        in homogenous or (for W==1) cartesian form), for some scale
        factor W != 0, then it is reset to be P(x, y, z, W). This will
        only work correctly if the point is in homogenous or cartesian
        form. If the point is already in rational form, the resultsare
        not defined.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def homogenize(self): 
        '''
        homogenize(self) -> MFloatPoint

        Synopsis
        -----
        If this point instance is of the form P(x, y, z, W) (ie. is in
        rational or (for W==1) cartesian form), for some scale factor W
        != 0, then it is reset to be P(W*x, W*y, W*z, W).

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def distanceTo(self, other: MFloatPoint): 
        '''
        distanceTo(self, other: MFloatPoint) -> float

        Synopsis
        -----
        Return the distance between this instance and the point passed as
        an argument.

        Returns: 
        ----- 
        The distance between the two points.

        Parameters:
        -----
        other: MFloatPoint
        	[in] -> the point to compute the distance to


        '''
        pass

    def isEquivalent(self, other: MFloatPoint,
                        tol: float): 
        '''
        isEquivalent(self, other: MFloatPoint,
                        tol: float) -> bool

        Synopsis
        -----
        Returns true if this instance the the point passed as an argument
        represent the same position within the specified tolerance.

        Returns: 
        ----- 
        True if the points are equal within the given tolerance and false
        otherwise.

        Parameters:
        -----
        other: MFloatPoint
        	[in] -> the other point to compare to 

        tol: float
        	[in] -> the tolerance to use during the comparison


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MFloatPointArray:
    '''Array of
MFloatPoint data type.
This class implements an array of MFloatPoints. Common
convenience functions are available, and the implementation is
compatible with the internal Maya implementation so that it can
be passed efficiently between plugins and internal maya data
structures.
'''
    def __init__(self):
        pass


    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> const MFloatPoint&

        Synopsis
        -----
        Index operator. Returns the value of the element at the given
        index. No range checking is done - valid indices are 0 to
        length()-1.

        Returns: 
        ----- 
        The value of the indicated element.

        Parameters:
        -----
        index: int
        	[in] -> the index of the element whose value is to be returned


        '''
        pass

    @overload
    def set(self, element: MFloatPoint,
                        index: int): 
        '''
        set(self, element: MFloatPoint,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated value.
        NOTE: This method does not grow the array if the index is out of
        bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MFloatPoint
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    @overload
    def set(self, index: int,
                        x: float,
                        y: float,
                        z: float,
                        w: float): 
        '''
        set(self, index: int,
                        x: float,
                        y: float,
                        z: float,
                        w: float)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated values.
        The x component of the element is set to x, the y component to y,
        the z component to z, and the w component to w.NOTE: This method
        does not grow the array if the index is out of bounds. Only a
        valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the index of the element that is to be set to the the new value 

        x: float
        	[in] -> the new value for the x component 

        y: float
        	[in] -> the new value for the y component 

        z: float
        	[in] -> the new value for the z component,defaulted to 0 

        w: float
        	[in] -> the new value for the w component,defaulted to 1


        '''
        pass

    @overload
    def set(self, val: float4,
                        index: int): 
        '''
        set(self, val: float4,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated value.
        The x component of the element is set to val[0], the y component
        to val[1], the z component to val[2], and the w component to
        val[3].NOTE: This method does not grow the array if the index is
        out of bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        val: float4
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    @overload
    def set(self, val: double4,
                        index: int): 
        '''
        set(self, val: double4,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated value.
        The x component of the element is set to val[0], the y component
        to val[1], the z component to val[2], and the w component to
        val[3].NOTE: This method does not grow the array if the index is
        out of bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        val: double4
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    def setLength(self, length: int): 
        '''
        setLength(self, length: int)

        Synopsis
        -----
        Set the length of the array. This will grow and shrink the array
        as desired. Elements that are grown have uninitialized values,
        while those which are shrunk will lose the data contained in the
        deleted elements (ie. it will release the memory).

        Returns:
        -----
        None

        Parameters:
        -----
        length: int
        	[in] -> the new size of the array 


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Returns the number of elements in the instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Remove the array element at the given index. All array elements
        following the removed element are shifted toward the first
        element.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> index of the element to be removed


        '''
        pass

    def insert(self, element: MFloatPoint,
                        index: int): 
        '''
        insert(self, element: MFloatPoint,
                        index: int)

        Synopsis
        -----
        Inserts a new value into the array at the given index. The
        initial element at that index, and all following elements, are
        shifted towards the last. If the array cannot be expanded in size
        by 1 element, then the insert will fail and the existing array
        will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MFloatPoint
        	[in] -> the new value to insert into the array 

        index: int
        	[in] -> the index of the element to set to the the new value


        '''
        pass

    @overload
    def append(self, element: MFloatPoint): 
        '''
        append(self, element: MFloatPoint)

        Synopsis
        -----
        Adds a new element to the end of the array. If the array cannot
        be expanded in size by 1 element, then the append will fail and
        the existing array will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MFloatPoint
        	[in] -> the value for the new last element


        '''
        pass

    @overload
    def append(self, x: float,
                        y: float,
                        z: float,
                        w: float): 
        '''
        append(self, x: float,
                        y: float,
                        z: float,
                        w: float)

        Synopsis
        -----
        Adds a new element to the end of the array. The appended element
        has the indicated values for its x,y,z and w components. The x
        component of the element is set to x, the y component to y, the z
        component to z, and the w component to w.If the array cannot be
        expanded in size by 1 element, then the append will fail and the
        existing array will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        x: float
        	[in] -> the value for the x component 

        y: float
        	[in] -> the value for the y component 

        z: float
        	[in] -> the value for the z component, defaulted to 0 

        w: float
        	[in] -> the value for the w component, defaulted to 1


        '''
        pass

    def copy(self, source: MFloatPointArray): 
        '''
        copy(self, source: MFloatPointArray)

        Synopsis
        -----
        Copy the contents of the source array to this array.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MFloatPointArray
        	[in] -> array to copy from


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clear the contents of the array. After this operation the length
        method will return 0. This does not change the amount of memory
        allocated to the array, only the number of valid elements in it.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def get(self, dest: float): 
        '''
        get(self, dest: float)

        Synopsis
        -----
        Copy the elements of the array into the C++ array of float
        arrays. No checking is done to ensure that the destination C++
        array of float arrays is large enough to hold all the elements of
        the instance.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: float
        	[out] -> the array to populate


        '''
        pass

    @overload
    def get(self, dest: double): 
        '''
        get(self, dest: double)

        Synopsis
        -----
        Copy the elements of the array into the C++ array of double
        arrays. No checking is done to ensure that the destination C++
        array of double arrays is large enough to hold all the elements
        of the instance.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: double
        	[out] -> the array to populate


        '''
        pass

    def setSizeIncrement(self, newIncrement: int): 
        '''
        setSizeIncrement(self, newIncrement: int)

        Synopsis
        -----
        Set the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        newIncrement: int
        	[in] -> the new increment 


        '''
        pass

    def sizeIncrement(self): 
        '''
        sizeIncrement(self) -> int

        Synopsis
        -----
        Return the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MFloatPointArray.MFloatPointArray

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MFloatPointArray.MFloatPointArray

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MFloatPointArray.MFloatPointArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MFloatPointArray.MFloatPointArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MFloatPointArray.MFloatPointArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MFloatPointArray.MFloatPointArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MFloatVector:
    '''A vector math class for vectors of floats.
This class provides access to Maya's internal vector math library
allowing vectors to be handled easily, and in a manner compatible
with internal Maya data structures.
All methods that query the vector are threadsafe, all methods
that modify the vector are not threadsafe.
'''
    def __init__(self):
        pass


    def __getitem__(self, i: int): 
        '''
        __getitem__(self, i: int) -> float

        Synopsis
        -----
        The index operator. If its argument is 0 it will return the x
        component of the vector. If its argument is 1 it will return the
        y component of the vector. Otherwise it will return the z
        component of the vector.

        Returns: 
        ----- 
        The vector component.

        Parameters:
        -----
        i: int
        	[in] -> Value indicating which component to return.


        '''
        pass

    def __rdiv__(self, scalar: float): 
        '''
        __rdiv__(self, scalar: float) -> MFloatVector

        Synopsis
        -----
        The in place division operator.

        Returns: 
        ----- 
        A reference to the scaled vector.

        Parameters:
        -----
        scalar: float
        	[in] -> Division factor.


        '''
        pass

    def __div__(self, scalar: float): 
        '''
        __div__(self, scalar: float) -> MFloatVector

        Synopsis
        -----
        The division operator.

        Returns: 
        ----- 
        The scaled vector.

        Parameters:
        -----
        scalar: float
        	[in] -> Division factor.


        '''
        pass

    def __add__(self, other: MFloatVector): 
        '''
        __add__(self, other: MFloatVector) -> MFloatVector

        Synopsis
        -----
        The vector addition operator.

        Returns: 
        ----- 
        The resulting vector.

        Parameters:
        -----
        other: MFloatVector
        	[in] -> Vector to add.


        '''
        pass

    def __radd__(self, other: MFloatVector): 
        '''
        __radd__(self, other: MFloatVector) -> MFloatVector

        Synopsis
        -----
        The in place vector addition operator.

        Returns: 
        ----- 
        A reference to the resulting vector.

        Parameters:
        -----
        other: MFloatVector
        	[in] -> Vector to add.


        '''
        pass

    @overload
    def __sub__(self): 
        '''
        __sub__(self) -> MFloatVector

        Synopsis
        -----
        The unary minus operator. Negates the value of each of the x, y,
        and z components of the vector.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def __sub__(self, other: MFloatVector): 
        '''
        __sub__(self, other: MFloatVector) -> MFloatVector

        Synopsis
        -----
        The vector subtraction operator.

        Returns: 
        ----- 
        The resulting vector.

        Parameters:
        -----
        other: MFloatVector
        	[in] -> Vector to subtract.


        '''
        pass

    def __rsub__(self, other: MFloatVector): 
        '''
        __rsub__(self, other: MFloatVector) -> MFloatVector

        Synopsis
        -----
        The in place vector subtraction operator.

        Returns: 
        ----- 
        A reference to the resulting vector.

        Parameters:
        -----
        other: MFloatVector
        	[in] -> Vector to subtract.


        '''
        pass

    def __neq__(self, other: MFloatVector): 
        '''
        __neq__(self, other: MFloatVector) -> bool

        Synopsis
        -----
        The vector inequality operator. This returns false if all three
        of the x, y, and z components are identical.

        Returns: 
        ----- 
        Bool false if the vectors are identical and true otherwise.

        Parameters:
        -----
        other: MFloatVector
        	[in] -> Vector to compare against.


        '''
        pass

    def __eq__(self, other: MFloatVector): 
        '''
        __eq__(self, other: MFloatVector) -> bool

        Synopsis
        -----
        The vector equality operator. This returns true if all three of
        the x, y, and z components are identical.

        Returns: 
        ----- 
        Bool true if the vectors are identical and false otherwise.

        Parameters:
        -----
        other: MFloatVector
        	[in] -> Vector to compare against.


        '''
        pass

    def get(self, d: float3): 
        '''
        get(self, d: float3)

        Synopsis
        -----
        Extracts the x, y, and z components of the vector and places them
        in elements 0, 1, and 2 of the float array passed.

        Returns:
        -----
        None

        Parameters:
        -----
        d: float3
        	[out] -> The array of 3 floats into which the results are placed.


        '''
        pass

    def length(self): 
        '''
        length(self) -> float

        Synopsis
        -----

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def normal(self): 
        '''
        normal(self) -> MFloatVector

        Synopsis
        -----
        Computes a unit vector aligned to the vector.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def normalize(self): 
        '''
        normalize(self)

        Synopsis
        -----
        Performs an in place normalization of the vector.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def angle(self, other: MFloatVector): 
        '''
        angle(self, other: MFloatVector) -> float

        Synopsis
        -----
        Returns the angle in radians between the vector and the one
        passed as an argument.

        Returns: 
        ----- 
        The angle in radians

        Parameters:
        -----
        other: MFloatVector
        	[in] -> the vector from which to compute the angle.


        '''
        pass

    def isEquivalent(self, other: MFloatVector,
                        tol: float): 
        '''
        isEquivalent(self, other: MFloatVector,
                        tol: float) -> bool

        Synopsis
        -----
        Returns true if the vector and the one passed as an argument are
        equal to each other within the specified tolerance.

        Returns: 
        ----- 
        true if the vectors are equivalent and false otherwise

        Parameters:
        -----
        other: MFloatVector
        	[in] -> the vector to compare to 

        tol: float
        	[in] -> the tolerance to use during the comparison


        '''
        pass

    def isParallel(self, other: MFloatVector,
                        tol: float): 
        '''
        isParallel(self, other: MFloatVector,
                        tol: float) -> bool

        Synopsis
        -----
        Returns true if the current vector and the one passed as an
        argument are parallel to each other within the specified
        tolerance.

        Returns: 
        ----- 
        true if the vectors are parallel and false otherwise

        Parameters:
        -----
        other: MFloatVector
        	[in] -> the vector to compare to 

        tol: float
        	[in] -> the tolerance to use during the comparison


        '''
        pass

class MFloatVectorArray:
    '''Array of MFloatVectors data type.
This class implements an array of MFloatVectors. Common
convenience functions are available, and the implementation is
compatible with the internal Maya implementation so that it can
be passed efficiently between plugins and internal maya data
structures.
'''
    def __init__(self):
        pass


    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> const MFloatVector&

        Synopsis
        -----
        Index operator. Returns the value of the element at the given
        index. No range checking is done - valid indices are 0 to
        length()-1.

        Returns: 
        ----- 
        The value of the indicated element.

        Parameters:
        -----
        index: int
        	[in] -> the index of the element whose value is to be returned


        '''
        pass

    @overload
    def set(self, element: MFloatVector,
                        index: int): 
        '''
        set(self, element: MFloatVector,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated
        MFloatVector value. NOTE: This method does not grow the array if
        the index is out of bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MFloatVector
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    @overload
    def set(self, element: double3,
                        index: int): 
        '''
        set(self, element: double3,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated double
        array value. NOTE: This method does not grow the array if the
        index is out of bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        element: double3
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    @overload
    def set(self, element: float3,
                        index: int): 
        '''
        set(self, element: float3,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated float
        array value. NOTE: This method does not grow the array if the
        index is out of bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        element: float3
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    def setLength(self, length: int): 
        '''
        setLength(self, length: int)

        Synopsis
        -----
        Set the length of the array. This will grow and shrink the array
        as desired. Elements that are grown have uninitialized values,
        while those which are shrunk will lose the data contained in the
        deleted elements (ie. it will release the memory).

        Returns:
        -----
        None

        Parameters:
        -----
        length: int
        	[in] -> the new size of the array 


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Returns the number of elements in the instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Remove the array element at the given index. All array elements
        following the removed element are shifted toward the first
        element.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> index of the element to be removed


        '''
        pass

    def insert(self, element: MFloatVector,
                        index: int): 
        '''
        insert(self, element: MFloatVector,
                        index: int)

        Synopsis
        -----
        Inserts a new value into the array at the given index. The
        initial element at that index, and all following elements, are
        shifted towards the last. If the array cannot be expanded in size
        by 1 element, then the insert will fail and the existing array
        will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MFloatVector
        	[in] -> the new value to insert into the array 

        index: int
        	[in] -> the index of the element to set to the the new value


        '''
        pass

    def append(self, element: MFloatVector): 
        '''
        append(self, element: MFloatVector)

        Synopsis
        -----
        Adds a new element to the end of the array. If the array cannot
        be expanded in size by 1 element, then the append will fail and
        the existing array will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MFloatVector
        	[in] -> the value for the new last element


        '''
        pass

    def copy(self, source: MFloatVectorArray): 
        '''
        copy(self, source: MFloatVectorArray)

        Synopsis
        -----
        Copy the contents of the source array to this array.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MFloatVectorArray
        	[in] -> array to copy from


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clear the contents of the array. After this operation the length
        method will return 0. This does not change the amount of memory
        allocated to the array, only the number of valid elements in it.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def get(self, array: double): 
        '''
        get(self, array: double)

        Synopsis
        -----
        Copy the elements of the array into the given C++ array of double
        arrays. No checking is done to ensure that the destination C++
        array of double arrays is large enough to hold all the elements
        of the instance.

        Returns:
        -----
        None

        Parameters:
        -----
        array: double
        	[out] -> the array to populate


        '''
        pass

    @overload
    def get(self, array: float): 
        '''
        get(self, array: float)

        Synopsis
        -----
        Copy the elements of the array into the given C++ array of float
        arrays. No checking is done to ensure that the destination C++
        array of floats arrays is large enough to hold all the elements
        of the instance.

        Returns:
        -----
        None

        Parameters:
        -----
        array: float
        	[out] -> the array to populate


        '''
        pass

    def setSizeIncrement(self, newIncrement: int): 
        '''
        setSizeIncrement(self, newIncrement: int)

        Synopsis
        -----
        Set the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        newIncrement: int
        	[in] -> the new increment 


        '''
        pass

    def sizeIncrement(self): 
        '''
        sizeIncrement(self) -> int

        Synopsis
        -----
        Return the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MFloatVectorArray.MFloatVectorArray

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MFloatVectorArray.MFloatVectorArray

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MFloatVectorArray.MFloatVectorArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MFloatVectorArray.MFloatVectorArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MFloatVectorArray.MFloatVectorArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MFloatVectorArray.MFloatVectorArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MFnAmbientLight:
    '''Manage Ambient Light dependency Nodes.
MFnAmbientLight facilitates creation and manipulation of ambient light
dependency graph nodes.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kAmbientLight.Reimplemented from MFnLight.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnAmbientLight.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnAmbientLight".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def create(self, UIvisible: bool,
                        ReturnStatus: MFnAmbientLight.MStatus): 
        '''
        create(self, UIvisible: bool,
                        ReturnStatus: MFnAmbientLight.MStatus) -> MObject

        Synopsis
        -----
        Creates a new ambient light dependency graph node and adds it to
        the dependency graph. If the UIvisible parameter is true, the new
        node will be connected to the light classification node (which
        allows the UI to recognize the node as a light) and added to the
        default light list. If UIvisible is false, the node will be
        created in isolation.The light node is added to the current
        model, under a new transformation.

        Returns: 
        ----- 
        MObject representing the new dependency node.

        Parameters:
        -----
        UIvisible: bool
        	[in] -> determines whether or not to connect the new node to the light classification node and add it to the default light list. 

        ReturnStatus: MFnAmbientLight.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def create(self, parent: MObject,
                        UIvisible: bool,
                        wantTransform: bool,
                        ReturnStatus: MFnAmbientLight.MStatus): 
        '''
        create(self, parent: MObject,
                        UIvisible: bool,
                        wantTransform: bool,
                        ReturnStatus: MFnAmbientLight.MStatus) -> MObject

        Synopsis
        -----
        Creates a new ambient light dependency graph node and adds it to
        the dependency graph. If the UIvisible parameter is true, the new
        node will be connected to the light classification node (which
        allows the UI to recognize the node as a light) and added to the
        default light list. If UIvisible is false, the node will be
        created in isolation.If wantTransform parameter is false ( which
        is by default ), the new shape node is created under the
        specified parent and no transform node is created. If the
        specified parent is null, then no shape node will be created.The
        light node is added to the current model, under the specified
        parent.

        Returns: 
        ----- 
        MObject representing the new dependency node.

        Parameters:
        -----
        parent: MObject
        	[in] -> the node under which the new light and its transform will be added. 

        UIvisible: bool
        	[in] -> determines whether or not to connect the new node to the light classification node and add it to the default light list. 

        wantTransform: bool
        	[in] -> Boolean to indicate whether the transform node is needed or not, which is 'false' by default. 

        ReturnStatus: MFnAmbientLight.MStatus
        	[out] -> return status


        '''
        pass

    def ambientShade(self, ReturnStatus: MFnAmbientLight.MStatus): 
        '''
        ambientShade(self, ReturnStatus: MFnAmbientLight.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "ambientShade" attribute of an ambient
        light node. This attribute determines how positional the light
        is. A value of 0 represents a completely ambient light, while a
        value of 1 represents a point light.

        Returns: 
        ----- 
        The value of the "ambientShade" attribute of the ambient light
        node.

        Parameters:
        -----
        ReturnStatus: MFnAmbientLight.MStatus
        	[out] -> return status


        '''
        pass

    def setAmbientShade(self, ambient_shade: float): 
        '''
        setAmbientShade(self, ambient_shade: float)

        Synopsis
        -----
        Sets the value of the "ambientShade" attribute of an ambient
        light node.

        Returns:
        -----
        None

        Parameters:
        -----
        ambient_shade: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def castSoftShadows(self, ReturnStatus: MFnAmbientLight.MStatus): 
        '''
        castSoftShadows(self, ReturnStatus: MFnAmbientLight.MStatus) -> bool

        Synopsis
        -----
        Retrieves the value of the "castSoftShadows" attribute of an
        ambient light node. This attribute determines whether or not the
        light casts soft shadows.

        Returns: 
        ----- 
        The value of the "castSoftShadows" attribute of the ambient light
        node.

        Parameters:
        -----
        ReturnStatus: MFnAmbientLight.MStatus
        	[out] -> return status


        '''
        pass

    def setCastSoftShadows(self, cast_soft_shadows: bool): 
        '''
        setCastSoftShadows(self, cast_soft_shadows: bool)

        Synopsis
        -----
        Sets the value of the "castSoftShadows" attribute of an ambient
        light node.

        Returns:
        -----
        None

        Parameters:
        -----
        cast_soft_shadows: bool
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def shadowRadius(self, ReturnStatus: MFnAmbientLight.MStatus): 
        '''
        shadowRadius(self, ReturnStatus: MFnAmbientLight.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "shadowRadius" attribute of an ambient
        light node. This attribute represents the radius of the light
        used when computing soft shadows. Higher radius values result in
        more extended soft shadows.

        Returns: 
        ----- 
        The value of the "shadowRadius" attribute of the ambient light
        node.

        Parameters:
        -----
        ReturnStatus: MFnAmbientLight.MStatus
        	[out] -> return status


        '''
        pass

    def setShadowRadius(self, shadow_radius: float): 
        '''
        setShadowRadius(self, shadow_radius: float)

        Synopsis
        -----
        Sets the value of the "shadowRadius" attribute of an ambient
        light node.

        Returns:
        -----
        None

        Parameters:
        -----
        shadow_radius: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

class MFnAnisotropyShader:
    '''Manage anisotropic shaders.
MFnAnisotropyShader facilitates creation and manipulation of dependency graph nodes
representing anisotropy shaders.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kAnisotropy.Reimplemented from MFnDependencyNode.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnAnisotropyShader.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnAnisotropyShader".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, UIvisible: bool,
                        ReturnStatus: MFnAnisotropyShader.MStatus): 
        '''
        create(self, UIvisible: bool,
                        ReturnStatus: MFnAnisotropyShader.MStatus) -> MObject

        Synopsis
        -----
        Creates a new layered shader dependency graph node and adds it to
        the dependency graph. If the UIvisible parameter is true, the new
        node will be connected to the shader classification node (which
        allows the UI to recognize the node as a shader). If UIvisible is
        false, the node will be created in isolation.

        Returns: 
        ----- 
        MObject representing the new dependency node.

        Parameters:
        -----
        UIvisible: bool
        	[in] -> determines whether or not the new node will be connected to the shader classification node. 

        ReturnStatus: MFnAnisotropyShader.MStatus
        	[out] -> return status


        '''
        pass

    def tangentUCamera(self, ReturnStatus: MFnAnisotropyShader.MStatus): 
        '''
        tangentUCamera(self, ReturnStatus: MFnAnisotropyShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "color" attribute of a shader node.
        This attribute represents the surface color of the shader.

        Returns: 
        ----- 
        The value of the "color" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnAnisotropyShader.MStatus
        	[out] -> return status


        '''
        pass

    def setTangentUCamera(self, tangu_camera: MColor): 
        '''
        setTangentUCamera(self, tangu_camera: MColor)

        Synopsis
        -----
        Sets the value of the "color" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        tangu_camera: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def tangentVCamera(self, ReturnStatus: MFnAnisotropyShader.MStatus): 
        '''
        tangentVCamera(self, ReturnStatus: MFnAnisotropyShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "transparency" attribute of a shader
        node. This attribute represents the surface transparency of the
        shader.

        Returns: 
        ----- 
        The value of the "transparency" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnAnisotropyShader.MStatus
        	[out] -> return status


        '''
        pass

    def setTangentVCamera(self, tangv_camera: MColor): 
        '''
        setTangentVCamera(self, tangv_camera: MColor)

        Synopsis
        -----
        Sets the value of the "transparency" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        tangv_camera: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def correlationX(self, ReturnStatus: MFnAnisotropyShader.MStatus): 
        '''
        correlationX(self, ReturnStatus: MFnAnisotropyShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "spreadX" attribute of a shader node.

        Returns: 
        ----- 
        The value of the "spreadX" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnAnisotropyShader.MStatus
        	[out] -> return status


        '''
        pass

    def setCorrelationX(self, correl_x: float): 
        '''
        setCorrelationX(self, correl_x: float)

        Synopsis
        -----
        Sets the value of the "spreadX" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        correl_x: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def correlationY(self, ReturnStatus: MFnAnisotropyShader.MStatus): 
        '''
        correlationY(self, ReturnStatus: MFnAnisotropyShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "spreadY" attribute of a shader node.

        Returns: 
        ----- 
        The value of the "spreadY" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnAnisotropyShader.MStatus
        	[out] -> return status


        '''
        pass

    def setCorrelationY(self, correl_y: float): 
        '''
        setCorrelationY(self, correl_y: float)

        Synopsis
        -----
        Sets the value of the "spreadY" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        correl_y: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def roughness(self, ReturnStatus: MFnAnisotropyShader.MStatus): 
        '''
        roughness(self, ReturnStatus: MFnAnisotropyShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "roughness" attribute of a shader
        node.

        Returns: 
        ----- 
        The value of the "roughness" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnAnisotropyShader.MStatus
        	[out] -> return status


        '''
        pass

    def setRoughness(self, roughness: float): 
        '''
        setRoughness(self, roughness: float)

        Synopsis
        -----
        Sets the value of the "roughness" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        roughness: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def rotateAngle(self, ReturnStatus: MFnAnisotropyShader.MStatus): 
        '''
        rotateAngle(self, ReturnStatus: MFnAnisotropyShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "angle" attribute of a layered shader
        node.

        Returns: 
        ----- 
        The value of the "angle" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnAnisotropyShader.MStatus
        	[out] -> return status


        '''
        pass

    def setRotateAngle(self, rotate_angle: float): 
        '''
        setRotateAngle(self, rotate_angle: float)

        Synopsis
        -----
        Sets the value of the "angle" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        rotate_angle: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def refractiveIndex(self, ReturnStatus: MFnAnisotropyShader.MStatus): 
        '''
        refractiveIndex(self, ReturnStatus: MFnAnisotropyShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "fresnelRefractiveIndex" attribute of
        a layered shader node.

        Returns: 
        ----- 
        The value of the "fresnelRefractiveIndex" attribute of the shader
        node.

        Parameters:
        -----
        ReturnStatus: MFnAnisotropyShader.MStatus
        	[out] -> return status


        '''
        pass

    def setRefractiveIndex(self, refractive_index: float): 
        '''
        setRefractiveIndex(self, refractive_index: float)

        Synopsis
        -----
        Sets the value of the "fresnelRefractiveIndex" attribute of a
        shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        refractive_index: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def anisotropicReflectivity(self, ReturnStatus: MFnAnisotropyShader.MStatus): 
        '''
        anisotropicReflectivity(self, ReturnStatus: MFnAnisotropyShader.MStatus) -> bool

        Synopsis
        -----
        Retrieves the value of the "anisotropicReflectivity" attribute of
        a layered shader node.

        Returns: 
        ----- 
        The value of the "anisotropicReflectivity" attribute of the
        shader node.

        Parameters:
        -----
        ReturnStatus: MFnAnisotropyShader.MStatus
        	[out] -> return status


        '''
        pass

    def setAnisotropicReflectivity(self, anisotropic_reflectivity: bool): 
        '''
        setAnisotropicReflectivity(self, anisotropic_reflectivity: bool)

        Synopsis
        -----
        Sets the value of the "anisotropicReflectivity" attribute of a
        shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        anisotropic_reflectivity: bool
        	[in] -> value to which the attribute will be set.


        '''
        pass

class MFnAreaLight:
    '''Manage Area Light dependency Nodes.
MFnAreaLight facilitates creation and manipulation of dependency graph nodes
representing area lights.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kAreaLight.Reimplemented from MFnNonExtendedLight.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnAreaLight.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnAreaLight".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def create(self, UIvisible: bool,
                        ReturnStatus: MFnAreaLight.MStatus): 
        '''
        create(self, UIvisible: bool,
                        ReturnStatus: MFnAreaLight.MStatus) -> MObject

        Synopsis
        -----
        Creates a new area light dependency graph node and adds it to the
        dependency graph. If the UIvisible parameter is true, the new
        node will be connected to the light classification node (which
        allows the UI to recognize the node as a light) and added to the
        default light list. If UIvisible is false, the node will be
        created in isolation.The light node is added to the current
        model, under a new transformation.

        Returns: 
        ----- 
        MObject representing the new dependency node.

        Parameters:
        -----
        UIvisible: bool
        	[in] -> determines whether or not to connect the new node to the light classification node and add it to the default light list. 

        ReturnStatus: MFnAreaLight.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def create(self, parent: MObject,
                        UIvisible: bool,
                        wantTransform: bool,
                        ReturnStatus: MFnAreaLight.MStatus): 
        '''
        create(self, parent: MObject,
                        UIvisible: bool,
                        wantTransform: bool,
                        ReturnStatus: MFnAreaLight.MStatus) -> MObject

        Synopsis
        -----
        Creates a new area light dependency graph node and adds it to the
        dependency graph. If the UIvisible parameter is true, the new
        node will be connected to the light classification node (which
        allows the UI to recognize the node as a light) and added to the
        default light list. If UIvisible is false, the node will be
        created in isolation.If wantTransform parameter is false ( which
        is by default ), the new shape node is created under the
        specified parent and no transform node is created. If the
        specified parent is null, then no shape node will be created.The
        light node is added to the current model, under the specified
        parent.

        Returns: 
        ----- 
        MObject representing the new dependency node.

        Parameters:
        -----
        parent: MObject
        	[in] -> the node under which the new light and its transform will be added. 

        UIvisible: bool
        	[in] -> determines whether or not to connect the new node to the light classification node and add it to the default light list. 

        wantTransform: bool
        	[in] -> Boolean to indicate whether the transform node is needed or not, which is 'false' by default. 

        ReturnStatus: MFnAreaLight.MStatus
        	[out] -> return status


        '''
        pass

class MFnArrayAttrsData:
    '''Function set for multiple arrays of attributes for dependency
node data.
MFnArrayAttrsData allows the creation and manipulation of multiple arrays of
attributes as a data object over a single connection for use as
dependency graph data.
If a user written dependency node either accepts or produces
MFnArrayAttrsData, then this class is used to extract or create the data that
comes from or goes to other dependency graph nodes. The
MDataHandle::type method will return kDynArrayAttrsData when data of this type is
present. To access it, the
MDataHandle::data() method is used to get an
MObject for the data and this should then be used to initialize an
instance of
MFnArrayAttrsData.
NOTE: these data attributes are not storable.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kDynArrayAttrsData.Reimplemented from MFnData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnArrayAttrsData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnArrayAttrsData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clear the contents of all of the arrays.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def count(self): 
        '''
        count(self) -> int

        Synopsis
        -----
        Returns the number of attribute arrays.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def list(self, ReturnStatus: MFnArrayAttrsData.MStatus): 
        '''
        list(self, ReturnStatus: MFnArrayAttrsData.MStatus) -> MStringArray

        Synopsis
        -----
        Returns a list of names for the attribute arrays.

        Returns: 
        ----- 
        A list of all the names of all the arrays stored in the data.

        Parameters:
        -----
        ReturnStatus: MFnArrayAttrsData.MStatus
        	[out] -> Status code.


        '''
        pass

    def checkArrayExist(self, name: MString,
                        arrayType: MFnArrayAttrsData.MFnArrayAttrsData,
                        ReturnStatus: MFnArrayAttrsData.MStatus): 
        '''
        checkArrayExist(self, name: MString,
                        arrayType: MFnArrayAttrsData.MFnArrayAttrsData,
                        ReturnStatus: MFnArrayAttrsData.MStatus) -> bool

        Synopsis
        -----
        Check if the attribute array related to the given name has been
        created. If the named array exists return true and the array data
        type.

        Returns: 
        ----- 
        True if the array exists and false otherwise.

        Parameters:
        -----
        name: MString
        	[in] -> the name of the array to check 

        arrayType: MFnArrayAttrsData.MFnArrayAttrsData
        	[out] -> the type of the array 

        ReturnStatus: MFnArrayAttrsData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    def vectorArray(self, name: MString,
                        ReturnStatus: MFnArrayAttrsData.MStatus): 
        '''
        vectorArray(self, name: MString,
                        ReturnStatus: MFnArrayAttrsData.MStatus) -> MVectorArray

        Synopsis
        -----
        Return an MVectorArray containing the vector array currently
        operated upon by the function set. The MVectorArray returned by
        this method is editable, so any changes to the return instance
        also affects the MObject operated upon by this function set. If
        the array did not exist it will be created.

        Returns: 
        ----- 
        A copy of the MVectorArray held in this instance

        Parameters:
        -----
        name: MString
        	[in] -> the name of the array to edit or create. 

        ReturnStatus: MFnArrayAttrsData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    def doubleArray(self, name: MString,
                        ReturnStatus: MFnArrayAttrsData.MStatus): 
        '''
        doubleArray(self, name: MString,
                        ReturnStatus: MFnArrayAttrsData.MStatus) -> MDoubleArray

        Synopsis
        -----
        Return an MDoubleArray containing the double array currently
        operated upon by the function set. The MDoubleArray returned by
        this method is editable, so any changes to the return instance
        also affects the MObject operated upon by this function set. If
        the array did not exist it will be created.

        Returns: 
        ----- 
        A copy of the MDoubleArray held in this instance

        Parameters:
        -----
        name: MString
        	[in] -> the name of the array to edit or create. 

        ReturnStatus: MFnArrayAttrsData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    def intArray(self, name: MString,
                        ReturnStatus: MFnArrayAttrsData.MStatus): 
        '''
        intArray(self, name: MString,
                        ReturnStatus: MFnArrayAttrsData.MStatus) -> MIntArray

        Synopsis
        -----
        Return an MIntArray containing the int array currently operated
        upon by the function set. The MIntArray returned by this method
        is editable, so any changes to the return instance also affects
        the MObject operated upon by this function set. If the array did
        not exist it will be created.

        Returns: 
        ----- 
        A copy of the MIntArray held in this instance

        Parameters:
        -----
        name: MString
        	[in] -> the name of the array to edit or create. 

        ReturnStatus: MFnArrayAttrsData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    def stringArray(self, name: MString,
                        ReturnStatus: MFnArrayAttrsData.MStatus): 
        '''
        stringArray(self, name: MString,
                        ReturnStatus: MFnArrayAttrsData.MStatus) -> MStringArray

        Synopsis
        -----
        Return an MStringArray containing the string array currently
        operated upon by the function set. The MStringArray returned by
        this method is editable, so any changes to the return instance
        also affects the MObject operated upon by this function set. If
        the array did not exist it will be created.

        Returns: 
        ----- 
        A copy of the MStringArray held in this instance

        Parameters:
        -----
        name: MString
        	[in] -> the name of the array to edit or create. 

        ReturnStatus: MFnArrayAttrsData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    def create(self, ReturnStatus: MFnArrayAttrsData.MStatus): 
        '''
        create(self, ReturnStatus: MFnArrayAttrsData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance, and initialize
        it to be empty.

        Returns: 
        ----- 
        The newly created MObject

        Parameters:
        -----
        ReturnStatus: MFnArrayAttrsData.MStatus
        	[out] -> kSuccess


        '''
        pass

    def getVectorData(self, attrName: MString,
                        ReturnStatus: MFnArrayAttrsData.MStatus): 
        '''
        getVectorData(self, attrName: MString,
                        ReturnStatus: MFnArrayAttrsData.MStatus) -> MVectorArray

        Synopsis
        -----
        Return an MVectorArray containing the vector array currently
        operated upon by the function set. The MVectorArray returned by
        this method is read only. If the array did not exist it will be
        created.

        Returns: 
        ----- 
        A copy of the MVectorArray held in this instance

        Parameters:
        -----
        attrName: MString
        	[in] -> the name of the array to read 

        ReturnStatus: MFnArrayAttrsData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    def getDoubleData(self, attrName: MString,
                        ReturnStatus: MFnArrayAttrsData.MStatus): 
        '''
        getDoubleData(self, attrName: MString,
                        ReturnStatus: MFnArrayAttrsData.MStatus) -> MDoubleArray

        Synopsis
        -----
        Return an MDoubleArray containing the double array currently
        operated upon by the function set. The MDoubleArray returned by
        this method is read only. If the array did not exist it will be
        created.

        Returns: 
        ----- 
        A copy of the MDoubleArray held in this instance

        Parameters:
        -----
        attrName: MString
        	[in] -> the name of the array to edit or create. 

        ReturnStatus: MFnArrayAttrsData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    def getIntData(self, attrName: MString,
                        ReturnStatus: MFnArrayAttrsData.MStatus): 
        '''
        getIntData(self, attrName: MString,
                        ReturnStatus: MFnArrayAttrsData.MStatus) -> MIntArray

        Synopsis
        -----
        Return an MIntArray containing the int array currently operated
        upon by the function set. The MIntArray returned by this method
        is read only. If the array did not exist it will be created.

        Returns: 
        ----- 
        A copy of the MIntArray held in this instance

        Parameters:
        -----
        attrName: MString
        	[in] -> the name of the array to edit or create. 

        ReturnStatus: MFnArrayAttrsData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    def getStringData(self, attrName: MString,
                        ReturnStatus: MFnArrayAttrsData.MStatus): 
        '''
        getStringData(self, attrName: MString,
                        ReturnStatus: MFnArrayAttrsData.MStatus) -> MStringArray

        Synopsis
        -----
        Return an MStringArray containing the string array currently
        operated upon by the function set. The MStringArray returned by
        this method is read only. If the array did not exist it will be
        created.

        Returns: 
        ----- 
        A copy of the MStringArray held in this instance

        Parameters:
        -----
        attrName: MString
        	[in] -> the name of the array to edit or create. 

        ReturnStatus: MFnArrayAttrsData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

class Type:
    '''use vectorArray() method to extract the attribute array. 
    Non-functional class.  Values for this enum:
    kVectorArray
    kDoubleArray
    kIntArray
    kStringArray
    '''

    def __init__(self):
        pass

    def kVectorArray(self):
        '''This is an enum of Type.
        - Description: use vectorArray() method to extract the attribute array. 
        - Value: 1
        '''
        pass

    def kDoubleArray(self):
        '''This is an enum of Type.
        - Description: use doubleArray() method to extract the attribute array. 
        - Value: 2
        '''
        pass

    def kIntArray(self):
        '''This is an enum of Type.
        - Description: use intArray() method to extract the attribute array. 
        - Value: 3
        '''
        pass

    def kStringArray(self):
        '''This is an enum of Type.
        - Description: use stringArray() method to extract the attribute array. 
        - Value: 4
        '''
        pass

class MFnAssembly:
    '''Function set for scene assembly.
An assembly is a node that is used to maintain a list of
representations, and to keep one as the active representation.
Correspondingly, representations can be activated and
inactivated. In general, a representation can be a full hierarchy
of animated geometry, but can also be as simple as a locator or a
bounding box. The assembly can be used to activate the
representation that best corresponds to a given task: a simple,
fast-loading, fast-drawing representation for overall planning,
or a more detailed representations for fine tuning.
The assembly API does not specify the implementation of
representations. For example, representations can be actual DAG
nodes, or data structures internal to the assembly that can be
used to generate DAG nodes in the Maya scene graph on
representation activation. In this function set as well as in
MPxAssembly, representations are identified only by a string identifier.
Representations in a single
MPxAssembly must have unique string names. Representation name strings must
not contain spaces and quotes, as these characters would cause
argument parsing to fail when names are used in commands.
Representations are created from a set of representation types,
which each assembly type must define. A representation of a given
type will share properties (such as viewport appearance, or
memory size) with other representations of the same type.
Examples could include a "BoundingBox" representation type, or a
"BakedGeometry" representation type. As with representation
names, representation type name strings must not contain spaces
and quotes. Representation type names are not used in the UI, and
are not localized. Rather, each representation type has a
corresponding type label that is used for this purpose. The
representation type label can contain spaces and quotes, and
should be localized.
An assembly object is also a DAG container. As such, operations
on containers can be done on assemblies. For use of container
functionality on assemblies, see function set
MFnContainerNode.
Scene assembly nodes are DAG container nodes that provide the
following services:
Assembly nodes have a single active representation, chosen from a
list of available representations, to best suit the task at hand,
and / or the size of the data set.
Assembly nodes represent a part of a scene that can be loaded and
unloaded efficiently as a block, and that can be worked upon
separately and cooperatively.
Assembly nodes can track certain edits done on their members.
These edits are non-destructive and recorded separately from the
representation data onto which they are applied.
Scene assembly is fully exposed through the OpenMaya API, and its
Autodesk reference implementation is done through this API, to
ensure parity of capability between third-party scene assembly
node implementations, and Autodesk implementations.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kAssembly.Reimplemented from MFnDagNode.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnAssembly.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnAssembly".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getTopLevelAssemblies(self): 
        '''
        getTopLevelAssemblies(self) -> MObjectArray

        Synopsis
        -----
        Returns a list containing top-level assemblies. These are
        assemblies that are not nested inside another assembly.The
        runtime complexity of this method is linear in the number of top-
        level assemblies and top-level file references.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def createRepresentation(self, input: MString,
                        type: MString,
                        undoRedo: MDagModifier,
                        status: MFnAssembly.MStatus): 
        '''
        createRepresentation(self, input: MString,
                        type: MString,
                        undoRedo: MDagModifier,
                        status: MFnAssembly.MStatus) -> MString

        Synopsis
        -----
        Create a representation and add it to the list of those managed
        by this node. The input argument string is used as input data to
        the representation creation process. The semantics of this input
        are defined by the assembly derived class. The representation
        return value string is the representation name, after it has been
        added. The type of the representation is a property of the
        representation that expresses its commonality with other
        representations of this assembly type, for example a "Bounding
        Box" representation type. See the getRepType() method.

        Returns: 
        ----- 
        Added representation name.

        Parameters:
        -----
        input: MString
        	[in] -> Input data for representation creation. 

        type: MString
        	[in] -> Type of representation to create. 

        undoRedo: MDagModifier
        	[in] -> Pointer to 

        status: MFnAssembly.MStatus
        	[out] -> Return status. 


        '''
        pass

    @overload
    def createRepresentation(self, input: MString,
                        type: MString,
                        representation: MString,
                        undoRedo: MDagModifier,
                        status: MFnAssembly.MStatus): 
        '''
        createRepresentation(self, input: MString,
                        type: MString,
                        representation: MString,
                        undoRedo: MDagModifier,
                        status: MFnAssembly.MStatus) -> MString

        Synopsis
        -----
        Create a representation and add it to the list of those managed
        by this node. See alternate createRepresentation() overload for
        documentation. This overload version of createRepresentation()
        allows passing in a representation name. If passed in non-empty,
        the representation argument is used as a starting point for the
        representation name. This string value can be modified by the
        derived implementation to meet representation name uniqueness, or
        other constraints. If empty, the implementation is responsible
        for creating the representation name. The final representation
        name is returned by this method, after it has been added to the
        assembly.

        Returns: 
        ----- 
        Added representation name.

        Parameters:
        -----
        input: MString
        	[in] -> Input data for representation creation. 

        type: MString
        	[in] -> Type of representation to create. 

        representation: MString
        	[in] -> Representation name starting point. 

        undoRedo: MDagModifier
        	[in] -> Pointer to 

        status: MFnAssembly.MStatus
        	[out] -> Return status. 


        '''
        pass

    def postLoad(self): 
        '''
        postLoad(self)

        Synopsis
        -----
        Method to initialize assemblies after their creation. In general,
        postLoad() does not need to be called explicity by a plugin. Maya
        will call it automatically on any assembly node created by
        representation activation, to initialize the assembly node. See
        MPxAssembly::postLoad() for more details.However, if an existing
        assembly needs to be re-initialized, because of a parameter
        change for example, the representation activation code path is
        obviously not involved. In such a case, the postLoad() re-
        initialization can be done by calling this method explicitly, so
        that Maya is made aware that the node is being re-initialized,
        and that for example, no edits should be recorded during this re-
        initialization.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def activate(self, representation: MString): 
        '''
        activate(self, representation: MString)

        Synopsis
        -----
        Activate a representation. The representation to activate is
        specified as a string name. Passing in an empty string argument
        means inactivate the previously-active representation (if any),
        and activate no representation.If canActivate() is false,
        activate() will return failure.

        Returns:
        -----
        None

        Parameters:
        -----
        representation: MString
        	[in] -> Representation to activate. 


        '''
        pass

    def getActive(self, status: MFnAssembly.MStatus): 
        '''
        getActive(self, status: MFnAssembly.MStatus) -> MString

        Synopsis
        -----
        Get the active representation in the list of representations. If
        the list of representations is empty, the status code will be
        kSuccess, and the return string will be empty.

        Returns: 
        ----- 
        The active representation.

        Parameters:
        -----
        status: MFnAssembly.MStatus
        	[out] -> Return status. 


        '''
        pass

    def activateNonRecursive(self, representation: MString): 
        '''
        activateNonRecursive(self, representation: MString)

        Synopsis
        -----
        Activate a representation, but prevent any nested assemblies
        created and initialized during this activation from activating
        any of their representations. Normal activation of a
        representation can create nested assemblies in the
        representation. Maya will call MPxAssembly::postLoad()
        automatically on these nested assemblies to initialize them. This
        initialization of nested assemblies can, in turn, call activate
        on a representation. activateNonRecursive() causes canActivate()
        to return false on these nested assemblies. An implementation of
        MPxAssembly::postLoad() should check canActivate() to determine
        whether it can activate a representation. Stopping the activation
        at the current assembly prunes recursive activation of
        representations.If canActivate() is false, activateNonRecursive()
        will return failure.The representation is specified as a string
        identifier. Passing in an empty string argument means inactivate
        the previously-active representation (if any), and activate no
        representation.

        Returns:
        -----
        None

        Parameters:
        -----
        representation: MString
        	[in] -> Representation to activate. 


        '''
        pass

    def canActivate(self, status: MFnAssembly.MStatus): 
        '''
        canActivate(self, status: MFnAssembly.MStatus) -> bool

        Synopsis
        -----
        Determines whether this assembly can activate a representation,
        for the node attached to this function set. For example, this
        method will return false for a nested assembly, during a call to
        activateNonRecursive() on the parent assembly.If canActivate() is
        false, activate() and activateNonRecursive() will return failure.

        Returns: 
        ----- 
        true if activation is allowed, false otherwise.

        Parameters:
        -----
        status: MFnAssembly.MStatus
        	[out] -> Return status. 


        '''
        pass

    def isActive(self, representation: MString,
                        status: MFnAssembly.MStatus): 
        '''
        isActive(self, representation: MString,
                        status: MFnAssembly.MStatus) -> bool

        Synopsis
        -----
        Determines whether the given representation is the active
        representation for the node attached to this function set.

        Returns: 
        ----- 
        true if the representation is active, false otherwise.

        Parameters:
        -----
        representation: MString
        	[in] -> Representation to query. 

        status: MFnAssembly.MStatus
        	[out] -> Return status. 


        '''
        pass

    def getInitialRep(self, hasInitialRep: bool,
                        status: MFnAssembly.MStatus): 
        '''
        getInitialRep(self, hasInitialRep: bool,
                        status: MFnAssembly.MStatus) -> MString

        Synopsis
        -----
        Get the initial representation to use when the assembly is first
        loaded. This method returns the representation which should be
        activated when the assembly is first initialized. The
        hasInitialRep parameter will be set to true if the assembly has
        an initial representation or false if no initial representation
        has been set. If the returned representation is the empty string
        and hasInitialRep is true it means that assembly has been
        explicitly set to have no initial representationPlug-in writers
        can customize the manner in which the initial representation is
        determined. Refer to MPxAssembly::getInitialRep().

        Returns: 
        ----- 
        The initial representation to use, if any, else an empty string.

        Parameters:
        -----
        hasInitialRep: bool
        	[out] -> Return whether or not we have an initial representation 

        status: MFnAssembly.MStatus
        	[out] -> Return status


        '''
        pass

    def getRepresentations(self, status: MFnAssembly.MStatus): 
        '''
        getRepresentations(self, status: MFnAssembly.MStatus) -> MStringArray

        Synopsis
        -----
        Returns an array of the representations managed by the node
        attached to this function set.

        Returns: 
        ----- 
        Return representations array.

        Parameters:
        -----
        status: MFnAssembly.MStatus
        	[out] -> Return status. 


        '''
        pass

    def getRepType(self, representation: MString,
                        status: MFnAssembly.MStatus): 
        '''
        getRepType(self, representation: MString,
                        status: MFnAssembly.MStatus) -> MString

        Synopsis
        -----
        Get the type of the specified representation. The type string
        does not have to be user-readable, and does not have to be
        localized; the type label should be used for UI purposes. If the
        specified representation is not found in this assembly, an empty
        string is returned.

        Returns: 
        ----- 
        The representation type.

        Parameters:
        -----
        representation: MString
        	[in] -> Representation whose type must be returned. 

        status: MFnAssembly.MStatus
        	[out] -> Return status. 


        '''
        pass

    def getRepLabel(self, representation: MString,
                        status: MFnAssembly.MStatus): 
        '''
        getRepLabel(self, representation: MString,
                        status: MFnAssembly.MStatus) -> MString

        Synopsis
        -----
        Get the label of the specified representation. The label of a
        representation is a string that is meant to be shown in the UI
        and identify the representation meaningfully to a user. The
        representation label should support localization requirements. If
        the specified representation is not found in this assembly, an
        empty string is returned.

        Returns: 
        ----- 
        The representation label.

        Parameters:
        -----
        representation: MString
        	[in] -> Representation whose label must be returned. 

        status: MFnAssembly.MStatus
        	[out] -> Return status. 


        '''
        pass

    def repTypes(self, status: MFnAssembly.MStatus): 
        '''
        repTypes(self, status: MFnAssembly.MStatus) -> MStringArray

        Synopsis
        -----
        Return the list of representation types that can be created for
        this assembly node.

        Returns: 
        ----- 
        Array of representation types.

        Parameters:
        -----
        status: MFnAssembly.MStatus
        	[out] -> Return status.


        '''
        pass

    def deleteRepresentation(self, representation: MString): 
        '''
        deleteRepresentation(self, representation: MString)

        Synopsis
        -----
        Delete a representation managed by the node attached to this
        function set.

        Returns:
        -----
        None

        Parameters:
        -----
        representation: MString
        	[in] -> Representation to delete.


        '''
        pass

    def deleteAllRepresentations(self): 
        '''
        deleteAllRepresentations(self)

        Synopsis
        -----
        Delete all representations managed by the node attached to this
        function set.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getRepNamespace(self, status: MFnAssembly.MStatus): 
        '''
        getRepNamespace(self, status: MFnAssembly.MStatus) -> MString

        Synopsis
        -----
        Get the representations namespace of this assembly node. This is
        the namespace where nodes created by the activation of a
        representation will be added. This namespace is shared by all
        representations. The name can be updated by Maya if a name clash
        occurs when the namespace is added to its parent namespace (see
        MPxAssembly::updateRepNamespace() for details).

        Returns: 
        ----- 
        Namespace for representations.

        Parameters:
        -----
        status: MFnAssembly.MStatus
        	[out] -> Return status.


        '''
        pass

    def setRepName(self, representation: MString,
                        newName: MString,
                        status: MFnAssembly.MStatus): 
        '''
        setRepName(self, representation: MString,
                        newName: MString,
                        status: MFnAssembly.MStatus) -> MString

        Synopsis
        -----
        Rename a representation. The newName argument is used as a
        starting point for the new representation name. This string value
        can be modified by the derived implementation to meet
        representation name uniqueness, or other constraints. This method
        returns the final representation name.

        Returns: 
        ----- 
        New representation name.

        Parameters:
        -----
        representation: MString
        	[in] -> Current representation name. 

        newName: MString
        	[in] -> New representation name starting point. 

        status: MFnAssembly.MStatus
        	[out] -> Return status.


        '''
        pass

    def setRepLabel(self, representation: MString,
                        label: MString): 
        '''
        setRepLabel(self, representation: MString,
                        label: MString)

        Synopsis
        -----
        Change the representation label.

        Returns:
        -----
        None

        Parameters:
        -----
        representation: MString
        	[in] -> Representation name. 

        label: MString
        	[in] -> New representation label.


        '''
        pass

    def importFile(self, fileName: MString,
                        type: char,
                        preserveReferences: bool,
                        nameSpace: char,
                        ignoreVersion: bool): 
        '''
        importFile(self, fileName: MString,
                        type: char,
                        preserveReferences: bool,
                        nameSpace: char,
                        ignoreVersion: bool)

        Synopsis
        -----
        Import the scene elements from the given file into this assembly.
        See MFileIO::importFile() for more information. All elements
        imported from the file become members of the assembly. DAG nodes
        in the imported file that are parented to world are parented to
        the assembly. DAG nodes in the imported file whose parent is not
        world keep their existing parenting relationship.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> name of the file from which to import objects 

        type: char
        	[in] -> if NULL, Maya will try to deduce the type of the file. If not NULL, it must contain a file type to use when importing the file. 

        preserveReferences: bool
        	[in] -> Boolean to indicate whether the references need to be preserved. 

        nameSpace: char
        	[in] -> optional name of the namespace to use when importing objects. Use NULL for default of no namespace. 

        ignoreVersion: bool
        	[in] -> Boolean to control whether to ignore version when importing a file. 


        '''
        pass

    def getAbsoluteRepNamespace(self, status: MFnAssembly.MStatus): 
        '''
        getAbsoluteRepNamespace(self, status: MFnAssembly.MStatus) -> MString

        Synopsis
        -----
        Get the fully-qualified (absolute) namespace for representations
        of this assembly node. This is the namespace where nodes created
        by the activation of a representation will be added. This
        namespace is shared by all representations.This namespace starts
        at the root namespace, contains the namespace of the assembly
        node, and ends (inclusively) with the representation
        namespace.Two namespaces are optionally involved when dealing
        with an assembly node: the namespace of the assembly node itself,
        and the namespace of its representations. The representation
        namespace is a child of its assembly node's namespace. The
        assembly node's namespace is set by its containing assembly, if
        it is nested, or by the top-level file. Either the assembly
        node's namespace, or the representation namespace, or both, can
        be the empty string.It should be noted that if the assembly node
        is nested, the assembly node's namespace will be (by virtue of
        its nesting) the representation namespace of its containing
        assembly.

        Returns: 
        ----- 
        The fully-qualified (absolute) namespace for representations of
        this assembly node. The name can be empty if the namespace has
        not been created yet.

        Parameters:
        -----
        status: MFnAssembly.MStatus
        	[out] -> Return status.


        '''
        pass

    def isTopLevel(self, status: MFnAssembly.MStatus): 
        '''
        isTopLevel(self, status: MFnAssembly.MStatus) -> bool

        Synopsis
        -----
        Returns whether this assembly node is a top-level assembly. An
        assembly node is a top-level assembly if no container in its
        (possibly empty) chain of nesting parent containers is an
        assembly. Of course, this includes the trivial case of its
        immediate parent container being null.

        Returns: 
        ----- 
        Whether the assembly node is a top-level assembly.

        Parameters:
        -----
        status: MFnAssembly.MStatus
        	[out] -> Return status.


        '''
        pass

    def supportsEdits(self, status: MFnAssembly.MStatus): 
        '''
        supportsEdits(self, status: MFnAssembly.MStatus) -> bool

        Synopsis
        -----
        Does this assembly support edit tracking?

        Returns: 
        ----- 
        Whether the assembly supports tracking of edits on its nodes

        Parameters:
        -----
        status: MFnAssembly.MStatus
        	[out] -> Return status


        '''
        pass

    def supportsMemberChanges(self, status: MFnAssembly.MStatus): 
        '''
        supportsMemberChanges(self, status: MFnAssembly.MStatus) -> bool

        Synopsis
        -----
        Can members of the assembly be changed? If the assembly does not
        use Maya's edit tracking system (see supportsEdits()), does it
        support changes to its member nodes, outside of activation? If
        so, this means that any mutating operation on Maya nodes
        (parenting, connecting, disconnecting, renaming, deleting,
        setting attributes, adding attributes, removing attributes,
        locking) can be performed on member nodes of the assembly.This
        method is only used if supportsEdits() returns false. If
        supportsEdits() returns true, Maya will track edits to assembly
        members, and the return value of supportsMemberChanges() will
        have no meaning.When this method returns false, any mutating
        operation to member nodes of the assembly is prevented, and the
        assembly behaves as a read-only container of nodes. When this
        method returns true, the assembly supports changes to its member
        nodes.This predicate is only used outside of representation
        activation. During activation, all types of changes to the
        assembly's members are allowed, including of course deleting the
        previous representation's nodes, and creating nodes for the new
        representation.

        Returns: 
        ----- 
        Whether the assembly supports changes to its nodes

        Parameters:
        -----
        status: MFnAssembly.MStatus
        	[out] -> Return status


        '''
        pass

    def canRepApplyEdits(self, representation: MString,
                        status: MFnAssembly.MStatus): 
        '''
        canRepApplyEdits(self, representation: MString,
                        status: MFnAssembly.MStatus) -> bool

        Synopsis
        -----
        Determines whether the given representation can apply edits to
        its data, for the node attached to this function set. If an empty
        string is passed in as the representation name, this method will
        return false, since an invalid (or 'None') representation does
        not have any data and thus, cannot have edits applied to it.
        method will return false.

        Returns: 
        ----- 
        true if the representation can apply edits, false otherwise.

        Parameters:
        -----
        representation: MString
        	[in] -> Representation to query. 

        status: MFnAssembly.MStatus
        	[out] -> Return status. 


        '''
        pass

    def handlesAddEdits(self, status: MFnAssembly.MStatus): 
        '''
        handlesAddEdits(self, status: MFnAssembly.MStatus) -> bool

        Synopsis
        -----
        Determines whether the assembly supplies edits to its data, for
        the node attached to this function set. If this method returns
        true, Maya will call MPxAssembly::addEdits(). These edits will
        later be applied, either by Maya, or by the assembly through
        MPxAssembly::applyEdits(), if MPxAssembly::handlesApplyEdits()
        returns true.Adding edits can be done by a plugin that implements
        its own persistency scheme. When an assembly node is brought into
        Maya through activation of a representation, this assembly can
        carry edits and make them known to Maya through the addEdits()
        method.Edits can be added for any node in the assembly's
        representations, which includes edits to any nested assembly of
        this assembly. In a scene with multiple levels of nested
        assemblies, if more than one nested assembly has edits to a given
        lower-level nested assembly, edits are applied by Maya starting
        at the most nested assembly level, moving up the chain of nesting
        assemblies. In this way, the most nested assembly's edit are
        overridden by less nested assembly edits, if they edit the same
        attribute or connection.

        Returns: 
        ----- 
        true if the assembly adds edits, false if no edits are added.

        Parameters:
        -----
        status: MFnAssembly.MStatus
        	[out] -> Return status. 


        '''
        pass

    def getParentAssembly(self, status: MFnAssembly.MStatus): 
        '''
        getParentAssembly(self, status: MFnAssembly.MStatus) -> MObject

        Synopsis
        -----
        Return the immediate parent assembly of this assembly if there is
        one, otherwise return a null object. An assembly with no parent
        is a top level assembly.

        Returns: 
        ----- 
        Parent assembly, or a null object if this assembly has no parent
        assembly

        Parameters:
        -----
        status: MFnAssembly.MStatus
        	[out] -> Return status. 


        '''
        pass

    def getSubAssemblies(self, status: MFnAssembly.MStatus): 
        '''
        getSubAssemblies(self, status: MFnAssembly.MStatus) -> MObjectArray

        Synopsis
        -----
        Returns a list containing direct children of this assembly that
        are themselves assemblies, for the currently active
        representation. The returned list will be empty if there are no
        assembly children of the currently active representation.

        Returns: 
        ----- 
        Array of child assemblies.

        Parameters:
        -----
        status: MFnAssembly.MStatus
        	[out] -> Return status. 


        '''
        pass

class MFnAttribute:
    '''Dependency node attribute function set.
MFnAttribute is the function set for dependency node attributes.
An attribute of a dependency node describes a piece of data that
belongs to nodes of that type. For example, a node that makes a
sphere might have a radius attribute. A node's attributes
describe connections sites on the node that can be used in the
dependency graph.
Attributes typically belong to a class of nodes, rather than to
an individual node. For example, all sphere nodes have a radius.
Even though a single attribute may be shared by all nodes of a
given type, each node will have its own value for the attribute.
Attributes are hierarchical. For example, the translate scale
attribute of a transform has x, y, and z child attributes.
By default, attributes are:
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kAttribute.Reimplemented from MFnBase.Reimplemented in
        MFnCompoundAttribute, MFnNumericAttribute, MFnUnitAttribute,
        MFnGenericAttribute, MFnTypedAttribute, MFnMessageAttribute,
        MFnLightDataAttribute, MFnEnumAttribute, and MFnMatrixAttribute.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnAttribute.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnAttribute".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isReadable(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        isReadable(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute is readable. If an attribute is
        readable, then it can be used as the source in a dependency graph
        connection.Attributes are readable by default.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute is readable

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def isWritable(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        isWritable(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute is writable. If an attribute is
        writable, then it can be used as the destination in a dependency
        graph connection.Attributes are writable by default.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute is writable

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def isConnectable(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        isConnectable(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute accepts dependency graph
        connections. If it does, then the readable and writable methods
        will indicate what types of connections are accepted.Attributes
        are connectable by default.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute is connectable

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def isStorable(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        isStorable(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute is to be stored when the node is
        saved to a file. Attributes are storable by default.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute is storable

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def isCached(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        isCached(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute is cached locally in the node's
        data block. The default for this is true. Caching a node locally
        causes a copy of the attribute value for the node to be cached
        with the node. This removes the need to traverse through the
        graph to get the value each time it is requested.Caching the
        value locally gives a speed increase at the cost of more
        memory.Attributes are cached by default.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute is cached
        locally

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def isArray(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        isArray(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute supports an array of data.
        Attributes are single elements by default.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute stores an array
        of data

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def indexMatters(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        indexMatters(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Determines whether the user must specify an index when connecting
        to this attribute, or whether the next available index can be
        used. This method only applies to array attributes which are non
        readable, i.e. destination attributes.This corresponds with the
        connectAttr command's -na/nextAvailable flag. If the destination
        attribute has set the indexMatters to be false with this flag
        specified, a connection is made to the next available index. No
        index need be specifiedThe index matters to attributes by
        default.

        Returns: 
        ----- 
        true The user must specify the index when connecting to this
        attribute using connectAttr  false The next available index can
        be used when connecting to this attribute using connectAttr -na

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def isKeyable(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        isKeyable(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute is keyable. Keyable attributes
        will be keyed by AutoKey and the Set Keyframe UI. Non-keyable
        attributes prevent the user from setting keys via the obvious UI
        provided for keying. Being non-keyable is not a hard block
        against adding keys to an attribute.This method determines the
        default keyability of a plug. The keyability can be changed after
        it is created. Use the MPlug::isKeyable method to determine
        whether or not a specific plug is keyable.Attributes are not
        keyable by default.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute is keyable

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def isChannelBoxFlagSet(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        isChannelBoxFlagSet(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute has its channel box flag set.
        Attributes will appear in the channel box if their channel box
        flag is set or if they are keyable.This method returns the
        default channel box display state of a plug. The display can be
        changed after it is created. Use the MPlug::isChannelBox method
        to determine whether or not a specific plug is displayed in the
        channel box.Attributes are not in the channel box by default.

        Returns: 
        ----- 
        A boolean value indicating the status of the channel box flag on
        this attribute

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def isHidden(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        isHidden(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute is to hidden from the UI. The
        attribute will not show up in attribute editors.Attributes are
        not hidden by default.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute is hidden

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def isUsedAsColor(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        isUsedAsColor(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute is to be presented as a color in
        the UI.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute is used as a
        color

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def isIndeterminant(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        isIndeterminant(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute is indeterminant. If an attribute
        may or may not be used during an evaluation then it is
        indeterminant. This attribute classification is mainly used on
        rendering nodes to indicate that some attributes are not always
        used.Attributes are not indeterminant by default.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute is
        indeterminant

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def isRenderSource(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        isRenderSource(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute is a render source. This attribute
        is used on rendering nodes to override the rendering sampler
        info.Attributes are not render source by default.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute is render
        source

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def isDynamic(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        isDynamic(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute is a dynamic attribute.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute is dynamic

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def isExtension(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        isExtension(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute is an extension attribute. An
        extension attribute is a class-level attribute which has been
        added dynamically to a node class. Because it is added at the
        class level, all nodes of that class will have the given
        attribute, and will only store the attribute's value if it
        differs from the default.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute is an extension
        attribute

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def isWorldSpace(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        isWorldSpace(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute is worldspace. Attributes are not
        worldspace by default.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute is worldspace

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def isAffectsWorldSpace(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        isAffectsWorldSpace(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute affects worldspace. Attributes do
        not affect worldspace by default.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute affects
        worldspace

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def isUsedAsFilename(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        isUsedAsFilename(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute is to be used as a filename. In
        the UI this attr will be presented as a file name.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute is used as a
        filename

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def affectsAppearance(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        affectsAppearance(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute affects the appearance of the
        object when rendering in the viewport.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute affects the
        appearance of the object when rendering in the viewport.

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def isProxyAttribute(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        isProxyAttribute(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute is a proxy attribute.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute is a proxy
        attribute

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def disconnectBehavior(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        disconnectBehavior(self, ReturnStatus: MFnAttribute.MStatus) -> MFnAttribute.MFnAttribute

        Synopsis
        -----
        Returns the behavior of this attribute when it is disconnected.
        The possible settings are as follows:Attributes have a default
        disconnect behavior of kNothing.

        Returns: 
        ----- 
        The disconnect behavior

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def usesArrayDataBuilder(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        usesArrayDataBuilder(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute uses an array data builder. If so,
        then the MArrayDataBuilder class may be used with this
        attribute.By default array attributes do not use an array data
        builder.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute uses an array
        data builder.

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def internal(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        internal(self, ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if a node has internal member data representing this
        attribute.

        Returns: 
        ----- 
        A boolean value indicating whether this attribute uses internal
        data

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def setReadable(self, state: bool): 
        '''
        setReadable(self, state: bool)

        Synopsis
        -----
        Sets whether this attribute should be readable. If an attribute
        is readable, then it can be used as the source in a dependency
        graph connection.Attributes are readable by default.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute is to be readable


        '''
        pass

    def setWritable(self, state: bool): 
        '''
        setWritable(self, state: bool)

        Synopsis
        -----
        Sets whether this attribute should be writable. If an attribute
        is writable, then it can be used as the destination in a
        dependency graph connection.If both keyable and writable for an
        attribute are set to true it will be displayed in the channel box
        when the node is selected.Attributes are writable by default.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute is to be writable


        '''
        pass

    def setConnectable(self, state: bool): 
        '''
        setConnectable(self, state: bool)

        Synopsis
        -----
        Sets whether this attribute should allow dependency graph
        connections. This should only get called in the initialize call
        of your node creator.Attributes are connectable by default.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute is to be connectable


        '''
        pass

    def setStorable(self, state: bool): 
        '''
        setStorable(self, state: bool)

        Synopsis
        -----
        Sets whether this attribute should be storable. If an attribute
        is storable, then it will be writen out when the node is stored
        to a file. This should only get called in the initialize call of
        your node creator.Attributes are storable by default.NOTE: Typed
        attributes of setting MFnData::kDynArrayAttrs are not storable.
        Message attribute are also not storable.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute is to be storable


        '''
        pass

    def setCached(self, state: bool): 
        '''
        setCached(self, state: bool)

        Synopsis
        -----
        Sets whether the data for this attribute is cached locally in the
        node's data block. The default for this is true. Caching a node
        locally causes a copy of the attribute value for the node to be
        cached with the node. This removes the need to traverse through
        the graph to get the value each time it is requested. This should
        only get called in the initialize call of your node
        creator.Caching the value locally gives a speed increase at the
        cost of more memory.Attributes are cached by default.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute is to be cached locally


        '''
        pass

    def setArray(self, state: bool): 
        '''
        setArray(self, state: bool)

        Synopsis
        -----
        Sets whether this attribute should have an array of data. This
        should be set to true if the attribute needs to accept multiple
        incoming connections.Attributes are single elements by default.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute is to have an array of data


        '''
        pass

    def setIndexMatters(self, state: bool): 
        '''
        setIndexMatters(self, state: bool)

        Synopsis
        -----
        If the attribute is an array, then this method specifies whether
        to force the user to specify an index when connecting to this
        attribute, or to use the next available index. This corresponds
        with the connectAttr command's -na/nextAvailable flag. If the
        destination attribute has set the indexMatters to be false with
        this flag specified, a connection is made to the next available
        index. No index need be specifiedThis method will only affect
        array attributes with setReadable set to false, i.e. destination
        attributes.The index matters to attributes by default.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute's index must be specified when connecting to this attribute using the connectAttr command


        '''
        pass

    def setKeyable(self, state: bool): 
        '''
        setKeyable(self, state: bool)

        Synopsis
        -----
        Sets whether this attribute should accept keyframe data. This
        should only get called in the initialize call of your node
        creator. Keyable attributes will be keyed by AutoKey and the Set
        Keyframe UI. Non-keyable attributes prevent the user from setting
        keys via the obvious UI provided for keying. Being non-keyable is
        not a hard block against adding keys to an attribute.This method
        changes the default state of a plug. The keyability of a specific
        plug can be changed using the MPlug::setKeyable method.If both
        keyable and writable for an attribute are set to true it will be
        displayed in the channel box when the node is selected.Attributes
        are not keyable by default.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute is to be keyable


        '''
        pass

    def setChannelBox(self, state: bool): 
        '''
        setChannelBox(self, state: bool)

        Synopsis
        -----
        Sets whether this attribute should appear in the channel box when
        the node is selected. This should only get called in the
        initialize call of your node creator. Keyable attributes are
        always shown in the channel box so this flag is ignored on
        keyable attributes. It is for intended for use on non-keyable
        attributes which you want to appear in the channel box.This
        method changes the default state of a plug. Channel box
        visibility for a specific plug can be changed using the
        MPlug::setChannelBox method.Attributes are not in the channel box
        by default unless they are keyable.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute is to appear in the channel box


        '''
        pass

    def setHidden(self, state: bool): 
        '''
        setHidden(self, state: bool)

        Synopsis
        -----
        Sets whether this attribute should be hidden from the UI. This is
        useful if the attribute is being used for blind data, or if it is
        being used as scratch space for a geometry calculation (should
        also be marked non-connectable in that case).Attributes are not
        hidden by default.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute is to be hidden


        '''
        pass

    def setUsedAsColor(self, state: bool): 
        '''
        setUsedAsColor(self, state: bool)

        Synopsis
        -----
        Sets whether this attribute should be presented as a color in the
        UI.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute is to be presented as a color


        '''
        pass

    def setIndeterminant(self, state: bool): 
        '''
        setIndeterminant(self, state: bool)

        Synopsis
        -----
        Sets whether this attribute is indeterminant. If an attribute may
        or may not be used during an evaluation then it is indeterminant.
        This attribute classification is mainly used on rendering nodes
        to indicate that some attributes are not always used.Attributes
        are not indeterminant by default.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute indeterminant


        '''
        pass

    def setRenderSource(self, state: bool): 
        '''
        setRenderSource(self, state: bool)

        Synopsis
        -----
        Sets whether this attribute should be used as a render source
        attribute. When writing shader plug-ins, it is sometimes useful
        to be able to modify the sampler info, so upstream shading
        network can be re- evaluated with different sampler info
        values.For example, if a shading node takes a 2D texture as
        input, the result color of the 2D texture is evaluated at the
        current sample's UV coordinates. Initializing uvCoords attributes
        as render source and modifing the U and V values, then setting it
        as output will modify the sampler info. Re-evaluating the input
        plug will cause the 2D texture to re-evaluate with the new U and
        V values, and return a different color to the shading node.Only
        valid Maya rendering attributes can be set to render source.The
        following code example demonstrates how this is
        done:initialize()...creates attributes for uvCoord and set them
        to be render sourceu = nAttr.create( "uCoord", "u",
        MFnNumericData::kFloat, 0.0 ); nAttr.setStorable(false);
        nAttr.setWritable(true); nAttr.setRenderSource(true); v =
        nAttr.create( "vCoord", "v", MFnNumericData::kFloat, 0.0 );
        nAttr.setStorable(false); nAttr.setWritable(true);
        nAttr.setRenderSource(true); uv = nAttr.create( "uvCoord", "uv",
        u, v ); nAttr.setStorable(false); nAttr.setWritable(true);
        nAttr.setRenderSource(true);need to have the output uv affect the
        input uv because we want the new uv values we set to cause other
        inputs to this node to evaluateattributeAffects ( uv, uv
        );...compute()...get uv coordinates from the samplerMDataHandle
        uH = data.inputValue( u, &stat); MDataHandle vH =
        data.inputValue( v, &stat); float oldU = uH.asFloat(); float oldV
        = vH.asFloat();get shading color input at the current sampler's
        uv coordinatesMDataHandle colorH = data.inputValue( inColor,
        &stat); MFloatVector color = colorH.asFloatVector(); // color at
        the sampled uv locationevaluate input color at a different uv
        location:set output uv coordinates back to sampler this is only
        possible because we've set uv to be render sourceMDataHandle
        outUV = data.outputValue( uv ); outUV.set( oldU-0.01, oldV-0.01
        );get newly evaluated inColor at uv(oldU-0.01, oldV-0.01)any
        shading node connected to inColor will get uvCoord values as
        we've supplied. Calling data.inputValue( inColor, &stat) causes
        it to re-evaluate the network again with the new uvCoord
        values.colorH = data.inputValue( inColor, &stat); // evaluate
        again color = colorH.asFloatVector(); // color at the new uv
        location...outUV.set( oldU, oldV ); // set the values back before
        we exit...

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute is to be a render source


        '''
        pass

    def setWorldSpace(self, state: bool): 
        '''
        setWorldSpace(self, state: bool)

        Synopsis
        -----
        Sets whether this attribute should be treated as worldspace.
        Being worldspace indicates the attribute is dependent on the
        worldSpace transformation of this node, and will be marked dirty
        by any attribute changes in the hierarchy that affects the
        worldSpace transformation. The attribute needs to be an array
        since during instancing there are multiple worldSpace paths to
        the node & Maya requires one array element per path for
        worldSpace attributes.NOTES: 1. Can only be used on array
        attributes. 2. This property is ignored on non-dag nodes. 3. The
        attribute should be affected by another attribute or have a
        connection. Otherwise, the attribute will not get computed and
        will not get dirty again.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute is to be presented as worldspace


        '''
        pass

    def setAffectsWorldSpace(self, state: bool): 
        '''
        setAffectsWorldSpace(self, state: bool)

        Synopsis
        -----
        Sets whether this attribute should affect worldspace. NOTES: This
        property is ignored on non-dag nodes.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute should affect worldspace


        '''
        pass

    def setUsedAsFilename(self, state: bool): 
        '''
        setUsedAsFilename(self, state: bool)

        Synopsis
        -----
        Sets whether this attribute should be presented as a filename in
        the UI.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute is to be presented as a filename


        '''
        pass

    def setAffectsAppearance(self, state: bool): 
        '''
        setAffectsAppearance(self, state: bool)

        Synopsis
        -----
        Sets whether this attribute affects the appearance of the object
        when rendering in the viewport.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute affects the appearance of the object when rendering in the viewport.


        '''
        pass

    def setProxyAttribute(self, state: bool): 
        '''
        setProxyAttribute(self, state: bool)

        Synopsis
        -----
        Sets whether this attribute is a proxy attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute is a proxy attribute.


        '''
        pass

    def setDisconnectBehavior(self, behavior: MFnAttribute.MFnAttribute): 
        '''
        setDisconnectBehavior(self, behavior: MFnAttribute.MFnAttribute)

        Synopsis
        -----
        Sets the disconnection behavior for this attribute. This
        determines what happens when a connection to this attribute is
        deleted. This should only get called in the initialize call of
        your node creator.The settings are as follows:Attributes have a
        default disconnect behavior of kNothing.If the kDelete behaviour
        is set on an array attribute which is a compound, that will only
        handle the case where the connection is to the parent attribute
        not to its children. So breaking a connection to an element of
        the parent (e.g. node.parent[3]) would cause that element to be
        removed, but breaking a connection to a child (e.g.
        node.parent[3].child) would leave the element intact, even if it
        was the last such connection.To have the parent array element
        deleted when the last connection to a child is broken, you must
        set the kDelete behaviour on the connectable children as well.

        Returns:
        -----
        None

        Parameters:
        -----
        behavior: MFnAttribute.MFnAttribute
        	[in] -> the new disconnect behavior


        '''
        pass

    def setUsesArrayDataBuilder(self, state: bool): 
        '''
        setUsesArrayDataBuilder(self, state: bool)

        Synopsis
        -----
        Sets whether this attribute uses an array data builder. If true,
        then the MArrayDataBuilder class may be used with this attribute
        to generate its data. If false, MArrayDataHandle::builder will
        fail.By default array attributes do not use an array data
        builder.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute uses an array data builder


        '''
        pass

    def setInternal(self, state: bool): 
        '''
        setInternal(self, state: bool)

        Synopsis
        -----
        The function controls an attribute's data storage. When set to
        true, the virtual methods MPxNode::setInternalValue() and
        MPxNode::getInternalValue() are invoked whenever the attribute
        value is set or queried, respectively. By default, attributes are
        not internal.There are two reasons to set an attribute as
        'internal'. The first, and simplest, is when you want
        notification that the attribute has been set, or queried. This
        allows you to invoke some related action. In this case
        getInternalValue() and setInternalValue() should return false to
        indicate that Maya can store the attribute's value in the data
        block, instead of your own custom structure.The second use of
        internal attributes is to store the data in a structure other
        than the datablock. When MPxNode::setInternalValue() is called,
        the attribute's data can be transferred into your custom data
        structure. When getInternalValue( you can return your data. In
        this case getInternalValue() and setInternalValue() should return
        true to indicate that Maya should not store the attribute's value
        in the data block but use your own custom structure instead.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> whether the attribute uses internal data


        '''
        pass

    def setNiceNameOverride(self, localizedName: MString): 
        '''
        setNiceNameOverride(self, localizedName: MString)

        Synopsis
        -----
        Sets the localized string which should be used for this attribute
        in the UI. The name given to an attribute when it is created is
        the name used to refer to it when the scene is written to a file.
        To ensure that the scene file is readable across all locales it
        is essential that the attribute have the same name in all
        locales. So if it's called 'keyLight' in an English locale then
        it must also be called 'keyLight' in French and Chinese
        locales.The setNiceNameOverride() method provides a means for
        associating a more user-friendly name with the attribute, one
        which can change to accomodate the user's locale. If such a name
        is present then Maya will use it instead of the attribute's fixed
        name when displaying the attribute in various UI elements such as
        the Channel Box.

        Returns:
        -----
        None

        Parameters:
        -----
        localizedName: MString
        	[in] -> The name to use for the current locale.


        '''
        pass

    def acceptsAttribute(self, attr: MFnAttribute,
                        ReturnStatus: MFnAttribute.MStatus): 
        '''
        acceptsAttribute(self, attr: MFnAttribute,
                        ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute can accept a connection with the
        given attribute.

        Returns: 
        ----- 
        A boolean value indicating whether a connection with that
        attribute is valid

        Parameters:
        -----
        attr: MFnAttribute
        	[in] -> attribute 

        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def accepts(self, type: MFnData.MFnData,
                        ReturnStatus: MFnAttribute.MStatus): 
        '''
        accepts(self, type: MFnData.MFnData,
                        ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute can accept a connection of the
        given type.

        Returns: 
        ----- 
        A boolean value indicating whether a connection of that type is
        valid

        Parameters:
        -----
        type: MFnData.MFnData
        	[in] -> data type 

        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def accepts(self, id: MTypeId,
                        ReturnStatus: MFnAttribute.MStatus): 
        '''
        accepts(self, id: MTypeId,
                        ReturnStatus: MFnAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this attribute can accept a connection of the
        given type.

        Returns: 
        ----- 
        A boolean value indicating whether a connection of that type is
        valid

        Parameters:
        -----
        id: MTypeId
        	[in] -> data type id 

        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def parent(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        parent(self, ReturnStatus: MFnAttribute.MStatus) -> MObject

        Synopsis
        -----
        Get the parent of this attribute, if it has one.

        Returns: 
        ----- 
        The parent attribute

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def name(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        name(self, ReturnStatus: MFnAttribute.MStatus) -> MString

        Synopsis
        -----
        Returns the long name of the attribute. If the attribute has no
        long name then its short name is returned.

        Returns: 
        ----- 
        The name of the attribute.

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> The status of the resulting operation.


        '''
        pass

    def shortName(self, ReturnStatus: MFnAttribute.MStatus): 
        '''
        shortName(self, ReturnStatus: MFnAttribute.MStatus) -> MString

        Synopsis
        -----
        Returns the short name of the attribute. If the attribute has no
        short name then its long name is returned.

        Returns: 
        ----- 
        The name of the attribute.

        Parameters:
        -----
        ReturnStatus: MFnAttribute.MStatus
        	[out] -> The status of the resulting operation.


        '''
        pass

    def getAddAttrCmd(self, useLongName: bool,
                        status: MFnAttribute.MStatus): 
        '''
        getAddAttrCmd(self, useLongName: bool,
                        status: MFnAttribute.MStatus) -> MString

        Synopsis
        -----
        Returns a string containing the addAttr command which would be
        required to recreate the attribute on a node. The command
        includes the terminating semicolon and is formatted as if for use
        with a selected node, meaning that it contains no node name.To
        get the addAttr commands for a compound attribute and its
        children, use MFnCompoundAttribute::getAddAttrCmds.

        Returns: 
        ----- 
        Return status

        Parameters:
        -----
        useLongName: bool
        	[in] -> if true, use the attribute's long name rather than its short name 

        status: MFnAttribute.MStatus
        	[out] -> The status of the resulting operation. 


        '''
        pass

    def addToCategory(self, category: MString): 
        '''
        addToCategory(self, category: MString)

        Synopsis
        -----
        Add the attribute to the named category. Attributes can be
        associated with different categories to facilitate grouping
        related concepts. For example, these categories could be queried
        at runtime to customize the UI.

        Returns:
        -----
        None

        Parameters:
        -----
        category: MString
        	[in] -> New category to which the attribute is to be added 


        '''
        pass

    def removeFromCategory(self, category: MString): 
        '''
        removeFromCategory(self, category: MString)

        Synopsis
        -----
        Remove the attribute from the named category. Presumes membership
        in the named category and fails if that's not true.

        Returns:
        -----
        None

        Parameters:
        -----
        category: MString
        	[in] -> Category from which the attribute is to be removed 


        '''
        pass

    def hasCategory(self, category: MString): 
        '''
        hasCategory(self, category: MString) -> bool

        Synopsis
        -----
        Check to see if the attribute belongs to the named category.
        Matching is done solely on the string so multiple categories with
        the same name will not be unique.

        Returns: 
        ----- 
        True if the attribute belongs to that category

        Parameters:
        -----
        category: MString
        	[in] -> Category to check for attribute membership 


        '''
        pass

    def getCategories(self, categories: MStringArray): 
        '''
        getCategories(self, categories: MStringArray)

        Synopsis
        -----
        Get all of the categories to which this attribute belongs.

        Returns:
        -----
        None

        Parameters:
        -----
        categories: MStringArray
        	[out] -> An 


        '''
        pass

class DisconnectBehavior:
    '''Attribute behaviour on disconnect. 
    Non-functional class.  Values for this enum:
    kDelete
    kReset
    kNothing
    '''

    def __init__(self):
        pass

    def kDelete(self):
        '''This is an enum of DisconnectBehavior.
        - Description: Delete array element (array attributes only). 
        - Value: 0
        '''
        pass

    def kReset(self):
        '''This is an enum of DisconnectBehavior.
        - Description: Reset the attribute to its default. 
        - Value: 1
        '''
        pass

    def kNothing(self):
        '''This is an enum of DisconnectBehavior.
        - Description: Do nothing to the attribute's value. 
        - Value: 2
        '''
        pass

class MFnBase:
    '''Function Set Base Class.
Defines the interface for the API RTTI and Maya Object attachment
methods common to all Function Set Classes.
Implements the Function Set compatibility test methods for all
Function Sets.
The API provides access to Maya Objects as generic MObjects.
Under the C++ class scheme MObjects simply have type
MObject with no base or derived hierarchy. However, MObjects may be many
different types of model or scene objects, from Attributes to
Transforms, within Maya. This allows many different types of
objects to be moved across or accessed through the API without
undue concern on the part of plug-in developers for the type of
object being manipulated.
Since it is impractical to provide every applicable method on
MObjects, the methods applicable to Maya Objects are encapsulated
in Function Sets. Function Sets can be attached to compatible
MObjects to provide an external interface to methods appropriate
to that
MObject. All Function Sets provide a method
setObject() which attaches them to the specified Maya Object. Additionally,
most Function Sets provide a version of their constructor which
attaches the new Function Set to a specified
MObject.
The link between an
MObject and the role it performs as a Maya scene or model object, as
well as the compatibility between MObjects and Function Sets is
managed by the API Run-Time Type Identification (RTTI) system.
The two key concepts of this system are the Maya Object type and
the Function Set type (both are
MFn::Type). All MObjects have one and only one Maya Object type. All
Function Sets have one and only one Function Set type. MObjects
may, however, be compatible with many types of Function Sets.
This compatibility follows the class hierarchy of the Function
Sets. Thus an
MObject with Maya Object type
MFn::kNurbsSurface would be compatible with
MFnNurbsSurface,
MFnDagNode,
MFnDependencyNode, MFnNamedObject and
MFnBase.
Any
MObject can be queried with the
MObject::hasFn() method to determine if it is comaptible with a given Function
Set.
The purpose of the Base Function Set (
MFnBase) is to provide methods for determining whether or not a Function
Set is compatible with a given Maya Object (
MObject) type (
MFn::Type) or a specific
MObject. See: MFnBase::hasObj(MFn::Type) and MFnBase::hasObj(const
MObject &)
As well, this Function Set provides virtual methods for
determining the type of a Function Set under the API RTTI system.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Determines the type of the Function Set within the API RTTI
        system. Reimplemented in MFnAnimCurve, MFnSubd, MFnMesh,
        MFnTransform, MFnFalloffData, MFnNurbsSurface, MFnPlugin,
        MFnNurbsCurve, MFnAssembly, MFnClip, MFnCharacter,
        MFnBlendShapeDeformer, MFnParticleSystem, MFnDagNode, MFnIkJoint,
        MFnPluginData, MFnAttribute, MFnLatticeDeformer,
        MFnNurbsSurfaceData, MFnComponent, MFnWeightGeometryFilter,
        MFnDynSweptGeometryData, MFnNurbsCurveData, MFnSet, MFnSubdData,
        MFnDependencyNode, MFnCompoundAttribute, MFnData, MFnMeshData,
        MFnMotionPath, MFnNumericAttribute, MFnLattice, MFnRotateManip,
        MFnScaleManip, MFnUnitAttribute, MFnDisplayLayerManager,
        MFnNumericData, MFnSkinCluster, MFnArrayAttrsData,
        MFnDisplayLayer, MFnDoubleArrayData, MFnFloatArrayData,
        MFnKeyframeDeltaTangent, MFnCameraSet, MFnGenericAttribute,
        MFnSphereData, MFnFloatVectorArrayData, MFnFluid,
        MFnFreePointTriadManip, MFnGeometryData, MFnGeometryFilter,
        MFnImageSource, MFnKeyframeDelta, MFnKeyframeDeltaBlockAddRemove,
        MFnNIdData, MFnUintArrayData, MFnMatrixData, MFnPartition,
        MFnReference, MFnSpotLight, MFnWireDeformer,
        MFnComponentListData, MFnIntArrayData, MFnKeyframeDeltaInfType,
        MFnLayeredShader, MFnMatrixArrayData, MFnPhongEShader,
        MFnPointArrayData, MFnStringArrayData, MFnStringData,
        MFnToggleManip, MFnTypedAttribute, MFnUInt64ArrayData,
        MFnVectorArrayData, MFnAnisotropyShader, MFnCamera,
        MFnContainerNode, MFnExpression, MFnHikEffector,
        MFnLambertShader, MFnReflectShader, MFnDirectionManip,
        MFnDistanceManip, MFnIkEffector, MFnIkSolver, MFnLatticeData,
        MFnManip3D, MFnMessageAttribute, MFnRenderPass, MFnStateManip,
        MFnToolContext, MFnCircleSweepManip, MFnCurveSegmentManip,
        MFnDragField, MFnLight, MFnNewtonField, MFnNonAmbientLight,
        MFnNonExtendedLight, MFnPointOnCurveManip,
        MFnPointOnSurfaceManip, MFnRadialField, MFnRenderLayer,
        MFnStandardSurfaceShader, MFnVortexField, MFnAmbientLight,
        MFnAreaLight, MFnDirectionalLight, MFnDiscManip,
        MFnDoubleIndexedComponent, MFnGravityField, MFnKeyframeDeltaMove,
        MFnLightDataAttribute, MFnPfxGeometry, MFnPointLight,
        MFnSingleIndexedComponent, MFnTripleIndexedComponent,
        MFnTurbulenceField, MFnUint64SingleIndexedComponent,
        MFnUniformField, MFnVolumeAxisField, MFnVolumeLight, MFnAirField,
        MFnBlinnShader, MFnField, MFnIkHandle, MFnPhongShader,
        MFnEnumAttribute, MFnInstancer, MFnKeyframeDeltaAddRemove,
        MFnKeyframeDeltaScale, MFnMatrixAttribute,
        MFnKeyframeDeltaBreakdown, MFnKeyframeDeltaWeighted, and
        MFnNObjectData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def hasObj(self, mtype: MFn.MFn): 
        '''
        hasObj(self, mtype: MFn.MFn) -> bool

        Synopsis
        -----
        Determines whether or not the Function Set is compatible with the
        specified Maya Object within the API RTTI system.

        Returns: 
        ----- 
        true = Compatible  false = Not Compatible

        Parameters:
        -----
        mtype: MFn.MFn
        	[in] -> Maya Object type


        '''
        pass

    @overload
    def hasObj(self, object: MObject): 
        '''
        hasObj(self, object: MObject) -> bool

        Synopsis
        -----
        Determines whether or not the Function Set is compatible with the
        specified Maya Object within the API RTTI system.

        Returns: 
        ----- 
        true = Compatible  false = Not Compatible

        Parameters:
        -----
        object: MObject
        	[in] -> Maya Object to be tested for compatibility


        '''
        pass

    def object(self, ReturnStatus: MFnBase.MStatus): 
        '''
        object(self, ReturnStatus: MFnBase.MStatus) -> MObject

        Synopsis
        -----
        Returns the MObject that is attached to the Function Set.

        Returns: 
        ----- 
        An MObject that references the object to which the Function Set
        is attached. If the function set is not attached to an MObject,
        MObject::kNullObj will be returned.

        Parameters:
        -----
        ReturnStatus: MFnBase.MStatus
        	[in] -> Status Code (see below)


        '''
        pass

    def setObject(self, object: MObject): 
        '''
        setObject(self, object: MObject)

        Synopsis
        -----
        Attaches the Function Set to the specified Maya Object.
        Reimplemented in MFnDagNode.

        Returns:
        -----
        None

        Parameters:
        -----
        object: MObject
        	[in] -> Maya Object which is the target for attachment


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def typeString(self, mtype: MFn.MFn): 
        '''
        typeString(self, mtype: MFn.MFn) -> char*

        Synopsis
        -----
        Introduced in 2020.0 Returns the type string for a given type.

        Returns: 
        ----- 
        Type string.

        Parameters:
        -----
        mtype: MFn.MFn
        	[in] -> Maya Object type


        '''
        pass

    def isValid(self, mtype: MFn.MFn): 
        '''
        isValid(self, mtype: MFn.MFn) -> bool

        Synopsis
        -----
        Introduced in 2020.0 Returns true if type is in the range of
        valid types.

        Returns: 
        ----- 
        Type string.

        Parameters:
        -----
        mtype: MFn.MFn
        	[in] -> Maya Object type


        '''
        pass

class MFnBlinnShader:
    '''Manage Blinn shaders.
MFnBlinnShader facilitates creation and manipulation of dependency graph nodes
representing Blinn shaders.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kBlinn.Reimplemented from MFnReflectShader.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnBlinnShader.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnBlinnShader".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, UIvisible: bool,
                        ReturnStatus: MFnBlinnShader.MStatus): 
        '''
        create(self, UIvisible: bool,
                        ReturnStatus: MFnBlinnShader.MStatus) -> MObject

        Synopsis
        -----
        Creates a new blinn shader dependency graph node and adds it to
        the dependency graph. If the UIvisible parameter is true, the new
        node will be connected to the shader classification node (which
        allows the UI to recognize the node as a shader). If UIvisible is
        false, the node will be created in isolation.

        Returns: 
        ----- 
        MObject representing the new dependency node.

        Parameters:
        -----
        UIvisible: bool
        	[in] -> determines whether or not the new node will be connected to the shader classification node. 

        ReturnStatus: MFnBlinnShader.MStatus
        	[out] -> return status


        '''
        pass

    def eccentricity(self, ReturnStatus: MFnBlinnShader.MStatus): 
        '''
        eccentricity(self, ReturnStatus: MFnBlinnShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "eccentricity" attribute of a blinn
        shader node. This attribute determines the size of the highlight
        produced by the shader.

        Returns: 
        ----- 
        The value of the "eccentricity" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnBlinnShader.MStatus
        	[out] -> return status


        '''
        pass

    def setEccentricity(self, eccentr: float): 
        '''
        setEccentricity(self, eccentr: float)

        Synopsis
        -----
        Sets the value of the "eccentricity" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        eccentr: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def specularRollOff(self, ReturnStatus: MFnBlinnShader.MStatus): 
        '''
        specularRollOff(self, ReturnStatus: MFnBlinnShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "specularRollOff" attribute of a blinn
        shader node. This attribute controls the increased oblique angle
        reflectivity of the shader.

        Returns: 
        ----- 
        The value of the "specularRollOff" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnBlinnShader.MStatus
        	[out] -> return status


        '''
        pass

    def setSpecularRollOff(self, specular_rolloff: float): 
        '''
        setSpecularRollOff(self, specular_rolloff: float)

        Synopsis
        -----
        Sets the value of the "specularRollOff" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        specular_rolloff: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

class MFnCamera:
    '''Function set for cameras.
Function set for creation, edit, and query of cameras.
Many of the camera settings only affect the resulting rendered
image. E.g. the F/Stop, shutter speed, the film related options,
etc.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kCamera.Reimplemented from MFnDagNode.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> staticchar*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def create(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        create(self, ReturnStatus: MFnCamera.MStatus) -> MObject

        Synopsis
        -----
        Creates a perspective camera and a transform to parent it. The
        camera is positioned at (0, 0, 0), its center of interest at (0,
        0, -1), which implies that the view-direction is pointing in the
        direction of the negative z-axis, and its up-direction along the
        positive Y axis.

        Returns: 
        ----- 
        The transform parenting the new camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def create(self, parent: MObject,
                        ReturnStatus: MFnCamera.MStatus): 
        '''
        create(self, parent: MObject,
                        ReturnStatus: MFnCamera.MStatus) -> MObject

        Synopsis
        -----
        Creates a perspective camera. A parent can be specified for the
        new camera, otherwise a transform is created.The camera is
        positioned at (0, 0, 0), its center of interest at (0, 0, -1),
        which implies that the view-direction is pointing in the
        direction of the negative z-axis, and its up-direction along the
        positive Y axis.

        Returns: 
        ----- 
        The transform parenting the new camera

        Parameters:
        -----
        parent: MObject
        	[in] -> The parent of the new camera 

        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def eyePoint(self, space: MSpace.MSpace,
                        ReturnStatus: MFnCamera.MStatus): 
        '''
        eyePoint(self, space: MSpace.MSpace,
                        ReturnStatus: MFnCamera.MStatus) -> MPoint

        Synopsis
        -----
        Returns the eye point for the camera.

        Returns: 
        ----- 
        The eye point location for the camera

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation 

        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def viewDirection(self, space: MSpace.MSpace,
                        ReturnStatus: MFnCamera.MStatus): 
        '''
        viewDirection(self, space: MSpace.MSpace,
                        ReturnStatus: MFnCamera.MStatus) -> MVector

        Synopsis
        -----
        Returns the view direction for the camera.

        Returns: 
        ----- 
        The view direction vector for the camera

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation 

        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def upDirection(self, space: MSpace.MSpace,
                        ReturnStatus: MFnCamera.MStatus): 
        '''
        upDirection(self, space: MSpace.MSpace,
                        ReturnStatus: MFnCamera.MStatus) -> MVector

        Synopsis
        -----
        Returns the up direction vector for the camera.

        Returns: 
        ----- 
        The up direction vector for this camera

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation 

        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def rightDirection(self, space: MSpace.MSpace,
                        ReturnStatus: MFnCamera.MStatus): 
        '''
        rightDirection(self, space: MSpace.MSpace,
                        ReturnStatus: MFnCamera.MStatus) -> MVector

        Synopsis
        -----
        Returns the right direction vector for the camera.

        Returns: 
        ----- 
        The right direction vector for the camera

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation 

        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def centerOfInterestPoint(self, space: MSpace.MSpace,
                        ReturnStatus: MFnCamera.MStatus): 
        '''
        centerOfInterestPoint(self, space: MSpace.MSpace,
                        ReturnStatus: MFnCamera.MStatus) -> MPoint

        Synopsis
        -----
        Returns the center of interest point for the camera.

        Returns: 
        ----- 
        The center of interest location of the camera

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation 

        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def set(self, wsEyeLocation: MPoint,
                        wsViewDirection: MVector,
                        wsUpDirection: MVector,
                        horizFieldOfView: double,
                        aspectRatio: double): 
        '''
        set(self, wsEyeLocation: MPoint,
                        wsViewDirection: MVector,
                        wsUpDirection: MVector,
                        horizFieldOfView: double,
                        aspectRatio: double)

        Synopsis
        -----
        Convenience routine to set the camera viewing parameters. The
        specified values should be in world space where applicable.This
        method will only work when the world space information for the
        camera is available, i.e. when the function set has been
        initialized with a DAG path.

        Returns:
        -----
        None

        Parameters:
        -----
        wsEyeLocation: MPoint
        	[in] -> Eye location to set in world space 

        wsViewDirection: MVector
        	[in] -> View direction to set in world space 

        wsUpDirection: MVector
        	[in] -> Up direction to set in world space 

        horizFieldOfView: double
        	[in] -> The horizontal field of view to set 

        aspectRatio: double
        	[in] -> The aspect ratio to set


        '''
        pass

    def setEyePoint(self, eyeLocation: MPoint,
                        space: MSpace.MSpace): 
        '''
        setEyePoint(self, eyeLocation: MPoint,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Positions the eye-point of the camera keeping the center of
        interest fixed in space. This method changed the orientation and
        translation of the camera's transform attributes as well as the
        center-of-interest distance.This method will only work when the
        world space information for the camera is available, i.e. when
        the function set has been initialized with a DAG path.

        Returns:
        -----
        None

        Parameters:
        -----
        eyeLocation: MPoint
        	[in] -> The eye location to set 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def setCenterOfInterestPoint(self, centerOfInterest: MPoint,
                        space: MSpace.MSpace): 
        '''
        setCenterOfInterestPoint(self, centerOfInterest: MPoint,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Positions the center-of-interest of the camera keeping the eye-
        point fixed in space. This method changed the orientation and
        translation of the camera's transform attributes as well as the
        center-of-interest distance.This method will only work when the
        world space information for the camera is available, i.e. when
        the function set has been initialized with a DAG path.

        Returns:
        -----
        None

        Parameters:
        -----
        centerOfInterest: MPoint
        	[in] -> Center of interest point to be set 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def hasSamePerspective(self, otherCamera: MDagPath,
                        ReturnStatus: MFnCamera.MStatus): 
        '''
        hasSamePerspective(self, otherCamera: MDagPath,
                        ReturnStatus: MFnCamera.MStatus) -> bool

        Synopsis
        -----
        Returns true if the camera has same perspective settings as the
        given camera. This method will only work when the world space
        information for the camera is available, i.e. when the function
        set has been initialized with a DAG path.

        Returns: 
        ----- 
        True if the specified camera has same perspective as this camera,
        false otherwise.

        Parameters:
        -----
        otherCamera: MDagPath
        	[in] -> Camera to compare perspective with 

        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def copyViewFrom(self, otherCamera: MDagPath): 
        '''
        copyViewFrom(self, otherCamera: MDagPath)

        Synopsis
        -----
        Copy the camera settings related to the perspective from the
        given camera view. This method will only work when the world
        space information for the camera is available, i.e. when the
        function set has been initialized with a DAG path.

        Returns:
        -----
        None

        Parameters:
        -----
        otherCamera: MDagPath
        	[in] -> Camera to copy view from


        '''
        pass

    @overload
    def getFilmFrustum(self, distance: double,
                        hSize: double,
                        vSize: double,
                        hOffset: double,
                        vOffset: double,
                        applyPanZoom: bool): 
        '''
        getFilmFrustum(self, distance: double,
                        hSize: double,
                        vSize: double,
                        hOffset: double,
                        vOffset: double,
                        applyPanZoom: bool)

        Synopsis
        -----
        Returns the film frustum for the camera. The frustum defines the
        projective transformation.

        Returns:
        -----
        None

        Parameters:
        -----
        distance: double
        	[in] -> Specifies the focal length 

        hSize: double
        	[out] -> storage for horizontal size 

        vSize: double
        	[out] -> storage for vertical size 

        hOffset: double
        	[out] -> storage for horizontal offset 

        vOffset: double
        	[out] -> storage for vertical offset 

        applyPanZoom: bool
        	[in] -> specifies whether to apply 2D pan/zoom


        '''
        pass

    def getPortFieldOfView(self, width: int,
                        height: int,
                        horizontalFOV: double,
                        verticalFOV: double): 
        '''
        getPortFieldOfView(self, width: int,
                        height: int,
                        horizontalFOV: double,
                        verticalFOV: double)

        Synopsis
        -----
        Compute the horizontal and vertical field of view in radians from
        the given viewport width and height.

        Returns:
        -----
        None

        Parameters:
        -----
        width: int
        	[in] -> width of viewport 

        height: int
        	[in] -> height of viewport 

        horizontalFOV: double
        	[out] -> storage for the horizonal field of view 

        verticalFOV: double
        	[out] -> storage for the vertical field of view


        '''
        pass

    def getViewParameters(self, windowAspect: double,
                        apertureX: double,
                        apertureY: double,
                        offsetX: double,
                        offsetY: double,
                        applyOverscan: bool,
                        applySqueeze: bool,
                        applyPanZoom: bool): 
        '''
        getViewParameters(self, windowAspect: double,
                        apertureX: double,
                        apertureY: double,
                        offsetX: double,
                        offsetY: double,
                        applyOverscan: bool,
                        applySqueeze: bool,
                        applyPanZoom: bool)

        Synopsis
        -----
        Computes and returns the intermediate viewing frustum parameters
        for the camera. The aperture and offset are used by
        getViewingFrustrum() and getRenderingFrustrum() to compute the
        extent (left, right, top, bottom) of the frustrum in the
        following manner:Here, focal_to_near is equal to cameraScale() if
        the camera is orthographic, or it is equal to
        ((nearClippingPlane() / (focalLength() * MM_TO_INCH)) *
        cameraScale()) where MM_TO_INCH equals 0.03937.

        Returns:
        -----
        None

        Parameters:
        -----
        windowAspect: double
        	[in] -> windowAspect 

        apertureX: double
        	[out] -> storage for the horizontal aperture 

        apertureY: double
        	[out] -> storage for the vertical aperture 

        offsetX: double
        	[out] -> storage for the horizontal offset 

        offsetY: double
        	[out] -> storage for the vertical offset 

        applyOverscan: bool
        	[in] -> specifies whether to apply overscan 

        applySqueeze: bool
        	[in] -> specifies whether to apply the lens squeeze ratio of the camera 

        applyPanZoom: bool
        	[in] -> specifies whether to apply 2D pan/zoom


        '''
        pass

    def getViewingFrustum(self, windowAspect: double,
                        left: double,
                        right: double,
                        bottom: double,
                        top: double,
                        applyOverscan: bool,
                        applySqueeze: bool,
                        applyPanZoom: bool): 
        '''
        getViewingFrustum(self, windowAspect: double,
                        left: double,
                        right: double,
                        bottom: double,
                        top: double,
                        applyOverscan: bool,
                        applySqueeze: bool,
                        applyPanZoom: bool)

        Synopsis
        -----
        Computes and returns the viewing frustum for the camera.

        Returns:
        -----
        None

        Parameters:
        -----
        windowAspect: double
        	[in] -> windowAspect 

        left: double
        	[out] -> storage for the left side of frustum 

        right: double
        	[out] -> storage for the right side of frustum 

        bottom: double
        	[out] -> storage for the bottom of frustum 

        top: double
        	[out] -> storage for the top of frustum 

        applyOverscan: bool
        	[in] -> specifies whether to apply overscan 

        applySqueeze: bool
        	[in] -> specifies whether to apply the lens squeeze ratio of the camera 

        applyPanZoom: bool
        	[in] -> specifies whether to apply 2D pan/zoom


        '''
        pass

    def getRenderingFrustum(self, windowAspect: double,
                        left: double,
                        right: double,
                        bottom: double,
                        top: double): 
        '''
        getRenderingFrustum(self, windowAspect: double,
                        left: double,
                        right: double,
                        bottom: double,
                        top: double)

        Synopsis
        -----
        Computes and returns the rendering frustum for the camera. This
        is the frustum that the maya renderer uses.

        Returns:
        -----
        None

        Parameters:
        -----
        windowAspect: double
        	[in] -> windowAspect 

        left: double
        	[out] -> storage for the left side of frustum 

        right: double
        	[out] -> storage for the right side of frustum 

        bottom: double
        	[out] -> storage for the bottom of frustum 

        top: double
        	[out] -> storage for the top of frustum


        '''
        pass

    @overload
    def projectionMatrix(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        projectionMatrix(self, ReturnStatus: MFnCamera.MStatus) -> MFloatMatrix

        Synopsis
        -----
        Returns the orthographic or perspective projection matrix for the
        camera. The projection matrix that maya's software renderer uses
        is almost identical to the OpenGL projection matrix. The
        difference is that maya uses a left hand coordinate system and so
        the entries [2][2] and [3][2] are negated.

        Returns: 
        ----- 
        The projection matrix

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setHorizontalFilmAperture(self, hFilmAperture: double): 
        '''
        setHorizontalFilmAperture(self, hFilmAperture: double)

        Synopsis
        -----
        Change the horizontal size of the camera aperture. Unit used is
        inches.

        Returns:
        -----
        None

        Parameters:
        -----
        hFilmAperture: double
        	[in] -> Horizontal file aperture value to be set


        '''
        pass

    def horizontalFilmAperture(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        horizontalFilmAperture(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the horizontal film aperture for the camera.

        Returns: 
        ----- 
        The horizontal film aperture for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setVerticalFilmAperture(self, vFilmAperture: double): 
        '''
        setVerticalFilmAperture(self, vFilmAperture: double)

        Synopsis
        -----
        Change the vertical size of the camera aperture. Unit used is
        inches.

        Returns:
        -----
        None

        Parameters:
        -----
        vFilmAperture: double
        	[in] -> The vertical film aperture for the camera


        '''
        pass

    def verticalFilmAperture(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        verticalFilmAperture(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the vertical film aperture for the camera.

        Returns: 
        ----- 
        The vertical film aperture for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def getFilmApertureLimits(self, min: double,
                        max: double): 
        '''
        getFilmApertureLimits(self, min: double,
                        max: double)

        Synopsis
        -----
        Returns the maximum and minimum film aperture limits for the
        camera.

        Returns:
        -----
        None

        Parameters:
        -----
        min: double
        	[out] -> Storage for the minimum film aperture limit 

        max: double
        	[out] -> Storage for the maximum film aperture limit


        '''
        pass

    def setAspectRatio(self, aspectRatio: double): 
        '''
        setAspectRatio(self, aspectRatio: double)

        Synopsis
        -----
        Set the aspect ratio of the View. The aspect ratio is expressed
        as width/height. This also modifies the entity's scale
        transformation to reflect the new aspect ratio.

        Returns:
        -----
        None

        Parameters:
        -----
        aspectRatio: double
        	[in] -> The aspect ratio to be set


        '''
        pass

    def aspectRatio(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        aspectRatio(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the aspect ratio for the camera.

        Returns: 
        ----- 
        The aspect ratio

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def getAspectRatioLimits(self, min: double,
                        max: double): 
        '''
        getAspectRatioLimits(self, min: double,
                        max: double)

        Synopsis
        -----
        Returns the minimum and maximum aspect ratio limits for the
        camera.

        Returns:
        -----
        None

        Parameters:
        -----
        min: double
        	[out] -> Storage for the minimum aspect ratio limit 

        max: double
        	[out] -> Storage for the maximum aspect ratio limit


        '''
        pass

    def setVerticalLock(self, lockFlag: bool): 
        '''
        setVerticalLock(self, lockFlag: bool)

        Synopsis
        -----
        Sets the vertical lock to on or off for the camera.

        Returns:
        -----
        None

        Parameters:
        -----
        lockFlag: bool
        	[in] -> Vertical lock value to be set


        '''
        pass

    def isVerticalLock(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        isVerticalLock(self, ReturnStatus: MFnCamera.MStatus) -> bool

        Synopsis
        -----
        Determines if vertical lock is turned on for the camera.

        Returns: 
        ----- 
        True if the vertical lock is on, false otherwise.

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def horizontalFilmOffset(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        horizontalFilmOffset(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the horizontal offset of the film. Unit used is inches.

        Returns: 
        ----- 
        The horizontal film offset for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setHorizontalFilmOffset(self, hOffset: double): 
        '''
        setHorizontalFilmOffset(self, hOffset: double)

        Synopsis
        -----
        Change the horizontal offset of the film. Unit used is inches.

        Returns:
        -----
        None

        Parameters:
        -----
        hOffset: double
        	[in] -> The horizontal film offset value to be set


        '''
        pass

    def verticalFilmOffset(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        verticalFilmOffset(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Change the vertical offset of the film. Unit used is inches.

        Returns: 
        ----- 
        The vertical film offset for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setVerticalFilmOffset(self, vOffset: double): 
        '''
        setVerticalFilmOffset(self, vOffset: double)

        Synopsis
        -----
        Change the vertical offset of the film. Unit used is inches.

        Returns:
        -----
        None

        Parameters:
        -----
        vOffset: double
        	[in] -> The vertical film offset value to be set


        '''
        pass

    def shakeEnabled(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        shakeEnabled(self, ReturnStatus: MFnCamera.MStatus) -> bool

        Synopsis
        -----
        Returns the toggle value for the camera shake enabled attribute.
        If this attribute is false, the horizontalShake and verticalShake
        values are ignored by the camera.

        Returns: 
        ----- 
        The horizontal film-based camera shake toggle value for the
        camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setShakeEnabled(self, enabled: bool): 
        '''
        setShakeEnabled(self, enabled: bool)

        Synopsis
        -----
        Changes the toggle value for the camera shake enabled attribute.
        If this attribute is false, the horizontalShake and verticalShake
        values are ignored by the camera.

        Returns:
        -----
        None

        Parameters:
        -----
        enabled: bool
        	[in] -> The film-based camera shake toggle value to be set


        '''
        pass

    def horizontalShake(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        horizontalShake(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the horizontal offset of the film due to the shake
        attribute. Unit used is inches. This horizontal/vertical
        attribute pair acts identically to the film offset pair, but
        gives another point of input to that system. This allows film-
        based camera shake to be accessed conveniently and independently
        without disturbing any other film-offsetting techniques.

        Returns: 
        ----- 
        The horizontal film-based camera shake offset for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setHorizontalShake(self, hOffset: double): 
        '''
        setHorizontalShake(self, hOffset: double)

        Synopsis
        -----
        Change the horizontal film-based camera shake value. Unit used is
        inches.

        Returns:
        -----
        None

        Parameters:
        -----
        hOffset: double
        	[in] -> The horizontal film-based camera shake value to be set


        '''
        pass

    def verticalShake(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        verticalShake(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Change the vertical film-based camera shake value. Unit used is
        inches. This horizontal/vertical attribute pair acts identically
        to the film offset pair, but gives another point of input to that
        system. This allows film-based camera shake to be accessed
        conveniently and independently without disturbing any other film-
        offsetting techniques.

        Returns: 
        ----- 
        The vertical film-based camera shake value for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setVerticalShake(self, vOffset: double): 
        '''
        setVerticalShake(self, vOffset: double)

        Synopsis
        -----
        Changes the vertical film-based camera shake value. Unit used is
        inches.

        Returns:
        -----
        None

        Parameters:
        -----
        vOffset: double
        	[in] -> The vertical film-based camera shake value to be set


        '''
        pass

    def shakeOverscanEnabled(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        shakeOverscanEnabled(self, ReturnStatus: MFnCamera.MStatus) -> bool

        Synopsis
        -----
        Returns the toggle value for the camera shake overscan attribute.
        If this attribute is false, the shakeOverscan value is ignored by
        the camera.

        Returns: 
        ----- 
        The camera shake overscan toggle value for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setShakeOverscanEnabled(self, enabled: bool): 
        '''
        setShakeOverscanEnabled(self, enabled: bool)

        Synopsis
        -----
        Changes the toggle value for the camera shake overscan enabled
        attribute. If this attribute is false, the shakeOverscan value is
        ignored by the camera.

        Returns:
        -----
        None

        Parameters:
        -----
        enabled: bool
        	[in] -> The film-based camera shake overscan toggle value to be set


        '''
        pass

    def shakeOverscan(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        shakeOverscan(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the camera shake overscan value. Unit is a multiplier to
        the film aperture. This overscan is used to render a larger area
        than would be necessary if the camera were not shaking. This
        attribute will affect the output render.

        Returns: 
        ----- 
        The film-based camera shake overscan value for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setShakeOverscan(self, overscan: double): 
        '''
        setShakeOverscan(self, overscan: double)

        Synopsis
        -----
        Changes the camera shake overscan value. Unit is a multiplier to
        the film aperture size. This attribute will affect the output
        render.

        Returns:
        -----
        None

        Parameters:
        -----
        overscan: double
        	[in] -> The camera shake overscan value to be set


        '''
        pass

    def panZoomEnabled(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        panZoomEnabled(self, ReturnStatus: MFnCamera.MStatus) -> bool

        Synopsis
        -----
        Return the toggle value for the camera 2D pan/zoom enabled
        attribute. If this attribute is false, the 2D pan/zoom values are
        ignored by the camera.

        Returns: 
        ----- 
        The camera 2D pan/zoom toggle value for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setPanZoomEnabled(self, enabled: bool): 
        '''
        setPanZoomEnabled(self, enabled: bool)

        Synopsis
        -----
        Changes the toggle value for the camera 2D pan/zoom enabled
        attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        enabled: bool
        	[in] -> The camera 2D pan/zoom enabled toggle value to be set


        '''
        pass

    def renderPanZoom(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        renderPanZoom(self, ReturnStatus: MFnCamera.MStatus) -> bool

        Synopsis
        -----
        Return the toggle value for the camera render 2D pan/zoom
        attribute. If this attribute is false, the 2D pan/zoom values
        will not affect the output render.

        Returns: 
        ----- 
        The camera render 2D pan/zoom toggle value

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setRenderPanZoom(self, render: bool): 
        '''
        setRenderPanZoom(self, render: bool)

        Synopsis
        -----
        Changes the toggle value for the camera render 2D pan/zoom
        enabled attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        render: bool
        	[in] -> The camera render 2D pan/zoom toggle value to be set


        '''
        pass

    def horizontalPan(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        horizontalPan(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Return the camera 2D horizontal pan value. Unit is inches.

        Returns: 
        ----- 
        The camera 2D horizontal pan value

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setHorizontalPan(self, hPan: double): 
        '''
        setHorizontalPan(self, hPan: double)

        Synopsis
        -----
        Changes the camera 2D horizontal pan value. Unit is inches.

        Returns:
        -----
        None

        Parameters:
        -----
        hPan: double
        	[in] -> The camera 2D horizontal pan value to be set


        '''
        pass

    def verticalPan(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        verticalPan(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Return the camera 2D vertical pan value. Unit is inches.

        Returns: 
        ----- 
        The camera 2D vertical pan value

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setVerticalPan(self, vPan: double): 
        '''
        setVerticalPan(self, vPan: double)

        Synopsis
        -----
        Changes the camera 2D vertical pan value. Unit is inches.

        Returns:
        -----
        None

        Parameters:
        -----
        vPan: double
        	[in] -> The camera 2D vertical pan value to be set


        '''
        pass

    def zoom(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        zoom(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Return the camera 2D zoom value, which is the percent over the
        film viewable frustum to display.

        Returns: 
        ----- 
        The camera 2D zoom value

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setZoom(self, zoom: double): 
        '''
        setZoom(self, zoom: double)

        Synopsis
        -----
        Changes the camera 2D zoom value.

        Returns:
        -----
        None

        Parameters:
        -----
        zoom: double
        	[in] -> The camera 2D zoom value to be set


        '''
        pass

    def stereoHITEnabled(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        stereoHITEnabled(self, ReturnStatus: MFnCamera.MStatus) -> bool

        Synopsis
        -----
        Returns the toggle value for the stereo HIT enabled attribute. If
        this attribute is false, the stereoHIT value is ignored by the
        camera.

        Returns: 
        ----- 
        The camera stereo HIT toggle value for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setStereoHITEnabled(self, enabled: bool): 
        '''
        setStereoHITEnabled(self, enabled: bool)

        Synopsis
        -----
        Changes the toggle value for the stereo HIT enabled attribute. If
        this attribute is false, the stereoHIT value is ignored by the
        camera.

        Returns:
        -----
        None

        Parameters:
        -----
        enabled: bool
        	[in] -> The film-based camera stereo HIT toggle value to be set


        '''
        pass

    def stereoHIT(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        stereoHIT(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the camera stereo horizontal image translation (stereo
        HIT) value. Unit is inches. This has the same effect as the HFO
        attribute, but is intended as an input hook for use with stereo
        camera rigs.

        Returns: 
        ----- 
        The stereo HIT value for this camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setStereoHIT(self, hit: double): 
        '''
        setStereoHIT(self, hit: double)

        Synopsis
        -----
        Changes the camera stereo horizontal image translation (stereo
        HIT) value. Unit is inches. This has the same effect as the HFO
        attribute, but is intended as an input hook for use with stereo
        camera rigs.

        Returns:
        -----
        None

        Parameters:
        -----
        hit: double
        	[in] -> The stereo HIT value to be set


        '''
        pass

    def setFilmFit(self, filmFit: MFnCamera.FilmFit): 
        '''
        setFilmFit(self, filmFit: MFnCamera.FilmFit)

        Synopsis
        -----
        Sets how the digital image is to be fitted to the film back.

        Returns:
        -----
        None

        Parameters:
        -----
        filmFit: MFnCamera.FilmFit
        	[in] -> The type of film fit


        '''
        pass

    def filmFit(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        filmFit(self, ReturnStatus: MFnCamera.MStatus) -> MFnCamera.MFnCamera

        Synopsis
        -----
        Returns how the digital image is being fitted to the film back.

        Returns: 
        ----- 
        The type of film fit.

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setFilmFitOffset(self, filmFitOffset: double): 
        '''
        setFilmFitOffset(self, filmFitOffset: double)

        Synopsis
        -----
        Set the film fit offset for the camera. Since the digital image
        may not match the film back exactly, we now have the question of
        how to position one relative to the other. Thus fit offset.
        Normally the centers are aligned. Fit offset lets you move the
        smaller image within the larger one. Specify the distance for
        film offset (inches).

        Returns:
        -----
        None

        Parameters:
        -----
        filmFitOffset: double
        	[in] -> 


        '''
        pass

    def filmFitOffset(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        filmFitOffset(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the film fit offset for the camera. Since the digital
        image may not match the film back exactly, we now have the
        question of how to position one relative to the other. Thus fit
        offset. Normally the centers are aligned. Fit offset lets you
        move the smaller image within the larger one. Specify the
        distance for film offset (inches).

        Returns: 
        ----- 
        The film fit offset as double.

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setOverscan(self, overscan: double): 
        '''
        setOverscan(self, overscan: double)

        Synopsis
        -----
        Set the percent of overscan for this camera.

        Returns:
        -----
        None

        Parameters:
        -----
        overscan: double
        	[in] -> 


        '''
        pass

    def overscan(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        overscan(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the percent of overscan for this camera.

        Returns: 
        ----- 
        The percent of overscan

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setHorizontalRollPivot(self, horizontalRollPivot: double): 
        '''
        setHorizontalRollPivot(self, horizontalRollPivot: double)

        Synopsis
        -----
        Set the horizontal roll pivot for film back roll.

        Returns:
        -----
        None

        Parameters:
        -----
        horizontalRollPivot: double
        	[in] -> Specifies the horizontal pivot value.


        '''
        pass

    def horizontalRollPivot(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        horizontalRollPivot(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the current horizontal roll pivot value.

        Returns: 
        ----- 
        The horizontal roll pivot value.

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setVerticalRollPivot(self, verticalRollPivot: double): 
        '''
        setVerticalRollPivot(self, verticalRollPivot: double)

        Synopsis
        -----
        Set the vertical roll pivot for film back roll.

        Returns:
        -----
        None

        Parameters:
        -----
        verticalRollPivot: double
        	[in] -> Specifies the vertical pivot value.


        '''
        pass

    def verticalRollPivot(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        verticalRollPivot(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the vertical roll pivot's value.

        Returns: 
        ----- 
        Vertical roll pivot

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setFilmRollValue(self, filmRollValue: double): 
        '''
        setFilmRollValue(self, filmRollValue: double)

        Synopsis
        -----
        Set the film roll value for film back.

        Returns:
        -----
        None

        Parameters:
        -----
        filmRollValue: double
        	[in] -> Specifies the amount rotation in the film back. The film back rotation value is specified in radians.


        '''
        pass

    def filmRollValue(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        filmRollValue(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the current roll value in radians.

        Returns: 
        ----- 
        Roll value in radians.

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setFilmRollOrder(self, filmRollOrder: MFnCamera.RollOrder): 
        '''
        setFilmRollOrder(self, filmRollOrder: MFnCamera.RollOrder)

        Synopsis
        -----
        Assign the order in which the film back rotation is applied with
        respect to the pivot point. There are 2 choices.

        Returns:
        -----
        None

        Parameters:
        -----
        filmRollOrder: MFnCamera.RollOrder
        	[in] -> The order to apply the film roll.


        '''
        pass

    def filmRollOrder(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        filmRollOrder(self, ReturnStatus: MFnCamera.MStatus) -> MFnCamera.MFnCamera

        Synopsis
        -----
        Returns the current roll order.

        Returns: 
        ----- 
        The roll order

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setPreScale(self, sf: double): 
        '''
        setPreScale(self, sf: double)

        Synopsis
        -----
        Set the pre scale value.

        Returns:
        -----
        None

        Parameters:
        -----
        sf: double
        	[in] -> The scaling factor.


        '''
        pass

    def preScale(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        preScale(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Return the post projection matrix's pre-scale value.

        Returns: 
        ----- 
        Pre scale value.

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code.


        '''
        pass

    def setPostScale(self, sf: double): 
        '''
        setPostScale(self, sf: double)

        Synopsis
        -----
        Set the post scale value.

        Returns:
        -----
        None

        Parameters:
        -----
        sf: double
        	[in] -> The scaling factor.


        '''
        pass

    def postScale(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        postScale(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Return the post projection matrix's post-scale value.

        Returns: 
        ----- 
        Post scale value.

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code.


        '''
        pass

    def setFilmTranslateH(self, translate: double): 
        '''
        setFilmTranslateH(self, translate: double)

        Synopsis
        -----
        Set the horizontal film translate.

        Returns:
        -----
        None

        Parameters:
        -----
        translate: double
        	[in] -> The amount of translation normalized to the viewing area.


        '''
        pass

    def filmTranslateH(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        filmTranslateH(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the horizontal film translate value. This value
        corresponds to the normalized viewport.

        Returns: 
        ----- 
        The horizontal translation amount.

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setFilmTranslateV(self, translate: double): 
        '''
        setFilmTranslateV(self, translate: double)

        Synopsis
        -----
        Set the vertical film translate.

        Returns:
        -----
        None

        Parameters:
        -----
        translate: double
        	[in] -> The amount of translation normalized to the viewing area.


        '''
        pass

    def filmTranslateV(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        filmTranslateV(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the vertical film translate value. This value corresponds
        to the normalized viewport, [-1,1].

        Returns: 
        ----- 
        The vertical film translation.

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def postProjectionMatrix(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        postProjectionMatrix(self, ReturnStatus: MFnCamera.MStatus) -> MFloatMatrix

        Synopsis
        -----
        Returns the post projection matrix used to compute film roll on
        the film back plane.

        Returns: 
        ----- 
        The film roll matrix.

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setDisplayGateMask(self, displayGateMask: bool): 
        '''
        setDisplayGateMask(self, displayGateMask: bool)

        Synopsis
        -----
        Activate shaded display of the film or resolution gate mask when
        looking through the camera. Does not activate the film or
        resolution gate display.

        Returns:
        -----
        None

        Parameters:
        -----
        displayGateMask: bool
        	[in] -> Specifies whether to display the film gate shaded.


        '''
        pass

    def isDisplayGateMask(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        isDisplayGateMask(self, ReturnStatus: MFnCamera.MStatus) -> bool

        Synopsis
        -----
        Determines if the film gate is displayed shaded.

        Returns: 
        ----- 
        True if the film gate is shaded, false otherwise.

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setDisplayFilmGate(self, displayFilmGate: bool): 
        '''
        setDisplayFilmGate(self, displayFilmGate: bool)

        Synopsis
        -----
        Activate display of the film gate icons when looking through the
        camera.

        Returns:
        -----
        None

        Parameters:
        -----
        displayFilmGate: bool
        	[in] -> Specifies whether to display the film gate.


        '''
        pass

    def isDisplayFilmGate(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        isDisplayFilmGate(self, ReturnStatus: MFnCamera.MStatus) -> bool

        Synopsis
        -----
        Determines if the film gate icons are displayed when looking
        through the camera.

        Returns: 
        ----- 
        True if the film gate is displayed, false otherwise.

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setHorizontalFieldOfView(self, fov: double): 
        '''
        setHorizontalFieldOfView(self, fov: double)

        Synopsis
        -----
        Sets the horizontal field of view for the camera.

        Returns:
        -----
        None

        Parameters:
        -----
        fov: double
        	[in] -> The horizontal field of view value to be set


        '''
        pass

    def horizontalFieldOfView(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        horizontalFieldOfView(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the horizontal field of view for the camera.

        Returns: 
        ----- 
        The horizontal field of view for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setVerticalFieldOfView(self, fov: double): 
        '''
        setVerticalFieldOfView(self, fov: double)

        Synopsis
        -----
        Sets the vertical field of view for the camera.

        Returns:
        -----
        None

        Parameters:
        -----
        fov: double
        	[in] -> The vertical field of view value to be set


        '''
        pass

    def verticalFieldOfView(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        verticalFieldOfView(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the vertical field of view for the camera.

        Returns: 
        ----- 
        The vertical field of view for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setFocalLength(self, focalLength: double): 
        '''
        setFocalLength(self, focalLength: double)

        Synopsis
        -----
        Sets the focal length for the camera. This is the distance along
        the lens axis between the lens and the film plane when "focal
        distance" is infinitely large. This is an optical property of the
        lens. This double precision parameter is always specified in
        millimeters.

        Returns:
        -----
        None

        Parameters:
        -----
        focalLength: double
        	[in] -> The focal length value to be set


        '''
        pass

    def focalLength(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        focalLength(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the focal length for the camera. This is the distance
        along the lens axis between the lens and the film plane when
        "focal distance" is infinitely large. This is an optical property
        of the lens. This double precision parameter is always specified
        in millimeters.

        Returns: 
        ----- 
        The focal length for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def getFocalLengthLimits(self, min: double,
                        max: double): 
        '''
        getFocalLengthLimits(self, min: double,
                        max: double)

        Synopsis
        -----
        Returns the focal length limits for the camera.

        Returns:
        -----
        None

        Parameters:
        -----
        min: double
        	[out] -> Storage for the minimum focal length limit 

        max: double
        	[out] -> Storage for the maximum focal length limit


        '''
        pass

    def setLensSqueezeRatio(self, aspectRatio: double): 
        '''
        setLensSqueezeRatio(self, aspectRatio: double)

        Synopsis
        -----
        Set the squeeze ratio of the lens. The aspect ratio is expressed
        as width/height.

        Returns:
        -----
        None

        Parameters:
        -----
        aspectRatio: double
        	[in] -> The lens squeeze ratio to be set


        '''
        pass

    def lensSqueezeRatio(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        lensSqueezeRatio(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the lens squeeze ratio for the camera.

        Returns: 
        ----- 
        The lens squeeze ratio for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setClippingPlanes(self, ClippingPlanes: bool): 
        '''
        setClippingPlanes(self, ClippingPlanes: bool)

        Synopsis
        -----
        Turn on/off manual setting of clip planes.

        Returns:
        -----
        None

        Parameters:
        -----
        ClippingPlanes: bool
        	[in] -> 


        '''
        pass

    def isClippingPlanes(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        isClippingPlanes(self, ReturnStatus: MFnCamera.MStatus) -> bool

        Synopsis
        -----
        Determines whether manual clipping planes are activated.

        Returns: 
        ----- 
        True if the manual clipping planes are activated, false
        otherwise.

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setNearClippingPlane(self, dNear: double): 
        '''
        setNearClippingPlane(self, dNear: double)

        Synopsis
        -----
        Set the distances to the Near Clipping Plane.

        Returns:
        -----
        None

        Parameters:
        -----
        dNear: double
        	[in] -> The near clipping plane value to be set


        '''
        pass

    def nearClippingPlane(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        nearClippingPlane(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the distance to the near clipping plane.

        Returns: 
        ----- 
        The near clipping plane value for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setFarClippingPlane(self, dFar: double): 
        '''
        setFarClippingPlane(self, dFar: double)

        Synopsis
        -----
        Set the distances to the Far Clipping Plane.

        Returns:
        -----
        None

        Parameters:
        -----
        dFar: double
        	[in] -> The far clipping plane value to be set


        '''
        pass

    def farClippingPlane(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        farClippingPlane(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the distance to the far clipping plane.

        Returns: 
        ----- 
        The far clipping plane value for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setNearFarClippingPlanes(self, dNear: double,
                        dFar: double): 
        '''
        setNearFarClippingPlanes(self, dNear: double,
                        dFar: double)

        Synopsis
        -----
        Set the distances to the Near and Far Clipping Planes.

        Returns:
        -----
        None

        Parameters:
        -----
        dNear: double
        	[in] -> The near clipping plane value to be set 

        dFar: double
        	[in] -> The far clipping plane value to be set


        '''
        pass

    def setDepthOfField(self, depthOfField: bool): 
        '''
        setDepthOfField(self, depthOfField: bool)

        Synopsis
        -----
        Specifies whether the depth of field calculation is performed for
        the camera. The depth of field calculation is used to give
        varying focus depending on the distance of the objects.

        Returns:
        -----
        None

        Parameters:
        -----
        depthOfField: bool
        	[in] -> The depth of field value to be set


        '''
        pass

    def isDepthOfField(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        isDepthOfField(self, ReturnStatus: MFnCamera.MStatus) -> bool

        Synopsis
        -----
        Determines whether the depth of field calculation is performed
        for the camera. The depth of field calculation is used to give
        varying focus depending on the distance of the objects.

        Returns: 
        ----- 
        True if the depth of field is on, false otherwise.

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setFStop(self, fStop: double): 
        '''
        setFStop(self, fStop: double)

        Synopsis
        -----
        Sets the f-stop value for the camera. A real lens normally
        contains a diaphragm or other stop which blocks some of the light
        that would otherwise pass through it. This stop is usually
        approximately round, and its diameter as seen from the front of
        the lens is called the lens diameter. The lens diameter is often
        described by its relation to the focal length of the lens. A lens
        whose diameter is one-eighth its local length is said to have an
        F-stop of 8. This is an optical property of the lens.

        Returns:
        -----
        None

        Parameters:
        -----
        fStop: double
        	[in] -> The F/Stop value to be set


        '''
        pass

    def fStop(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        fStop(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the f-stop value for the camera. A real lens normally
        contains a diaphragm or other stop which blocks some of the light
        that would otherwise pass through it. This stop is usually
        approximately round, and its diameter as seen from the front of
        the lens is called the lens diameter. The lens diameter is often
        described by its relation to the focal length of the lens. A lens
        whose diameter is one-eighth its local length is said to have an
        F-stop of 8. This is an optical property of the lens.

        Returns: 
        ----- 
        The F/Stop value for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setFocusDistance(self, distance: double): 
        '''
        setFocusDistance(self, distance: double)

        Synopsis
        -----
        Set the focus at a certain distance in front of the camera.

        Returns:
        -----
        None

        Parameters:
        -----
        distance: double
        	[in] -> The focus distance to be set


        '''
        pass

    def focusDistance(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        focusDistance(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the focus distance for the camera. This value sets the
        focus at a certain distance in front of the camera.

        Returns: 
        ----- 
        The focus distance for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setNearFocusDistance(self, nearFocusDistance: double): 
        '''
        setNearFocusDistance(self, nearFocusDistance: double)

        Synopsis
        -----
        Set the nearest distance within the well-focus region.

        Returns:
        -----
        None

        Parameters:
        -----
        nearFocusDistance: double
        	[in] -> The near focus distance value to be set


        '''
        pass

    def nearFocusDistance(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        nearFocusDistance(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the linear distance to the near focus plane.

        Returns: 
        ----- 
        The near focus distance for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setFarFocusDistance(self, farFocusDistance: double): 
        '''
        setFarFocusDistance(self, farFocusDistance: double)

        Synopsis
        -----
        Set the farthest distance within the well-focus region.

        Returns:
        -----
        None

        Parameters:
        -----
        farFocusDistance: double
        	[in] -> The far focus distance value to be set


        '''
        pass

    def farFocusDistance(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        farFocusDistance(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the linear distance to the far focus plane.

        Returns: 
        ----- 
        The far focus distance for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def computeDepthOfField(self): 
        '''
        computeDepthOfField(self)

        Synopsis
        -----

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def computeDepthOfField(self, nearLimit: double): 
        '''
        computeDepthOfField(self, nearLimit: double)

        Synopsis
        -----

        Returns:
        -----
        None

        Parameters:
        -----
        nearLimit: double
        	[in] -> 


        '''
        pass

    def setMotionBlur(self, motionBlur: bool): 
        '''
        setMotionBlur(self, motionBlur: bool)

        Synopsis
        -----
        Turns motion blur on/off for the camera. Motion blur determines
        whether the camera's image is motion blurred (as opposed to an
        object's image). For example, if you want to blur the camera
        movement when you are performing a fly-by.

        Returns:
        -----
        None

        Parameters:
        -----
        motionBlur: bool
        	[in] -> true turns motion blur on, false turns it off.


        '''
        pass

    def isMotionBlur(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        isMotionBlur(self, ReturnStatus: MFnCamera.MStatus) -> bool

        Synopsis
        -----
        Determine if motion blur is on/off for the camera. Motion blur
        determines whether the camera's image is motion blurred (as
        opposed to an object's image). For example, if you want to blur
        the camera movement when you are performing a fly-by.

        Returns: 
        ----- 
        True if the motion blur is on, false otherwise.

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setShutterAngle(self, shutterAngle: double): 
        '''
        setShutterAngle(self, shutterAngle: double)

        Synopsis
        -----
        Change the current shutter angle which is one of the variables
        used to compute motion blur. The shutterAngle is specified in
        radians.Valid shutter angles must be in the range 1.0 (degrees)
        to 359.0 (degrees), and must be given in radians. Note: PI
        radians = 180 degrees.

        Returns:
        -----
        None

        Parameters:
        -----
        shutterAngle: double
        	[in] -> The shutter angle value to be set


        '''
        pass

    def shutterAngle(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        shutterAngle(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Return the current shutter angle which is one of the variables
        used to compute motion blur. The shutter angle is specified in
        radians.

        Returns: 
        ----- 
        The shutter angle for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setCenterOfInterest(self, dist: double): 
        '''
        setCenterOfInterest(self, dist: double)

        Synopsis
        -----
        Set the Center of Interest, which is defined to be a positive
        distance along the View Direction (i.e., "in front" of the
        Camera).

        Returns:
        -----
        None

        Parameters:
        -----
        dist: double
        	[in] -> center of interest distance value


        '''
        pass

    def centerOfInterest(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        centerOfInterest(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Return the linear distance from the camera's eye point to the
        center of interest.

        Returns: 
        ----- 
        center of interest distance value

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def setIsOrtho(self, orthoState: bool): 
        '''
        setIsOrtho(self, orthoState: bool)

        Synopsis
        -----
        Switch the camera in and out of orthographic mode. This does not
        change the preset fov or the ortho width, presuming that these
        values are going to be set at the same time separately.

        Returns:
        -----
        None

        Parameters:
        -----
        orthoState: bool
        	[in] -> If 


        '''
        pass

    @overload
    def setIsOrtho(self, orthoState: bool,
                        useDist: double): 
        '''
        setIsOrtho(self, orthoState: bool,
                        useDist: double)

        Synopsis
        -----
        Switch the camera in and out of orthographic mode. When the
        switch happens, the camera has to calculate a new fov or ortho
        width, each of which is based on the other and a set distance.
        The caller can specify the distance; otherwise the center of
        interest is used.

        Returns:
        -----
        None

        Parameters:
        -----
        orthoState: bool
        	[in] -> If 

        useDist: double
        	[in] -> 


        '''
        pass

    def isOrtho(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        isOrtho(self, ReturnStatus: MFnCamera.MStatus) -> bool

        Synopsis
        -----
        Determines if the camera is in orthographic mode.

        Returns: 
        ----- 
        True if the camera is orthographic, false otherwise.

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setOrthoWidth(self, orthoWidth: double): 
        '''
        setOrthoWidth(self, orthoWidth: double)

        Synopsis
        -----
        Sets a new width for the ortho camera. Bad values are ignored.

        Returns:
        -----
        None

        Parameters:
        -----
        orthoWidth: double
        	[in] -> The ortho width value to be set


        '''
        pass

    def orthoWidth(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        orthoWidth(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the orthographic projection width.

        Returns: 
        ----- 
        The orthographic width

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setCameraScale(self, scale: double): 
        '''
        setCameraScale(self, scale: double)

        Synopsis
        -----
        Sets the camera scale.

        Returns:
        -----
        None

        Parameters:
        -----
        scale: double
        	[in] -> The camera scale value to be set


        '''
        pass

    def cameraScale(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        cameraScale(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the camera scale.

        Returns: 
        ----- 
        The scale value of the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def setTumblePivot(self, point: MPoint): 
        '''
        setTumblePivot(self, point: MPoint)

        Synopsis
        -----
        The tumble pivot is used for non-local tumble operations. It is
        in world space for "tumble pivot" mode and relative space for
        "local axis" mode (see setUsePivotAsLocalSpace).Note that when
        camera is told to look at an object and the camera's
        usePivotAsLocalSpace() is false, the tumble pivot value for the
        camera is reset to the centre of the bounding box for the object
        being looked at.

        Returns:
        -----
        None

        Parameters:
        -----
        point: MPoint
        	[in] -> The tumble pivot location to be set


        '''
        pass

    def tumblePivot(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        tumblePivot(self, ReturnStatus: MFnCamera.MStatus) -> MPoint

        Synopsis
        -----
        Returns the tumble pivot value for the camera. The pivot value
        will be in world space coordinates unless usePivotAsLocalSpace()
        is true in which case the pivot is a relative offset.

        Returns: 
        ----- 
        The tumble pivot location of the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def unnormalizedNearClippingPlane(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        unnormalizedNearClippingPlane(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the distance to the near clipping plane. When a camera
        set is used to draw in the viewport the minimum near distance of
        all camera members may be computed. This is the "normalized"
        value which is returned by the nearClippingPlane() method. The
        unnormalized value can be queried by this method.

        Returns: 
        ----- 
        The near clipping plane value for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    def unnormalizedFarClippingPlane(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        unnormalizedFarClippingPlane(self, ReturnStatus: MFnCamera.MStatus) -> double

        Synopsis
        -----
        Returns the distance to the far clipping plane. When a camera set
        is used to draw in the viewport the maximum far distance of all
        camera members may be computed. This is the "normalized" value
        which is returned by the farClippingPlane() method. The
        unnormalized value can be queried by this method.

        Returns: 
        ----- 
        The far clipping plane value for the camera

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def getFilmFrustum(self, distance: double,
                        clipPlane: MPoint4,
                        applyPanZoom: bool): 
        '''
        getFilmFrustum(self, distance: double,
                        clipPlane: MPoint4,
                        applyPanZoom: bool)

        Synopsis
        -----
        Returns the film frustum for the camera. The frustum defines the
        projective transformation.

        Returns:
        -----
        None

        Parameters:
        -----
        distance: double
        	[in] -> Specifies the focal length 

        clipPlane: MPoint4
        	[out] -> Storage for the film frustum (allocated by user) 

        applyPanZoom: bool
        	[in] -> specifies whether to apply 2D pan/zoom


        '''
        pass

    def setUsePivotAsLocalSpace(self, how: bool): 
        '''
        setUsePivotAsLocalSpace(self, how: bool)

        Synopsis
        -----
        Local space tumbling specifies that when the camera is tumbled,
        the camera will rotate about its local axis, offset by the
        tumblePivot. The effect is like that of tilting the camera on a
        tripod. This per-camera setting overrides whatever tumble mode is
        defined globally in Maya.For an example of local space tumbling,
        if `how' is true and this camera's tumblePivot value is (0,1,0)
        then when tumbled the camera will rotate about a point one unit
        in Y away from the camera's local axis.

        Returns:
        -----
        None

        Parameters:
        -----
        how: bool
        	[in] -> True to use local space tumbling for this camera, or false to use the current global tumble setting in Maya (the global tumble setting can be set via the Tumble Tool Option Box). The default value is false.


        '''
        pass

    def usePivotAsLocalSpace(self, ReturnStatus: MFnCamera.MStatus): 
        '''
        usePivotAsLocalSpace(self, ReturnStatus: MFnCamera.MStatus) -> bool

        Synopsis
        -----
        Returns the value of the local axis tumble setting for this
        camera.

        Returns: 
        ----- 
        True if using local space tumbling for this camera, or false if
        using the current global tumble setting in Maya. See
        setUsePivotAsLocalSpace() for more details.

        Parameters:
        -----
        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def postProjectionMatrix(self, context: MDGContext,
                        ReturnStatus: MFnCamera.MStatus): 
        '''
        postProjectionMatrix(self, context: MDGContext,
                        ReturnStatus: MFnCamera.MStatus) -> MFloatMatrix

        Synopsis
        -----
        Returns the post projection matrix used to compute film roll on
        the film back plane. This version evaluates in a context other
        than the current evaluation context, e.g. a different time. Use
        only when appropriate.

        Returns: 
        ----- 
        The film roll matrix.

        Parameters:
        -----
        context: MDGContext
        	[in] -> DG time-context to specify time of evaluation 

        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def projectionMatrix(self, context: MDGContext,
                        ReturnStatus: MFnCamera.MStatus): 
        '''
        projectionMatrix(self, context: MDGContext,
                        ReturnStatus: MFnCamera.MStatus) -> MFloatMatrix

        Synopsis
        -----
        Returns the orthographic or perspective projection matrix for the
        camera. This version evaluates in a context other than the
        current evaluation context, e.g. a different time. Use only when
        appropriate.The projection matrix that maya's software renderer
        uses is almost identical to the OpenGL projection matrix. The
        difference is that maya uses a left hand coordinate system and so
        the entries [2][2] and [3][2] are negated.

        Returns: 
        ----- 
        The projection matrix

        Parameters:
        -----
        context: MDGContext
        	[in] -> DG time-context to specify time of evaluation. 

        ReturnStatus: MFnCamera.MStatus
        	[out] -> Status code


        '''
        pass

class FilmFit:
    '''Specifies how to fit the digital image to the film back. 
    Non-functional class.  Values for this enum:
    kFillFilmFit
    kHorizontalFilmFit
    kVerticalFilmFit
    kOverscanFilmFit
    kInvalid
    '''

    def __init__(self):
        pass

    def kFillFilmFit(self):
        '''This is an enum of FilmFit.
        - Description: The system calculates both horizontal and vertical fits and then applies the one that makes the digital image larger than the film back. 
        - Value: 0
        '''
        pass

    def kHorizontalFilmFit(self):
        '''This is an enum of FilmFit.
        - Description: The digital image is made to fit the film back exactly in the horizontal direction. This then gives each pixel a horizontal size = (film back width) / (horizontal resolution). The pixel height is then = (pixel width) / (pixel aspect ratio). Now that the pixel has a size, resolution gives us a complete image. That image will match the film back exactly in width. It will almost never match in height, either being too tall or too short. By playing with the numbers you can get it pretty close though. 
        - Value: 1
        '''
        pass

    def kVerticalFilmFit(self):
        '''This is an enum of FilmFit.
        - Description: The same idea as horizontal fit, only applied vertically. Thus the digital image will match the film back exactly in height, but miss in width. 
        - Value: 2
        '''
        pass

    def kOverscanFilmFit(self):
        '''This is an enum of FilmFit.
        - Description: Over-scanning the film gate in the camera view allows us to choreograph action outside of the frustum from within the camera view without having to resort to a dolly or zoom. This feature is also essential for animating image planes. 
        - Value: 3
        '''
        pass

    def kInvalid(self):
        '''This is an enum of FilmFit.
        - Description:  
        - Value: 4
        '''
        pass

class RollOrder:
    '''Order in which film back rotation and its transformation by the pivot point are applied. 
    Non-functional class.  Values for this enum:
    kRotateTranslate
    kTranslateRotate
    '''

    def __init__(self):
        pass

    def kRotateTranslate(self):
        '''This is an enum of RollOrder.
        - Description: Rotate the film back before translating it by the pivot point. 
        - Value: 0
        '''
        pass

    def kTranslateRotate(self):
        '''This is an enum of RollOrder.
        - Description: Translate the film back by the pivot point before rotating it. 
        - Value: 1
        '''
        pass

class MFnCameraSet:
    '''Camera set node function set.
MFnCameraSet is the function set that is used for manipulating cameraSet
nodes.
A cameraSet node defines a list of camera layeres to be processed
in order, defining a multi-layer viewing of the scene. A camera
layer consists of an object set to be used by the layer, and a
camera through which the set is viewed. Individual layers may be
marked active or inactive and ordered arbitrarily.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kCameraSet.Reimplemented from MFnDependencyNode.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnCameraSet.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnCameraSet".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def create(self, returnStatus: MFnCameraSet.MStatus): 
        '''
        create(self, returnStatus: MFnCameraSet.MStatus) -> MObject

        Synopsis
        -----
        Creates a new cameraSet dependency node and puts it in the
        dependency graph.

        Returns: 
        ----- 
        A pointer to the new cameraSet node object.

        Parameters:
        -----
        returnStatus: MFnCameraSet.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def create(self, camList: MDagPathArray,
                        returnStatus: MFnCameraSet.MStatus): 
        '''
        create(self, camList: MDagPathArray,
                        returnStatus: MFnCameraSet.MStatus) -> MObject

        Synopsis
        -----
        Creates a new cameraSet dependency node and puts it in the
        dependency graph. The method takes a list of cameras and creates
        a camera layer for each corresponding camera. Sets are not
        connected.

        Returns: 
        ----- 
        A pointer to the new cameraSet node object.

        Parameters:
        -----
        camList: MDagPathArray
        	[in] -> The list of cameras or stereo rigs 

        returnStatus: MFnCameraSet.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def create(self, name: MString,
                        returnStatus: MFnCameraSet.MStatus): 
        '''
        create(self, name: MString,
                        returnStatus: MFnCameraSet.MStatus) -> MObject

        Synopsis
        -----
        Creates a new cameraSet dependency node and puts it in the
        dependency graph.

        Returns: 
        ----- 
        A pointer to the new cameraSet node object.

        Parameters:
        -----
        name: MString
        	[in] -> The name for the new cameraSet node 

        returnStatus: MFnCameraSet.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def create(self, camList: MDagPathArray,
                        setList: MObjectArray,
                        returnStatus: MFnCameraSet.MStatus): 
        '''
        create(self, camList: MDagPathArray,
                        setList: MObjectArray,
                        returnStatus: MFnCameraSet.MStatus) -> MObject

        Synopsis
        -----
        Creates a new cameraSet dependency node and puts it in the
        dependency graph. The method takes a list of cameras and object
        sets and creates a camera layer for each corresponding camera and
        object set.

        Returns: 
        ----- 
        A pointer to the new cameraSet node object.

        Parameters:
        -----
        camList: MDagPathArray
        	[in] -> The list of cameras or stereo rigs 

        setList: MObjectArray
        	[in] -> The list of sets 

        returnStatus: MFnCameraSet.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def create(self, name: MString,
                        camList: MDagPathArray,
                        setList: MObjectArray,
                        returnStatus: MFnCameraSet.MStatus): 
        '''
        create(self, name: MString,
                        camList: MDagPathArray,
                        setList: MObjectArray,
                        returnStatus: MFnCameraSet.MStatus) -> MObject

        Synopsis
        -----
        Creates a new cameraSet dependency node and puts it in the
        dependency graph. The method takes a list of cameras and object
        sets and creates a camera layer for each corresponding camera and
        object set.

        Returns: 
        ----- 
        A pointer to the new cameraSet node object.

        Parameters:
        -----
        name: MString
        	[in] -> The name for the new cameraSet node 

        camList: MDagPathArray
        	[in] -> The list of cameras or stereo rigs 

        setList: MObjectArray
        	[in] -> The list of sets 

        returnStatus: MFnCameraSet.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def appendLayer(self, camera: MDagPath,
                        set: MObject): 
        '''
        appendLayer(self, camera: MDagPath,
                        set: MObject)

        Synopsis
        -----
        Appends a layer to the associated cameraSet node. The given
        camera and object set are used in the layer. If MObject::kNullObj
        is passed as the set, then the whole scene will be rendered in
        the layer.

        Returns:
        -----
        None

        Parameters:
        -----
        camera: MDagPath
        	[in] -> The camera or stereo rig for the layer 

        set: MObject
        	[in] -> The set of objects used in the layer


        '''
        pass

    @overload
    def appendLayer(self, camera: MDagPath): 
        '''
        appendLayer(self, camera: MDagPath)

        Synopsis
        -----
        Appends a layer to the associated cameraSet node using the given
        camera. The whole scene will be used with this layer as no object
        set is provided.

        Returns:
        -----
        None

        Parameters:
        -----
        camera: MDagPath
        	[in] -> The camera or stereo rig for the layer


        '''
        pass

    @overload
    def insertLayer(self, index: int,
                        camera: MDagPath,
                        set: MObject): 
        '''
        insertLayer(self, index: int,
                        camera: MDagPath,
                        set: MObject)

        Synopsis
        -----
        Inserts a layer at the given index to the associated cameraSet
        node using the given camera. The index value must be in the range
        from 0 to the number of layers currently defined. The given
        camera and object set are used in the layer. If MObject::kNullObj
        is passed as the set, then the whole scene will be rendered in
        the layer.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of the layer 

        camera: MDagPath
        	[in] -> The camera for the layer 

        set: MObject
        	[in] -> The set of objects used in the layer


        '''
        pass

    @overload
    def insertLayer(self, index: int,
                        camera: MDagPath): 
        '''
        insertLayer(self, index: int,
                        camera: MDagPath)

        Synopsis
        -----
        Inserts a layer at the given index to the associated cameraSet
        node using the given camera. The index value must be in the range
        from 0 to the number of layers currently defined. The whole scene
        will be used with this layer as no object set is provided.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of the layer 

        camera: MDagPath
        	[in] -> The camera for the layer


        '''
        pass

    def deleteLayer(self, index: int): 
        '''
        deleteLayer(self, index: int)

        Synopsis
        -----
        Deletes the layer denoted by the given index.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of the layer


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clear all of the camera layers.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getNumLayers(self, returnStatus: MFnCameraSet.MStatus): 
        '''
        getNumLayers(self, returnStatus: MFnCameraSet.MStatus) -> int

        Synopsis
        -----
        Return the number of layers in the cameraSet.

        Returns: 
        ----- 
        The number of layers

        Parameters:
        -----
        returnStatus: MFnCameraSet.MStatus
        	[out] -> The return status


        '''
        pass

    def setLayerCamera(self, index: int,
                        camera: MDagPath): 
        '''
        setLayerCamera(self, index: int,
                        camera: MDagPath)

        Synopsis
        -----
        Set the camera to be used for a particular layer.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of the layer 

        camera: MDagPath
        	[in] -> The camera for the layer


        '''
        pass

    def getLayerCamera(self, index: int,
                        camera: MDagPath): 
        '''
        getLayerCamera(self, index: int,
                        camera: MDagPath)

        Synopsis
        -----
        Get the camera used for a particular layer.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of the layer 

        camera: MDagPath
        	[out] -> The camera for the layer


        '''
        pass

    def setLayerSceneData(self, index: int,
                        set: MObject): 
        '''
        setLayerSceneData(self, index: int,
                        set: MObject)

        Synopsis
        -----
        Set the scene data to be used for a particular layer.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of the layer 

        set: MObject
        	[in] -> The object set for the layer


        '''
        pass

    def getLayerSceneData(self, index: int,
                        set: MObject): 
        '''
        getLayerSceneData(self, index: int,
                        set: MObject)

        Synopsis
        -----
        Get the scene data used for a particular layer. The returned
        scene data could be MObject::kNullObj if no scene data has been
        set. The operation will still be deemed successful.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of the layer 

        set: MObject
        	[out] -> The object set for the layer


        '''
        pass

    def setLayerActive(self, index: int,
                        isActive: bool): 
        '''
        setLayerActive(self, index: int,
                        isActive: bool)

        Synopsis
        -----
        Set a particular layer to be active.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of the layer 

        isActive: bool
        	[in] -> Whether the layer should be processed


        '''
        pass

    def isLayerActive(self, index: int,
                        returnStatus: MFnCameraSet.MStatus): 
        '''
        isLayerActive(self, index: int,
                        returnStatus: MFnCameraSet.MStatus) -> bool

        Synopsis
        -----
        Get whether a particular layer is active.

        Returns: 
        ----- 
        Whether the layer is being processed

        Parameters:
        -----
        index: int
        	[in] -> The index of the layer 

        returnStatus: MFnCameraSet.MStatus
        	[out] -> The return status


        '''
        pass

    def setLayerOrder(self, index: int,
                        order: int): 
        '''
        setLayerOrder(self, index: int,
                        order: int)

        Synopsis
        -----
        Set the processing order of a particular layer.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of the layer 

        order: int
        	[in] -> The order number


        '''
        pass

    def getLayerOrder(self, index: int,
                        order: int): 
        '''
        getLayerOrder(self, index: int,
                        order: int)

        Synopsis
        -----
        Get the processing order of a particular layer.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of the layer 

        order: int
        	[out] -> The processing order


        '''
        pass

    def getSortedIndices(self, sortedIndices: MUintArray): 
        '''
        getSortedIndices(self, sortedIndices: MUintArray)

        Synopsis
        -----
        Get a list of the layer indices, sorted by the order attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        sortedIndices: MUintArray
        	[out] -> The sorted indices


        '''
        pass

    def setLayerClearDepthValue(self, index: int,
                        depth: bool): 
        '''
        setLayerClearDepthValue(self, index: int,
                        depth: bool)

        Synopsis
        -----
        This method sets the clearDepth attribute for the specified
        camera layer.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of the layer 

        depth: bool
        	[in] -> The clear depth value


        '''
        pass

    def getLayerClearDepthValue(self, index: int,
                        depth: bool): 
        '''
        getLayerClearDepthValue(self, index: int,
                        depth: bool)

        Synopsis
        -----
        This method gets the clearDepth attribute value for the specified
        camera layer.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of the layer 

        depth: bool
        	[out] -> The clear depth value


        '''
        pass

class MFnComponent:
    '''Base class for component function sets.
This is the base class for all function sets which deal with
component objects.
Components are MObjects which hold index information for shapes.
The component object does not contain any information about the
shape, it just contains index values and type information.
Components can be marked as complete meaning that the component
represents a complete set of indices from 0 to numElements-1;
Components come is 3 varieties based upon the dimensions of the
index. The types are single, double, and triple indexed. Examples
of these types are mesh vertices (single indexed), nurbs surface
CVs (double indexed), and lattice points (triple indexed).
To create, edit, or query a specific type of component, use the
derived classes
MFnSingleIndexedComponent,
MFnDoubleIndexedComponent, and
MFnTripleIndexedComponent.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kComponent.Reimplemented from MFnBase.Reimplemented in
        MFnDoubleIndexedComponent, MFnSingleIndexedComponent,
        MFnTripleIndexedComponent, and MFnUint64SingleIndexedComponent.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnComponent.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnComponent".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def elementCount(self, ReturnStatus: MFnComponent.MStatus): 
        '''
        elementCount(self, ReturnStatus: MFnComponent.MStatus) -> int

        Synopsis
        -----
        Returns the number of elements that this component contains.

        Returns: 
        ----- 
        The number of elements

        Parameters:
        -----
        ReturnStatus: MFnComponent.MStatus
        	[out] -> Status code


        '''
        pass

    def componentType(self, ReturnStatus: MFnComponent.MStatus): 
        '''
        componentType(self, ReturnStatus: MFnComponent.MStatus) -> MFn.MFn

        Synopsis
        -----
        Returns the MFn type of the component.

        Returns: 
        ----- 
        The type

        Parameters:
        -----
        ReturnStatus: MFnComponent.MStatus
        	[out] -> Status code


        '''
        pass

    def isEmpty(self, ReturnStatus: MFnComponent.MStatus): 
        '''
        isEmpty(self, ReturnStatus: MFnComponent.MStatus) -> bool

        Synopsis
        -----
        Determines if this component is empty, i.e. there are no index
        elements.

        Returns: 
        ----- 
        True if empty, false otherwise

        Parameters:
        -----
        ReturnStatus: MFnComponent.MStatus
        	[out] -> Status code


        '''
        pass

    def isEqual(self, component: MObject,
                        ReturnStatus: MFnComponent.MStatus): 
        '''
        isEqual(self, component: MObject,
                        ReturnStatus: MFnComponent.MStatus) -> bool

        Synopsis
        -----
        Compares this component with the given component.

        Returns: 
        ----- 
        True if the components are equal, false otherwise

        Parameters:
        -----
        component: MObject
        	[in] -> component to compare 

        ReturnStatus: MFnComponent.MStatus
        	[out] -> Status code


        '''
        pass

    def isComplete(self, ReturnStatus: MFnComponent.MStatus): 
        '''
        isComplete(self, ReturnStatus: MFnComponent.MStatus) -> bool

        Synopsis
        -----
        Returns the complete state of the component. Components can be
        marked as complete meaning that the component represents a
        complete set of indices from 0 to numElements-1;

        Returns: 
        ----- 
        True if this component is complete, false otherwise

        Parameters:
        -----
        ReturnStatus: MFnComponent.MStatus
        	[out] -> Status code


        '''
        pass

    def setComplete(self, complete: bool): 
        '''
        setComplete(self, complete: bool)

        Synopsis
        -----
        Sets the complete state of the component. Components can be
        marked as complete meaning that the component represents a
        complete set of indices from 0 to numElements-1;Important: if the
        component is set as complete, setCompleteData must also be called
        with the appropriate parameter (the total number of elements in
        the object). Note that setCompleteData(...) also sets the
        component as complete, thus 'setComplete(true)' may never need to
        appear in your code.setCompleteData(...) is defined in derived
        classes.

        Returns:
        -----
        None

        Parameters:
        -----
        complete: bool
        	[in] -> true sets the component as complete


        '''
        pass

    def hasWeights(self): 
        '''
        hasWeights(self) -> bool

        Synopsis
        -----
        Query this component for the existance of attached weight data.
        Weight data will be added to a component as part of soft
        selection and/or symmetry. Note that this method does not test
        for the existance of external weight information (e.g. deformer
        weights stored in separate attributes).

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def weight(self, index: int,
                        ReturnStatus: MFnComponent.MStatus): 
        '''
        weight(self, index: int,
                        ReturnStatus: MFnComponent.MStatus) -> MWeight

        Synopsis
        -----
        Return the weight data for a given element within this component.
        Note that this method does not return external weight data (e.g.
        deformer weights stored in separate attributes).

        Returns: 
        ----- 
        The element weight data.

        Parameters:
        -----
        index: int
        	[in] -> The element to return weight data for (note that this is the linear index between 0 and 

        ReturnStatus: MFnComponent.MStatus
        	[out] -> Status code


        '''
        pass

    def setWeight(self, index: int,
                        weight: MWeight): 
        '''
        setWeight(self, index: int,
                        weight: MWeight)

        Synopsis
        -----
        Set the weight data for a given element within this component.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The element to set weight data for (note that this is the linear index between 0 and 

        weight: MWeight
        	[in] -> The new weight for the element


        '''
        pass

    def setWeights(self, weight: MWeight): 
        '''
        setWeights(self, weight: MWeight)

        Synopsis
        -----
        Set the weight data for all elements within this component.

        Returns:
        -----
        None

        Parameters:
        -----
        weight: MWeight
        	[in] -> The new weight for all element


        '''
        pass

class MFnComponentListData:
    '''Component list function set for dependency node data.
MFnComponentListData allows the creation and manipulation of component list
(represented as MObjects) data objects for use in the dependency
graph.
If a user written dependency node either accepts or produces
MObjects containing component lists, then this class is used to
extract or create the data that comes from or goes to other
dependency graph nodes. To access it, the
MDataHandle::data method is used to get an
MObject for the data and this should then be used to initialize an
instance of
MFnComponentListData.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kComponentListData.Reimplemented from MFnData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnComponentListData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnComponentListData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def length(self, ReturnStatus: MFnComponentListData.MStatus): 
        '''
        length(self, ReturnStatus: MFnComponentListData.MStatus) -> int

        Synopsis
        -----
        Return the number of components in the instance.

        Returns: 
        ----- 
        The number of components in the instance

        Parameters:
        -----
        ReturnStatus: MFnComponentListData.MStatus
        	[out] -> Status code.


        '''
        pass

    def has(self, obj: MObject,
                        ReturnStatus: MFnComponentListData.MStatus): 
        '''
        has(self, obj: MObject,
                        ReturnStatus: MFnComponentListData.MStatus) -> bool

        Synopsis
        -----
        Determine if the instance of the component list contains the
        component represented by the given MObject.

        Returns: 
        ----- 
        true if the component list contains the component, false
        otherwise

        Parameters:
        -----
        obj: MObject
        	[in] -> the 

        ReturnStatus: MFnComponentListData.MStatus
        	[out] -> Status code.


        '''
        pass

    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> MObject

        Synopsis
        -----
        Extract the indicated component from the const instance. If the
        index is out of range or the functionset is not attached to a
        valid object, MObject::kNullObj will be returned.

        Returns: 
        ----- 
        The indicated component

        Parameters:
        -----
        index: int
        	[in] -> the index of the component to extract


        '''
        pass

    def add(self, obj: MObject): 
        '''
        add(self, obj: MObject)

        Synopsis
        -----
        Add the given component to the component list.

        Returns:
        -----
        None

        Parameters:
        -----
        obj: MObject
        	[in] -> an 


        '''
        pass

    @overload
    def remove(self, obj: MObject): 
        '''
        remove(self, obj: MObject)

        Synopsis
        -----
        Remove the given component from the component list.

        Returns:
        -----
        None

        Parameters:
        -----
        obj: MObject
        	[in] -> an 


        '''
        pass

    @overload
    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Remove the indicated component from the component list.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the index of the component to remove


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Remove all components from the component list.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, ReturnStatus: MFnComponentListData.MStatus): 
        '''
        create(self, ReturnStatus: MFnComponentListData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance, and initialize
        it to contain an empty component list.

        Returns: 
        ----- 
        The newly created MObject

        Parameters:
        -----
        ReturnStatus: MFnComponentListData.MStatus
        	[out] -> kSuccess


        '''
        pass

class MFnCompoundAttribute:
    '''Compound attribute function set.
MFnCompoundAttribute is the function set for compound dependency node attributes.
Compound attributes allow the grouping of related attributes into
a larger unit. It is possible to connect to a compound attribute
as a whole, or to any of the individual children.
For example, the three attributes RED, GREEN, and BLUE could be
grouped into a compound attribute of type COLOR. It is then
possible to connect two COLOR attributes together. This removes
the need to connect each child explicitly.
A second use for compound attributes is when there are multi
attributes that relate to each other on an element-by-element
basis. An example of this is the weighted matrix node that has a
multi attribute with matrices that must be matched with the multi
attribute that provides the weights for each matrix.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kCompoundAttribute.Reimplemented from MFnAttribute.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnCompoundAttribute.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnCompoundAttribute".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, fullName: MString,
                        briefName: MString,
                        ReturnStatus: MFnCompoundAttribute.MStatus): 
        '''
        create(self, fullName: MString,
                        briefName: MString,
                        ReturnStatus: MFnCompoundAttribute.MStatus) -> MObject

        Synopsis
        -----
        Creates a new compound attribute. The create method needs to be
        called on a per node basis. That means if you want to create and
        add the same attribute to multiple nodes, you need to call the
        create method for each node to get a unique MObject back. If you
        call create just once and add the attribute to multiple nodes,
        Maya will encounter a fatal error.

        Returns: 
        ----- 
        Return status

        Parameters:
        -----
        fullName: MString
        	[in] -> Long name of the attribute. 

        briefName: MString
        	[in] -> Short name of the attribute. 

        ReturnStatus: MFnCompoundAttribute.MStatus
        	[out] -> Status code.


        '''
        pass

    def addChild(self, child: MObject): 
        '''
        addChild(self, child: MObject)

        Synopsis
        -----
        Add a child attribute under this compound attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        child: MObject
        	[in] -> new child attribute


        '''
        pass

    def removeChild(self, child: MObject): 
        '''
        removeChild(self, child: MObject)

        Synopsis
        -----
        Remove a child attribute from this compound attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        child: MObject
        	[in] -> child attribute to remove


        '''
        pass

    def numChildren(self, ReturnStatus: MFnCompoundAttribute.MStatus): 
        '''
        numChildren(self, ReturnStatus: MFnCompoundAttribute.MStatus) -> int

        Synopsis
        -----
        Returns the number of child attributes that this compound
        attribute has.

        Returns: 
        ----- 
        The number of children

        Parameters:
        -----
        ReturnStatus: MFnCompoundAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def child(self, index: int,
                        ReturnStatus: MFnCompoundAttribute.MStatus): 
        '''
        child(self, index: int,
                        ReturnStatus: MFnCompoundAttribute.MStatus) -> MObject

        Synopsis
        -----
        Get a child of this compound attribute.

        Returns: 
        ----- 
        The child attribute

        Parameters:
        -----
        index: int
        	[in] -> index of child 

        ReturnStatus: MFnCompoundAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def getAddAttrCmds(self, cmds: MStringArray,
                        useLongNames: bool): 
        '''
        getAddAttrCmds(self, cmds: MStringArray,
                        useLongNames: bool)

        Synopsis
        -----
        Returns a string array containing the addAttr commands which
        would be required to recreate the attribute and all of its
        descendents on a node. The attributes are returned in depth-first
        order, meaning that element 0 of the array will contain this
        attribute's addAttr command, element 1 will contain the command
        for its first child, element 2 will contain the command for its
        first child's child, if one exists, and so on.Each command is
        returned with the terminating semicolon and is formatted as if
        for use with a selected node, meaning that no node name is
        supplied.

        Returns:
        -----
        None

        Parameters:
        -----
        cmds: MStringArray
        	[out] -> string array to receive the 

        useLongNames: bool
        	[in] -> if true, long attribute names are used rather than short


        '''
        pass

class MFnContainerNode:
    '''container function set
MFnContainerNode is the function set for creating, querying and editing
containers.
Maya uses container nodes to bundle sets of related nodes
together with a published attribute list that defines the primary
interface to those nodes. This class allows you to query
information about container nodes in the Maya scene.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kContainerBase.Reimplemented from MFnDependencyNode.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnContainerNode.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnContainerNode".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getPublishedPlugs(self, publishedPlugs: MPlugArray,
                        publishedNames: MStringArray): 
        '''
        getPublishedPlugs(self, publishedPlugs: MPlugArray,
                        publishedNames: MStringArray)

        Synopsis
        -----
        Return two arrays: the first contains the plugs that have been
        published on this container. The second contains that published
        names for those plugs. There is a one-to-one correspondence
        between the plugs in the first array and the strings in the
        second.

        Returns:
        -----
        None

        Parameters:
        -----
        publishedPlugs: MPlugArray
        	[out] -> array to store the result plugs 

        publishedNames: MStringArray
        	[out] -> array to store the result names


        '''
        pass

    def getPublishedNames(self, publishedNames: MStringArray,
                        unboundOnly: bool): 
        '''
        getPublishedNames(self, publishedNames: MStringArray,
                        unboundOnly: bool)

        Synopsis
        -----
        Return a list of published names on the container. Depending on
        the arguments, either all published names or only unbound
        published names will be returned.

        Returns:
        -----
        None

        Parameters:
        -----
        publishedNames: MStringArray
        	[out] -> array to store the result names 

        unboundOnly: bool
        	[in] -> if true, only return names that are not associated with a plug


        '''
        pass

    def getMembers(self, members: MObjectArray): 
        '''
        getMembers(self, members: MObjectArray)

        Synopsis
        -----
        Return an array of the nodes included in this container.

        Returns:
        -----
        None

        Parameters:
        -----
        members: MObjectArray
        	[out] -> array to store the result nodes


        '''
        pass

    def getSubcontainers(self, subcontainers: MObjectArray): 
        '''
        getSubcontainers(self, subcontainers: MObjectArray)

        Synopsis
        -----
        Return an array of the container nodes included in this
        container.

        Returns:
        -----
        None

        Parameters:
        -----
        subcontainers: MObjectArray
        	[out] -> array to store the result nodes


        '''
        pass

    def getParentContainer(self, parent: MObject): 
        '''
        getParentContainer(self, parent: MObject)

        Synopsis
        -----
        Return the parent container, if there is one. Otherwise return an
        empty MObject

        Returns:
        -----
        None

        Parameters:
        -----
        parent: MObject
        	[out] -> parent container, if found


        '''
        pass

    def getRootTransform(self, root: MObject): 
        '''
        getRootTransform(self, root: MObject)

        Synopsis
        -----
        Return the root transform, if there is one. Otherwise return an
        empty MObject.

        Returns:
        -----
        None

        Parameters:
        -----
        root: MObject
        	[out] -> root transform, if found


        '''
        pass

    def getPublishedNodes(self, type: MFnContainerNode.MPublishNodeType,
                        publishedNames: MStringArray,
                        nodes: MObjectArray): 
        '''
        getPublishedNodes(self, type: MFnContainerNode.MPublishNodeType,
                        publishedNames: MStringArray,
                        nodes: MObjectArray)

        Synopsis
        -----
        Return a list of the published nodes of a given type. For any
        names that have assigned nodes, return the node at the
        corresponding array index. For any names that do not have
        assigned nodes, a NULL MObject will be at the corresponding array
        index.

        Returns:
        -----
        None

        Parameters:
        -----
        type: MFnContainerNode.MPublishNodeType
        	[in] -> published node type of interest 

        publishedNames: MStringArray
        	[out] -> published names of the specified type 

        nodes: MObjectArray
        	[out] -> corresponding published node or a NULL 


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Delete all members of the container.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def makeCurrent(self, isCurrent: bool): 
        '''
        makeCurrent(self, isCurrent: bool)

        Synopsis
        -----
        Set or clear whether the container managed by this function set
        is denoted as the the current container. If the flag is true and
        the container is allowed to be current, then the current
        container is set to be the container. Otherwise, if the container
        managed by the function set is the current container, then the
        current container is cleared.

        Returns:
        -----
        None

        Parameters:
        -----
        isCurrent: bool
        	[in] -> Specifies whether this container shall be current


        '''
        pass

    def isCurrent(self, status: MFnContainerNode.MStatus): 
        '''
        isCurrent(self, status: MFnContainerNode.MStatus) -> bool

        Synopsis
        -----
        Return whether the container node managed by this function set is
        the current container.

        Returns: 
        ----- 
        True if the container is the current container, false otherwise

        Parameters:
        -----
        status: MFnContainerNode.MStatus
        	[out] -> return status


        '''
        pass

    def getCurrentAsMObject(self): 
        '''
        getCurrentAsMObject(self) -> MObject

        Synopsis
        -----
        Retrieve the current container node.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MPublishNodeType:
    '''Specify which type of published node. 
    Non-functional class.  Values for this enum:
    kParentAnchor
    kChildAnchor
    kGeneric
    '''

    def __init__(self):
        pass

    def kParentAnchor(self):
        '''This is an enum of MPublishNodeType.
        - Description: published as parent anchor 
        - Value: 0
        '''
        pass

    def kChildAnchor(self):
        '''This is an enum of MPublishNodeType.
        - Description: published as child anchor 
        - Value: 1
        '''
        pass

    def kGeneric(self):
        '''This is an enum of MPublishNodeType.
        - Description: published as node (non-anchor) 
        - Value: 2
        '''
        pass

class MFnDagNode:
    '''DAG Node Function Set.
Provides methods for attaching Function Sets to, querying, and
adding children to DAG Nodes. Particularly useful when used in
conjunction with the DAG Iterator class (
MItDag).
The
MFnDagNode function set is used to query and set the attributes of nodes in
the DAG (Directed Acyclic Graph). The DAG is a graph that
describes the hierarchy of the objects in the model. At each
level of the hierarchy there is a four by four transformation
matrix that affects all of the objects beneath it in the DAG.
In the DAG, geometry objects (also known as shapes) do not have
transformation information associated with them. Only transform
nodes have actual transform matrices (see
MFnTransform).
Each node that exists in the DAG is also a dependency node that
exists in the dependency graph. This makes it possible to control
the attributes of a DAG node based on calculations performed by
dependency nodes.
There are two ways to specify a DAG node in Maya. The first is to
use an
MObject handle, which acts as a pointer to a specific node in the DAG.
Given only an
MObject, it is not possible to do world space operations on a DAG node
because there may be more than one path through the DAG to any
given node. In other words, it is not possible to identify a
particular instance only given an
MObject.
In many cases it is preferable to use a DAG path (
MDagPath) to specify a DAG node. A DAG path always refers to a specific
instance of an object. This makes it possible to perform
unambiguous world space transformations.
It is also possible to iterate over the nodes in the DAG using a
DAG iterator (
MItDag).
'''
    def __init__(self):
        pass


    def enum(self): 
        '''
        enum(self) -> anonymous

        Synopsis
        -----
        Anonymous enum to store constant values. used by addChild to
        indicate the next empty position in the list.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kDagNode.Reimplemented from MFnDependencyNode.Reimplemented
        in MFnSubd, MFnMesh, MFnTransform, MFnNurbsSurface,
        MFnNurbsCurve, MFnAssembly, MFnParticleSystem, MFnIkJoint,
        MFnLattice, MFnRotateManip, MFnScaleManip, MFnFluid,
        MFnFreePointTriadManip, MFnSpotLight, MFnToggleManip, MFnCamera,
        MFnHikEffector, MFnDirectionManip, MFnDistanceManip,
        MFnIkEffector, MFnManip3D, MFnStateManip, MFnCircleSweepManip,
        MFnCurveSegmentManip, MFnDragField, MFnLight, MFnNewtonField,
        MFnNonAmbientLight, MFnNonExtendedLight, MFnPointOnCurveManip,
        MFnPointOnSurfaceManip, MFnRadialField, MFnVortexField,
        MFnAmbientLight, MFnAreaLight, MFnDirectionalLight, MFnDiscManip,
        MFnGravityField, MFnPfxGeometry, MFnPointLight,
        MFnTurbulenceField, MFnUniformField, MFnVolumeAxisField,
        MFnVolumeLight, MFnAirField, MFnField, MFnIkHandle, and
        MFnInstancer.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnDagNode.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnDagNode".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def create(self, typeId: MTypeId,
                        parent: MObject,
                        ReturnStatus: MFnDagNode.MStatus): 
        '''
        create(self, typeId: MTypeId,
                        parent: MObject,
                        ReturnStatus: MFnDagNode.MStatus) -> MObject

        Synopsis
        -----
        Creates a new DAG node with the given type tag. The new node is
        placed into the DAG.If a parent is specified, the new node is
        parented to it, and the new node is returned. If no parent is
        specified and the new node is a transform, the new node is
        returned. Otherwise, a transform created and the new node is
        automatically parented to it. The returned object is the
        transform, not the new node.

        Returns: 
        ----- 
        A pointer to the new dependency node object or the transform
        added above it.

        Parameters:
        -----
        typeId: MTypeId
        	[in] -> type id of the node to be created 

        parent: MObject
        	[in] -> the parent of the node to be created 

        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    @overload
    def create(self, typeId: MTypeId,
                        name: MString,
                        parent: MObject,
                        ReturnStatus: MFnDagNode.MStatus): 
        '''
        create(self, typeId: MTypeId,
                        name: MString,
                        parent: MObject,
                        ReturnStatus: MFnDagNode.MStatus) -> MObject

        Synopsis
        -----
        Creates a new DAG node with the given type tag. The new node is
        placed into the DAG.If a parent is specified, the new node is
        parented to it, and the new node is returned. If no parent is
        specified and the new node is a transform, the new node is
        returned. Otherwise, a transform created and the new node is
        automatically parented to it. The returned object is the
        transform, not the new node.

        Returns: 
        ----- 
        A pointer to the new dependency node object or the transform
        added above it.

        Parameters:
        -----
        typeId: MTypeId
        	[in] -> type id of the node to be created 

        name: MString
        	[in] -> the name to be assigned to the new node If the node's name is not unique, it will be given a unique name by changing its numerical suffix. For example, if this node is called "myNode" and a node by the same name exists, this node will be renamed to "myNode1". 

        parent: MObject
        	[in] -> the parent of the node to be created 

        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    @overload
    def create(self, type: MString,
                        parent: MObject,
                        ReturnStatus: MFnDagNode.MStatus): 
        '''
        create(self, type: MString,
                        parent: MObject,
                        ReturnStatus: MFnDagNode.MStatus) -> MObject

        Synopsis
        -----
        Creates a new DAG node with the given type tag. The new node is
        placed into the DAG.If a parent is specified, the new node is
        parented to it, and the new node is returned. If no parent is
        specified and the new node is a transform, the new node is
        returned. Otherwise, a transform created and the new node is
        automatically parented to it. The returned object is the
        transform, not the new node.

        Returns: 
        ----- 
        The new dependency node or the transform added above it.

        Parameters:
        -----
        type: MString
        	[in] -> Name of the type of DAG node to create. 

        parent: MObject
        	[in] -> The DAG parent of this node. 

        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    @overload
    def create(self, type: MString,
                        name: MString,
                        parent: MObject,
                        ReturnStatus: MFnDagNode.MStatus): 
        '''
        create(self, type: MString,
                        name: MString,
                        parent: MObject,
                        ReturnStatus: MFnDagNode.MStatus) -> MObject

        Synopsis
        -----
        Creates a new DAG node with the given type tag. The new node is
        placed into the DAG.If a parent is specified, the new node is
        parented to it, and the new node is returned. If no parent is
        specified and the new node is a transform, the new node is
        returned. Otherwise, a transform created and the new node is
        automatically parented to it. The returned object is the
        transform, not the new node.

        Returns: 
        ----- 
        The new dependency node or the transform added above it.

        Parameters:
        -----
        type: MString
        	[in] -> Name of the type of DAG node to create. 

        name: MString
        	[in] -> Name to be assigned to the new node. If the node's name is not unique it will be given a unique name by adding a numerical suffix. For example, if 

        parent: MObject
        	[in] -> The DAG parent of this node. 

        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def parentCount(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        parentCount(self, ReturnStatus: MFnDagNode.MStatus) -> int

        Synopsis
        -----
        Determines the number of parent Nodes of the Node. Used to
        determine the upper bound for the parent index (max index =
        parentCount-1).

        Returns: 
        ----- 
        Number of parent Nodes.

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def parent(self, i: int,
                        ReturnStatus: MFnDagNode.MStatus): 
        '''
        parent(self, i: int,
                        ReturnStatus: MFnDagNode.MStatus) -> MObject

        Synopsis
        -----
        Queries the DAG Node attached to the Function Set for the parent
        Node corresponding to the given index.

        Returns: 
        ----- 
        The parent Node for the given index.

        Parameters:
        -----
        i: int
        	[in] -> Index to the parent Node 

        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def addChild(self, child: MObject,
                        index: int,
                        keepExistingParents: bool): 
        '''
        addChild(self, child: MObject,
                        index: int,
                        keepExistingParents: bool)

        Synopsis
        -----
        Makes the given DAG Node a child of the DAG Node to which this
        instance of the Function Set is attached. By default, the child
        will be added to the end of the child list. If an index is
        specified, and it is less than or equal to the upper bound, Maya
        will add the child to the specified index and shift the position
        of subsequent children onto the next position. If the index is
        greater than the upper bound, the behavior is undefined.By
        default, the child is removed from its existing parents as a
        result of this operation. If the flag keepExistingParents is set
        to true, the child will keep its existing parents and a new
        instance connection will be created for the new node. Any
        instanced attributes downstream from the new child will be
        updated with new instance numbers.

        Returns:
        -----
        None

        Parameters:
        -----
        child: MObject
        	[in] -> The node to be added as child 

        index: int
        	[in] -> The index that the child should be position. Defaulted to 

        keepExistingParents: bool
        	[in] -> Should the child be instanced?


        '''
        pass

    def removeChild(self, child: MObject): 
        '''
        removeChild(self, child: MObject)

        Synopsis
        -----
        Removes the given DAG Node from the parent. Once the child is
        removed, all children at higher indices would shift 1 position to
        the left.If the child being removed is an instance, any instance
        attributes downstream from the node being removed will be updated
        with the new instance count.

        Returns:
        -----
        None

        Parameters:
        -----
        child: MObject
        	[in] -> The Node to be removed as child


        '''
        pass

    def removeChildAt(self, index: int): 
        '''
        removeChildAt(self, index: int)

        Synopsis
        -----
        Removes the child at the given index from the parent. Once the
        child is removed, all children at higher indices would shift 1
        position to the left.If the child being removed is an instance,
        any instance attributes downstream from the node being removed
        will be updated with the new instance count.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of the child.


        '''
        pass

    def childCount(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        childCount(self, ReturnStatus: MFnDagNode.MStatus) -> int

        Synopsis
        -----
        Determines the number of child Nodes of the Node. Used to
        determine the upper bound for the child index (max index =
        childCount-1).

        Returns: 
        ----- 
        Number of child Nodes.

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def child(self, i: int,
                        ReturnStatus: MFnDagNode.MStatus): 
        '''
        child(self, i: int,
                        ReturnStatus: MFnDagNode.MStatus) -> MObject

        Synopsis
        -----
        Queries the DAG Node attached to the Function Set for the child
        Node corresponding to the given index.

        Returns: 
        ----- 
        The child Node for the given index.

        Parameters:
        -----
        i: int
        	[in] -> Index to the child Node 

        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def dagRoot(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        dagRoot(self, ReturnStatus: MFnDagNode.MStatus) -> MObject

        Synopsis
        -----
        Determines the root of the first DAG Path to the DAG Node
        attached to the Function Set.

        Returns: 
        ----- 
        The DAG root

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def hasParent(self, node: MObject,
                        ReturnStatus: MFnDagNode.MStatus): 
        '''
        hasParent(self, node: MObject,
                        ReturnStatus: MFnDagNode.MStatus) -> bool

        Synopsis
        -----
        Determines whether or not the given Node is a parent of the DAG
        Node attached to the Function Set.

        Returns: 
        ----- 
        true if the node is a parent, false otherwise.

        Parameters:
        -----
        node: MObject
        	[in] -> Potential parent node 

        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def hasChild(self, node: MObject,
                        ReturnStatus: MFnDagNode.MStatus): 
        '''
        hasChild(self, node: MObject,
                        ReturnStatus: MFnDagNode.MStatus) -> bool

        Synopsis
        -----
        Determines whether or not the given Node is a child of the DAG
        Node attached to the Function Set.

        Returns: 
        ----- 
        true if the node is a child, false otherwise.

        Parameters:
        -----
        node: MObject
        	[in] -> node to check 

        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def isChildOf(self, node: MObject,
                        ReturnStatus: MFnDagNode.MStatus): 
        '''
        isChildOf(self, node: MObject,
                        ReturnStatus: MFnDagNode.MStatus) -> bool

        Synopsis
        -----
        Determines whether or not the DAG Node attached to the Function
        Set is a child of the given node.

        Returns: 
        ----- 
        true is a child, false otherwise.

        Parameters:
        -----
        node: MObject
        	[in] -> node to check 

        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def isParentOf(self, node: MObject,
                        ReturnStatus: MFnDagNode.MStatus): 
        '''
        isParentOf(self, node: MObject,
                        ReturnStatus: MFnDagNode.MStatus) -> bool

        Synopsis
        -----
        Determines whether or not the DAG Node attached to the Function
        Set is a parent of the given node.

        Returns: 
        ----- 
        true is a parent, false otherwise.

        Parameters:
        -----
        node: MObject
        	[in] -> node to check 

        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def inUnderWorld(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        inUnderWorld(self, ReturnStatus: MFnDagNode.MStatus) -> bool

        Synopsis
        -----
        Determines whether or not the DAG Node is an underworld node. (An
        example of an underworld node is a curve on surface.)

        Returns: 
        ----- 
        true if the node is an underworld node, false otherwise.

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def inModel(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        inModel(self, ReturnStatus: MFnDagNode.MStatus) -> bool

        Synopsis
        -----
        Determines whether or not the DAG Node is in the model.

        Returns: 
        ----- 
        true if the node in the model, false otherwise.

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def isInstanceable(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        isInstanceable(self, ReturnStatus: MFnDagNode.MStatus) -> bool

        Synopsis
        -----
        Returns true if the DAG node can be instanced, and false
        otherwise.

        Returns: 
        ----- 
        true if the DAG node is instanceable, false otherwise.

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def setInstanceable(self, how: bool): 
        '''
        setInstanceable(self, how: bool)

        Synopsis
        -----
        Sets whether or not the DAG node is instanceable. If the node is
        marked as noninstanceable, then if Maya attempts to create
        instances on the node the instancing operation will not succeed
        and instead an error will be reported. A node cannot be marked
        non-instanceable if it or any of its children are currently
        instanced. MS::kFailure will be returned it this occurs. The
        default instanceable state for newly created nodes if true,
        meaning that nodes can be instanced by default.

        Returns:
        -----
        None

        Parameters:
        -----
        how: bool
        	[in] -> true if the node should be made instanceable, false to make the node noninstanceable.


        '''
        pass

    def isInstanced(self, indirect: bool,
                        ReturnStatus: MFnDagNode.MStatus): 
        '''
        isInstanced(self, indirect: bool,
                        ReturnStatus: MFnDagNode.MStatus) -> bool

        Synopsis
        -----
        Determines whether the DAG Node attached to the Function Set is
        directly or indirectly instanced. If indirect instance flag is
        false, the result is true if and only if the Node itself is
        multiply instanced (node->parentCount > 1).If the indirect flag
        is true, the result is true if and only if the Node itself is
        multiply instanced (node->parentCount > 1) or if the Node is not
        multiply instanced, but it has a directly instanced parent
        (node->parentCount()=1 amd parent->parentCount >1).

        Returns: 
        ----- 
        true if the node is instanced (directly or indirectly according
        to indirect instance flag), false otherwise.

        Parameters:
        -----
        indirect: bool
        	[in] -> Indirect instance flag 

        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def isInstancedAttribute(self, attribute: MObject,
                        ReturnStatus: MFnDagNode.MStatus): 
        '''
        isInstancedAttribute(self, attribute: MObject,
                        ReturnStatus: MFnDagNode.MStatus) -> bool

        Synopsis
        -----
        Returns true if the specified attribute is instanced. An
        instanced attribute is an array attribute whose index depends
        upon which instance of the node is being referred to.Attributes
        are not instanced by default.

        Returns: 
        ----- 
        A boolean value indicating whether the attribute is instanced

        Parameters:
        -----
        attribute: MObject
        	[in] -> The attribute to test. 

        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def instanceCount(self, total: bool,
                        ReturnStatus: MFnDagNode.MStatus): 
        '''
        instanceCount(self, total: bool,
                        ReturnStatus: MFnDagNode.MStatus) -> int

        Synopsis
        -----
        Determines the number of times the Node attached to the Function
        Set is instanced. If indirect instance flag is false, the number
        of direct instances is returned.If the indirect flag is true, the
        total number of times the Node is instanced in the DAG above it
        is returned.

        Returns: 
        ----- 
        Number of instances (direct or indirect according to indirect
        instance flag).

        Parameters:
        -----
        total: bool
        	[in] -> Indirect instance flag 

        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def duplicate(self, instance: bool,
                        leafInstance: bool,
                        ReturnStatus: MFnDagNode.MStatus): 
        '''
        duplicate(self, instance: bool,
                        leafInstance: bool,
                        ReturnStatus: MFnDagNode.MStatus) -> MObject

        Synopsis
        -----
        This method duplicates the DAG hierarchy rooted at the current
        node. The copy will have the same parent, if any, as the original
        node.If instance is false then a true copy will be made,
        otherwise a new node will be created which instances the child
        nodes of the original node. If instance is false then
        instanceLeaf is ignored.If instance is true and instanceLeaf is
        false then the child nodes of the original node are instanced. If
        instanceLeaf is true, then the results are similar to a copy, but
        the leaf level objects are instanced.If the function set is
        initialized without an MDagPath, then this method uses the first
        path to the node. This is only a problem if the node has been
        instanced, in which case the simple solution is to use an
        MDagPath to initialize the function set.

        Returns: 
        ----- 
        A reference to the newly created node.

        Parameters:
        -----
        instance: bool
        	[in] -> Duplicate using instancing if true 

        leafInstance: bool
        	[in] -> Instance only at the leaf level if true 

        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def getPath(self, path: MDagPath): 
        '''
        getPath(self, path: MDagPath)

        Synopsis
        -----
        Returns a DAG Path to the DAG Node attached to the Function Set.
        The difference between this method and the method dagPath below
        is that this one will not fail if the function set is not
        attached to a dag path, it will always return a path to the node.
        dagPath will fail if the function set is not attached to a dag
        path.

        Returns:
        -----
        None

        Parameters:
        -----
        path: MDagPath
        	[out] -> The DAG Path that is found (implicit return)


        '''
        pass

    def getAllPaths(self, paths: MDagPathArray): 
        '''
        getAllPaths(self, paths: MDagPathArray)

        Synopsis
        -----
        Determines all DAG Paths to the DAG Node attached to the Function
        Set.

        Returns:
        -----
        None

        Parameters:
        -----
        paths: MDagPathArray
        	[out] -> Array of all DAG Paths that are found (implicit return)


        '''
        pass

    def fullPathName(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        fullPathName(self, ReturnStatus: MFnDagNode.MStatus) -> MString

        Synopsis
        -----
        Return a string representing the full path from the root of the
        dag to this object.

        Returns: 
        ----- 
        The full path name

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def partialPathName(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        partialPathName(self, ReturnStatus: MFnDagNode.MStatus) -> MString

        Synopsis
        -----
        Return a string representing the partial path from the root of
        the dag to this object. The partial path is the minimum path that
        is still unique. This string may contain wildcards.

        Returns: 
        ----- 
        The partial path name

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def transformationMatrix(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        transformationMatrix(self, ReturnStatus: MFnDagNode.MStatus) -> MMatrix

        Synopsis
        -----
        Returns the object space transformation matrix for this DAG node.
        In general, only transform nodes have matrices associated with
        them. Nodes such as shapes (geometry nodes) do not have transform
        matrices.The identity matrix will be returned if this node does
        not have a transformation matrix.

        Returns: 
        ----- 
        Object space transformation matrix.

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def isIntermediateObject(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        isIntermediateObject(self, ReturnStatus: MFnDagNode.MStatus) -> bool

        Synopsis
        -----
        Returns true if this object is an intermediate in a geometry
        calculation. When geometry calculations are performed using
        dependency nodes, it is sometimes necessary to use intermediate
        objects. These objects are not draw or rendered. For example,
        deformers use intermediate geometry during their
        calculations.This method exists to provide a more convenient way
        of accessing the intermediateObject attribute of DAG nodes.

        Returns: 
        ----- 
        True if this is an intermediate object.

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def setIntermediateObject(self, isIntermediate: bool): 
        '''
        setIntermediateObject(self, isIntermediate: bool)

        Synopsis
        -----
        Sets whether this object is an intermediate in a geometry
        calculation. When geometry calculations are performed using
        dependency nodes, it is sometimes necessary to use intermediate
        objects. These objects are not draw or rendered. For example,
        deformers use intermediate geometry during their
        calculations.This method exists to provide a more convenient way
        of accessing the intermediateObject attribute of DAG nodes.

        Returns:
        -----
        None

        Parameters:
        -----
        isIntermediate: bool
        	[in] -> whether to make this an intermediate object


        '''
        pass

    @overload
    def setObjectColor(self, index: int): 
        '''
        setObjectColor(self, index: int)

        Synopsis
        -----
        Sets the index for the current user defined inactive color used
        by the node. This method is only meaningful for shape or joint
        nodes (e.g. nurbs curves/surfaces, meshes). It will work for
        other nodes, but will have no visible effect.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> Index for current user color (0 - 7)


        '''
        pass

    def objectColorType(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        objectColorType(self, ReturnStatus: MFnDagNode.MStatus) -> MFnDagNode.MFnDagNode

        Synopsis
        -----
        Determines whether or not the user defined inactive color will be
        used for the node, or whether the default inactive color will be
        used. This method is only meaningful for shape or joint nodes
        (e.g. nurbs curves/surfaces, meshes). It will work for other
        nodes, but will have no visible effect.

        Returns: 
        ----- 
        MFnDagNode::kUseDefaultColor if using the the color defined in
        the color preferences  MFnDagNode::kUseIndexColor if using the
        inactive indexed object color  MFnDagNode::kUseRGBColor if using
        the inactive RGB object color

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def setObjectColorType(self, type: MFnDagNode.MObjectColorType): 
        '''
        setObjectColorType(self, type: MFnDagNode.MObjectColorType)

        Synopsis
        -----
        Sets whether or not the user defined inactive object color will
        be used. This method is only meaningful for shape or joint nodes
        (e.g. nurbs curves/surfaces, meshes). It will work for other
        nodes, but will have no visible effect.

        Returns:
        -----
        None

        Parameters:
        -----
        type: MFnDagNode.MObjectColorType
        	[in] -> MFnDagNode::kUseDefaultColor


        '''
        pass

    @overload
    def setObjectColor(self, color: MColor): 
        '''
        setObjectColor(self, color: MColor)

        Synopsis
        -----
        Sets the color value for the current user defined inactive color
        used by the node. This method is only meaningful for shape or
        joint nodes (e.g. nurbs curves/surfaces, meshes). It will work
        for other nodes, but will have no visible effect.

        Returns:
        -----
        None

        Parameters:
        -----
        color: MColor
        	[in] -> Color to be set


        '''
        pass

    def objectColorRGB(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        objectColorRGB(self, ReturnStatus: MFnDagNode.MStatus) -> MColor

        Synopsis
        -----
        Determines the RGB color for the current user defined inactive
        color used by the node. This method is only meaningful for shape
        or joint nodes (e.g. nurbs curves/surfaces, meshes). It will work
        for other nodes, but will have no visible effect.

        Returns: 
        ----- 
        MColor defining the current RGB color

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def objectColorIndex(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        objectColorIndex(self, ReturnStatus: MFnDagNode.MStatus) -> int

        Synopsis
        -----
        Determines the index for the current user defined inactive color
        used by the node. Valid indices are from 0 to 7.This method is
        only meaningful for shape or joint nodes (e.g. nurbs
        curves/surfaces, meshes). It will work for other nodes, but will
        have no visible effect.

        Returns: 
        ----- 
        Index for current user defined inactive color (0 - 7)

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def hiliteColor(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        hiliteColor(self, ReturnStatus: MFnDagNode.MStatus) -> MColor

        Synopsis
        -----
        Determines the current hilite color used by the node.

        Returns: 
        ----- 
        The current hilite color.

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def usingHiliteColor(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        usingHiliteColor(self, ReturnStatus: MFnDagNode.MStatus) -> bool

        Synopsis
        -----
        Determines whether or not the hilite color will be used for the
        node. hilite command sets this flag to true.

        Returns: 
        ----- 
        True if using the hilite color.

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def dormantColor(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        dormantColor(self, ReturnStatus: MFnDagNode.MStatus) -> MColor

        Synopsis
        -----
        Determines the dormant color used by this node. The order to
        determine the dormant color is:

        Returns: 
        ----- 
        The dormant color.

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def activeColor(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        activeColor(self, ReturnStatus: MFnDagNode.MStatus) -> MColor

        Synopsis
        -----
        Determines the active color used by this node. The active color
        is the active color for this kind of dag node.

        Returns: 
        ----- 
        The active color.

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def drawOverrideEnabled(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        drawOverrideEnabled(self, ReturnStatus: MFnDagNode.MStatus) -> bool

        Synopsis
        -----
        Determines whether or not draw override is turned on for this
        node.

        Returns: 
        ----- 
        True if draw override is turned on.

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def drawOverrideIsReference(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        drawOverrideIsReference(self, ReturnStatus: MFnDagNode.MStatus) -> bool

        Synopsis
        -----
        Determines whether or not Display Type of the draw override is
        Reference for this node.

        Returns: 
        ----- 
        True if Display Type is Reference.

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def drawOverrideIsTemplate(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        drawOverrideIsTemplate(self, ReturnStatus: MFnDagNode.MStatus) -> bool

        Synopsis
        -----
        Determines whether or not Display Type of the draw override is
        Template for this node.

        Returns: 
        ----- 
        True if Display Type is Template.

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def drawOverrideColor(self, color: MColor,
                        ReturnStatus: MFnDagNode.MStatus): 
        '''
        drawOverrideColor(self, color: MColor,
                        ReturnStatus: MFnDagNode.MStatus) -> bool

        Synopsis
        -----
        Determines the draw override color used by this node. Returns
        true if there is a draw override color. Otherwise, returns false
        and color parameter is not changed.

        Returns: 
        ----- 
        True if a draw override color is used.

        Parameters:
        -----
        color: MColor
        	[out] -> The draw override color. 

        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def getConnectedSetsAndMembers(self, instanceNumber: int,
                        sets: MObjectArray,
                        comps: MObjectArray,
                        renderableSetsOnly: bool): 
        '''
        getConnectedSetsAndMembers(self, instanceNumber: int,
                        sets: MObjectArray,
                        comps: MObjectArray,
                        renderableSetsOnly: bool)

        Synopsis
        -----
        Returns all the sets connected to the specified instance of this
        DAG object. For each set in the "sets" array there is a
        corresponding entry in the "comps" array which are all the
        components in that set. If the entire object is in a set, then
        the corresponding entry in the comps array will have no elements
        in it.

        Returns:
        -----
        None

        Parameters:
        -----
        instanceNumber: int
        	[in] -> The instance number of the mesh to query 

        sets: MObjectArray
        	[out] -> Storage for the sets 

        comps: MObjectArray
        	[out] -> Storage for the components that are in the corresponding set 

        renderableSetsOnly: bool
        	[in] -> If true then this method will only return renderable sets


        '''
        pass

    def boundingBox(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        boundingBox(self, ReturnStatus: MFnDagNode.MStatus) -> MBoundingBox

        Synopsis
        -----
        Returns the bounding box for the dag node in object space.

        Returns: 
        ----- 
        The bounding box for the dag node

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    def dagPath(self, ReturnStatus: MFnDagNode.MStatus): 
        '''
        dagPath(self, ReturnStatus: MFnDagNode.MStatus) -> MDagPath

        Synopsis
        -----
        Returns the DagPath to which the Function Set is attached. The
        difference between this method and the method getPath above is
        that this one will fail if the function set is not attached to a
        dag path. getPath will find a dag path if the function set is not
        attached to one.

        Returns: 
        ----- 
        An MDagPath that references the object to which the Function Set
        is attached. If the function set is not attached to a dag path an
        uninitialized MDagPath will be returned.

        Parameters:
        -----
        ReturnStatus: MFnDagNode.MStatus
        	[out] -> Status code.


        '''
        pass

    @overload
    def setObject(self, objectPath: MDagPath): 
        '''
        setObject(self, objectPath: MDagPath)

        Synopsis
        -----
        Attaches Function Set to the DAG Node that has the given DAG
        Path.

        Returns:
        -----
        None

        Parameters:
        -----
        objectPath: MDagPath
        	[in] -> DAG Path to Node to be attached.


        '''
        pass

    @overload
    def setObject(self, object: MObject): 
        '''
        setObject(self, object: MObject)

        Synopsis
        -----
        Attaches Function Set to given DAG Node. Reimplemented from
        MFnBase.

        Returns:
        -----
        None

        Parameters:
        -----
        object: MObject
        	[in] -> Target Node for attachment.


        '''
        pass

class MObjectColorType:
    '''Enum to set how an object is colored. 
    Non-functional class.  Values for this enum:
    kUseDefaultColor
    kUseIndexColor
    kUseRGBColor
    '''

    def __init__(self):
        pass

    def kUseDefaultColor(self):
        '''This is an enum of MObjectColorType.
        - Description: Use preference color. 
        - Value: 0
        '''
        pass

    def kUseIndexColor(self):
        '''This is an enum of MObjectColorType.
        - Description: Use index color. 
        - Value: 1
        '''
        pass

    def kUseRGBColor(self):
        '''This is an enum of MObjectColorType.
        - Description: Use RGB color. 
        - Value: 2
        '''
        pass

class MFnData:
    '''Parent class for dependency graph data function sets.
MFnData is the parent class for all dependency graph data function sets.
Conceptually, data objects are what flow through the connections
in the dependency graph.
Each node in the dependency graph has a data block associated
with it. The data block holds the data objects for all of the
node's attributes (see
MDataBlock). The data block is only available during the compute method of
a node. A data handle (
MDataHandle) can be created to access a particular attribute's data inside
of the data block.
Once a data handle is obtained, it is possible to get the data
object from it. This is only necessary for heavier data
structures such as geometry or strings. Simple numeric data can
be manipulated straight through the data handle.
Note: using kDynSweptGeometry data requires that a plug-in or
stand alone API application be linked with the OpenMayaFX
library.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kData.Reimplemented from MFnBase.Reimplemented in
        MFnFalloffData, MFnPluginData, MFnNurbsSurfaceData,
        MFnDynSweptGeometryData, MFnNurbsCurveData, MFnSubdData,
        MFnMeshData, MFnNumericData, MFnArrayAttrsData,
        MFnDoubleArrayData, MFnFloatArrayData, MFnSphereData,
        MFnFloatVectorArrayData, MFnGeometryData, MFnNIdData,
        MFnUintArrayData, MFnMatrixData, MFnComponentListData,
        MFnIntArrayData, MFnMatrixArrayData, MFnPointArrayData,
        MFnStringArrayData, MFnStringData, MFnUInt64ArrayData,
        MFnVectorArrayData, MFnLatticeData, and MFnNObjectData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class Type:
    '''Types of dependency graph data. 
    Non-functional class.  Values for this enum:
    kInvalid
    kNumeric
    kPlugin
    kPluginGeometry
    kString
    kMatrix
    kStringArray
    kDoubleArray
    kFloatArray
    kIntArray
    kPointArray
    kVectorArray
    kMatrixArray
    kComponentList
    kMesh
    kLattice
    kNurbsCurve
    kNurbsSurface
    kSphere
    kDynArrayAttrs
    kDynSweptGeometry
    kSubdSurface
    kNObject
    kNId
    kAny
    kFalloffFunction
    kLast
    '''

    def __init__(self):
        pass

    def kInvalid(self):
        '''This is an enum of Type.
        - Description: Invalid value. 
        - Value: 0
        '''
        pass

    def kNumeric(self):
        '''This is an enum of Type.
        - Description: Numeric, use MFnNumericData extract the node data. 
        - Value: 1
        '''
        pass

    def kPlugin(self):
        '''This is an enum of Type.
        - Description: Plugin Blind Data, use MFnPluginData to extract the node data. 
        - Value: 2
        '''
        pass

    def kPluginGeometry(self):
        '''This is an enum of Type.
        - Description: Plugin Geometry, use MFnGeometryData to extract the node data. 
        - Value: 3
        '''
        pass

    def kString(self):
        '''This is an enum of Type.
        - Description: String, use MFnStringData to extract the node data. 
        - Value: 4
        '''
        pass

    def kMatrix(self):
        '''This is an enum of Type.
        - Description: Matrix, use MFnMatrixData to extract the node data. 
        - Value: 5
        '''
        pass

    def kStringArray(self):
        '''This is an enum of Type.
        - Description: String Array, use MFnStringArrayData to extract the node data. 
        - Value: 6
        '''
        pass

    def kDoubleArray(self):
        '''This is an enum of Type.
        - Description: Double Array, use MFnDoubleArrayData to extract the node data. 
        - Value: 7
        '''
        pass

    def kFloatArray(self):
        '''This is an enum of Type.
        - Description: Float Array, use MFnFloatArrayData to extract the node data. 
        - Value: 8
        '''
        pass

    def kIntArray(self):
        '''This is an enum of Type.
        - Description: Int Array, use MFnIntArrayData to extract the node data. 
        - Value: 9
        '''
        pass

    def kPointArray(self):
        '''This is an enum of Type.
        - Description: Point Array, use MFnPointArrayData to extract the node data. 
        - Value: 10
        '''
        pass

    def kVectorArray(self):
        '''This is an enum of Type.
        - Description: Vector Array, use MFnVectorArrayData to extract the node data. 
        - Value: 11
        '''
        pass

    def kMatrixArray(self):
        '''This is an enum of Type.
        - Description: Matrix Array, use MFnMatrixArrayData to extract the node data. 
        - Value: 12
        '''
        pass

    def kComponentList(self):
        '''This is an enum of Type.
        - Description: Component List, use MFnComponentListData to extract the node data. 
        - Value: 13
        '''
        pass

    def kMesh(self):
        '''This is an enum of Type.
        - Description: Mesh, use MFnMeshData to extract the node data. 
        - Value: 14
        '''
        pass

    def kLattice(self):
        '''This is an enum of Type.
        - Description: Lattice, use MFnLatticeData to extract the node data. 
        - Value: 15
        '''
        pass

    def kNurbsCurve(self):
        '''This is an enum of Type.
        - Description: Nurbs Curve, use MFnNurbsCurveData to extract the node data. 
        - Value: 16
        '''
        pass

    def kNurbsSurface(self):
        '''This is an enum of Type.
        - Description: Nurbs Surface, use MFnNurbsSurfaceData to extract the node data. 
        - Value: 17
        '''
        pass

    def kSphere(self):
        '''This is an enum of Type.
        - Description: Sphere, use MFnSphereData to extract the node data. 
        - Value: 18
        '''
        pass

    def kDynArrayAttrs(self):
        '''This is an enum of Type.
        - Description: ArrayAttrs, use MFnArrayAttrsData to extract the node data. 
        - Value: 19
        '''
        pass

    def kDynSweptGeometry(self):
        '''This is an enum of Type.
        - Description: SweptGeometry, use MFnDynSweptGeometryData to extract the node data. This data node is in OpenMayaFX which must be linked to. 
        - Value: 20
        '''
        pass

    def kSubdSurface(self):
        '''This is an enum of Type.
        - Description: Subdivision Surface, use MFnSubdData to extract the node data. 
        - Value: 21
        '''
        pass

    def kNObject(self):
        '''This is an enum of Type.
        - Description: nObject data, use MFnNObjectData to extract node data 
        - Value: 22
        '''
        pass

    def kNId(self):
        '''This is an enum of Type.
        - Description: nId data, use MFnNIdData to extract node data 
        - Value: 23
        '''
        pass

    def kAny(self):
        '''This is an enum of Type.
        - Description: Typically used when the data can be one of several types. 
        - Value: 24
        '''
        pass

    def kFalloffFunction(self):
        '''This is an enum of Type.
        - Description: Introduced in 2022.0 2022.0:Introduced in this version. Falloff function, use MFnFalloffData to extrat the data 
        - Value: 25
        '''
        pass

    def kLast(self):
        '''This is an enum of Type.
        - Description: Last value. It does not represent real data, but can be used to loop on all possible types 
        - Value: 26
        '''
        pass

class MFnDependencyNode:
    '''Dependency node function set.
MFnDependencyNode allows the creation and manipulation of dependency graph nodes.
Traversal of the dependency graph is possible using the
getConnections method.
This function set does not support creation or removal of
connections.
MDGModifier should be used for that purpose.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kDependencyNode.Reimplemented from MFnBase.Reimplemented in
        MFnAnimCurve, MFnSubd, MFnMesh, MFnTransform, MFnNurbsSurface,
        MFnNurbsCurve, MFnAssembly, MFnClip, MFnCharacter,
        MFnBlendShapeDeformer, MFnParticleSystem, MFnDagNode, MFnIkJoint,
        MFnLatticeDeformer, MFnWeightGeometryFilter, MFnSet,
        MFnMotionPath, MFnLattice, MFnRotateManip, MFnScaleManip,
        MFnDisplayLayerManager, MFnSkinCluster, MFnDisplayLayer,
        MFnCameraSet, MFnFluid, MFnFreePointTriadManip,
        MFnGeometryFilter, MFnImageSource, MFnPartition, MFnReference,
        MFnSpotLight, MFnWireDeformer, MFnLayeredShader, MFnPhongEShader,
        MFnToggleManip, MFnAnisotropyShader, MFnCamera, MFnContainerNode,
        MFnExpression, MFnHikEffector, MFnLambertShader,
        MFnReflectShader, MFnDirectionManip, MFnDistanceManip,
        MFnIkEffector, MFnIkSolver, MFnManip3D, MFnRenderPass,
        MFnStateManip, MFnCircleSweepManip, MFnCurveSegmentManip,
        MFnDragField, MFnLight, MFnNewtonField, MFnNonAmbientLight,
        MFnNonExtendedLight, MFnPointOnCurveManip,
        MFnPointOnSurfaceManip, MFnRadialField, MFnRenderLayer,
        MFnStandardSurfaceShader, MFnVortexField, MFnAmbientLight,
        MFnAreaLight, MFnDirectionalLight, MFnDiscManip, MFnGravityField,
        MFnPfxGeometry, MFnPointLight, MFnTurbulenceField,
        MFnUniformField, MFnVolumeAxisField, MFnVolumeLight, MFnAirField,
        MFnBlinnShader, MFnField, MFnIkHandle, MFnPhongShader, and
        MFnInstancer.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnDependencyNode.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnDependencyNode".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def create(self, typeId: MTypeId,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        create(self, typeId: MTypeId,
                        ReturnStatus: MFnDependencyNode.MStatus) -> MObject

        Synopsis
        -----
        Creates a new dependency node with the given type tag. The new
        node is placed into the dependency graph.If the node is a DAG
        node, it will be parented to a transform.The initial name for the
        node will be the node's "typeName" followed by a number to make
        the instance unique. For example, the first transform node
        created will be named "transform1".

        Returns: 
        ----- 
        A pointer to the new dependency node object

        Parameters:
        -----
        typeId: MTypeId
        	[in] -> type id of node to be created 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def create(self, typeId: MTypeId,
                        name: MString,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        create(self, typeId: MTypeId,
                        name: MString,
                        ReturnStatus: MFnDependencyNode.MStatus) -> MObject

        Synopsis
        -----
        Creates a new dependency node with the given type tag. The new
        node is placed into the dependency graph.If the node is a DAG
        node, it will be parented to a transform.

        Returns: 
        ----- 
        A pointer to the new dependency node object

        Parameters:
        -----
        typeId: MTypeId
        	[in] -> type id of node to be created 

        name: MString
        	[in] -> the name to be assigned to the new node If the node's name is not unique, it will be given a unique name by changing its numerical suffix. For example, if this node is called "myNode" and a node by the same name exists, this node will be renamed to "myNode1". 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def create(self, type: MString,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        create(self, type: MString,
                        ReturnStatus: MFnDependencyNode.MStatus) -> MObject

        Synopsis
        -----
        Creates a new dependency node with the given type. The new node
        is placed into the dependency graph.If the node is a DAG node, it
        will be parented to a transform.The initial name for the node
        will be the node's "typeName" followed by a number to make the
        instance unique. For example, the first transform node created
        will be named "transform1".

        Returns: 
        ----- 
        A pointer to the new dependency node object

        Parameters:
        -----
        type: MString
        	[in] -> int name for the type of dependency node 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def create(self, type: MString,
                        name: MString,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        create(self, type: MString,
                        name: MString,
                        ReturnStatus: MFnDependencyNode.MStatus) -> MObject

        Synopsis
        -----
        Creates a new dependency node with the given type. The new node
        is placed into the dependency graph.If the node is a DAG node, it
        will be parented to a transform.

        Returns: 
        ----- 
        A pointer to the new dependency node object

        Parameters:
        -----
        type: MString
        	[in] -> int name for the type of dependency node 

        name: MString
        	[in] -> the name to be assigned to the new node If the node's name is not unique, it will be given a unique name by changing its numerical suffix. For example, if this node is called "myNode" and a node by the same name exists, this node will be renamed to "myNode1". 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def typeId(self, ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        typeId(self, ReturnStatus: MFnDependencyNode.MStatus) -> MTypeId

        Synopsis
        -----
        Returns the type id of this node. The type is is the 4 byte code
        that is used in the binary file format to identify the type of
        this node.

        Returns: 
        ----- 
        The type id of this node

        Parameters:
        -----
        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def typeName(self, ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        typeName(self, ReturnStatus: MFnDependencyNode.MStatus) -> MString

        Synopsis
        -----
        Returns the type name of this node. The string returned is the
        name of the node type as it is used in the ascii file format.

        Returns: 
        ----- 
        The type name of this node

        Parameters:
        -----
        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def name(self, ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        name(self, ReturnStatus: MFnDependencyNode.MStatus) -> MString

        Synopsis
        -----
        Returns the name of this node. Note that if the object the
        instance of this class is attached to is data instead of being in
        the graph (ie. the object was created by one of the MFn*Data
        function sets, or was passed to an MPxNode::compute function in a
        data block) then the name method will not work.

        Returns: 
        ----- 
        The name of this node

        Parameters:
        -----
        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def absoluteName(self, ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        absoluteName(self, ReturnStatus: MFnDependencyNode.MStatus) -> MString

        Synopsis
        -----
        Returns the absolute name of this node. The absolute name of a
        node is the full namespace path starting at (and including) the
        root namespace, down to (and including) the node itself.
        Regardless of relative name mode, absoluteName() will always
        return a full namespace path prefixed with a leading colon (the
        root namespace).If the underlying node is a DAG node, then
        absoluteName() does not guarantee uniqueness, that is, two
        dependency nodes could have the same absoluteName(). In cases
        like this the uniqueName() method will guarantee that the name
        uniquely identifies the node.See MFnDependencyNode::name()
        comments for MFn*Data restrictions.

        Returns: 
        ----- 
        The absolute name of this node.

        Parameters:
        -----
        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def uniqueName(self, ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        uniqueName(self, ReturnStatus: MFnDependencyNode.MStatus) -> MString

        Synopsis
        -----
        Introduced in 2023.0 Returns the unique name of this node.For a
        DAG node, the unique name of a node is the full namespace path
        starting at (and including) the root namespace, down to (and
        including) the node itself.For a non-DAG node, the uniqueName is
        just its name.

        Returns: 
        ----- 
        The unique name of this node.

        Parameters:
        -----
        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def pluginName(self, ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        pluginName(self, ReturnStatus: MFnDependencyNode.MStatus) -> MString

        Synopsis
        -----
        Returns the name of the plug-in this MFnDependendencyNode was
        defined in. The name returned is the name of the plug-in on disk,
        and may contain pathname separators (such as `/') and drive
        letters (e.g. C:). If this object is not an MFnDependency node,
        then MS::kFailure is returned instead.

        Returns: 
        ----- 
        The name of the plug-in

        Parameters:
        -----
        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def setName(self, name: MString,
                        createNamespace: bool,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        setName(self, name: MString,
                        createNamespace: bool,
                        ReturnStatus: MFnDependencyNode.MStatus) -> MString

        Synopsis
        -----
        Sets the name of this node. If the new name conflicts with the
        name of an existing node then the object will be given a unique
        name based on the supplied name. If the new name ends in a single
        '#' it will be replaced with a number that ensures the new name
        is unique.The name can also have a namespace path, for example
        "ns:ball". If the namespace already exists, the object will be be
        moved into that namespace (in addition to being renamed). If the
        namespace does not exist then the 'createNamespace' parameter
        will determine how to handle it. If the parameter is true then
        the namespace will be created (under the root if the namespace
        name is absolute, or under the current namespace if not) and the
        object will be moved into the new namespace. If the parameter is
        false then the object will be moved into the current
        namespace.When a transform is renamed, any shape nodes beneath
        the transform that have the same prefix as the old transform name
        are also renamed. For example, "rename nurbsSphere1 ball" would
        rename "nurbsSphere1|nurbsSphereShape1" to "ball|ballShape".The
        unique name set for the node is returned.Note that if the object
        to which the functionset is attached is data rather than a node
        (ie. the object was created by one of the MFn*Data function sets,
        or was passed to an MPxNode::compute function in a data block)
        then the setName method will not work.

        Returns: 
        ----- 
        The new name of the node.

        Parameters:
        -----
        name: MString
        	[in] -> the new name for the node 

        createNamespace: bool
        	[in] -> determine whether or not to create a new namespace when the given name includes a namespace which does not exist. 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def uuid(self, ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        uuid(self, ReturnStatus: MFnDependencyNode.MStatus) -> MUuid

        Synopsis
        -----
        Returns the node's UUID.

        Returns: 
        ----- 
        The node's UUID.

        Parameters:
        -----
        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def setUuid(self, muuid: MUuid,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        setUuid(self, muuid: MUuid,
                        ReturnStatus: MFnDependencyNode.MStatus)

        Synopsis
        -----
        Sets the node's UUID. If the node is in the dependency graph,
        this operation will fail if another node in the graph already has
        the given UUID.

        Returns:
        -----
        None

        Parameters:
        -----
        muuid: MUuid
        	[in] -> the new UUID for the node 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def getConnections(self, array: MPlugArray): 
        '''
        getConnections(self, array: MPlugArray)

        Synopsis
        -----
        Get all of the current connections to this node as an array of
        plugs.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MPlugArray
        	[out] -> storage for the array of plugs


        '''
        pass

    def attributeCount(self, ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        attributeCount(self, ReturnStatus: MFnDependencyNode.MStatus) -> int

        Synopsis
        -----
        Returns the number of attributes that this node has.

        Returns: 
        ----- 
        The attribute count

        Parameters:
        -----
        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def attribute(self, index: int,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        attribute(self, index: int,
                        ReturnStatus: MFnDependencyNode.MStatus) -> MObject

        Synopsis
        -----
        Finds the attribute of this node at the given index. Index order
        is based on the order in which the attributes were added to the
        node.

        Returns: 
        ----- 
        A pointer to the attribute

        Parameters:
        -----
        index: int
        	[in] -> the index of the attribute 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def reorderedAttribute(self, index: int,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        reorderedAttribute(self, index: int,
                        ReturnStatus: MFnDependencyNode.MStatus) -> MObject

        Synopsis
        -----
        Some nodes, such as the various animCurve nodes, require that
        their attributes be set in a specific order for proper operation.
        Usually this ordering is only important when the node is being
        created during file I/O.The attribute(index) method above returns
        the attributes according to the order in which they were
        originally added to the node.This method returns the attributes
        according to the reordering, if any, which is required by the
        node.

        Returns: 
        ----- 
        A pointer to the attribute

        Parameters:
        -----
        index: int
        	[in] -> the reordered index of the attribute 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def attribute(self, attrName: MString,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        attribute(self, attrName: MString,
                        ReturnStatus: MFnDependencyNode.MStatus) -> MObject

        Synopsis
        -----
        Finds the attribute of this node that has the given name.

        Returns: 
        ----- 
        A pointer to the attribute

        Parameters:
        -----
        attrName: MString
        	[in] -> name of the attribute to find 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def attributeClass(self, attribute: MObject,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        attributeClass(self, attribute: MObject,
                        ReturnStatus: MFnDependencyNode.MStatus) -> MFnDependencyNode.MFnDependencyNode

        Synopsis
        -----
        Returns the class (normal, dynamic, extension) of the specified
        attribute.

        Returns: 
        ----- 
        The class of the attribute. If the node does not have the
        specified attribute, then kInvalidAttr is returned as the class.

        Parameters:
        -----
        attribute: MObject
        	[in] -> the attribute to check 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def getAffectedAttributes(self, attr: MObject,
                        affectedAttributes: MObjectArray): 
        '''
        getAffectedAttributes(self, attr: MObject,
                        affectedAttributes: MObjectArray)

        Synopsis
        -----
        Returns an array of attributes that are affected by the attribute
        passed in. That is, when the given attribute, attr is marked
        dirty (changed) all the affectedAttributes attributes will also
        be marked dirty. For nodes defined in plug-ins this call returns
        all those attributes that were marked as being affected by the
        given one via the MPxNode::attributeAffects call.It should be
        noted that dynamic attributes cannot be handled by this method.
        This is because the attribute affects dependencies are statically
        defined when the node is created. An alternate approach which
        works for dynamic as well as non-dynamic attributes is available
        through MPxNode::setDependentsDirty override.

        Returns:
        -----
        None

        Parameters:
        -----
        attr: MObject
        	[in] -> the attribute to check 

        affectedAttributes: MObjectArray
        	[out] -> an array of attributes affected by 


        '''
        pass

    def getAffectedByAttributes(self, attr: MObject,
                        affectedByAttributes: MObjectArray): 
        '''
        getAffectedByAttributes(self, attr: MObject,
                        affectedByAttributes: MObjectArray)

        Synopsis
        -----
        Returns an array of attributes that affect the attribute passed
        in, attr. That is, when one of the attributes in
        affectedByAttributes is marked dirty (changed) then attr will
        also be marked dirty. For nodes defined in plug-ins this call
        returns all those attributes that were marked as affecting the
        given one via the MPxNode::attributeAffects call.It should be
        noted that dynamic attributes cannot be handled by this method.
        This is because the attribute affects dependencies are statically
        defined when the node is created. An alternate approach which
        works for dynamic as well as non-dynamic attributes is available
        through MPxNode::setDependentsDirty override.

        Returns:
        -----
        None

        Parameters:
        -----
        attr: MObject
        	[in] -> the attribute to check 

        affectedByAttributes: MObjectArray
        	[out] -> an array of attributes affected by 


        '''
        pass

    @overload
    def findPlug(self, attr: MObject,
                        wantNetworkedPlug: bool,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        findPlug(self, attr: MObject,
                        wantNetworkedPlug: bool,
                        ReturnStatus: MFnDependencyNode.MStatus) -> MPlug

        Synopsis
        -----
        Attempt to find a plug for the given attribute. This method will
        first try to find the networked version of the plug if requested.
        The networked version of a plug is one that currently exists in
        the dependency graph at a particular connection point. If a
        networked version is not found, then a standard non-networked
        plug is returned.A non-networked plug is not actually used by the
        dependency graph, but is used to represent the same connections.
        Every time an operation is performed on a non-networked plug, a
        search is made for the networked version of the plug.Networked
        and non-networked plugs behave the same, but networked plugs are
        much more efficient if used for multiple operations.Networked
        plugs should be avoided if you will be deleting connections to
        the plug.

        Returns: 
        ----- 
        The plug

        Parameters:
        -----
        attr: MObject
        	[in] -> attribute whose plug we wish to find 

        wantNetworkedPlug: bool
        	[in] -> if true, request a networked plug if it is available 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def findPlug(self, attrName: MString,
                        wantNetworkedPlug: bool,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        findPlug(self, attrName: MString,
                        wantNetworkedPlug: bool,
                        ReturnStatus: MFnDependencyNode.MStatus) -> MPlug

        Synopsis
        -----
        Attempt to find a plug for the given attribute. This method will
        first try to find the networked version of the plug if requested.
        The networked version of a plug is one that currently exists in
        the dependency graph at a particular connection point. If a
        networked version is not found, then a standard non-networked
        plug is returned.A non-networked plug is not actually used by the
        dependency graph, but is used to represent the same connections.
        Every time an operation is performed on a non-networked plug, a
        search is made for the networked version of the plug.Networked
        and non-networked plugs behave the same, but networked plugs are
        much more efficient if used for multiple operations.Networked
        plugs should be avoided if you will be deleting connections to
        the plug.

        Returns: 
        ----- 
        The plug

        Parameters:
        -----
        attrName: MString
        	[in] -> name of attribute whose plug we wish to find 

        wantNetworkedPlug: bool
        	[in] -> if true, request a networked plug if it is available 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def addAttribute(self, attr: MObject): 
        '''
        addAttribute(self, attr: MObject)

        Synopsis
        -----
        Add a new dynamic attibute to this node.

        Returns:
        -----
        None

        Parameters:
        -----
        attr: MObject
        	[in] -> new attribute


        '''
        pass

    def removeAttribute(self, attribute: MObject): 
        '''
        removeAttribute(self, attribute: MObject)

        Synopsis
        -----
        Remove a dynamic attribute from a node. Note: After a successful
        call to this method, the MObject passed to it will have been
        reset to MObject::kNullObj because the attribute it referenced no
        longer exists. Thus no function sets, such as MFnAttribute,
        should be attached to the MObject at the time this call is made.

        Returns:
        -----
        None

        Parameters:
        -----
        attribute: MObject
        	[in] -> attribute to remove


        '''
        pass

    def isFromReferencedFile(self, ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        isFromReferencedFile(self, ReturnStatus: MFnDependencyNode.MStatus) -> bool

        Synopsis
        -----
        Indicates whether or not this node came from a referenced file.
        If it did, the node will be marked as read-only in the scene and
        changes to the node's attributes will be saved in the main scene
        file, not the referenced file from which the node came.

        Returns: 
        ----- 
        true if the node came from a referenced file, false otherwise.

        Parameters:
        -----
        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def isShared(self, ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        isShared(self, ReturnStatus: MFnDependencyNode.MStatus) -> bool

        Synopsis
        -----
        Indicates whether or not this node is shared. This comes into
        play when you attempt to create a new node with the same name as
        an existing node. If the existing node is shared, then no new
        node will be created. If the existing node is not shared, then
        the new node will be created and given a different name.For
        example, if you import several scene files into a single scene,
        they may all attempt to create their own 'defaultResolution'
        node. However, since this node is shared, only one such node will
        be created and the other requests will be ignored.The concept of
        "sharing" can also be found in the "createNode -shared" flag
        found in MEL which, if specified causes an implicit node to be
        created (or not created, if it is already present).

        Returns: 
        ----- 
        true if the node is shared, false otherwise.

        Parameters:
        -----
        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def isTrackingEdits(self, ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        isTrackingEdits(self, ReturnStatus: MFnDependencyNode.MStatus) -> bool

        Synopsis
        -----
        Returns whether or not edits on the given node are being tracked
        by the generalized edit system. Referenced nodes and nodes in
        assemblies that are tracking edits will return true.

        Returns: 
        ----- 
        true if edits on the given node are being tracked, false
        otherwise.

        Parameters:
        -----
        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> Status code


        '''
        pass

    def hasUniqueName(self, ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        hasUniqueName(self, ReturnStatus: MFnDependencyNode.MStatus) -> bool

        Synopsis
        -----
        Indicates whether or not this node's name is unique within the
        scene.

        Returns: 
        ----- 
        true if the node's name is unique within scene, false otherwise.

        Parameters:
        -----
        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def parentNamespace(self, ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        parentNamespace(self, ReturnStatus: MFnDependencyNode.MStatus) -> MString

        Synopsis
        -----
        Returns the name of the namespace in which this node resides.
        Namespaces are often used when importing files to prevent name
        collisions.

        Returns: 
        ----- 
        The name of the namespace in which this node exists. This will be
        a colon separated path. If the object is in the root namespace,
        then an empty string will be returned.

        Parameters:
        -----
        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def isLocked(self, ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        isLocked(self, ReturnStatus: MFnDependencyNode.MStatus) -> bool

        Synopsis
        -----
        Indicates whether or not this node is locked. See the setLocked
        method for more information on what it means for a node to be
        locked.

        Returns: 
        ----- 
        true if the node is locked, false otherwise.

        Parameters:
        -----
        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def setLocked(self, lock: bool): 
        '''
        setLocked(self, lock: bool)

        Synopsis
        -----
        Locks or unlocks this node. If a node is locked, it may not be
        deleted, renamed, or reparented; it may not have attributes added
        or removed; attributes which are unlocked may not be locked and
        those which are already locked may not be unlocked.

        Returns:
        -----
        None

        Parameters:
        -----
        lock: bool
        	[in] -> If true then node will be locked.


        '''
        pass

    def classification(self, nodeTypeName: MString): 
        '''
        classification(self, nodeTypeName: MString) -> MString

        Synopsis
        -----
        Retrieves the classification string for a node type. This is a
        string that is used in dependency nodes that are also shaders to
        provide more detailed type information to the rendering system.
        See the documentation for the MEL commands getClassification and
        listNodeTypes for information on the strings that can be
        provided.User-defined nodes set this value through a parameter to
        MFnPlugin::registerNode.

        Returns: 
        ----- 
        The classification string. If the node does not have an
        associated classification, an empty string will be returned.

        Parameters:
        -----
        nodeTypeName: MString
        	[in] -> The name of the node for which a classification should be retrieved. Since this is a static method, the 


        '''
        pass

    def isNewAttribute(self, attr: MObject,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        isNewAttribute(self, attr: MObject,
                        ReturnStatus: MFnDependencyNode.MStatus) -> bool

        Synopsis
        -----
        Indicates whether or not the specified attribute was added to
        this node within the current scene. For nodes from referenced
        files, this method will only return true if the attribute was
        added to the node after the reference file was loaded into the
        scene.For all other nodes, this method will return true if the
        attribute is dynamic (i.e. not one of the node's original,
        permanent attributes).

        Returns: 
        ----- 
        true if the attribute was added within the current scene, false
        if the attribute is permanent or was added within a referenced
        file.

        Parameters:
        -----
        attr: MObject
        	[in] -> Attribute to check. 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def allocateFlag(self, pluginName: MString,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        allocateFlag(self, pluginName: MString,
                        ReturnStatus: MFnDependencyNode.MStatus) -> int

        Synopsis
        -----
        Allocates a node flag for sole use by the caller. Note that the
        flag is not specific to any one node but is made available to the
        caller on all nodes. Furthermore, node flags only persist for the
        duration of the current Maya session: they are not saved with the
        scene.deallocateFlag must be called when a flag is no longer
        needed.There are a total of just 8 flags available, so plugins
        should strive not to hold onto flags for extended periods of time
        as that might interfere with the needs of other plugins.When a
        plugin is unloaded, deallocateAllFlags is automatically invoked
        to free up any node flags still held by the plugin.

        Returns: 
        ----- 
        The newly-allocated flag.

        Parameters:
        -----
        pluginName: MString
        	[in] -> The name of the plugin which is allocating the flag. A plugin's name can be retrieved by calling 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> Return status.


        '''
        pass

    def deallocateFlag(self, pluginName: MString,
                        flag: int): 
        '''
        deallocateFlag(self, pluginName: MString,
                        flag: int)

        Synopsis
        -----
        Deallocates a node flag which was previously allocated by a call
        to allocateFlag. The flag subsequently becomes available for
        reallocation and use by someone else.

        Returns:
        -----
        None

        Parameters:
        -----
        pluginName: MString
        	[in] -> The name of the plugin which allocated the flag. A plugin's name can be retrieved by calling 

        flag: int
        	[in] -> Flag to deallocate.


        '''
        pass

    def deallocateAllFlags(self, pluginName: MString): 
        '''
        deallocateAllFlags(self, pluginName: MString)

        Synopsis
        -----
        Deallocates all of the node flags which are currently allocated
        to the specified plugin. The deallocated flags immediately become
        available for use by any plugin.

        Returns:
        -----
        None

        Parameters:
        -----
        pluginName: MString
        	[in] -> The name of the plugin whose flags are to be deallocated. A plugin's name can be retrieved by calling 


        '''
        pass

    def setFlag(self, flag: int,
                        state: bool): 
        '''
        setFlag(self, flag: int,
                        state: bool)

        Synopsis
        -----
        Sets the state of the specified flag for the node. The flag
        number must have been previously obtained through a call to
        allocateFlag.

        Returns:
        -----
        None

        Parameters:
        -----
        flag: int
        	[in] -> flag to set 

        state: bool
        	[in] -> new state to which the flag will be set


        '''
        pass

    def isFlagSet(self, flag: int,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        isFlagSet(self, flag: int,
                        ReturnStatus: MFnDependencyNode.MStatus) -> bool

        Synopsis
        -----
        Retrieves the current state of the specified flag for a node. The
        flag must have been previously obtained through a call to
        allocateFlag.

        Returns: 
        ----- 
        Current state of the flag

        Parameters:
        -----
        flag: int
        	[in] -> number of the flag to retrieve. 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def isDefaultNode(self, ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        isDefaultNode(self, ReturnStatus: MFnDependencyNode.MStatus) -> bool

        Synopsis
        -----
        Returns true if the node is a default node. A default node is one
        that Maya creates automatically and does not get saved out with
        the scene, although some of its attribute values may.

        Returns: 
        ----- 
        true if the node is default, false otherwise.

        Parameters:
        -----
        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def setDoNotWrite(self, flag: bool): 
        '''
        setDoNotWrite(self, flag: bool)

        Synopsis
        -----
        Use this method to mark the "do not write" state of this node. If
        set, this node will not be saved when the Maya model is written
        out.NOTES: 1. If this node is a DAG and has a parent or children,
        the "do not write" flag of the parent or children will not be
        set. It is the developer's responsibility to ensure that the
        resulting scene file is capable of being read in without errors
        due to unwritten nodes.

        Returns:
        -----
        None

        Parameters:
        -----
        flag: bool
        	[in] -> True if the node should not be saved. 


        '''
        pass

    def canBeWritten(self, ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        canBeWritten(self, ReturnStatus: MFnDependencyNode.MStatus) -> bool

        Synopsis
        -----
        Returns the do not write state of the node. Will be true if the
        node can be written/exported to scene files.Note that if a node
        is marked as being shared (see MFnDependencyNode::isShared) that
        overrides being marked as not writable. So shared nodes can be
        written, even if not marked as writable.

        Returns: 
        ----- 
        true if the node can be written, false otherwise.

        Parameters:
        -----
        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def hasAttribute(self, attrName: MString,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        hasAttribute(self, attrName: MString,
                        ReturnStatus: MFnDependencyNode.MStatus) -> bool

        Synopsis
        -----
        Returns true if the node already has an attribute with the given
        name.

        Returns: 
        ----- 
        true if the node has attribute, false otherwise.

        Parameters:
        -----
        attrName: MString
        	[in] -> Name of attribute to be checked. 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def getAliasAttr(self, force: bool,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        getAliasAttr(self, force: bool,
                        ReturnStatus: MFnDependencyNode.MStatus) -> MObject

        Synopsis
        -----
        Returns the node's alias attribute, which is a special attribute
        used to store information about the node's attribute aliases. If
        the node doesn't have an alias attribute and the 'force'
        parameter is true, then an alias attribute will be created and
        returned, otherwise MObject::kNullObj will be returned.

        Returns: 
        ----- 
        The MObject corresponding to the alias attribute.

        Parameters:
        -----
        force: bool
        	[in] -> To indicate whether the alias attr should be created. 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def setAlias(self, alias: MString,
                        name: MString,
                        plug: MPlug,
                        add: bool,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        setAlias(self, alias: MString,
                        name: MString,
                        plug: MPlug,
                        add: bool,
                        ReturnStatus: MFnDependencyNode.MStatus) -> bool

        Synopsis
        -----
        Sets or removes an alias (i.e. an alternative name) for an
        attribute.A node can have at most one alias per attribute, so if
        there is already an alias on the specified attribute it will be
        replaced by the new one.

        Returns: 
        ----- 
        True on success, false on failure. If the ReturnStatus indicates
        success then false means either that the alias to be added
        already exists, or the alias to be removed does not exist.

        Parameters:
        -----
        alias: MString
        	[in] -> alternative name for the attribute 

        name: MString
        	[in] -> real name of the attribute 

        plug: MPlug
        	[in] -> plug to the attribute 

        add: bool
        	[in] -> true to add the alias, false to remove it 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def findAlias(self, alias: MString,
                        attrObj: MObject,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        findAlias(self, alias: MString,
                        attrObj: MObject,
                        ReturnStatus: MFnDependencyNode.MStatus) -> bool

        Synopsis
        -----
        Retrieves the attribute with the given alias. If there is no
        attribute with the given alias, the method will return false and
        the value of 'attrObj' will be undefined.

        Returns: 
        ----- 
        True if the alias was found.

        Parameters:
        -----
        alias: MString
        	[in] -> alternative name of the attribute 

        attrObj: MObject
        	[out] -> the attribute having the specified alias 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def getAliasList(self, strArray: MStringArray,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        getAliasList(self, strArray: MStringArray,
                        ReturnStatus: MFnDependencyNode.MStatus) -> bool

        Synopsis
        -----
        Returns a list of all attribute aliases for this node. The
        aliases are pairs of strings with the first being the alias and
        the second being the attribute's real name.

        Returns: 
        ----- 
        true if any alias was found, false otherwise.

        Parameters:
        -----
        strArray: MStringArray
        	[out] -> list of aliases 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def plugsAlias(self, plug: MPlug,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        plugsAlias(self, plug: MPlug,
                        ReturnStatus: MFnDependencyNode.MStatus) -> MString

        Synopsis
        -----
        Returns the alias for the plug's attribute or the empty string if
        that attribute has no alias.

        Returns: 
        ----- 
        Alternative name for the attribute, if any.

        Parameters:
        -----
        plug: MPlug
        	[in] -> plug for whose attribute we want the alias 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status. See below.


        '''
        pass

    def setIcon(self, filename: MString): 
        '''
        setIcon(self, filename: MString)

        Synopsis
        -----
        Associates a custom icon with the node for display in the Maya
        UI. Currently the icon only shows up in Outliner panels (the DAG
        Outliner, Graph Editor and Dope Sheet).

        Returns:
        -----
        None

        Parameters:
        -----
        filename: MString
        	[in] -> specifies the name of the image file defining the icon, or the empty string (i.e. "") to revert to using Maya's default. The filename must be a PNG file (.png) and may either be an absolute pathname or be relative to the XBMLANGPATH environment variable.


        '''
        pass

    def icon(self, ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        icon(self, ReturnStatus: MFnDependencyNode.MStatus) -> MString

        Synopsis
        -----
        Returns the custom icon filename associated with the node. The
        icon can be assigned using setIcon().

        Returns: 
        ----- 
        The custom icon filename, or the empty string (i.e. "") if the
        node is using Maya's default.

        Parameters:
        -----
        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def getExternalContent(self, table: MExternalContentInfoTable): 
        '''
        getExternalContent(self, table: MExternalContentInfoTable)

        Synopsis
        -----
        Returns the external content (files) that this node depends on.
        The table populated by this method must include the location of
        all the content (files) used by this node, including those that
        do not exist. See MExternalContentInfoTable for details.Keys used
        to add items to this table will be the same that get passed to
        setExternalContent through its MExternalContentLocationTable
        parameter to perform a batched change of content location.The
        default implementation does nothing.

        Returns:
        -----
        None

        Parameters:
        -----
        table: MExternalContentInfoTable
        	[out] -> Content information table that this method must populate.


        '''
        pass

    def addExternalContentForFileAttr(self, table: MExternalContentInfoTable,
                        attr: MObject): 
        '''
        addExternalContentForFileAttr(self, table: MExternalContentInfoTable,
                        attr: MObject)

        Synopsis
        -----
        Adds content info to the specified table from a file path
        attribute. This method is a helper for derived clases
        implementing getExternalContent(). It augments the external
        content info table passed in with an entry describing external
        content whose location is described by the specified
        attribute.The method will not overwrite existing items, i.e.
        items with the same key (attribute name). If this function is
        called twice with the same attribute, or two separate but
        identically named attributes are used, the table stays unchanged
        and false is returned. If replacing an entry is the desired
        effect, it is the caller's responsibility to erase the previous
        item first.

        Returns:
        -----
        None

        Parameters:
        -----
        table: MExternalContentInfoTable
        	[out] -> The table in which the new entry will be added. 

        attr: MObject
        	[in] -> The attribute for which the plug value will be queried for a location.


        '''
        pass

    def setExternalContentForFileAttr(self, attr: MObject,
                        table: MExternalContentLocationTable): 
        '''
        setExternalContentForFileAttr(self, attr: MObject,
                        table: MExternalContentLocationTable)

        Synopsis
        -----
        Sets content info in the specified attribute from the table. This
        method is a helper for derived clases implementing
        setExternalContent(). It assigns a value to a plug with the one
        from the table whose key is the same as the passed in attribute
        name.The method will not write to the plug if the attribute is
        not found in the table.

        Returns:
        -----
        None

        Parameters:
        -----
        attr: MObject
        	[in] -> The attribute of the plug we want to write to. 

        table: MExternalContentLocationTable
        	[in] -> A table which may hold or not the value for a given plug.


        '''
        pass

    def setExternalContent(self, table: MExternalContentLocationTable): 
        '''
        setExternalContent(self, table: MExternalContentLocationTable)

        Synopsis
        -----
        Changes the location of external content. This is useful in the
        context of content relocation. This will be called while the
        scene is being loaded to apply path changes performed externally.
        Consequently, interaction with the rest of the scene must be kept
        to a minimum. It is however valid to call this method outside of
        scene loading contexts.The keys in the map must be the same as
        the ones provided by the node in getExternalContent. The values
        are the new locations.

        Returns:
        -----
        None

        Parameters:
        -----
        table: MExternalContentLocationTable
        	[in] -> Key->location table with new content locations.


        '''
        pass

    def affectsAnimation(self, ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        affectsAnimation(self, ReturnStatus: MFnDependencyNode.MStatus) -> bool

        Synopsis
        -----
        Introduced in 2019.0 Indicates whether or not this node is
        allowed to animate.See the setAffectsAnimation method for more
        information on what it means for a node to be allowed to animate.

        Returns: 
        ----- 
        true if the node is allowed to animate, false otherwise.

        Parameters:
        -----
        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def setAffectsAnimation(self): 
        '''
        setAffectsAnimation(self)

        Synopsis
        -----
        Introduced in 2019.0 Define a node can affect animation.Normally
        this is done automatically through the evaluation graph creation
        process but if you know from the start that your node will
        definitely participate in animation then you can mark it as such
        at any point.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def enableDGTiming(self, enable: bool): 
        '''
        enableDGTiming(self, enable: bool)

        Synopsis
        -----
        Globally enables or disables the DG node timing mechanism. There
        are two levels of control for DG node timing. dgTimerOn() and
        dgTimerOff() are used to determine which nodes are eligible for
        timer data collection and this method is used to globally enable
        or disable the DG node timing mechanism.For example, if you want
        to collect timing information for nodes X and Y you would call
        their dgTimerOn() methods and then call this method to enable
        timing. Those two nodes would then begin collecting timing
        data.If you subsequently call this method to disable timing then
        X and Y will cease collecting timing data but the data already
        collected would still be available (e.g. using dgTimer()).If you
        later use this method to re-enable timing then X and Y would
        resume collecting data. Note that this method does not clear the
        nodes' timing data. If you want a clean start you would have to
        call dgTimerReset() individually on X and Y.

        Returns:
        -----
        None

        Parameters:
        -----
        enable: bool
        	[in] -> flag to turn timing on or off. 


        '''
        pass

    def dgTimerOn(self): 
        '''
        dgTimerOn(self)

        Synopsis
        -----
        Indicates that this node should collect DG timing data whenever
        DG timing is enabled. See enableDGTiming() for more details.Note
        that this method does not reset the timers and counters on the
        node, it merely enables (or re-enables) timer data collection for
        the node and subsequent timing values are added to the current
        timer and counter values. If you want the counters to be reset,
        use the method dgTimerReset().To stop the node from collecting
        further timing data, use dgTimerOff().Calls to dgTimerOn() and
        dgTimerOff() are not cumulative. Even if you call dgTimerOn()
        three times for a node it still only takes a single call to
        dgTimerOff() to disable its data collection.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def dgTimerOff(self): 
        '''
        dgTimerOff(self)

        Synopsis
        -----
        Indicates that this node should no longer collect DG timing data
        when DG timing is enabled. See dgTimerOn() and enableDGTiming()
        for more details.Any timing data which has already been collected
        remains available, for example, using the dgTimer() method.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def dgTimerQueryState(self, ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        dgTimerQueryState(self, ReturnStatus: MFnDependencyNode.MStatus) -> MFnDependencyNode.MFnDependencyNode

        Synopsis
        -----
        The function returns the current on/off state of the node's
        timer.

        Returns: 
        ----- 
        The node's timer's current on/off state.

        Parameters:
        -----
        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status.


        '''
        pass

    def dgTimerReset(self): 
        '''
        dgTimerReset(self)

        Synopsis
        -----
        The function resets the dependency graph timers and counters for
        this node to zero. Note that this method does not start or stop
        timing, it only resets the values to zero. If you want to turn on
        timing, use the method dgTimerOn(). If you want to turn off
        timing, use dgTimerOff().

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def dgTimer(self, timerMetric: MFnDependencyNode.MdgTimerMetric,
                        timerType: MFnDependencyNode.MdgTimerType,
                        ReturnStatus: MFnDependencyNode.MStatus): 
        '''
        dgTimer(self, timerMetric: MFnDependencyNode.MdgTimerMetric,
                        timerType: MFnDependencyNode.MdgTimerType,
                        ReturnStatus: MFnDependencyNode.MStatus) -> double

        Synopsis
        -----
        The function returns the specified timer value for the current
        node. This is the total amount of time spent performing the
        requested operation since the timer was last reset (see
        dgTimerReset() for details). There are numerous timers per node
        and these are referenced by the metric and the timer type.

        Returns: 
        ----- 
        Value of the timer in seconds for types of kTimerType_self and
        kTimerType_inclusive, and as a simple count for kTimerType_count.

        Parameters:
        -----
        timerMetric: MFnDependencyNode.MdgTimerMetric
        	[in] -> The timing metric we wish to query. 

        timerType: MFnDependencyNode.MdgTimerType
        	[in] -> The timer type we wish to query. 

        ReturnStatus: MFnDependencyNode.MStatus
        	[out] -> return status


        '''
        pass

    def dgCallbacks(self, timerType: MFnDependencyNode.MdgTimerType,
                        callbackName: MStringArray,
                        value: MDoubleArray): 
        '''
        dgCallbacks(self, timerType: MFnDependencyNode.MdgTimerType,
                        callbackName: MStringArray,
                        value: MDoubleArray)

        Synopsis
        -----
        Node callbacks that occur when timing is enabled get logged with
        the node and can be queried via this method. See the
        dgCallbackIds method for getting a further breakdown of the time
        for an individual callback on this node.There are several
        important items of note:The result of calling this method is an
        array of names and an array of values. There is a one-to-one
        correspondence between the two arrays.

        Returns:
        -----
        None

        Parameters:
        -----
        timerType: MFnDependencyNode.MdgTimerType
        	[in] -> The timer we want to query, e.g. kTimerType_self for self time. 

        callbackName: MStringArray
        	[in] -> Returns an array of callback names that were invoked for this node since the last timer reset. 

        value: MDoubleArray
        	[in] -> Returns an array of timing values. There is a one-to-one correspondence with the `callbackName' array.


        '''
        pass

    def dgCallbackIds(self, timerType: MFnDependencyNode.MdgTimerType,
                        callbackName: MString,
                        callbackId: MCallbackIdArray,
                        value: MDoubleArray): 
        '''
        dgCallbackIds(self, timerType: MFnDependencyNode.MdgTimerType,
                        callbackName: MString,
                        callbackId: MCallbackIdArray,
                        value: MDoubleArray)

        Synopsis
        -----
        This method provides a further breakdown of the per-callback time
        returned via dgCallbacks() by returning the data on a per-
        callbackId basis. We define a "callback" to be an event withing
        Maya that "callback methods" can be registered with to be invoked
        when the given event occurs. The registered client information is
        called a "callbackId". There can be multiple callbackIds
        registered with a given callback, and a callbackId can be shared
        amongst multiple nodes or multiple callbacks.An example of a
        callback is "attributeChangedMsg", which the user can register
        callback methods against via
        MNodeMessage::addAttributeChangedCallback(). The process of
        registering a callback method returns a callbackId, thus there
        can be multiple callbacksIds per callback.The general approach
        when querying callbackIds is as follows:The result of calling
        this method is an array of names and an array of values. There is
        a one-to-one correspondence between the two arrays.

        Returns:
        -----
        None

        Parameters:
        -----
        timerType: MFnDependencyNode.MdgTimerType
        	[in] -> The timer we want to query, e.g. kTimerType_self for self time. 

        callbackName: MString
        	[in] -> Name of the callback to query the callbackIds for. This should be one of the callback names that was returned from 

        callbackId: MCallbackIdArray
        	[in] -> Returns an array of callbackIds which were invoked for this node and `callbackName' since the last timer reset. There is a one-to-one correspondence with the `value' array. The entries in the list can include callbackIds that are no longer active (e.g. if you unregistered the callbackId), so be careful not to treat these as active callbackIds  they are for informational purposes only. 

        value: MDoubleArray
        	[in] -> Returns an array of timing values. There is a one-to-one correspondence with the `name' array.


        '''
        pass

class MAttrClass:
    '''Specifies the scope of the attribute. 
    Non-functional class.  Values for this enum:
    kLocalDynamicAttr
    kNormalAttr
    kExtensionAttr
    kInvalidAttr
    '''

    def __init__(self):
        pass

    def kLocalDynamicAttr(self):
        '''This is an enum of MAttrClass.
        - Description: Dynamically added, applies to this specific node. 
        - Value: 1
        '''
        pass

    def kNormalAttr(self):
        '''This is an enum of MAttrClass.
        - Description: Static attribute which is part of the original definition for this node type. 
        - Value: 2
        '''
        pass

    def kExtensionAttr(self):
        '''This is an enum of MAttrClass.
        - Description: Extension attribute which is part of all nodes of this or derived node types. 
        - Value: 3
        '''
        pass

    def kInvalidAttr(self):
        '''This is an enum of MAttrClass.
        - Description: None of the above. 
        - Value: 4
        '''
        pass

class MdgTimerState:
    '''Possible states for the node's timer. 
    Non-functional class.  Values for this enum:
    kTimerOff
    kTimerOn
    kTimerUninitialized
    kTimerInvalidState
    '''

    def __init__(self):
        pass

    def kTimerOff(self):
        '''This is an enum of MdgTimerState.
        - Description:  
        - Value: 0
        '''
        pass

    def kTimerOn(self):
        '''This is an enum of MdgTimerState.
        - Description:  
        - Value: 1
        '''
        pass

    def kTimerUninitialized(self):
        '''This is an enum of MdgTimerState.
        - Description:  
        - Value: 2
        '''
        pass

    def kTimerInvalidState(self):
        '''This is an enum of MdgTimerState.
        - Description:  
        - Value: 3
        '''
        pass

class MdgTimerMetric:
    '''The different timer metrics which can be queried. 
    Non-functional class.  Values for this enum:
    kTimerMetric_callback
    kTimerMetric_compute
    kTimerMetric_dirty
    kTimerMetric_draw
    kTimerMetric_fetch
    kTimerMetric_callbackViaAPI
    kTimerMetric_callbackNotViaAPI
    kTimerMetric_computeDuringCallback
    kTimerMetric_computeNotDuringCallback
    kTimerMetrics
    '''

    def __init__(self):
        pass

    def kTimerMetric_callback(self):
        '''This is an enum of MdgTimerMetric.
        - Description: Time spent within node callbacks for this node. 
        - Value: 0
        '''
        pass

    def kTimerMetric_compute(self):
        '''This is an enum of MdgTimerMetric.
        - Description: Time spent within the compute method for this node. 
        - Value: 1
        '''
        pass

    def kTimerMetric_dirty(self):
        '''This is an enum of MdgTimerMetric.
        - Description: Time spent propogating dirty messages from this node. 
        - Value: 2
        '''
        pass

    def kTimerMetric_draw(self):
        '''This is an enum of MdgTimerMetric.
        - Description: Time spent drawing this node. 
        - Value: 3
        '''
        pass

    def kTimerMetric_fetch(self):
        '''This is an enum of MdgTimerMetric.
        - Description: Time spent fetching data from plugs. 
        - Value: 4
        '''
        pass

    def kTimerMetric_callbackViaAPI(self):
        '''This is an enum of MdgTimerMetric.
        - Description: Time spent in callbacks which were registered through the API. 
        - Value: 5
        '''
        pass

    def kTimerMetric_callbackNotViaAPI(self):
        '''This is an enum of MdgTimerMetric.
        - Description: Time spent in callbacks not registered through the API (i.e internal Maya callbacks). 
        - Value: 6
        '''
        pass

    def kTimerMetric_computeDuringCallback(self):
        '''This is an enum of MdgTimerMetric.
        - Description: Time spent in this node's compute while executing node callbacks on any node. 
        - Value: 7
        '''
        pass

    def kTimerMetric_computeNotDuringCallback(self):
        '''This is an enum of MdgTimerMetric.
        - Description: Time spent in this nodes compute when not executing any node callbacks on any nodes. 
        - Value: 8
        '''
        pass

    def kTimerMetrics(self):
        '''This is an enum of MdgTimerMetric.
        - Description: Total number of metrics available. 
        - Value: 9
        '''
        pass

class MdgTimerType:
    '''The types of timers which can be queried. 
    Non-functional class.  Values for this enum:
    kTimerType_self
    kTimerType_inclusive
    kTimerType_count
    kTimerTypes
    '''

    def __init__(self):
        pass

    def kTimerType_self(self):
        '''This is an enum of MdgTimerType.
        - Description: Time spent performing an operation, not including any time spent by child operations. For example, if we are drawing a node and that requires a compute, self time will only include the time spent drawing and not the compute time. Self time measures wall-clock time as opposed to CPU time and the values are in seconds. 
        - Value: 0
        '''
        pass

    def kTimerType_inclusive(self):
        '''This is an enum of MdgTimerType.
        - Description: Time spent performing an operation including all time spent by child operations. For example, if we are drawing a node and that requires a compute, inclusive time is the time for the draw plus compute. Inclusive time measure wall-clock time as opposed to CPU time and the values are in seconds. 
        - Value: 1
        '''
        pass

    def kTimerType_count(self):
        '''This is an enum of MdgTimerType.
        - Description: The number of operations that occurred. Ideally we should return an integer when this timer type is queried, but there are two advantages to using a double. 1) it keeps the interface consistent and 2) integer has a fixed upper bound of roughly four billion so using a double allows us to exceed this. 
        - Value: 2
        '''
        pass

    def kTimerTypes(self):
        '''This is an enum of MdgTimerType.
        - Description: The total number of timer types supported. 
        - Value: 3
        '''
        pass

class MFnDirectionalLight:
    '''Manage Directional Light dependency nodes.
MFnDirectionalLight facilitates creation and manipulation of dependency nodes
representing direction lights.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kDirectionalLight.Reimplemented from MFnNonExtendedLight.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnDirectionalLight.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnDirectionalLight".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def create(self, UIvisible: bool,
                        ReturnStatus: MFnDirectionalLight.MStatus): 
        '''
        create(self, UIvisible: bool,
                        ReturnStatus: MFnDirectionalLight.MStatus) -> MObject

        Synopsis
        -----
        Creates a new directional light dependency graph node and adds it
        to the dependency graph. If the UIvisible parameter is true, the
        new node will be connected to the light classification node
        (which allows the UI to recognize the node as a light) and added
        to the default light list. If UIvisible is false, the node will
        be created in isolation.The light node is added to the current
        model, under a new transformation.

        Returns: 
        ----- 
        MObject representing the new dependency node.

        Parameters:
        -----
        UIvisible: bool
        	[in] -> determines whether or not to connect the new node to the light classification node and add it to the default light list. 

        ReturnStatus: MFnDirectionalLight.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def create(self, parent: MObject,
                        UIvisible: bool,
                        wantTransform: bool,
                        ReturnStatus: MFnDirectionalLight.MStatus): 
        '''
        create(self, parent: MObject,
                        UIvisible: bool,
                        wantTransform: bool,
                        ReturnStatus: MFnDirectionalLight.MStatus) -> MObject

        Synopsis
        -----
        Creates a new directional light dependency graph node and adds it
        to the dependency graph. If the UIvisible parameter is true, the
        new node will be connected to the light classification node
        (which allows the UI to recognize the node as a light) and added
        to the default light list. If UIvisible is false, the node will
        be created in isolation.If wantTransform parameter is false (
        which is by default ), the new shape node is created under the
        specified parent and no transform node is created. If the
        specified parent is null, then no shape node will be created.The
        light node is added to the current model, under the specified
        parent.

        Returns: 
        ----- 
        MObject representing the new dependency node.

        Parameters:
        -----
        parent: MObject
        	[in] -> the node under which the new light and its transform will be added. 

        UIvisible: bool
        	[in] -> determines whether or not to connect the new node to the light classification node and add it to the default light list. 

        wantTransform: bool
        	[in] -> Boolean to indicate whether the transform node is needed or not, which is 'false' by default. 

        ReturnStatus: MFnDirectionalLight.MStatus
        	[out] -> return status


        '''
        pass

    def shadowAngle(self, ReturnStatus: MFnDirectionalLight.MStatus): 
        '''
        shadowAngle(self, ReturnStatus: MFnDirectionalLight.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "shadowAngle" attribute of a
        directional light node. This attribute represents an angular
        divergence from the direction vector of the light used to
        calculate soft shadows.

        Returns: 
        ----- 
        The value of the "shadowAngle" attribute of the light node.

        Parameters:
        -----
        ReturnStatus: MFnDirectionalLight.MStatus
        	[out] -> return status


        '''
        pass

    def setShadowAngle(self, shadow_angle: float): 
        '''
        setShadowAngle(self, shadow_angle: float)

        Synopsis
        -----
        Sets the value of the "shadowAngle" attribute of a directional
        light node.

        Returns:
        -----
        None

        Parameters:
        -----
        shadow_angle: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def useLightPosition(self, ReturnStatus: MFnDirectionalLight.MStatus): 
        '''
        useLightPosition(self, ReturnStatus: MFnDirectionalLight.MStatus) -> bool

        Synopsis
        -----
        Retrieves the value of the "useLightPosition" attribute of a
        directional light. This attribute determines if the objects
        behind the light will cast shadows.

        Returns: 
        ----- 
        The value of the "useLightPosition" attribute of the directional
        light.

        Parameters:
        -----
        ReturnStatus: MFnDirectionalLight.MStatus
        	[out] -> return status


        '''
        pass

    def setUseLightPosition(self, use_light_position: bool): 
        '''
        setUseLightPosition(self, use_light_position: bool)

        Synopsis
        -----
        Sets the value of the "useLightPosition" attribute of a
        directional light.

        Returns:
        -----
        None

        Parameters:
        -----
        use_light_position: bool
        	[in] -> value to which the attribute will be set.


        '''
        pass

class MFnDoubleArrayData:
    '''double array function set for dependency node data.
MFnDoubleArrayData allows the creation and manipulation of
MDoubleArray data objects for use in the dependency graph.
If a user written dependency node either accepts or produces
MDoubleArrays, then this class is used to extract or create the
data that comes from or goes to other dependency graph nodes. The
MDataHandle::type() method will return kDoubleArray when data of this type is
present. To access it, the
MDataHandle::data() method is used to get an
MObject for the data and this should then be used to initialize an
instance of
MFnDoubleArrayData.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kDoubleArrayData.Reimplemented from MFnData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnDoubleArrayData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnDoubleArrayData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def length(self, ReturnStatus: MFnDoubleArrayData.MStatus): 
        '''
        length(self, ReturnStatus: MFnDoubleArrayData.MStatus) -> int

        Synopsis
        -----
        Return the number of doubles in the instance.

        Returns: 
        ----- 
        The number of doubles in the instance

        Parameters:
        -----
        ReturnStatus: MFnDoubleArrayData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> double

        Synopsis
        -----
        Extract the indicated double from the const instance. No checking
        is done by this class to ensure that the index is valid - use the
        length method to determine the size of the array. If the instance
        is not attached to an MObject, this method will return an double
        containing zero.

        Returns: 
        ----- 
        The indicated double

        Parameters:
        -----
        index: int
        	[in] -> the index of the double to extract


        '''
        pass

    @overload
    def set(self, element: double,
                        index: int): 
        '''
        set(self, element: double,
                        index: int)

        Synopsis
        -----
        Set the double array element at the specified index. The index
        must be valid for the array.

        Returns:
        -----
        None

        Parameters:
        -----
        element: double
        	[in] -> the element to set at the specified index 

        index: int
        	[in] -> the index of the double to set


        '''
        pass

    def copyTo(self, dest: MDoubleArray): 
        '''
        copyTo(self, dest: MDoubleArray)

        Synopsis
        -----
        Copy all the doubles in the instance into the given MDoubleArray.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: MDoubleArray
        	[out] -> the 


        '''
        pass

    @overload
    def set(self, array: MDoubleArray): 
        '''
        set(self, array: MDoubleArray)

        Synopsis
        -----
        Set the instance to contain the doubles defined in the given
        MDoubleArray.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MDoubleArray
        	[in] -> the 


        '''
        pass

    def array(self, ReturnStatus: MFnDoubleArrayData.MStatus): 
        '''
        array(self, ReturnStatus: MFnDoubleArrayData.MStatus) -> MDoubleArray

        Synopsis
        -----
        Return an MDoubleArray containing the double array currently
        operated upon by the function set. The MDoubleArray returned by
        this method is editable, so any changes to the return instance
        also affects the MObject operated upon by this function set.

        Returns: 
        ----- 
        A copy of the MDoubleArray held in this instance

        Parameters:
        -----
        ReturnStatus: MFnDoubleArrayData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    @overload
    def create(self, ReturnStatus: MFnDoubleArrayData.MStatus): 
        '''
        create(self, ReturnStatus: MFnDoubleArrayData.MStatus) -> MObject

        Synopsis
        -----
        Create a new double array data object, initialize it to be empty,
        and attach it to this instance.

        Returns: 
        ----- 
        MObject referring to the newly created double array data object

        Parameters:
        -----
        ReturnStatus: MFnDoubleArrayData.MStatus
        	[out] -> kSuccess


        '''
        pass

    @overload
    def create(self, arr: MDoubleArray,
                        ReturnStatus: MFnDoubleArrayData.MStatus): 
        '''
        create(self, arr: MDoubleArray,
                        ReturnStatus: MFnDoubleArrayData.MStatus) -> MObject

        Synopsis
        -----
        Create a new double array data object, initialize it to contain
        the data from the given MDoubleArray, and attach it to this
        instance.

        Returns: 
        ----- 
        MObject referring to the newly created double array data object

        Parameters:
        -----
        arr: MDoubleArray
        	[in] -> the data to use when initializing this instance 

        ReturnStatus: MFnDoubleArrayData.MStatus
        	[out] -> kSuccess


        '''
        pass

class MFnDoubleIndexedComponent:
    '''Double indexed component function set.
This function set allows you to create, edit, and query double
indexed components. Double indexed components store 2 dimensional
index values.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kDoubleIndexedComponent.Reimplemented from MFnComponent.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnDoubleIndexedComponent.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnDoubleIndexedComponent".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, compType: MFn.MFn,
                        ReturnStatus: MFnDoubleIndexedComponent.MStatus): 
        '''
        create(self, compType: MFn.MFn,
                        ReturnStatus: MFnDoubleIndexedComponent.MStatus) -> MObject

        Synopsis
        -----
        Create a double indexed component of the given type. Allowable
        types areMFn::kSurfaceCVComponent MFn::kSurfaceEPComponent
        MFn::kSurfaceKnotComponent MFn::kMeshVtxFaceComponent

        Returns: 
        ----- 
        The new component

        Parameters:
        -----
        compType: MFn.MFn
        	[in] -> the type of component to create 

        ReturnStatus: MFnDoubleIndexedComponent.MStatus
        	[out] -> status code


        '''
        pass

    def addElement(self, uIndex: int,
                        vIndex: int): 
        '''
        addElement(self, uIndex: int,
                        vIndex: int)

        Synopsis
        -----
        Add the specified element to the component.

        Returns:
        -----
        None

        Parameters:
        -----
        uIndex: int
        	[in] -> the u index to add 

        vIndex: int
        	[in] -> the v index to add


        '''
        pass

    def addElements(self, uIndices: MIntArray,
                        vIndices: MIntArray): 
        '''
        addElements(self, uIndices: MIntArray,
                        vIndices: MIntArray)

        Synopsis
        -----
        Add the specified elements to the component.

        Returns:
        -----
        None

        Parameters:
        -----
        uIndices: MIntArray
        	[in] -> the array of u indices to be added 

        vIndices: MIntArray
        	[in] -> the array of v indices to be added


        '''
        pass

    def getElement(self, index: int,
                        uIndex: int,
                        vIndex: int): 
        '''
        getElement(self, index: int,
                        uIndex: int,
                        vIndex: int)

        Synopsis
        -----
        Get the specified element from the component.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the index of the element to retrieve 

        uIndex: int
        	[out] -> the u index of the component 

        vIndex: int
        	[out] -> the v index of the component


        '''
        pass

    def getElements(self, uIndices: MIntArray,
                        vIndices: MIntArray): 
        '''
        getElements(self, uIndices: MIntArray,
                        vIndices: MIntArray)

        Synopsis
        -----
        Get all of the element indices from the component.

        Returns:
        -----
        None

        Parameters:
        -----
        uIndices: MIntArray
        	[out] -> storage for the array of u indices 

        vIndices: MIntArray
        	[out] -> storage for the array of v indices


        '''
        pass

    def setCompleteData(self, maxU: int,
                        maxV: int): 
        '''
        setCompleteData(self, maxU: int,
                        maxV: int)

        Synopsis
        -----
        Marks the component as complete (meaning all items are selected)
        and uses the argument to identify the total number of elements
        selected. If the component should contain N element indices, then
        the range would be [0,N-1].Also sets the complete state of the
        component to 'true' (i.e. setComplete(true)).

        Returns:
        -----
        None

        Parameters:
        -----
        maxU: int
        	[in] -> the maximum number of U elements 

        maxV: int
        	[in] -> the maximum number of V elements


        '''
        pass

    def getCompleteData(self, maxU: int,
                        maxV: int): 
        '''
        getCompleteData(self, maxU: int,
                        maxV: int)

        Synopsis
        -----
        Returns the number of elements for the complete component. A
        complete component means that all elements are selected.

        Returns:
        -----
        None

        Parameters:
        -----
        maxU: int
        	[out] -> storage for the maximum number of U elements 

        maxV: int
        	[out] -> storage for the maximum number of V elements


        '''
        pass

class MFnEnumAttribute:
    '''Enumerated attribute function set.
Function set for enumerated attributes. These attributes accept
fields as input. Each field consists of a short and its
associated string, which is a descriptive name for the field.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kEnumAttribute.Reimplemented from MFnAttribute.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnEnumAttribute.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnEnumAttribute".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, fullName: MString,
                        briefName: MString,
                        defaultValue: short,
                        ReturnStatus: MFnEnumAttribute.MStatus): 
        '''
        create(self, fullName: MString,
                        briefName: MString,
                        defaultValue: short,
                        ReturnStatus: MFnEnumAttribute.MStatus) -> MObject

        Synopsis
        -----
        Creates an enumerated attribute object. The create method needs
        to be called on a per node basis. That means if you want to
        create and add the same attribute to multiple nodes, you need to
        call the create method for each node to get a unique MObject
        back. If you call create just once and add the attribute to
        multiple nodes, Maya will encounter a fatal error.

        Returns: 
        ----- 
        The newly created enumerated attribute object.

        Parameters:
        -----
        fullName: MString
        	[in] -> The full name of the attribute 

        briefName: MString
        	[in] -> The brief name of the attribute 

        defaultValue: short
        	[in] -> The default value of the attribute 

        ReturnStatus: MFnEnumAttribute.MStatus
        	[out] -> Status code for the operation.


        '''
        pass

    def addField(self, fieldString: MString,
                        index: short): 
        '''
        addField(self, fieldString: MString,
                        index: short)

        Synopsis
        -----
        Add a field (a string/index pair) to the enumeration.

        Returns:
        -----
        None

        Parameters:
        -----
        fieldString: MString
        	[in] -> The string describing the field 

        index: short
        	[in] -> The index of the field


        '''
        pass

    def fieldName(self, index: short,
                        ReturnStatus: MFnEnumAttribute.MStatus): 
        '''
        fieldName(self, index: short,
                        ReturnStatus: MFnEnumAttribute.MStatus) -> MString

        Synopsis
        -----
        Retrieve the string associated with a given index.

        Returns: 
        ----- 
        The descriptive string corresponding to the given index

        Parameters:
        -----
        index: short
        	[in] -> The index of the string to look up 

        ReturnStatus: MFnEnumAttribute.MStatus
        	[out] -> Status code for the operation.


        '''
        pass

    def fieldIndex(self, fieldString: MString,
                        ReturnStatus: MFnEnumAttribute.MStatus): 
        '''
        fieldIndex(self, fieldString: MString,
                        ReturnStatus: MFnEnumAttribute.MStatus) -> short

        Synopsis
        -----
        Retrieve the index associated with a given string.

        Returns: 
        ----- 
        The index associated with the given descriptive string.

        Parameters:
        -----
        fieldString: MString
        	[in] -> The string describing the field. 

        ReturnStatus: MFnEnumAttribute.MStatus
        	[out] -> Status code for the operation.


        '''
        pass

    def getMin(self, minValue: short): 
        '''
        getMin(self, minValue: short)

        Synopsis
        -----
        Return the minimum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        minValue: short
        	[out] -> the minimum value for this attribute


        '''
        pass

    def getMax(self, maxValue: short): 
        '''
        getMax(self, maxValue: short)

        Synopsis
        -----
        Return the maximum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        maxValue: short
        	[out] -> the maximum value for this attribute


        '''
        pass

    @overload
    def setDefault(self, index: short): 
        '''
        setDefault(self, index: short)

        Synopsis
        -----
        Set a new default value for this enum attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        index: short
        	[in] -> new the default value for this attribute


        '''
        pass

    @overload
    def setDefault(self, fieldString: MString): 
        '''
        setDefault(self, fieldString: MString)

        Synopsis
        -----
        Set a new default value for this enum attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        fieldString: MString
        	[in] -> new the default value for this attribute


        '''
        pass

    def getDefault(self, index: short): 
        '''
        getDefault(self, index: short)

        Synopsis
        -----
        Get the default value for the enum attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        index: short
        	[out] -> default index value.


        '''
        pass

    def defaultValue(self, ReturnStatus: MFnEnumAttribute.MStatus): 
        '''
        defaultValue(self, ReturnStatus: MFnEnumAttribute.MStatus) -> MString

        Synopsis
        -----
        Get the default value for the enum attribute.

        Returns: 
        ----- 
        the string value for the default enum

        Parameters:
        -----
        ReturnStatus: MFnEnumAttribute.MStatus
        	[out] -> Optional status code. See below.


        '''
        pass

class MFnExpression:
    '''Expression function set.
This class is used to create, edit, and query expression nodes.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kExpression.Reimplemented from MFnDependencyNode.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnExpression.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnExpression".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, expression: MString,
                        object: MObject,
                        ReturnStatus: MFnExpression.MStatus): 
        '''
        create(self, expression: MString,
                        object: MObject,
                        ReturnStatus: MFnExpression.MStatus) -> MObject

        Synopsis
        -----
        This method creates and returns a dependency node for a given
        expression. A default object can be specified, but if it is not
        specified in the expression string then the expression string
        values will be used.If the expression string is of the form
        "objectName.attribute = ... " then the default object parameter
        is not needed. If you supply a default object in this case, then
        it will be ignored.If the expression has no default object then
        you must supply one. For example, if the expression is of the
        form "attribute = ...", then you must supply a default object.

        Returns: 
        ----- 
        The expression node

        Parameters:
        -----
        expression: MString
        	[in] -> The expression string 

        object: MObject
        	[in] -> The default object (optional - see above) 

        ReturnStatus: MFnExpression.MStatus
        	[out] -> Status code


        '''
        pass

    def expression(self, ReturnStatus: MFnExpression.MStatus): 
        '''
        expression(self, ReturnStatus: MFnExpression.MStatus) -> MString

        Synopsis
        -----
        Gets the expression string for this expression node.

        Returns: 
        ----- 
        The expression string

        Parameters:
        -----
        ReturnStatus: MFnExpression.MStatus
        	[out] -> Status code. See below.


        '''
        pass

    def setExpression(self, expression: MString): 
        '''
        setExpression(self, expression: MString)

        Synopsis
        -----
        Sets the expression string for this expression node.

        Returns:
        -----
        None

        Parameters:
        -----
        expression: MString
        	[in] -> The expression string


        '''
        pass

    def getDefaultObject(self, object: MObject): 
        '''
        getDefaultObject(self, object: MObject)

        Synopsis
        -----
        Gets the "default" object for the expression. Not all expressions
        have a default object. If there is no default object for the
        expression, the object will be set to MObject::kNullObject and
        the return status will indicate success. This is a completely
        legal case that the calling code should check for before blindly
        using the returned object.

        Returns:
        -----
        None

        Parameters:
        -----
        object: MObject
        	[out] -> storage for the default object


        '''
        pass

    def setDefaultObject(self, object: MObject): 
        '''
        setDefaultObject(self, object: MObject)

        Synopsis
        -----
        Sets the "default" object for the expression. This allows the
        expression writer to not type the object name for frequently-used
        objects.This method will only work for expression strings in
        which the object name is not specified.

        Returns:
        -----
        None

        Parameters:
        -----
        object: MObject
        	[in] -> the object to be set


        '''
        pass

    def isAnimated(self, ReturnStatus: MFnExpression.MStatus): 
        '''
        isAnimated(self, ReturnStatus: MFnExpression.MStatus) -> bool

        Synopsis
        -----
        If this is true, then the expression will be evaluated whenever
        time changes, regardless of whether the other inputs have
        changed. If it is false (the default) , then the expression will
        only be evaluated if one or more of the inputs change.Note, if
        'time' or 'frame' are inputs, then the expression will act as if
        this was set to true.

        Returns: 
        ----- 
        true expression will be evaluated whenever time changes  false

        Parameters:
        -----
        ReturnStatus: MFnExpression.MStatus
        	[out] -> Status code


        '''
        pass

    def setAnimated(self, value: bool): 
        '''
        setAnimated(self, value: bool)

        Synopsis
        -----
        Sets the way in which the expression is evaluated. If this is
        true, then the expression will be evaluated whenever time
        changes, regardless of whether the other inputs have changed.If
        it is false (the default) , then the expression will only be
        evaluated if one or more of the inputs change.Note, if 'time' or
        'frame' are inputs, then the expression will act as if this was
        set to true.

        Returns:
        -----
        None

        Parameters:
        -----
        value: bool
        	[in] -> sets the objects evaluation type


        '''
        pass

    def evaluate(self, result: MDoubleArray): 
        '''
        evaluate(self, result: MDoubleArray)

        Synopsis
        -----
        Evaluate this expression and return the result.

        Returns:
        -----
        None

        Parameters:
        -----
        result: MDoubleArray
        	[out] -> the value of the expression


        '''
        pass

    def unitConversion(self, ReturnStatus: MFnExpression.MStatus): 
        '''
        unitConversion(self, ReturnStatus: MFnExpression.MStatus) -> MFnExpression.MFnExpression

        Synopsis
        -----
        Get the unit conversion status for the expression node.

        Returns: 
        ----- 
        The unit conversion state for this node

        Parameters:
        -----
        ReturnStatus: MFnExpression.MStatus
        	[out] -> Status code


        '''
        pass

    def setUnitConversion(self, conversion: MFnExpression.UnitConversion): 
        '''
        setUnitConversion(self, conversion: MFnExpression.UnitConversion)

        Synopsis
        -----
        Set the unit conversion options for the expression node.

        Returns:
        -----
        None

        Parameters:
        -----
        conversion: MFnExpression.UnitConversion
        	[in] -> unit conversion state for this node


        '''
        pass

class UnitConversion:
    '''Unit conversion modes. 
    Non-functional class.  Values for this enum:
    kAll
    kNone
    kAngularOnly
    '''

    def __init__(self):
        pass

    def kAll(self):
        '''This is an enum of UnitConversion.
        - Description: Convert all units. 
        - Value: 0
        '''
        pass

    def kNone(self):
        '''This is an enum of UnitConversion.
        - Description: Do not do any unit conversion. 
        - Value: 1
        '''
        pass

    def kAngularOnly(self):
        '''This is an enum of UnitConversion.
        - Description: Only convert angular units. 
        - Value: 2
        '''
        pass

class MFnFloatArrayData:
    '''float array function set for dependency node data.
MFnFloatArrayData allows the creation and manipulation of
MFloatArray data objects for use in the dependency graph.
If a user written dependency node either accepts or produces
MFloatArrays, then this class is used to extract or create the
data that comes from or goes to other dependency graph nodes. The
MDataHandle::type() method will return kFloatArray when data of this type is
present. To access it, the
MDataHandle::data() method is used to get an
MObject for the data and this should then be used to initialize an
instance of
MFnFloatArrayData.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kFloatArrayData.Reimplemented from MFnData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnFloatArrayData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnFloatArrayData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def length(self, ReturnStatus: MFnFloatArrayData.MStatus): 
        '''
        length(self, ReturnStatus: MFnFloatArrayData.MStatus) -> int

        Synopsis
        -----
        Return the number of floats in the instance.

        Returns: 
        ----- 
        The number of floats in the instance

        Parameters:
        -----
        ReturnStatus: MFnFloatArrayData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> float

        Synopsis
        -----
        Extract the indicated float from the const instance. No checking
        is done by this class to ensure that the index is valid - use the
        length method to determine the size of the array. If the instance
        is not attached to an MObject, this method will return a float
        containing zero.

        Returns: 
        ----- 
        The indicated float

        Parameters:
        -----
        index: int
        	[in] -> the index of the float to extract


        '''
        pass

    @overload
    def set(self, element: float,
                        index: int): 
        '''
        set(self, element: float,
                        index: int)

        Synopsis
        -----
        Set the float array element at the specified index. The index
        must be valid for the array.

        Returns:
        -----
        None

        Parameters:
        -----
        element: float
        	[in] -> the element to set at the specified index 

        index: int
        	[in] -> the index of the float to set


        '''
        pass

    def copyTo(self, dest: MFloatArray): 
        '''
        copyTo(self, dest: MFloatArray)

        Synopsis
        -----
        Copy all the floats in the instance into the given MFloatArray.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: MFloatArray
        	[out] -> the 


        '''
        pass

    @overload
    def set(self, array: MFloatArray): 
        '''
        set(self, array: MFloatArray)

        Synopsis
        -----
        Set the instance to contain the floats defined in the given
        MFloatArray.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MFloatArray
        	[in] -> the 


        '''
        pass

    def array(self, ReturnStatus: MFnFloatArrayData.MStatus): 
        '''
        array(self, ReturnStatus: MFnFloatArrayData.MStatus) -> MFloatArray

        Synopsis
        -----
        Return an MFloatArray containing the float array currently
        operated upon by the function set. The MFloatArray returned by
        this method is editable, so any changes to the return instance
        also affects the MObject operated upon by this function set.

        Returns: 
        ----- 
        A copy of the MFloatArray held in this instance

        Parameters:
        -----
        ReturnStatus: MFnFloatArrayData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    @overload
    def create(self, ReturnStatus: MFnFloatArrayData.MStatus): 
        '''
        create(self, ReturnStatus: MFnFloatArrayData.MStatus) -> MObject

        Synopsis
        -----
        Create a new float array data object, initialize it to be empty,
        and attach it to this instance.

        Returns: 
        ----- 
        MObject referring to the newly created float array data object

        Parameters:
        -----
        ReturnStatus: MFnFloatArrayData.MStatus
        	[out] -> kSuccess


        '''
        pass

    @overload
    def create(self, arr: MFloatArray,
                        ReturnStatus: MFnFloatArrayData.MStatus): 
        '''
        create(self, arr: MFloatArray,
                        ReturnStatus: MFnFloatArrayData.MStatus) -> MObject

        Synopsis
        -----
        Create a new float array data object, initialize it to contain
        the data from the given MDoubleArray, and attach it to this
        instance.

        Returns: 
        ----- 
        MObject referring to the newly created float array data object

        Parameters:
        -----
        arr: MFloatArray
        	[in] -> the data to use when initializing this instance 

        ReturnStatus: MFnFloatArrayData.MStatus
        	[out] -> kSuccess


        '''
        pass

class MFnGenericAttribute:
    '''Generic attribute function set.
MFnGenericAttribute is a function set for attributes that can accept several types
of data. A generic attribute is similar to a typed attribute (
MFnTypedAttribute) except that it has a list of types that it considers valid.
If the attribute will only take one type of data then it is more
efficient to use one of the other attribute function sets such as
MFnTypedAttribute or
MFnNumericAttribute.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kGenericAttribute.Reimplemented from MFnAttribute.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnGenericAttribute.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnGenericAttribute".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, fullName: MString,
                        briefName: MString,
                        ReturnStatus: MFnGenericAttribute.MStatus): 
        '''
        create(self, fullName: MString,
                        briefName: MString,
                        ReturnStatus: MFnGenericAttribute.MStatus) -> MObject

        Synopsis
        -----
        Creates a new generic attribute. The create method needs to be
        called on a per node basis. That means if you want to create and
        add the same attribute to multiple nodes, you need to call the
        create method for each node to get a unique MObject back. If you
        call create just once and add the attribute to multiple nodes,
        Maya will encounter a fatal error.

        Returns: 
        ----- 
        New attribute.

        Parameters:
        -----
        fullName: MString
        	[in] -> Long name of the attribute. 

        briefName: MString
        	[in] -> Short name of the attribute. 

        ReturnStatus: MFnGenericAttribute.MStatus
        	[out] -> Status code.


        '''
        pass

    def addDataAccept(self, newType: MFnData.MFnData): 
        '''
        addDataAccept(self, newType: MFnData.MFnData)

        Synopsis
        -----
        Add a new connection type that this attribute can accept.

        Returns:
        -----
        None

        Parameters:
        -----
        newType: MFnData.MFnData
        	[in] -> new type


        '''
        pass

    def addNumericDataAccept(self, newType: MFnNumericData.MFnNumericData): 
        '''
        addNumericDataAccept(self, newType: MFnNumericData.MFnNumericData)

        Synopsis
        -----
        Add a new connection type that this attribute can accept.

        Returns:
        -----
        None

        Parameters:
        -----
        newType: MFnNumericData.MFnNumericData
        	[in] -> new type


        '''
        pass

    def addAccept(self, id: MTypeId): 
        '''
        addAccept(self, id: MTypeId)

        Synopsis
        -----
        Add a new connection type that this attribute can accept. This
        method takes the type id (iff tag) of the data objects that can
        be accepted.

        Returns:
        -----
        None

        Parameters:
        -----
        id: MTypeId
        	[in] -> id of new type


        '''
        pass

    def removeDataAccept(self, oldType: MFnData.MFnData): 
        '''
        removeDataAccept(self, oldType: MFnData.MFnData)

        Synopsis
        -----
        Remove one of the types that this attribute can accept.

        Returns:
        -----
        None

        Parameters:
        -----
        oldType: MFnData.MFnData
        	[in] -> old type that is no longer accepted


        '''
        pass

    def removeNumericDataAccept(self, oldType: MFnNumericData.MFnNumericData): 
        '''
        removeNumericDataAccept(self, oldType: MFnNumericData.MFnNumericData)

        Synopsis
        -----
        Remove one of the types that this attribute can accept.

        Returns:
        -----
        None

        Parameters:
        -----
        oldType: MFnNumericData.MFnNumericData
        	[in] -> old type that is no longer accepted


        '''
        pass

    def removeAccept(self, id: MTypeId): 
        '''
        removeAccept(self, id: MTypeId)

        Synopsis
        -----
        Remove one of the types that this attribute can accept. This
        method takes the type id (iff tag) of the data objects that can
        no longer be accepted.

        Returns:
        -----
        None

        Parameters:
        -----
        id: MTypeId
        	[in] -> id of old type that is no longer accepted


        '''
        pass

class MFnGeometryData:
    '''Geometry data function set.
This class is the function set for geometry data.
Geometry data adds matrix and grouping (set) information to
regular data and is used to pass geometry types such as mesh,
lattice, and NURBS shape data through DG connections.
User defined geometry data types (
MPxGeometryData) are also supported by this class.
The matrix within geometry data is the matrix used to convert the
object into local space.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kGeometryData.Reimplemented from MFnData.Reimplemented in
        MFnNurbsSurfaceData, MFnNurbsCurveData, MFnSubdData, MFnMeshData,
        and MFnLatticeData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnGeometryData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnGeometryData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setMatrix(self, matrix: MMatrix): 
        '''
        setMatrix(self, matrix: MMatrix)

        Synopsis
        -----
        Reset the matrix the the specified matrix and set the identity
        flag if the new matrix is the identity.

        Returns:
        -----
        None

        Parameters:
        -----
        matrix: MMatrix
        	[in] -> the new matrix to be set


        '''
        pass

    def getMatrix(self, matrix: MMatrix): 
        '''
        getMatrix(self, matrix: MMatrix)

        Synopsis
        -----
        Get the matrix associated with the geometry data.

        Returns:
        -----
        None

        Parameters:
        -----
        matrix: MMatrix
        	[out] -> storage for the returned matrix


        '''
        pass

    def matrixIsIdentity(self, ReturnStatus: MFnGeometryData.MStatus): 
        '''
        matrixIsIdentity(self, ReturnStatus: MFnGeometryData.MStatus) -> bool

        Synopsis
        -----
        Return true if the matrix is the identity.

        Returns: 
        ----- 
        True if the matrix for the geometry is identity, false otherwise

        Parameters:
        -----
        ReturnStatus: MFnGeometryData.MStatus
        	[out] -> return status


        '''
        pass

    def matrixIsNotIdentity(self, ReturnStatus: MFnGeometryData.MStatus): 
        '''
        matrixIsNotIdentity(self, ReturnStatus: MFnGeometryData.MStatus) -> bool

        Synopsis
        -----
        Return true if the matrix is different from identity.

        Returns: 
        ----- 
        True if the matrix for the geometry is NOT the identity, false
        otherwise

        Parameters:
        -----
        ReturnStatus: MFnGeometryData.MStatus
        	[out] -> return status


        '''
        pass

    def hasObjectGroup(self, id: int,
                        ReturnStatus: MFnGeometryData.MStatus): 
        '''
        hasObjectGroup(self, id: int,
                        ReturnStatus: MFnGeometryData.MStatus) -> bool

        Synopsis
        -----
        This method returns true if an object group with the given id is
        contained in the data.

        Returns: 
        ----- 
        True is there is an object group with the given id, false
        otherwise

        Parameters:
        -----
        id: int
        	[in] -> group id. 

        ReturnStatus: MFnGeometryData.MStatus
        	[out] -> return status


        '''
        pass

    def addObjectGroup(self, id: int): 
        '''
        addObjectGroup(self, id: int)

        Synopsis
        -----
        This method adds an object group with the given id to the object.

        Returns:
        -----
        None

        Parameters:
        -----
        id: int
        	[in] -> group id.


        '''
        pass

    def removeObjectGroup(self, id: int): 
        '''
        removeObjectGroup(self, id: int)

        Synopsis
        -----
        This method removes an object group with the given id from the
        object.

        Returns:
        -----
        None

        Parameters:
        -----
        id: int
        	[in] -> group id.


        '''
        pass

    def changeObjectGroupId(self, sourceId: int,
                        destId: int): 
        '''
        changeObjectGroupId(self, sourceId: int,
                        destId: int)

        Synopsis
        -----
        This method changes the id of the object group with the given id
        to the new id.

        Returns:
        -----
        None

        Parameters:
        -----
        sourceId: int
        	[in] -> id to change 

        destId: int
        	[in] -> new id to set


        '''
        pass

    def objectGroupCount(self, ReturnStatus: MFnGeometryData.MStatus): 
        '''
        objectGroupCount(self, ReturnStatus: MFnGeometryData.MStatus) -> int

        Synopsis
        -----
        This method returns the number of object groups contained by the
        object.

        Returns: 
        ----- 
        The number of object groups

        Parameters:
        -----
        ReturnStatus: MFnGeometryData.MStatus
        	[out] -> return status


        '''
        pass

    def objectGroup(self, index: int,
                        ReturnStatus: MFnGeometryData.MStatus): 
        '''
        objectGroup(self, index: int,
                        ReturnStatus: MFnGeometryData.MStatus) -> int

        Synopsis
        -----
        This method returns the id of the i'th object group contained by
        the object.

        Returns: 
        ----- 
        The id of the i'th object group

        Parameters:
        -----
        index: int
        	[out] -> index in the group array. 

        ReturnStatus: MFnGeometryData.MStatus
        	[out] -> return status


        '''
        pass

    def objectGroupType(self, id: int,
                        ReturnStatus: MFnGeometryData.MStatus): 
        '''
        objectGroupType(self, id: int,
                        ReturnStatus: MFnGeometryData.MStatus) -> MFn.MFn

        Synopsis
        -----
        This method returns the type of the component that the object
        group with the given id contains.

        Returns: 
        ----- 
        The type of the specified object group component

        Parameters:
        -----
        id: int
        	[in] -> group id. 

        ReturnStatus: MFnGeometryData.MStatus
        	[out] -> return status


        '''
        pass

    def objectGroupComponent(self, id: int,
                        ReturnStatus: MFnGeometryData.MStatus): 
        '''
        objectGroupComponent(self, id: int,
                        ReturnStatus: MFnGeometryData.MStatus) -> MObject

        Synopsis
        -----
        This method returns a component which contains the members of the
        object group with the given id.

        Returns: 
        ----- 
        A component containing the members of the specified object group

        Parameters:
        -----
        id: int
        	[in] -> group id. 

        ReturnStatus: MFnGeometryData.MStatus
        	[out] -> return status


        '''
        pass

    def setObjectGroupComponent(self, id: int,
                        component: MObject): 
        '''
        setObjectGroupComponent(self, id: int,
                        component: MObject)

        Synopsis
        -----
        This method sets the members of the object group with the given
        id to be only those in the given component.

        Returns:
        -----
        None

        Parameters:
        -----
        id: int
        	[in] -> id of object group to set 

        component: MObject
        	[in] -> new component for specified object group. The component should be an 


        '''
        pass

    def addObjectGroupComponent(self, id: int,
                        component: MObject): 
        '''
        addObjectGroupComponent(self, id: int,
                        component: MObject)

        Synopsis
        -----
        This method adds the members of the given component to the object
        group with the given id.

        Returns:
        -----
        None

        Parameters:
        -----
        id: int
        	[in] -> id of object group to add to 

        component: MObject
        	[in] -> new component to be added to the specified object group. The component should be an 


        '''
        pass

    def removeObjectGroupComponent(self, id: int,
                        component: MObject): 
        '''
        removeObjectGroupComponent(self, id: int,
                        component: MObject)

        Synopsis
        -----
        This method removes the members of the given component from the
        object group with the given id.

        Returns:
        -----
        None

        Parameters:
        -----
        id: int
        	[in] -> id of object group to be changed 

        component: MObject
        	[in] -> component specifying the members to be removed. The component should be an 


        '''
        pass

    def objectGroupSubsetState(self, id: int,
                        ReturnStatus: MFnGeometryData.MStatus): 
        '''
        objectGroupSubsetState(self, id: int,
                        ReturnStatus: MFnGeometryData.MStatus) -> MFnGeometryData.MFnGeometryData

        Synopsis
        -----
        Introduced in 2022.0 This method returns the state of the
        contents of the component that the object group with the given id
        contains.

        Returns: 
        ----- 
        The group contents of the specified object group component
        kInvalidGroup group could not be found  kEmptyGroup group
        contains no components  kCompleteGroup group contains all
        components of the geometry  kPartialGroup group contains some
        (but not all) components of the geometry

        Parameters:
        -----
        id: int
        	[in] -> group id. 

        ReturnStatus: MFnGeometryData.MStatus
        	[out] -> return status


        '''
        pass

    def copyObjectGroups(self, inGeom: MObject): 
        '''
        copyObjectGroups(self, inGeom: MObject)

        Synopsis
        -----
        Copies the object groups from the given geometry data object.

        Returns:
        -----
        None

        Parameters:
        -----
        inGeom: MObject
        	[in] -> the geometry data to be copied


        '''
        pass

    def componentTags(self, keys: MStringArray): 
        '''
        componentTags(self, keys: MStringArray)

        Synopsis
        -----
        Introduced in 2022.0 Get the componentTag keys associated with
        the geometry data.

        Returns:
        -----
        None

        Parameters:
        -----
        keys: MStringArray
        	[out] -> storage for the array of keys


        '''
        pass

    def hasComponentTag(self, key: MString,
                        ReturnStatus: MFnGeometryData.MStatus): 
        '''
        hasComponentTag(self, key: MString,
                        ReturnStatus: MFnGeometryData.MStatus) -> bool

        Synopsis
        -----
        Introduced in 2022.0 This method returns true if a componentTag
        with the given key is contained in the data.

        Returns: 
        ----- 
        True is there is a componentTag with the given key, false
        otherwise

        Parameters:
        -----
        key: MString
        	[in] -> componentTag key 

        ReturnStatus: MFnGeometryData.MStatus
        	[out] -> return status


        '''
        pass

    def addComponentTag(self, key: MString): 
        '''
        addComponentTag(self, key: MString)

        Synopsis
        -----
        Introduced in 2022.0 This method adds a componentTag with the
        given key to the object.

        Returns:
        -----
        None

        Parameters:
        -----
        key: MString
        	[in] -> componentTag key


        '''
        pass

    def removeComponentTag(self, key: MString): 
        '''
        removeComponentTag(self, key: MString)

        Synopsis
        -----
        Introduced in 2022.0 This method removes a componentTag with the
        given key from the object.

        Returns:
        -----
        None

        Parameters:
        -----
        key: MString
        	[in] -> componentTag key


        '''
        pass

    def renameComponentTag(self, key: MString,
                        newKey: MString): 
        '''
        renameComponentTag(self, key: MString,
                        newKey: MString)

        Synopsis
        -----
        Introduced in 2022.0 This method renames a componentTag with the
        given key to a new key.

        Returns:
        -----
        None

        Parameters:
        -----
        key: MString
        	[in] -> componentTag key to be altered 

        newKey: MString
        	[in] -> the new componentTag key to be used


        '''
        pass

    def componentTagContents(self, key: MString,
                        ReturnStatus: MFnGeometryData.MStatus): 
        '''
        componentTagContents(self, key: MString,
                        ReturnStatus: MFnGeometryData.MStatus) -> MObject

        Synopsis
        -----
        Introduced in 2022.0 This method returns a component which
        contains the members of the object group with the given id.

        Returns: 
        ----- 
        A component containing the members of the specified object group

        Parameters:
        -----
        key: MString
        	[in] -> componentTag key 

        ReturnStatus: MFnGeometryData.MStatus
        	[out] -> return status


        '''
        pass

    def setComponentTagContents(self, key: MString,
                        component: MObject): 
        '''
        setComponentTagContents(self, key: MString,
                        component: MObject)

        Synopsis
        -----
        Introduced in 2022.0 This method sets the members of the object
        group with the given id to be only those in the given component.

        Returns:
        -----
        None

        Parameters:
        -----
        key: MString
        	[in] -> key of componentTag to set 

        component: MObject
        	[in] -> new component for specified componentTag. The component should be an 


        '''
        pass

    def componentTagType(self, key: MString,
                        ReturnStatus: MFnGeometryData.MStatus): 
        '''
        componentTagType(self, key: MString,
                        ReturnStatus: MFnGeometryData.MStatus) -> MFn.MFn

        Synopsis
        -----
        Introduced in 2022.0 This method returns the type of the
        component the componentTag with the given key contains.

        Returns: 
        ----- 
        The type of the specified componentTag component

        Parameters:
        -----
        key: MString
        	[in] -> componentTag key 

        ReturnStatus: MFnGeometryData.MStatus
        	[out] -> return status


        '''
        pass

    def componentTagCategory(self, key: MString,
                        ReturnStatus: MFnGeometryData.MStatus): 
        '''
        componentTagCategory(self, key: MString,
                        ReturnStatus: MFnGeometryData.MStatus) -> MFnGeometryData.MFnGeometryData

        Synopsis
        -----
        Introduced in 2022.0 This method returns the category of the
        component the componentTag with the given key contains.

        Returns: 
        ----- 
        The type of the specified componentTag component

        Parameters:
        -----
        key: MString
        	[in] -> componentTag key 

        ReturnStatus: MFnGeometryData.MStatus
        	[out] -> return status


        '''
        pass

    def componentTagExpressionSubsetState(self, expression: MString,
                        ctg: MFnGeometryData.ComponentTagCategory,
                        ReturnStatus: MFnGeometryData.MStatus): 
        '''
        componentTagExpressionSubsetState(self, expression: MString,
                        ctg: MFnGeometryData.ComponentTagCategory,
                        ReturnStatus: MFnGeometryData.MStatus) -> MFnGeometryData.MFnGeometryData

        Synopsis
        -----
        Introduced in 2022.0 This method returns the state of the
        contents of the component that is defined by the given
        componentTag expression.

        Returns: 
        ----- 
        The state of the contents of the resolved expression
        kInvalidGroup expression could not be resolved  kEmptyGroup
        resolved expression contains no components  kCompleteGroup
        resolvedexpression contains all components of the geometry
        kPartialGroup resolvedexpression contains some (but not all)
        components of the geometry

        Parameters:
        -----
        expression: MString
        	[in] -> componentTag expression 

        ctg: MFnGeometryData.ComponentTagCategory
        	[in] -> the component category the expression must be resolved to 

        ReturnStatus: MFnGeometryData.MStatus
        	[out] -> return status


        '''
        pass

    def resolveComponentTagExpression(self, expression: MString,
                        ctg: MFnGeometryData.ComponentTagCategory,
                        ReturnStatus: MFnGeometryData.MStatus): 
        '''
        resolveComponentTagExpression(self, expression: MString,
                        ctg: MFnGeometryData.ComponentTagCategory,
                        ReturnStatus: MFnGeometryData.MStatus) -> MObject

        Synopsis
        -----
        Introduced in 2022.0 This method returns the resolved component
        that is defined by the given componentTag expression.

        Returns: 
        ----- 
        A component containing the members of the specified object group

        Parameters:
        -----
        expression: MString
        	[in] -> componentTag expression 

        ctg: MFnGeometryData.ComponentTagCategory
        	[in] -> the component category the expression must be resolved to 

        ReturnStatus: MFnGeometryData.MStatus
        	[out] -> return status


        '''
        pass

class MFnIntArrayData:
    '''int array function set for dependency node data.
MFnIntArrayData allows the creation and manipulation of
MIntArray data objects for use in the dependency graph.
If a user written dependency node either accepts or produces
MIntArrays, then this class is used to extract or create the data
that comes from or goes to other dependency graph nodes. The
MDataHandle::type method will return kIntArray when data of this type is present.
To access it, the
MDataHandle::data method is used to get an
MObject for the data and this should then be used to initialize an
instance of
MFnIntArrayData.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kIntArrayData.Reimplemented from MFnData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnIntArrayData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnIntArrayData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def length(self, ReturnStatus: MFnIntArrayData.MStatus): 
        '''
        length(self, ReturnStatus: MFnIntArrayData.MStatus) -> int

        Synopsis
        -----
        Return the number of integers in the instance.

        Returns: 
        ----- 
        The number of integers in the instance

        Parameters:
        -----
        ReturnStatus: MFnIntArrayData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> int

        Synopsis
        -----
        Extract the indicated integer from the const instance. No
        checking is done by this class to ensure that the index is valid
        - use the length method to determine the size of the array. If
        the instance is not attached to an MObject, this method will
        return an integer containing zero.

        Returns: 
        ----- 
        The indicated integer

        Parameters:
        -----
        index: int
        	[in] -> the index of the integer to extract


        '''
        pass

    @overload
    def set(self, element: int,
                        index: int): 
        '''
        set(self, element: int,
                        index: int)

        Synopsis
        -----
        Set the integer element at the specified index of this array. No
        checking is done by this class to ensure that the index is valid
        - use the length method to determine the size of the array.

        Returns:
        -----
        None

        Parameters:
        -----
        element: int
        	[in] -> the element 

        index: int
        	[in] -> the index of the integer to extract


        '''
        pass

    def copyTo(self, dest: MIntArray): 
        '''
        copyTo(self, dest: MIntArray)

        Synopsis
        -----
        Copy all the integers in the instance into the given MIntArray.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: MIntArray
        	[out] -> the 


        '''
        pass

    @overload
    def set(self, array: MIntArray): 
        '''
        set(self, array: MIntArray)

        Synopsis
        -----
        Set the instance to contain the integers defined in the given
        MIntArray.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MIntArray
        	[in] -> the 


        '''
        pass

    def array(self, ReturnStatus: MFnIntArrayData.MStatus): 
        '''
        array(self, ReturnStatus: MFnIntArrayData.MStatus) -> MIntArray

        Synopsis
        -----
        Return an MIntArray containing the integer array currently
        operated upon by the function set. The MIntArray returned by this
        method is editable, so any changes to the return instance also
        affects the MObject operated upon by this function set.

        Returns: 
        ----- 
        A copy of the MIntArray held in this instance

        Parameters:
        -----
        ReturnStatus: MFnIntArrayData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    @overload
    def create(self, ReturnStatus: MFnIntArrayData.MStatus): 
        '''
        create(self, ReturnStatus: MFnIntArrayData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance, and initialize
        it to contain no ints.

        Returns: 
        ----- 
        The newly created MObject

        Parameters:
        -----
        ReturnStatus: MFnIntArrayData.MStatus
        	[out] -> kSuccess


        '''
        pass

    @overload
    def create(self, arr: MIntArray,
                        ReturnStatus: MFnIntArrayData.MStatus): 
        '''
        create(self, arr: MIntArray,
                        ReturnStatus: MFnIntArrayData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance, and initialize
        it to contain the data from the given MIntArray.

        Returns: 
        ----- 
        The newly created MObject

        Parameters:
        -----
        arr: MIntArray
        	[in] -> the data to use when initializing this instance 

        ReturnStatus: MFnIntArrayData.MStatus
        	[out] -> kSuccess


        '''
        pass

class MFnLambertShader:
    '''Manage Lambert shaders.
MFnLambertShader facilitates creation and manipulation of dependency graph nodes
representing lambertian shaders.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kLambert.Reimplemented from MFnDependencyNode.Reimplemented
        in MFnReflectShader, MFnBlinnShader, and MFnPhongShader.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnLambertShader.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnLambertShader".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, UIvisible: bool,
                        ReturnStatus: MFnLambertShader.MStatus): 
        '''
        create(self, UIvisible: bool,
                        ReturnStatus: MFnLambertShader.MStatus) -> MObject

        Synopsis
        -----
        Creates a new lambert shader dependency graph node and adds it to
        the dependency graph. If the UIvisible parameter is true, the new
        node will be connected to the shader classification node (which
        allows the UI to recognize the node as a shader). If UIvisible is
        false, the node will be created in isolation.

        Returns: 
        ----- 
        MObject representing the new dependency node.

        Parameters:
        -----
        UIvisible: bool
        	[in] -> determines whether or not the new node will be connected to the shader classification node. 

        ReturnStatus: MFnLambertShader.MStatus
        	[out] -> return status


        '''
        pass

    def refractedRayDepthLimit(self, ReturnStatus: MFnLambertShader.MStatus): 
        '''
        refractedRayDepthLimit(self, ReturnStatus: MFnLambertShader.MStatus) -> short

        Synopsis
        -----
        Retrieves the value of the "refractedRayDepthLimit" attribute of
        a lambert shader node. This attribute represents the maximum
        refracted ray depth used in the shading calculation.

        Returns: 
        ----- 
        The value of the "refractedRayDepthLimit" attribute of the node.

        Parameters:
        -----
        ReturnStatus: MFnLambertShader.MStatus
        	[out] -> return status


        '''
        pass

    def setRefractedRayDepthLimit(self, refracted_ray_depth_limit: short): 
        '''
        setRefractedRayDepthLimit(self, refracted_ray_depth_limit: short)

        Synopsis
        -----
        Sets the value of the "refractedRayDepthLimit" attribute of a
        lambert shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        refracted_ray_depth_limit: short
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def refractiveIndex(self, ReturnStatus: MFnLambertShader.MStatus): 
        '''
        refractiveIndex(self, ReturnStatus: MFnLambertShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "refractiveIndex" attribute of a
        lambert shader node. This attribute represents the refractive
        index of the shader.

        Returns: 
        ----- 
        The value of the "refractiveIndex" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnLambertShader.MStatus
        	[out] -> return status


        '''
        pass

    def setRefractiveIndex(self, refractive_index: float): 
        '''
        setRefractiveIndex(self, refractive_index: float)

        Synopsis
        -----
        Sets the value of the "refractiveIndex" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        refractive_index: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def rtRefractedColor(self, ReturnStatus: MFnLambertShader.MStatus): 
        '''
        rtRefractedColor(self, ReturnStatus: MFnLambertShader.MStatus) -> bool

        Synopsis
        -----
        Retrieves the value of the "rtRefractedColor" attribute of a
        shader node. This attribute determines whether the shader uses
        the value of the "refractedColor" attribute for the refracted
        color or calculated the refracted color itself.

        Returns: 
        ----- 
        The value of the "rtRefractedColor" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnLambertShader.MStatus
        	[out] -> return status


        '''
        pass

    def setRtRefractedColor(self, rt_refracted_color: bool): 
        '''
        setRtRefractedColor(self, rt_refracted_color: bool)

        Synopsis
        -----
        Sets the value of the "rtRefractedColor" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        rt_refracted_color: bool
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def diffuseCoeff(self, ReturnStatus: MFnLambertShader.MStatus): 
        '''
        diffuseCoeff(self, ReturnStatus: MFnLambertShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "diffuseCoeff" attribute of a lambert
        shader node. This attribute represents the diffuse reflectivity
        of the shader.

        Returns: 
        ----- 
        The value of the "diffuseCoeff" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnLambertShader.MStatus
        	[out] -> return status


        '''
        pass

    def setDiffuseCoeff(self, diffuse_coeff: float): 
        '''
        setDiffuseCoeff(self, diffuse_coeff: float)

        Synopsis
        -----
        Sets the value of the "diffuseCoeff" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        diffuse_coeff: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def color(self, ReturnStatus: MFnLambertShader.MStatus): 
        '''
        color(self, ReturnStatus: MFnLambertShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "color" attribute of a shader node.
        This attribute represents the surface color of the shader.

        Returns: 
        ----- 
        The value of the "color" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnLambertShader.MStatus
        	[out] -> return status


        '''
        pass

    def setColor(self, col: MColor): 
        '''
        setColor(self, col: MColor)

        Synopsis
        -----
        Sets the value of the "color" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        col: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def transparency(self, ReturnStatus: MFnLambertShader.MStatus): 
        '''
        transparency(self, ReturnStatus: MFnLambertShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "transparency" attribute of a shader
        node. This attribute represents the surface transparency of the
        shader.

        Returns: 
        ----- 
        The value of the "transparency" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnLambertShader.MStatus
        	[out] -> return status


        '''
        pass

    def setTransparency(self, transp: MColor): 
        '''
        setTransparency(self, transp: MColor)

        Synopsis
        -----
        Sets the value of the "transparency" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        transp: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def ambientColor(self, ReturnStatus: MFnLambertShader.MStatus): 
        '''
        ambientColor(self, ReturnStatus: MFnLambertShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "ambientColor" attribute of a shader
        node. This attribute represents the ambient color of the shader.

        Returns: 
        ----- 
        The value of the "ambientColor" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnLambertShader.MStatus
        	[out] -> return status


        '''
        pass

    def setAmbientColor(self, ambient_color: MColor): 
        '''
        setAmbientColor(self, ambient_color: MColor)

        Synopsis
        -----
        Sets the value of the "ambientColor" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        ambient_color: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def incandescence(self, ReturnStatus: MFnLambertShader.MStatus): 
        '''
        incandescence(self, ReturnStatus: MFnLambertShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "incandescence" attribute of a shader
        node. This attribute represents the incandescence of the shader.

        Returns: 
        ----- 
        The value of the "incandescence" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnLambertShader.MStatus
        	[out] -> return status


        '''
        pass

    def setIncandescence(self, incand: MColor): 
        '''
        setIncandescence(self, incand: MColor)

        Synopsis
        -----
        Sets the value of the "incandescence" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        incand: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def translucenceCoeff(self, ReturnStatus: MFnLambertShader.MStatus): 
        '''
        translucenceCoeff(self, ReturnStatus: MFnLambertShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "translucenceCoeff" attribute of a
        lambert shader node. This attribute represents a constant
        multiplier applied to the transparency attribute of the shader.

        Returns: 
        ----- 
        The value of the "translucenceCoeff" attribute of the shader
        node.

        Parameters:
        -----
        ReturnStatus: MFnLambertShader.MStatus
        	[out] -> return status


        '''
        pass

    def setTranslucenceCoeff(self, translucence_coeff: float): 
        '''
        setTranslucenceCoeff(self, translucence_coeff: float)

        Synopsis
        -----
        Sets the value of the "translucenceCoeff" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        translucence_coeff: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def glowIntensity(self, ReturnStatus: MFnLambertShader.MStatus): 
        '''
        glowIntensity(self, ReturnStatus: MFnLambertShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "glowIntensity" attribute of a shader
        node. This attribute represents the constant multplier applied to
        the glow color of the shader.

        Returns: 
        ----- 
        The value of the "glowIntensity" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnLambertShader.MStatus
        	[out] -> return status


        '''
        pass

    def setGlowIntensity(self, glow_intensity: float): 
        '''
        setGlowIntensity(self, glow_intensity: float)

        Synopsis
        -----
        Sets the value of the "glowIntensity" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        glow_intensity: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def hideSource(self, ReturnStatus: MFnLambertShader.MStatus): 
        '''
        hideSource(self, ReturnStatus: MFnLambertShader.MStatus) -> bool

        Synopsis
        -----
        Retrieves the value of the "hideSource" attribute of a shader
        node. This attribute determines whether or not the computed
        surface color is used in the shading computation. If hideSource
        is true, then only the computed shader glow color will be used.
        Otherwise, both the glow and surface colors will be used.

        Returns: 
        ----- 
        The value of the "hideSource" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnLambertShader.MStatus
        	[out] -> return status


        '''
        pass

    def setHideSource(self, hide_source: bool): 
        '''
        setHideSource(self, hide_source: bool)

        Synopsis
        -----
        Sets the value of the "hideSource" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        hide_source: bool
        	[in] -> value to which the attribute will be set.


        '''
        pass

class MFnLatticeData:
    '''Lattice Data dependency graph type.
This simple function set is used to create lattice data objects
that can be transmitted through the dependency graph. It can also
be used to extract the lattice geometry from the data object.
See
MDataHandle and
MDataBlock for more information about getting and setting data in the
dependency graph.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kLatticeData.Reimplemented from MFnGeometryData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnLatticeData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnLatticeData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, ReturnStatus: MFnLatticeData.MStatus): 
        '''
        create(self, ReturnStatus: MFnLatticeData.MStatus) -> MObject

        Synopsis
        -----
        This method create a new lattice data object for use with the
        dependency graph. A node's lattice attribute may be set with this
        object using MDataHandle.

        Returns: 
        ----- 
        A handle to the new lattice data object

        Parameters:
        -----
        ReturnStatus: MFnLatticeData.MStatus
        	[out] -> return status


        '''
        pass

    def lattice(self, ReturnStatus: MFnLatticeData.MStatus): 
        '''
        lattice(self, ReturnStatus: MFnLatticeData.MStatus) -> MObject

        Synopsis
        -----
        Returns the lattice geometry so that it may be modified using the
        MFnLattice function set. It is possible that the data object will
        be NULL, indicating that the data handle (MDataHandle) or plug
        (MPlug) that owns this data has not initialized it. In this case,
        the create method of this function set can be used to create a
        new data object that can be used to set the data handle or plug.

        Returns: 
        ----- 
        A handle to the new lattice data object

        Parameters:
        -----
        ReturnStatus: MFnLatticeData.MStatus
        	[out] -> return status


        '''
        pass

class MFnLayeredShader:
    '''Manage Layered shaders.
MFnLayeredShader facilitates creation and manipulation of dependency graph nodes
representing layered shaders.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kLayeredShader.Reimplemented from MFnDependencyNode.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnLayeredShader.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnLayeredShader".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, UIvisible: bool,
                        ReturnStatus: MFnLayeredShader.MStatus): 
        '''
        create(self, UIvisible: bool,
                        ReturnStatus: MFnLayeredShader.MStatus) -> MObject

        Synopsis
        -----
        Creates a new layered shader dependency graph node and adds it to
        the dependency graph. If the UIvisible parameter is true, the new
        node will be connected to the shader classification node (which
        allows the UI to recognize the node as a shader). If UIvisible is
        false, the node will be created in isolation.

        Returns: 
        ----- 
        MObject representing the new dependency node.

        Parameters:
        -----
        UIvisible: bool
        	[in] -> determines whether or not the new node will be connected to the shader classification node. 

        ReturnStatus: MFnLayeredShader.MStatus
        	[out] -> return status


        '''
        pass

    def compositingFlag(self, ReturnStatus: MFnLayeredShader.MStatus): 
        '''
        compositingFlag(self, ReturnStatus: MFnLayeredShader.MStatus) -> short

        Synopsis
        -----
        Retrieves the value of the "compositingFlag" attribute of a
        shader node.

        Returns: 
        ----- 
        The value of the "compositingFlag" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnLayeredShader.MStatus
        	[out] -> return status


        '''
        pass

    def setCompositingFlag(self, cflag: short): 
        '''
        setCompositingFlag(self, cflag: short)

        Synopsis
        -----
        Sets the value of the "compositingFlag" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        cflag: short
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def color(self, lIndex: int,
                        ReturnStatus: MFnLayeredShader.MStatus): 
        '''
        color(self, lIndex: int,
                        ReturnStatus: MFnLayeredShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "color" attribute of a shader node.
        This attribute represents the surface color of the shader.

        Returns: 
        ----- 
        The value of the "color" attribute of the shader node.

        Parameters:
        -----
        lIndex: int
        	[in] -> Index of the shader's entry in the 

        ReturnStatus: MFnLayeredShader.MStatus
        	[out] -> Status code.


        '''
        pass

    def setColor(self, col: MColor,
                        lIndex: int): 
        '''
        setColor(self, col: MColor,
                        lIndex: int)

        Synopsis
        -----
        Sets the value of the "color" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        col: MColor
        	[in] -> Color. 

        lIndex: int
        	[in] -> Index of the shader's entry in the 


        '''
        pass

    def transparency(self, lIndex: int,
                        ReturnStatus: MFnLayeredShader.MStatus): 
        '''
        transparency(self, lIndex: int,
                        ReturnStatus: MFnLayeredShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "transparency" attribute of a shader
        node. This attribute represents the surface transparency of the
        shader.

        Returns: 
        ----- 
        The value of the "transparency" attribute of the shader node.

        Parameters:
        -----
        lIndex: int
        	[in] -> Index of the shader's entry in the 

        ReturnStatus: MFnLayeredShader.MStatus
        	[out] -> Status code.


        '''
        pass

    def setTransparency(self, transp: MColor,
                        lIndex: int): 
        '''
        setTransparency(self, transp: MColor,
                        lIndex: int)

        Synopsis
        -----
        Sets the value of the "transparency" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        transp: MColor
        	[in] -> Value to which the attribute will be set. 

        lIndex: int
        	[in] -> Index of the shader's entry in the 


        '''
        pass

    def glowColor(self, lIndex: int,
                        ReturnStatus: MFnLayeredShader.MStatus): 
        '''
        glowColor(self, lIndex: int,
                        ReturnStatus: MFnLayeredShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "glowColor" attribute of a shader
        node. This attribute represents the ambient color of the shader.

        Returns: 
        ----- 
        The value of the "glowColor" attribute of the shader node.

        Parameters:
        -----
        lIndex: int
        	[in] -> Index of the shader's entry in the 

        ReturnStatus: MFnLayeredShader.MStatus
        	[out] -> Status code.


        '''
        pass

    def setGlowColor(self, glow_color: MColor,
                        lIndex: int): 
        '''
        setGlowColor(self, glow_color: MColor,
                        lIndex: int)

        Synopsis
        -----
        Sets the value of the "glowColor" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        glow_color: MColor
        	[in] -> Color to which the attribute will be set. 

        lIndex: int
        	[in] -> Index of the shader's entry in the 


        '''
        pass

    def hardwareColor(self, ReturnStatus: MFnLayeredShader.MStatus): 
        '''
        hardwareColor(self, ReturnStatus: MFnLayeredShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "hardwareColor" attribute of a shader
        node. This attribute represents the color of the material that
        appears in shaded mode.

        Returns: 
        ----- 
        The value of the "hardwareColor" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnLayeredShader.MStatus
        	[out] -> return status


        '''
        pass

    def setHardwareColor(self, hardware_color: MColor): 
        '''
        setHardwareColor(self, hardware_color: MColor)

        Synopsis
        -----
        Sets the value of the "hardwareColor" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        hardware_color: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def hardwareShader(self, ReturnStatus: MFnLayeredShader.MStatus): 
        '''
        hardwareShader(self, ReturnStatus: MFnLayeredShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "hardwareShader" attribute of a
        layered shader node.

        Returns: 
        ----- 
        The value of the "hardwareShader" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnLayeredShader.MStatus
        	[out] -> return status


        '''
        pass

    def setHardwareShader(self, hardware_shader: MColor): 
        '''
        setHardwareShader(self, hardware_shader: MColor)

        Synopsis
        -----
        Sets the value of the "hardwareShader" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        hardware_shader: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

class MFnLight:
    '''Manage dependency graph nodes representing lights.
MFnLight allows the creation and manipulation of dependency graph nodes
representing lights. This is the top level of a hierarchy of
light node function sets. It permits manipulation of the
attributes common to all types of lights.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kLight.Reimplemented from MFnDagNode.Reimplemented in
        MFnSpotLight, MFnNonAmbientLight, MFnNonExtendedLight,
        MFnAmbientLight, MFnAreaLight, MFnDirectionalLight,
        MFnPointLight, and MFnVolumeLight.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnLight.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnLight".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def color(self, ReturnStatus: MFnLight.MStatus): 
        '''
        color(self, ReturnStatus: MFnLight.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "color" attribute of a light node.
        This attribute represents the color of the light emitted by the
        light node.

        Returns: 
        ----- 
        The value of the "color" attribute of the light node.

        Parameters:
        -----
        ReturnStatus: MFnLight.MStatus
        	[out] -> return status


        '''
        pass

    def setColor(self, col: MColor): 
        '''
        setColor(self, col: MColor)

        Synopsis
        -----
        Sets the value of the "color" attribute of a light node.

        Returns:
        -----
        None

        Parameters:
        -----
        col: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def intensity(self, ReturnStatus: MFnLight.MStatus): 
        '''
        intensity(self, ReturnStatus: MFnLight.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "intensity" attribute of a light node.
        This attribute represents a uniform scaling factor applied to the
        light color.

        Returns: 
        ----- 
        The value of the "intensity" attribute of the light node.

        Parameters:
        -----
        ReturnStatus: MFnLight.MStatus
        	[out] -> return status


        '''
        pass

    def setIntensity(self, intens: float): 
        '''
        setIntensity(self, intens: float)

        Synopsis
        -----
        Sets the value of the "intensity" attribute of a light node.

        Returns:
        -----
        None

        Parameters:
        -----
        intens: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def useRayTraceShadows(self, ReturnStatus: MFnLight.MStatus): 
        '''
        useRayTraceShadows(self, ReturnStatus: MFnLight.MStatus) -> bool

        Synopsis
        -----
        Retrieves the value of the "useRayTraceShadows" attribute of a
        light node. This attribute determines whether or not the light
        should raytrace it's shadows.

        Returns: 
        ----- 
        The value of the "useRayTraceShadows" attribute of the light
        node.

        Parameters:
        -----
        ReturnStatus: MFnLight.MStatus
        	[out] -> return status


        '''
        pass

    def setUseRayTraceShadows(self, useRayTraceShadows: bool): 
        '''
        setUseRayTraceShadows(self, useRayTraceShadows: bool)

        Synopsis
        -----
        Sets the value of the "useRayTraceShadows" attribute of a light
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        useRayTraceShadows: bool
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def shadowColor(self, ReturnStatus: MFnLight.MStatus): 
        '''
        shadowColor(self, ReturnStatus: MFnLight.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "shadowColor" attribute of a light
        node. This attribute represents the color of the shadows cast by
        the light.

        Returns: 
        ----- 
        The value of the "shadowColor" attribute of the light node.

        Parameters:
        -----
        ReturnStatus: MFnLight.MStatus
        	[out] -> return status


        '''
        pass

    def setShadowColor(self, shadow_color: MColor): 
        '''
        setShadowColor(self, shadow_color: MColor)

        Synopsis
        -----
        Sets the value of the "shadowColor" attribute of a light node.

        Returns:
        -----
        None

        Parameters:
        -----
        shadow_color: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def centerOfIllumination(self, ReturnStatus: MFnLight.MStatus): 
        '''
        centerOfIllumination(self, ReturnStatus: MFnLight.MStatus) -> double

        Synopsis
        -----
        Retrieves the value of the "centerOfIllumination" attribute of a
        light node. This attribute represents the distance to the center
        of illumination of the light.

        Returns: 
        ----- 
        The value of the "centerOfIllumination" attribute of the light
        node.

        Parameters:
        -----
        ReturnStatus: MFnLight.MStatus
        	[out] -> return status


        '''
        pass

    def setCenterOfIllumination(self, dist: double): 
        '''
        setCenterOfIllumination(self, dist: double)

        Synopsis
        -----
        Sets the value of the "centerOfIllumination" attribute of a light
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        dist: double
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def numShadowSamples(self, ReturnStatus: MFnLight.MStatus): 
        '''
        numShadowSamples(self, ReturnStatus: MFnLight.MStatus) -> short

        Synopsis
        -----
        Retrieves the value of the "numShadowSamples" attribute of a
        light node. This attribute represents the number of shadow
        samples per point used in occulusion testing.

        Returns: 
        ----- 
        The value of the "numShadowSamples" attribute of the light node.

        Parameters:
        -----
        ReturnStatus: MFnLight.MStatus
        	[out] -> return status


        '''
        pass

    def setNumShadowSamples(self, num_shadow_samples: short): 
        '''
        setNumShadowSamples(self, num_shadow_samples: short)

        Synopsis
        -----
        Sets the value of the "numShadowSamples" attribute of a light
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        num_shadow_samples: short
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def rayDepthLimit(self, ReturnStatus: MFnLight.MStatus): 
        '''
        rayDepthLimit(self, ReturnStatus: MFnLight.MStatus) -> short

        Synopsis
        -----
        Retrieves the value of the "rayDepthLimit" attribute of a light
        node. This attribute determines a cutoff point for shadow
        calculations related to the light. Rays whose depth is higher
        than the value of this attribute will not trigger a shadow
        calculation for the light.

        Returns: 
        ----- 
        The value of the "rayDepthLimit" attribute of the light node.

        Parameters:
        -----
        ReturnStatus: MFnLight.MStatus
        	[out] -> return status


        '''
        pass

    def setRayDepthLimit(self, ray_depth_limit: short): 
        '''
        setRayDepthLimit(self, ray_depth_limit: short)

        Synopsis
        -----
        Sets the value of the "rayDepthLimit" attribute of a light node.

        Returns:
        -----
        None

        Parameters:
        -----
        ray_depth_limit: short
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def opticalFXvisibility(self, ReturnStatus: MFnLight.MStatus): 
        '''
        opticalFXvisibility(self, ReturnStatus: MFnLight.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "opticalFXvisibility" attribute of a
        light node. This attribute represents an occlusion scaling factor
        for light glow effects on this light.

        Returns: 
        ----- 
        The value of the "opticalFXvisibility" attribute of the light
        node.

        Parameters:
        -----
        ReturnStatus: MFnLight.MStatus
        	[out] -> return status


        '''
        pass

    def setOpticalFXvisibility(self, visibility: MColor): 
        '''
        setOpticalFXvisibility(self, visibility: MColor)

        Synopsis
        -----
        Sets the value of the "opticalFXvisibility" attribute of a light
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        visibility: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def lightIntensity(self, ReturnStatus: MFnLight.MStatus): 
        '''
        lightIntensity(self, ReturnStatus: MFnLight.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "lightIntensity" attribute of a light
        node. This attribute represents the intensity of the light
        specified as a color.

        Returns: 
        ----- 
        The value of the "lightIntensity" attribute of the light node.

        Parameters:
        -----
        ReturnStatus: MFnLight.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def lightDirection(self, instance: int,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnLight.MStatus): 
        '''
        lightDirection(self, instance: int,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnLight.MStatus) -> MFloatVector

        Synopsis
        -----
        Returns the direction in which the light is pointing. This is
        only valid for lights which are associated with a direction, such
        as area, directional or spot lights. The vector returned is not
        normalized.

        Returns: 
        ----- 
        A vector containing the direction of the light is the specified
        coordinate system.

        Parameters:
        -----
        instance: int
        	[in] -> The instance of the light for which to return the direction. 

        space: MSpace.MSpace
        	[in] -> The coordinate space for which the direction vector is returned. If 

        ReturnStatus: MFnLight.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def lightDirection(self, ReturnStatus: MFnLight.MStatus): 
        '''
        lightDirection(self, ReturnStatus: MFnLight.MStatus) -> MFloatVector

        Synopsis
        -----
        Retrieves the value of the "lightDirection" attribute of a light
        node. This attribute represents the direction from the light to
        the point being shading.NOTE: This value is only valid during the
        rendering phase. See lightDirection method above for actual light
        direction.

        Returns: 
        ----- 
        The value of the "lightDirection" attribute of the light node.

        Parameters:
        -----
        ReturnStatus: MFnLight.MStatus
        	[out] -> return status


        '''
        pass

    def lightAmbient(self, ReturnStatus: MFnLight.MStatus): 
        '''
        lightAmbient(self, ReturnStatus: MFnLight.MStatus) -> bool

        Synopsis
        -----
        Retrieves the value of the "lightAmbient" attribute of a light
        node. This attribute indicates if the light has an ambient
        component.

        Returns: 
        ----- 
        The value of the "lightAmbient" attribute of the light node.

        Parameters:
        -----
        ReturnStatus: MFnLight.MStatus
        	[out] -> return status


        '''
        pass

    def lightDiffuse(self, ReturnStatus: MFnLight.MStatus): 
        '''
        lightDiffuse(self, ReturnStatus: MFnLight.MStatus) -> bool

        Synopsis
        -----
        Retrieves the value of the "lightDiffuse" attribute of a light
        node. This attribute indicates if the light has a diffuse
        component.

        Returns: 
        ----- 
        The value of the "lightDiffuse" attribute of the light node.

        Parameters:
        -----
        ReturnStatus: MFnLight.MStatus
        	[out] -> return status


        '''
        pass

    def lightSpecular(self, ReturnStatus: MFnLight.MStatus): 
        '''
        lightSpecular(self, ReturnStatus: MFnLight.MStatus) -> bool

        Synopsis
        -----
        Retrieves the value of the "lightSpecular" attribute of a light
        node. This attribute indicates if the light has a specular
        component.

        Returns: 
        ----- 
        The value of the "lightSpecular" attribute of the light node.

        Parameters:
        -----
        ReturnStatus: MFnLight.MStatus
        	[out] -> return status


        '''
        pass

class MFnLightDataAttribute:
    '''Light data attribute function set.
Function object for LightData attributes. A LightData attribute
describes a single light source, giving its direction and
intensity, as well as specifying whether or not it contributes to
the ambient, diffuse, and specular components of the shading
model.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kLightDataAttribute.Reimplemented from MFnAttribute.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnLightDataAttribute.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnLightDataAttribute".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, fullName: MString,
                        briefName: MString,
                        direction: MObject,
                        intensity: MObject,
                        ambient: MObject,
                        diffuse: MObject,
                        specular: MObject,
                        shadowFraction: MObject,
                        preShadowIntensity: MObject,
                        blindData: MObject,
                        ReturnStatus: MFnLightDataAttribute.MStatus): 
        '''
        create(self, fullName: MString,
                        briefName: MString,
                        direction: MObject,
                        intensity: MObject,
                        ambient: MObject,
                        diffuse: MObject,
                        specular: MObject,
                        shadowFraction: MObject,
                        preShadowIntensity: MObject,
                        blindData: MObject,
                        ReturnStatus: MFnLightDataAttribute.MStatus) -> MObject

        Synopsis
        -----
        Creates a LightData attribute object. The create method needs to
        be called on a per node basis. That means if you want to create
        and add the same attribute to multiple nodes, you need to call
        the create method for each node to get a unique MObject back. If
        you call create just once and add the attribute to multiple
        nodes, Maya will encounter a fatal error.

        Returns: 
        ----- 
        The newly created LightData attribute object.

        Parameters:
        -----
        fullName: MString
        	[in] -> The full name of the attribute 

        briefName: MString
        	[in] -> The brief name of the attribute 

        direction: MObject
        	[in] -> The 3Float child attribute that will represent the light direction 

        intensity: MObject
        	[in] -> The 3Float child attibute that will represent the light intensity 

        ambient: MObject
        	[in] -> The Boolean child attribute that specifies whether or not the light contributes to the ambient component of the shading model 

        diffuse: MObject
        	[in] -> The Boolean child attribute that specifies whether or not the light contributes to the diffuse component of the shading model 

        specular: MObject
        	[in] -> The Boolean child attribute that specifies whether or not the light contributes to the specular component of the shading model 

        shadowFraction: MObject
        	[in] -> The float attribute that will represent the percentage of the light that is in shadow with respect to the intersection point. 0 means the light is total visible to the intersection point and 1 means the light is total invisible to the intersection point. 

        preShadowIntensity: MObject
        	[in] -> The float attribute that will represetnt the light intensity without shadow consideration 

        blindData: MObject
        	[in] -> Attribute to hold the light's blind data. 

        ReturnStatus: MFnLightDataAttribute.MStatus
        	[out] -> Status code for the operation.


        '''
        pass

    def getDefault(self, defDirectionX: float,
                        defDirectionY: float,
                        defDirectionZ: float,
                        defIntensityR: float,
                        defIntensityG: float,
                        defIntensityB: float,
                        defAmbient: bool,
                        defDiffuse: bool,
                        defSpecular: bool,
                        defShadowFraction: float,
                        defPreShadowIntensity: float,
                        defBlindData: void): 
        '''
        getDefault(self, defDirectionX: float,
                        defDirectionY: float,
                        defDirectionZ: float,
                        defIntensityR: float,
                        defIntensityG: float,
                        defIntensityB: float,
                        defAmbient: bool,
                        defDiffuse: bool,
                        defSpecular: bool,
                        defShadowFraction: float,
                        defPreShadowIntensity: float,
                        defBlindData: void)

        Synopsis
        -----
        Gets the default value for the attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        defDirectionX: float
        	[out] -> returns the default x component of light direction 

        defDirectionY: float
        	[out] -> returns the default y component of light direction 

        defDirectionZ: float
        	[out] -> returns the default z component of light direction 

        defIntensityR: float
        	[out] -> returns the default red component of light intensity 

        defIntensityG: float
        	[out] -> returns the default green component of light intensity 

        defIntensityB: float
        	[out] -> returns the default blue component of light intensity 

        defAmbient: bool
        	[out] -> returns the default ambient flag 

        defDiffuse: bool
        	[out] -> returns the default diffuse flag 

        defSpecular: bool
        	[out] -> returns the default specular flag 

        defShadowFraction: float
        	[out] -> returns the default shadow fraction flag 

        defPreShadowIntensity: float
        	[out] -> returns the default pre shadow intensity flag 

        defBlindData: void
        	[out] -> returns the default blind data


        '''
        pass

    def setDefault(self, defDirectionX: float,
                        defDirectionY: float,
                        defDirectionZ: float,
                        defIntensityR: float,
                        defIntensityG: float,
                        defIntensityB: float,
                        defAmbient: bool,
                        defDiffuse: bool,
                        defSpecular: bool,
                        defShadowFraction: float,
                        defPreShadowIntensity: float,
                        defBlindData: void): 
        '''
        setDefault(self, defDirectionX: float,
                        defDirectionY: float,
                        defDirectionZ: float,
                        defIntensityR: float,
                        defIntensityG: float,
                        defIntensityB: float,
                        defAmbient: bool,
                        defDiffuse: bool,
                        defSpecular: bool,
                        defShadowFraction: float,
                        defPreShadowIntensity: float,
                        defBlindData: void)

        Synopsis
        -----
        Sets the default value for the attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        defDirectionX: float
        	[in] -> Default x component of light direction 

        defDirectionY: float
        	[in] -> Default y component of light direction 

        defDirectionZ: float
        	[in] -> Default z component of light direction 

        defIntensityR: float
        	[in] -> Default red component of light intensity 

        defIntensityG: float
        	[in] -> Default green component of light intensity 

        defIntensityB: float
        	[in] -> Default blue component of light intensity 

        defAmbient: bool
        	[in] -> Default ambient flag 

        defDiffuse: bool
        	[in] -> Default diffuse flag 

        defSpecular: bool
        	[in] -> Default specular flag 

        defShadowFraction: float
        	[in] -> Default shadow fraction flag 

        defPreShadowIntensity: float
        	[in] -> Default pre shadow intensity flag 

        defBlindData: void
        	[in] -> Default blind data


        '''
        pass

    def child(self, index: int,
                        ReturnStatus: MFnLightDataAttribute.MStatus): 
        '''
        child(self, index: int,
                        ReturnStatus: MFnLightDataAttribute.MStatus) -> MObject

        Synopsis
        -----
        Gets a pointer to one of the child attributes.

        Returns: 
        ----- 
        A pointer to the desired child attribute

        Parameters:
        -----
        index: int
        	[in] -> Specifies which child is desired: 

        ReturnStatus: MFnLightDataAttribute.MStatus
        	[out] -> Status code for the operation


        '''
        pass

class MFnMatrixArrayData:
    '''Matrix array function set for dependency node data.
MFnMatrixArrayData allows the creation and manipulation of
MMatrixArray data objects for use in the dependency graph.
If a user written dependency node either accepts or produces
MMatrixArrays, then this class is used to extract or create the
data that comes from or goes to other dependency graph nodes. The
MDataHandle::type() method will return kMatrixArray when data of this type is
present. To access it, the
MDataHandle::data() method is used to get an
MObject for the data and this should then be used to initialize an
instance of
MFnMatrixArrayData.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kMatrixArrayData.Reimplemented from MFnData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnMatrixArrayData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnMatrixArrayData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def length(self, ReturnStatus: MFnMatrixArrayData.MStatus): 
        '''
        length(self, ReturnStatus: MFnMatrixArrayData.MStatus) -> int

        Synopsis
        -----
        Return the number of matrices in the instance.

        Returns: 
        ----- 
        The number of matrices in the instance

        Parameters:
        -----
        ReturnStatus: MFnMatrixArrayData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    @overload
    def set(self, element: MMatrix,
                        index: int): 
        '''
        set(self, element: MMatrix,
                        index: int)

        Synopsis
        -----
        Set the matrix element at the specified index.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MMatrix
        	[in] -> the element to be set 

        index: int
        	[in] -> the index of the 


        '''
        pass

    def copyTo(self, dest: MMatrixArray): 
        '''
        copyTo(self, dest: MMatrixArray)

        Synopsis
        -----
        Copy all the matrices in the instance into the given
        MMatrixArray. No checking is done by this class on sizes, so it
        is up to the user to ensure that the given MMatrixArray is large
        enough to hold the number of MPoints in the instance.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: MMatrixArray
        	[out] -> the 


        '''
        pass

    @overload
    def set(self, array: MMatrixArray): 
        '''
        set(self, array: MMatrixArray)

        Synopsis
        -----
        Set the instance to contain the matrices defined in the given
        MMatrixArray.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MMatrixArray
        	[in] -> the 


        '''
        pass

    def array(self, ReturnStatus: MFnMatrixArrayData.MStatus): 
        '''
        array(self, ReturnStatus: MFnMatrixArrayData.MStatus) -> MMatrixArray

        Synopsis
        -----
        Get an MMatrixArray containing the matrices stored in this
        instance. The MMatrixArray returned by this method is editable,
        so any changes to the return instance also affects the MObject
        operated upon by this function set.

        Returns: 
        ----- 
        A copy of the MMatrixArray held in this instance

        Parameters:
        -----
        ReturnStatus: MFnMatrixArrayData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    @overload
    def create(self, ReturnStatus: MFnMatrixArrayData.MStatus): 
        '''
        create(self, ReturnStatus: MFnMatrixArrayData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance, and initialize
        it to contain no points.

        Returns: 
        ----- 
        The newly created MObject

        Parameters:
        -----
        ReturnStatus: MFnMatrixArrayData.MStatus
        	[out] -> kSuccess


        '''
        pass

    @overload
    def create(self, arr: MMatrixArray,
                        ReturnStatus: MFnMatrixArrayData.MStatus): 
        '''
        create(self, arr: MMatrixArray,
                        ReturnStatus: MFnMatrixArrayData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance, and initialize
        it to contain the data from the given MMatrixArray.

        Returns: 
        ----- 
        The newly created MObject

        Parameters:
        -----
        arr: MMatrixArray
        	[in] -> the data to use when initializing this instance 

        ReturnStatus: MFnMatrixArrayData.MStatus
        	[out] -> kSuccess


        '''
        pass

class MFnMatrixAttribute:
    '''Matrix attribute function set.
Function object for matrix attributes. These attributes accept
either a matrix of float values or double values depending on the
type specified to the create method.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kMatrixAttribute.Reimplemented from MFnAttribute.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnMatrixAttribute.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnMatrixAttribute".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, fullName: MString,
                        briefName: MString,
                        matrixType: MFnMatrixAttribute.Type,
                        ReturnStatus: MFnMatrixAttribute.MStatus): 
        '''
        create(self, fullName: MString,
                        briefName: MString,
                        matrixType: MFnMatrixAttribute.Type,
                        ReturnStatus: MFnMatrixAttribute.MStatus) -> MObject

        Synopsis
        -----
        Creates a matrix attribute object. The create method needs to be
        called on a per node basis. That means if you want to create and
        add the same attribute to multiple nodes, you need to call the
        create method for each node to get a unique MObject back. If you
        call create just once and add the attribute to multiple nodes,
        Maya will encounter a fatal error.

        Returns: 
        ----- 
        The newly created Matrix attribute object.

        Parameters:
        -----
        fullName: MString
        	[in] -> The full name of the attribute 

        briefName: MString
        	[in] -> The brief name of the attribute 

        matrixType: MFnMatrixAttribute.Type
        	[in] -> Whether to create a matrix of floats or doubles 

        ReturnStatus: MFnMatrixAttribute.MStatus
        	[out] -> Status code for the operation.


        '''
        pass

    @overload
    def getDefault(self, defaultArg: MMatrix): 
        '''
        getDefault(self, defaultArg: MMatrix)

        Synopsis
        -----
        Gets the default value for the attribute. Use this for getting
        the default value of a double matrix attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        defaultArg: MMatrix
        	[out] -> 


        '''
        pass

    @overload
    def getDefault(self, defaultArg: MFloatMatrix): 
        '''
        getDefault(self, defaultArg: MFloatMatrix)

        Synopsis
        -----
        Gets the default value for the attribute. Use this for getting
        the default value of a float matrix attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        defaultArg: MFloatMatrix
        	[out] -> 


        '''
        pass

    @overload
    def setDefault(self, defaultArg: MMatrix): 
        '''
        setDefault(self, defaultArg: MMatrix)

        Synopsis
        -----
        Sets the default value for the attribute. Use this for setting
        the defaults of a double matrix attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        defaultArg: MMatrix
        	[in] -> 


        '''
        pass

    @overload
    def setDefault(self, defaultArg: MFloatMatrix): 
        '''
        setDefault(self, defaultArg: MFloatMatrix)

        Synopsis
        -----
        Sets the default value for the attribute. Use this for setting
        the defaults of a float matrix attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        defaultArg: MFloatMatrix
        	[in] -> 


        '''
        pass

class Type:
    '''Matrix data type. 
    Non-functional class.  Values for this enum:
    kFloat
    kDouble
    '''

    def __init__(self):
        pass

    def kFloat(self):
        '''This is an enum of Type.
        - Description: Matrix of float values. 
        - Value: 0
        '''
        pass

    def kDouble(self):
        '''This is an enum of Type.
        - Description: Matrix of double values. 
        - Value: 1
        '''
        pass

class MFnMatrixData:
    '''Matrix function set for dependency node data.
MFnMatrixData allows the creation and manipulation of
MMatrix data objects for use in the dependency graph.
If a user written dependency node either accepts or produces
MMatrix, then this class is used to extract or create the data that
comes from or goes to other dependency graph nodes. The
MDataHandle::type method will return kMatrix when data of this type is present. To
access it, the
MDataHandle::data method is used to get an
MObject for the data and this should then be used to initialize an
instance of
MFnMatrixData.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kMatrixData.Reimplemented from MFnData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnMatrixData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnMatrixData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isTransformation(self, ReturnStatus: MFnMatrixData.MStatus): 
        '''
        isTransformation(self, ReturnStatus: MFnMatrixData.MStatus) -> bool

        Synopsis
        -----
        Determine if the matrix held in this instance is a transform
        matrix.

        Returns: 
        ----- 
        true if the instance holds a transform matrix, false otherwise

        Parameters:
        -----
        ReturnStatus: MFnMatrixData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    def transformation(self, ReturnStatus: MFnMatrixData.MStatus): 
        '''
        transformation(self, ReturnStatus: MFnMatrixData.MStatus) -> MTransformationMatrix

        Synopsis
        -----
        Return a copy of the transform matrix held in this instance. If
        the instance holds a MMatrix, this method is equivalent of
        `MTransformationMatrix{this->matrix()}`

        Returns: 
        ----- 
        A copy of the MTransformationMatrix held in this instance

        Parameters:
        -----
        ReturnStatus: MFnMatrixData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    def matrix(self, ReturnStatus: MFnMatrixData.MStatus): 
        '''
        matrix(self, ReturnStatus: MFnMatrixData.MStatus) -> const MMatrix&

        Synopsis
        -----
        Return the matrix representation of this transformation. If the
        instance holds a MTransformationMatrix, this method is equivalent
        of `this->transformation().asMatrix()`

        Returns: 
        ----- 
        A const reference to the MMatrix

        Parameters:
        -----
        ReturnStatus: MFnMatrixData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    @overload
    def set(self, transformation: MTransformationMatrix): 
        '''
        set(self, transformation: MTransformationMatrix)

        Synopsis
        -----
        Set this instance to hold a copy of the given transform matrix.

        Returns:
        -----
        None

        Parameters:
        -----
        transformation: MTransformationMatrix
        	[in] -> the 


        '''
        pass

    @overload
    def set(self, mat: MMatrix): 
        '''
        set(self, mat: MMatrix)

        Synopsis
        -----
        Set this instance to hold a copy of the given matrix.

        Returns:
        -----
        None

        Parameters:
        -----
        mat: MMatrix
        	[in] -> the 


        '''
        pass

    @overload
    def create(self, ReturnStatus: MFnMatrixData.MStatus): 
        '''
        create(self, ReturnStatus: MFnMatrixData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance and initialize
        it to the identity matrix. The result is not a transform matrix

        Returns: 
        ----- 
        The new MObject

        Parameters:
        -----
        ReturnStatus: MFnMatrixData.MStatus
        	[out] -> kSuccess


        '''
        pass

    @overload
    def create(self, mat: MMatrix,
                        ReturnStatus: MFnMatrixData.MStatus): 
        '''
        create(self, mat: MMatrix,
                        ReturnStatus: MFnMatrixData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance and initialize
        it to the given matrix. The result is not a transform matrix.

        Returns: 
        ----- 
        The new MObject

        Parameters:
        -----
        mat: MMatrix
        	[in] -> the 

        ReturnStatus: MFnMatrixData.MStatus
        	[out] -> kSuccess


        '''
        pass

    @overload
    def create(self, transformation: MTransformationMatrix,
                        ReturnStatus: MFnMatrixData.MStatus): 
        '''
        create(self, transformation: MTransformationMatrix,
                        ReturnStatus: MFnMatrixData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance and initialize
        it to the given transform matrix.

        Returns: 
        ----- 
        The new MObject

        Parameters:
        -----
        transformation: MTransformationMatrix
        	[in] -> the 

        ReturnStatus: MFnMatrixData.MStatus
        	[out] -> kSuccess


        '''
        pass

class MFnMesh:
    '''Polygonal surface function set.
 The following terms are used interchangeably:
 - they range between 0..(
numVertices()-1)
 - they range between 0..(polygonVertexCount(faceId)-1)
This function set provides access to polygonal meshes. Objects of
type
MFn::kMesh,
MFn::kMeshData, and
MFn::kMeshGeom are supported.
MFn::kMesh objects are shapes in the DAG,
MFn::kMeshGeom objects are the raw geometry that the shapes use, and
MFn::kMeshData objects are the data that is passed through dependency graph
connections.
NOTE: If the function set has been initialized with a
MFn::kMesh object then it must have geometry attached.
 Meshes are created by specifying a vertex list, a list of vertex
counts per-polygon, and a list of vertices that make up the
polygons. Edge data is also maintained for the mesh and can be
returned to the caller. The following lists are used by the
create method to construct a mesh:
There are several cases in which the create method will alter the
data passed in:
use the appropriate vertices.
 You can optionally specify texture (uv) coordinates. UV
coordinates are 2-d coordinates used for mapping textures to the
polygons of a mesh. All of the uv coordinates are stored in one
or more named UV sets. The default mesh uv list stores uv
coordinates in an array indexed from 0 to
numUVs()-1. UV's are referenced on a per-polygon per-vertex basis, so for
a polygon with 4 vertices there would be 4 uv's. The uv values
for a polygon are set by specifying the index of the uv for each
vertex of the polygon. This index is the uv's position in the
master uv array. UV's are optional so polygons do not have to
have uv values associated with them. There may be only 1 or 2
polygons in a mesh that have uv coordinates set, or all of the
polygons may have uv's. UV's can also be shared so several
different polygons may reference the same uv's. If you are
creating a UV for the first time or changing the order of the UV
then you need to set the UV using one of the setUV methods and
then assign new indices using one of the assignUV methods. It is
not necessary to call assignUV if editing the position of an
existing UV.
 You can optionally specify color per vertex information using
this class. It is possible to create and manipulate color per
vertex information using the methods available. Many of the color
per vertex methods have a default parameter: colorSet. If
unspecified, the method will operate on the current color set.
 Some of the Normals in Maya are now user-settable. If the vertex
normals are not set or locked, they are computed by maya when the
mesh changes. If set or locked, the normals remain frozen
relative to the object, unless the user unlocks them. There are 3
types of normals for a mesh:
For a cube, the list would contain 24 normals (4 vertices * 6
polygons) since the edges for a cube are hard and the per-vertex
per-polygon normals cannot be shared. For a sphere or torus,
which has smooth edges, the normals can be shared, and thus the
normal list contains the same number of normals as vertices.
MFnMesh allows you to create Blind Data types, and to create and access
mesh component level blind data, but not object level blind data.
Object level data may be assigned through the polyBlindData
command or the Blind Data Editor. However, object level blind
data is just an ordinary compound dynamic attribute directly on
the object. The parent attribute name is BlindDataNNNN where NNNN
is the blind data typeID. e.g. if your typeId is 1001 your object
will have a compound dynamic attr called BlindData1001.
 There are also three iterator classes which provide more
specific control over the vertices, edges, and polygons of a mesh
and are useful when dealing with components. See
MItMeshPolygon,
MItMeshEdge, and
MItMeshVertex.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kMesh.Reimplemented from MFnDagNode.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnMesh.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnMesh".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def create(self, numVertices: int,
                        numPolygons: int,
                        vertexArray: MFloatPointArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        create(self, numVertices: int,
                        numPolygons: int,
                        vertexArray: MFloatPointArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus) -> MObject

        Synopsis
        -----
        Creates a new polygonal mesh given an array of vertices and
        polygon connection information and sets this function set to
        operate on the new surface. This method is meant to be as
        efficient as possible and thus assumes that all the given data is
        topologically correct.The parentOrOwner argument is used to
        specify the owner of the new surface.If the parentOrOwner is
        kMeshData then the created surface will be of type kMeshGeom and
        will be returned. The parentOrOwner will become the owner of the
        new mesh.If parentOrOwner is nullptr then a new transform will be
        created and returned which will be the parent for the mesh. The
        new transform will be added to the DAG.If parentOrOwner is a DAG
        node then the new mesh will be returned and the parentOrOwner
        will become its parent.

        Returns: 
        ----- 
        If parentOrOwner is nullptr then the transform for this surface
        is returned  If parentOrOwner is a DAG object then the new
        surface shape is returned  The surface geometry is returned if
        parentOrOwner is of type kMeshData

        Parameters:
        -----
        numVertices: int
        	[in] -> number of vertices 

        numPolygons: int
        	[in] -> number of polygons 

        vertexArray: MFloatPointArray
        	[in] -> point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), (1,-1,-1), (1,-1,1), (-1,-1,1), (-1,1,-1), (-1,1,1), (1,1,1), (1,1,-1) } 

        polygonCounts: MIntArray
        	[in] -> array of vertex counts for each polygon. For example the cube would have 6 faces, each of which had 4 verts, so the polygonCounts would be {4,4,4,4,4,4}. 

        polygonConnects: MIntArray
        	[in] -> array of vertex connections for each polygon. For example, in the cube, we have 4 vertices for every face, so we list the vertices for face0, face1, etc consecutively in the array. These are specified by indexes in the vertexArray: e.g for the cube: { 0, 1, 2, 3, 4, 5, 6, 7, 3, 2, 6, 5, 0, 3, 5, 4, 0, 4, 7, 1, 1, 7, 6, 2 } 

        parentOrOwner: MObject
        	[in] -> parent of the polygon that will be created 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def create(self, numVertices: int,
                        numPolygons: int,
                        vertexArray: MPointArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray,
                        uArray: MFloatArray,
                        vArray: MFloatArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        create(self, numVertices: int,
                        numPolygons: int,
                        vertexArray: MPointArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray,
                        uArray: MFloatArray,
                        vArray: MFloatArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus) -> MObject

        Synopsis
        -----
        Creates a new polygonal mesh given an array of vertices, polygon
        connection information, UV information, and sets this function
        set to operate on the new surface. This method is meant to be as
        efficient as possible and thus assumes that all the given data is
        topologically correct.The parentOrOwner argument is used to
        specify the owner of the new surface.If the parentOrOwner is
        kMeshData then the created surface will be of type kMeshGeom and
        will be returned. The parentOrOwner will become the owner of the
        new mesh.If parentOrOwner is nullptr then a new transform will be
        created and returned which will be the parent for the mesh. The
        new transform will be added to the DAG.If parentOrOwner is a DAG
        node then the new mesh will be returned and the parentOrOwner
        will become its parent.The uv arrays must be of equal size. After
        using this method to create the mesh and the UV values, you can
        call assignUVs to assign the corresponding UV ids to the
        geometry.

        Returns: 
        ----- 
        If parentOrOwner is nullptr then the transform for this surface
        is returned  If parentOrOwner is a DAG object then the new
        surface shape is returned  The surface geometry is returned if
        parentOrOwner is of type kMeshData

        Parameters:
        -----
        numVertices: int
        	[in] -> number of vertices 

        numPolygons: int
        	[in] -> number of polygons 

        vertexArray: MPointArray
        	[in] -> point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), (1,-1,-1), (1,-1,1), (-1,-1,1), (-1,1,-1), (-1,1,1), (1,1,1), (1,1,-1) } 

        polygonCounts: MIntArray
        	[in] -> array of vertex counts for each polygon. For example the cube would have 6 faces, each of which had 4 verts, so the polygonCounts would be {4,4,4,4,4,4}. 

        polygonConnects: MIntArray
        	[in] -> array of vertex connections for each polygon. For example, in the cube, we have 4 vertices for every face, so we list the vertices for face0, face1, etc consecutively in the array. These are specified by indexes in the vertexArray: e.g for the cube: { 0, 1, 2, 3, 4, 5, 6, 7, 3, 2, 6, 5, 0, 3, 5, 4,0, 4, 7, 1, 1, 7, 6, 2 } 

        uArray: MFloatArray
        	[in] -> The array of u values to be set 

        vArray: MFloatArray
        	[in] -> The array of v values to be set 

        parentOrOwner: MObject
        	[in] -> parent of the polygon that will be created 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def create(self, numVertices: int,
                        numPolygons: int,
                        vertexArray: MPointArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray,
                        storeDoubles: bool,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        create(self, numVertices: int,
                        numPolygons: int,
                        vertexArray: MPointArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray,
                        storeDoubles: bool,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus) -> MObject

        Synopsis
        -----
        Creates a new polygonal mesh given an array of vertices and
        polygon connection information and sets this function set to
        operate on the new surface. This method is meant to be as
        efficient as possible and thus assumes that all the given data is
        topologically correct.The parentOrOwner argument is used to
        specify the owner of the new surface.If the parentOrOwner is
        kMeshData then the created surface will be of type kMeshGeom and
        will be returned. The parentOrOwner will become the owner of the
        new mesh.If parentOrOwner is nullptr then a new transform will be
        created and returned which will be the parent for the mesh. The
        new transform will be added to the DAG.If parentOrOwner is a DAG
        node then the new mesh will be returned and the parentOrOwner
        will become its parent.

        Returns: 
        ----- 
        If parentOrOwner is nullptr then the transform for this surface
        is returned  If parentOrOwner is a DAG object then the new
        surface shape is returned  The surface geometry is returned if
        parentOrOwner is of type kMeshData

        Parameters:
        -----
        numVertices: int
        	[in] -> number of vertices 

        numPolygons: int
        	[in] -> number of polygons 

        vertexArray: MPointArray
        	[in] -> point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), (1,-1,-1), (1,-1,1), (-1,-1,1), (-1,1,-1), (-1,1,1), (1,1,1), (1,1,-1) } 

        polygonCounts: MIntArray
        	[in] -> array of vertex counts for each polygon. For example the cube would have 6 faces, each of which had 4 verts, so the polygonCounts would be {4,4,4,4,4,4}. 

        polygonConnects: MIntArray
        	[in] -> array of vertex connections for each polygon. For example, in the cube, we have 4 vertices for every face, so we list the vertices for face0, face1, etc consecutively in the array. These are specified by indexes in the vertexArray: e.g for the cube: { 0, 1, 2, 3, 4, 5, 6, 7, 3, 2, 6, 5, 0, 3, 5, 4,0, 4, 7, 1, 1, 7, 6, 2 } 

        storeDoubles: bool
        	[in] -> Whether to store the vertex data at double precision internally. 

        parentOrOwner: MObject
        	[in] -> parent of the polygon that will be created 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def create(self, numVertices: int,
                        numPolygons: int,
                        vertexArray: MFloatPointArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray,
                        uArray: MFloatArray,
                        vArray: MFloatArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        create(self, numVertices: int,
                        numPolygons: int,
                        vertexArray: MFloatPointArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray,
                        uArray: MFloatArray,
                        vArray: MFloatArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus) -> MObject

        Synopsis
        -----
        Creates a new polygonal mesh given an array of vertices, polygon
        connection information, UV information, and sets this function
        set to operate on the new surface. This method is meant to be as
        efficient as possible and thus assumes that all the given data is
        topologically correct.The parentOrOwner argument is used to
        specify the owner of the new surface.If the parentOrOwner is
        kMeshData then the created surface will be of type kMeshGeom and
        will be returned. The parentOrOwner will become the owner of the
        new mesh.If parentOrOwner is nullptr then a new transform will be
        created and returned which will be the parent for the mesh. The
        new transform will be added to the DAG.If parentOrOwner is a DAG
        node then the new mesh will be returned and the parentOrOwner
        will become its parent.The uv arrays must be of equal size. After
        using this method to create the mesh and the UV values, you can
        call assignUVs to assign the corresponding UV ids to the
        geometry.

        Returns: 
        ----- 
        If parentOrOwner is nullptr then the transform for this surface
        is returned  If parentOrOwner is a DAG object then the new
        surface shape is returned  The surface geometry is returned if
        parentOrOwner is of type kMeshData

        Parameters:
        -----
        numVertices: int
        	[in] -> number of vertices 

        numPolygons: int
        	[in] -> number of polygons 

        vertexArray: MFloatPointArray
        	[in] -> point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), (1,-1,-1), (1,-1,1), (-1,-1,1), (-1,1,-1), (-1,1,1), (1,1,1), (1,1,-1) } 

        polygonCounts: MIntArray
        	[in] -> array of vertex counts for each polygon. For example the cube would have 6 faces, each of which had 4 verts, so the polygonCounts would be {4,4,4,4,4,4}. 

        polygonConnects: MIntArray
        	[in] -> array of vertex connections for each polygon. For example, in the cube, we have 4 vertices for every face, so we list the vertices for face0, face1, etc consecutively in the array. These are specified by indexes in the vertexArray: e.g for the cube: { 0, 1, 2, 3, 4, 5, 6, 7, 3, 2, 6, 5, 0, 3, 5, 4,0, 4, 7, 1, 1, 7, 6, 2 } 

        uArray: MFloatArray
        	[in] -> The array of u values to be set 

        vArray: MFloatArray
        	[in] -> The array of v values to be set 

        parentOrOwner: MObject
        	[in] -> parent of the polygon that will be created 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def create(self, vertexArray: MFloatPointArray,
                        edges: MIntArray,
                        edgeConnectsCount: MIntArray,
                        edgeFaceConnects: MIntArray,
                        edgeFaceDesc: MIntArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        create(self, vertexArray: MFloatPointArray,
                        edges: MIntArray,
                        edgeConnectsCount: MIntArray,
                        edgeFaceConnects: MIntArray,
                        edgeFaceDesc: MIntArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus) -> MObject

        Synopsis
        -----
        Creates a new polygonal mesh given an array of vertices, edge
        information, polygon connection information, UV and sets this
        function set to operate on the new surface. This method is meant
        to be as efficient as possible and thus assumes that all the
        given data is topologically correct.The parentOrOwner argument is
        used to specify the owner of the new surface.If the parentOrOwner
        is kMeshData then the created surface will be of type kMeshGeom
        and will be returned. The parentOrOwner will become the owner of
        the new mesh.If parentOrOwner is nullptr then a new transform
        will be created and returned which will be the parent for the
        mesh. The new transform will be added to the DAG.If parentOrOwner
        is a DAG node then the new mesh will be returned and the
        parentOrOwner will become its parent.

        Returns: 
        ----- 
        If parentOrOwner is nullptr then the transform for this surface
        is returned  If parentOrOwner is a DAG object then the new
        surface shape is returned  The surface geometry is returned if
        parentOrOwner is of type kMeshData

        Parameters:
        -----
        vertexArray: MFloatPointArray
        	[in] -> point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), (1,-1,-1), (1,-1,1), (-1,-1,1), (-1,1,-1), (-1,1,1), (1,1,1), (1,1,-1) } 

        edges: MIntArray
        	[in] -> array of vertex indices that define the edges of the geometry. For example, the cube { (0,1), (1,2), (2,3), (3,0), (4,7), (7,6), (6,5), (5,4), (0,4), (1,7), (2,6), (3,5) } 

        edgeConnectsCount: MIntArray
        	[in] -> array of edge counts for each polygon. For example the cube would have 6 faces, each of which had 4 edges, so the edgeConnectsCount would be {4,4,4,4,4,4}. 

        edgeFaceConnects: MIntArray
        	[in] -> array of edge connections for each polygon. For example, in the cube, we have 4 edges for every face, so we list the edges for face0, face1, etc consecutively in the array. These are specified by indexes in the edges array: e.g for the cube: { 0, 1, 2, 3, 1, 10, 5, 9, 2, 11, 6, 10, 3, 8, 7, 11, 0, 9, 4, 8, 4, 5, 6, 7 } 

        edgeFaceDesc: MIntArray
        	[in] -> array of edge direction populated by members of MFnMesh::MEdgeDirection defining if a given edge for a polygon is intended to be in its normal direction, or in the reverse direction. Example, for the cube: { 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0} 

        parentOrOwner: MObject
        	[in] -> parent of the polygon that will be created 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def create(self, vertexArray: MPointArray,
                        edges: MIntArray,
                        edgeConnectsCount: MIntArray,
                        edgeFaceConnects: MIntArray,
                        edgeFaceDesc: MIntArray,
                        storeDoubles: bool,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        create(self, vertexArray: MPointArray,
                        edges: MIntArray,
                        edgeConnectsCount: MIntArray,
                        edgeFaceConnects: MIntArray,
                        edgeFaceDesc: MIntArray,
                        storeDoubles: bool,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus) -> MObject

        Synopsis
        -----
        Introduced in 2019.0 Creates a new polygonal mesh given an array
        of vertices, edge information, polygon connection information, UV
        and sets this function set to operate on the new surface.This
        method is meant to be as efficient as possible and thus assumes
        that all the given data is topologically correct.The
        parentOrOwner argument is used to specify the owner of the new
        surface.If the parentOrOwner is kMeshData then the created
        surface will be of type kMeshGeom and will be returned. The
        parentOrOwner will become the owner of the new mesh.If
        parentOrOwner is nullptr then a new transform will be created and
        returned which will be the parent for the mesh. The new transform
        will be added to the DAG.If parentOrOwner is a DAG node then the
        new mesh will be returned and the parentOrOwner will become its
        parent.

        Returns: 
        ----- 
        If parentOrOwner is nullptr then the transform for this surface
        is returned  If parentOrOwner is a DAG object then the new
        surface shape is returned  The surface geometry is returned if
        parentOrOwner is of type kMeshData

        Parameters:
        -----
        vertexArray: MPointArray
        	[in] -> point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), (1,-1,-1), (1,-1,1), (-1,-1,1), (-1,1,-1), (-1,1,1), (1,1,1), (1,1,-1) } 

        edges: MIntArray
        	[in] -> array of vertex indices that define the edges of the geometry. For example, the cube { (0,1), (1,2), (2,3), (3,0), (4,7), (7,6), (6,5), (5,4), (0,4), (1,7), (2,6), (3,5) } 

        edgeConnectsCount: MIntArray
        	[in] -> array of edge counts for each polygon. For example the cube would have 6 faces, each of which had 4 edges, so the edgeConnectsCount would be {4,4,4,4,4,4}. 

        edgeFaceConnects: MIntArray
        	[in] -> array of edge connections for each polygon. For example, in the cube, we have 4 edges for every face, so we list the edges for face0, face1, etc consecutively in the array. These are specified by indexes in the edges array: e.g for the cube: { 0, 1, 2, 3, 1, 10, 5, 9, 2, 11, 6, 10, 3, 8, 7, 11, 0, 9, 4, 8, 4, 5, 6, 7 } 

        edgeFaceDesc: MIntArray
        	[in] -> array of edge direction populated by members of MFnMesh::MEdgeDirection defining if a given edge for a polygon is intended to be in its normal direction, or in the reverse direction. Example, for the cube: { 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0} 

        storeDoubles: bool
        	[in] -> Whether to store the vertex data at double precision internally. 

        parentOrOwner: MObject
        	[in] -> parent of the polygon that will be created 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def generateSmoothMesh(self, parentOrOwner: MObject,
                        options: MMeshSmoothOptions,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        generateSmoothMesh(self, parentOrOwner: MObject,
                        options: MMeshSmoothOptions,
                        ReturnStatus: MFnMesh.MStatus) -> MObject

        Synopsis
        -----
        Creates a new polygonal mesh using either the Smooth Mesh Preview
        attributes of this mesh or a set of options specified in an
        MMeshSmoothOptions object. Unlike the MFnMesh::create functions,
        this function does not set this function set to operate on the
        new surface.The parentOrOwner argument is used to specify the
        owner of the new surface.If the parentOrOwner is kMeshData then
        the created surface will be of type kMeshGeom and will be
        returned. The parentOrOwner will become the owner of the new
        mesh.If parentOrOwner is nullptr then a new transform will be
        created and returned which will be the parent for the mesh. The
        new transform will be added to the DAG.If parentOrOwner is a DAG
        node then the new mesh will be returned and the parentOrOwner
        will become its parent.

        Returns: 
        ----- 
        If parentOrOwner is nullptr then the transform for this surface
        is returned  If parentOrOwner is a DAG object then the new
        surface shape is returned  The surface geometry is returned if
        parentOrOwner is of type kMeshData

        Parameters:
        -----
        parentOrOwner: MObject
        	[in] -> parent of the polygon that will be created 

        options: MMeshSmoothOptions
        	[in] -> Set of options to use when generating the smoothed mesh 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def getSmoothMeshDisplayOptions(self, options: MMeshSmoothOptions): 
        '''
        getSmoothMeshDisplayOptions(self, options: MMeshSmoothOptions)

        Synopsis
        -----
        Retrieve the current display smoothing options for the mesh.

        Returns:
        -----
        None

        Parameters:
        -----
        options: MMeshSmoothOptions
        	[out] -> storge for the options


        '''
        pass

    def setSmoothMeshDisplayOptions(self, options: MMeshSmoothOptions): 
        '''
        setSmoothMeshDisplayOptions(self, options: MMeshSmoothOptions)

        Synopsis
        -----
        Sets the current display smoothing options for the mesh.

        Returns:
        -----
        None

        Parameters:
        -----
        options: MMeshSmoothOptions
        	[in] -> Options to set


        '''
        pass

    @overload
    def addPolygon(self, vertexArray: MPointArray,
                        mergeVertices: bool,
                        pointTolerance: double,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        addPolygon(self, vertexArray: MPointArray,
                        mergeVertices: bool,
                        pointTolerance: double,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus) -> MObject

        Synopsis
        -----
        Adds a new polygon to this polygonal mesh. If there is no current
        geometry then a new polygonal mesh is created and parentOrOwner
        is used to specify the owner of the new surface. If parentOrOwner
        is nullptr or a DAG parent is specified, then a new transform
        will be created in the DAG and returned. If the parentOrOwner is
        kMeshData then the new surface will become its data and the
        geometry will be returned.If we are adding to an existing
        polygonal mesh then parentOrOwner is ignored and the geometry is
        returned.

        Returns: 
        ----- 
        The transform if one is created, otherwise the geometry.

        Parameters:
        -----
        vertexArray: MPointArray
        	[in] -> array of ordered vertices that make up the polygon 

        mergeVertices: bool
        	[in] -> If true then if a vertex falls within pointTolerance of an existing vertex then the existing vertex is reused. 

        pointTolerance: double
        	[in] -> specifies how close verticies have to be to before they are 

        parentOrOwner: MObject
        	[in] -> the DAG parent or kMeshData the new surface will belong to 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> status code


        '''
        pass

    @overload
    def addPolygon(self, vertexArray: MPointArray,
                        faceIndex: int,
                        mergeVertices: bool,
                        pointTolerance: double,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        addPolygon(self, vertexArray: MPointArray,
                        faceIndex: int,
                        mergeVertices: bool,
                        pointTolerance: double,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus) -> MObject

        Synopsis
        -----
        Adds a new polygon to this polygonal mesh. Return an index of the
        created polygon.If there is no current geometry then a new
        polygonal mesh is created and parentOrOwner is used to specify
        the owner of the new surface. If parentOrOwner is nullptr or a
        DAG parent is specified, then a new transform will be created in
        the DAG and returned. If the parentOrOwner is kMeshData then the
        new surface will become its data and the geometry will be
        returned.If we are adding to an existing polygonal mesh then
        parentOrOwner is ignored and the geometry is returned.

        Returns: 
        ----- 
        The transform if one is created, otherwise the geometry.

        Parameters:
        -----
        vertexArray: MPointArray
        	[in] -> Array of ordered vertices that make up the polygon. 

        faceIndex: int
        	[out] -> Index of the newly added polygon. 

        mergeVertices: bool
        	[in] -> If true then if a vertex falls within pointTolerance of an existing vertex then the existing vertex is reused. 

        pointTolerance: double
        	[in] -> Specifies how close verticies have to be to before they are 

        parentOrOwner: MObject
        	[in] -> The DAG parent or kMeshData the new surface will belong to. 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code.


        '''
        pass

    @overload
    def addPolygon(self, vertexArray: MPointArray,
                        loopCounts: MIntArray,
                        faceIndex: int,
                        mergeVertices: bool,
                        pointTolerance: double,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        addPolygon(self, vertexArray: MPointArray,
                        loopCounts: MIntArray,
                        faceIndex: int,
                        mergeVertices: bool,
                        pointTolerance: double,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus) -> MObject

        Synopsis
        -----
        Adds a new polygon to this polygonal mesh. Return an index of the
        created polygon.This version of addPolygon() allows for the
        creation of faces with holes. The loopCounts argument is used for
        this. loopCounts is an array of vertex counts. The first entry
        gives the count of vertices that make up the exterior of the
        polygon (using that many entries in vertexArray). The following
        entries in loopCounts give the count of vertices that make up
        each hole, using the following entries in vertexArray.Therefore
        the sum of the entries of loopCounts should equal the total
        length of vertexArray.If loopCounts is an empty array, it is
        treated as if it had one entry equal to the length of vertexArray
        i.e. the face has no holes.Note that holes should normally be
        specified with the opposite winding order to the exterior
        polygon.If there is no current geometry then a new polygonal mesh
        is created and parentOrOwner is used to specify the owner of the
        new surface. If parentOrOwner is nullptr or a DAG parent is
        specified, then a new transform will be created in the DAG and
        returned. If the parentOrOwner is kMeshData then the new surface
        will become its data and the geometry will be returned.If we are
        adding to an existing polygonal mesh then parentOrOwner is
        ignored and the geometry is returned.

        Returns: 
        ----- 
        The transform if one is created, otherwise the geometry.

        Parameters:
        -----
        vertexArray: MPointArray
        	[in] -> Array of ordered vertices that make up the polygon. 

        loopCounts: MIntArray
        	[in] -> Array of vertex loop counts. 

        faceIndex: int
        	[out] -> Index of the newly added polygon. 

        mergeVertices: bool
        	[in] -> If true then if a vertex falls within pointTolerance of an existing vertex then the existing vertex is reused. 

        pointTolerance: double
        	[in] -> Specifies how close verticies have to be to before they are 

        parentOrOwner: MObject
        	[in] -> The DAG parent or kMeshData the new surface will belong to. 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code.


        '''
        pass

    def addHoles(self, faceIndex: int,
                        vertexArray: MPointArray,
                        loopCounts: MIntArray,
                        mergeVertices: bool,
                        pointTolerance: double): 
        '''
        addHoles(self, faceIndex: int,
                        vertexArray: MPointArray,
                        loopCounts: MIntArray,
                        mergeVertices: bool,
                        pointTolerance: double)

        Synopsis
        -----
        Adds holes to a mesh polygon. loopCounts is an array of vertex
        counts. The first entry gives the count of vertices that make up
        the first hole to add to the polygon (using that many entries in
        vertexArray). The following entries in loopCounts give the count
        of vertices that make up each remaining hole, using the following
        entries in vertexArray.Therefore the sum of the entries of
        loopCounts should equal the total length of vertexArray.Note that
        holes should normally be specified with the opposite winding
        order to the exterior polygon.

        Returns:
        -----
        None

        Parameters:
        -----
        faceIndex: int
        	[in] -> Index of the face to which to add holes. 

        vertexArray: MPointArray
        	[in] -> Array of ordered vertices that make up the polygon. 

        loopCounts: MIntArray
        	[in] -> Array of vertex loop counts. 

        mergeVertices: bool
        	[in] -> If true then if a vertex falls within pointTolerance of an existing vertex then the existing vertex is reused. 

        pointTolerance: double
        	[in] -> Specifies how close verticies have to be to before they are 


        '''
        pass

    def deleteFace(self, faceId: int,
                        modifier: MDGModifier): 
        '''
        deleteFace(self, faceId: int,
                        modifier: MDGModifier)

        Synopsis
        -----
        Delete this face. The method will return failure if an attempt is
        made to delete the last polygonal face in the object.

        Returns:
        -----
        None

        Parameters:
        -----
        faceId: int
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 


        '''
        pass

    def deleteEdge(self, edgeId: int,
                        modifier: MDGModifier): 
        '''
        deleteEdge(self, edgeId: int,
                        modifier: MDGModifier)

        Synopsis
        -----
        Delete this edge.

        Returns:
        -----
        None

        Parameters:
        -----
        edgeId: int
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 


        '''
        pass

    def deleteVertex(self, vertexId: int,
                        modifier: MDGModifier): 
        '''
        deleteVertex(self, vertexId: int,
                        modifier: MDGModifier)

        Synopsis
        -----
        Delete this vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexId: int
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 


        '''
        pass

    def split(self, placements: MIntArray,
                        edgeList: MIntArray,
                        edgeFactors: MFloatArray,
                        internalPoints: MFloatPointArray): 
        '''
        split(self, placements: MIntArray,
                        edgeList: MIntArray,
                        edgeFactors: MFloatArray,
                        internalPoints: MFloatPointArray)

        Synopsis
        -----
        This function splits a set of edges and faces in a continuous
        manner. The elements of the placements array must be elements of
        the SplitPlacement enumeration. For each SplitPlacement::kOnEdge
        element in the placements array, an equivalent edge ID and factor
        must be included in the edgeList and edgeFactors arrays.
        Similarly for SplitPlacement::kInternalPoint elements and the
        internalPoints array. The equivalent elements must be in the same
        order in all three arrays so that the first
        SplitPlacement::kOnEdge element in the placements array maps to
        the first elements in the edgeList and edgeFactors arrays. If one
        of the vertices cannot be created, the whole algorithm fails. The
        same edge cannot be split more than once.The split must also
        start and end on an edge. This means that the first and last
        elements in the placements array must be SplitPlacement::kOnEdge
        values. If the placements array does not start and end on an edge
        then the code will still succeed but the mesh will not be
        split.NOTE: the algorithm used by this method is the same as the
        polySplit command and has similar limitations.

        Returns:
        -----
        None

        Parameters:
        -----
        placements: MIntArray
        	[in] -> array that contains elements of the SplitPlacement enumeration. They represent where to place the new vertices for the split. 

        edgeList: MIntArray
        	[in] -> array of edge IDs to be split, in order of their appearance in the split. There must be as many elements in this array as there are SplitPlacement::kOnEdge elements in the placements array. 

        edgeFactors: MFloatArray
        	[in] -> array of factors in the range [0,1] that represent how far along each edge must the split be done. This array must have the same number of elements as the edgeList array. 

        internalPoints: MFloatPointArray
        	[in] -> array of positions for the vertices that will be added inside existing faces. There must be as many elements in this array as there are SplitPlacement::kInternalPoint elements in the placements array. This array can be empty. Internal points should be specified on the face between the previous edge id and the next edge id.


        '''
        pass

    def subdivideFaces(self, faceList: MIntArray,
                        divisionCount: int): 
        '''
        subdivideFaces(self, faceList: MIntArray,
                        divisionCount: int)

        Synopsis
        -----
        This function subdivides multiple faces. This method only accepts
        faces that are three of four-sided. The operation adds a vertex
        in the middle of each given face and connects it to the middle of
        every edge in the given face. This results in three or four new
        faces for each original face.

        Returns:
        -----
        None

        Parameters:
        -----
        faceList: MIntArray
        	[in] -> array of face IDs to subdivide 

        divisionCount: int
        	[in] -> number of subsequent subdivisions to do


        '''
        pass

    def subdivideEdges(self, edgeList: MIntArray,
                        divisionCount: int): 
        '''
        subdivideEdges(self, edgeList: MIntArray,
                        divisionCount: int)

        Synopsis
        -----
        This function subdivides edges at regular intervals. The
        divisionCount argument is the number of subdivisions per edges
        and represents the number of new vertices created on each
        edge.For example, a divisionCount of 2 will add a new vertex on
        every edge in the edgeList 33% along the edges and a new vertex
        at 67% along the edges.

        Returns:
        -----
        None

        Parameters:
        -----
        edgeList: MIntArray
        	[in] -> array of edge component IDs to be subdivided 

        divisionCount: int
        	[in] -> number of subsequent subdivisions to do


        '''
        pass

    def extrudeFaces(self, faceList: MIntArray,
                        extrusionCount: int,
                        translation: MFloatVector,
                        extrudeTogether: bool,
                        thickness: float,
                        offset: float): 
        '''
        extrudeFaces(self, faceList: MIntArray,
                        extrusionCount: int,
                        translation: MFloatVector,
                        extrudeTogether: bool,
                        thickness: float,
                        offset: float)

        Synopsis
        -----
        This function extrudes a set of faces. The resulting mesh will
        have extra parallelograms coming out of the edges of the given
        polygons going to the new extruded edges. The extrusionCount
        argument is the number of subsequent extrusions per polygon and
        represents the number of faces that will be created for each edge
        of the polygons in the list.The difference between using
        thickness or offset instead of providing a vector with the
        translation variable is that the translation will be applied to
        each vertex in the extrusion along its local direction. This can
        result in vertices being moved the same distance, but the angles
        between the original components are not maintained so the overall
        shape is not the same. Both the thickness and offset variables
        will attempt to move the components a distance that will maintain
        angles between edges at the border of the extrusion.

        Returns:
        -----
        None

        Parameters:
        -----
        faceList: MIntArray
        	[in] -> array of face component IDs to be extruded 

        extrusionCount: int
        	[in] -> number of subsequent extrusions to do 

        translation: MFloatVector
        	[in] -> translation vector to apply to the extruded elements. This is a world-space translation. Use nullptr if not required. 

        extrudeTogether: bool
        	[in] -> sets whether the components should be extruded individually or together, as if one complex component was being extruded. 

        thickness: float
        	[in] -> Faces are moved outwards this distance from their original position to give the object a consistent thickness. 

        offset: float
        	[in] -> Faces are moved this distance towards the inside of the face.


        '''
        pass

    def extrudeEdges(self, edgeList: MIntArray,
                        extrusionCount: int,
                        translation: MFloatVector,
                        extrudeTogether: bool,
                        thickness: float,
                        offset: float): 
        '''
        extrudeEdges(self, edgeList: MIntArray,
                        extrusionCount: int,
                        translation: MFloatVector,
                        extrudeTogether: bool,
                        thickness: float,
                        offset: float)

        Synopsis
        -----
        This function extrudes edges. The resulting mesh will have extra
        parallelograms coming out of the given edges and going to the new
        extruded edges. The extrusionCount argument is the number of
        subsequent extrusions per edges and represents the number of
        polygons that will be created from each given edge to the
        extruded edges.The difference between using thickness or offset
        instead of providing a vector with the translation variable is
        that the translation will be applied to each vertex in the
        extrusion along its local direction. This can result in vertices
        being moved the same distance, but the angles between the
        original components are not maintained so the overall shape is
        not the same. Both the thickness and offset variables will
        attempt to move the components a distance that will maintain
        angles between edges at the border of the extrusion.

        Returns:
        -----
        None

        Parameters:
        -----
        edgeList: MIntArray
        	[in] -> array of edge component IDs to be extruded 

        extrusionCount: int
        	[in] -> number of subsequent extrusions to do 

        translation: MFloatVector
        	[in] -> translation vector to apply to the extruded elements. This is a world-space translation. Use nullptr if not required. 

        extrudeTogether: bool
        	[in] -> sets whether the components should be extruded individually or together, as if one complex component was being extruded. 

        thickness: float
        	[in] -> Edges are moved this distance in the direction of the connected face normals. original position to give the object a consistent thickmess. 

        offset: float
        	[in] -> Edges are moved this distance in the opposite direction of the edge.


        '''
        pass

    def duplicateFaces(self, faceList: MIntArray,
                        translation: MFloatVector): 
        '''
        duplicateFaces(self, faceList: MIntArray,
                        translation: MFloatVector)

        Synopsis
        -----
        This function duplicates a set of faces and detaches them from
        the rest of the mesh. The resulting mesh will contain one more
        independant piece of geometry.

        Returns:
        -----
        None

        Parameters:
        -----
        faceList: MIntArray
        	[in] -> array of face component IDs to be duplicated 

        translation: MFloatVector
        	[in] -> translation vector to apply to the duplicated elements. This is a world-space translation. Use nullptr if not required.


        '''
        pass

    def extractFaces(self, faceList: MIntArray,
                        translation: MFloatVector): 
        '''
        extractFaces(self, faceList: MIntArray,
                        translation: MFloatVector)

        Synopsis
        -----
        This function detaches a set of faces from the mesh so that the
        resulting mesh will contain one more independant piece of
        geometry and leaves a hole where the faces use to be.

        Returns:
        -----
        None

        Parameters:
        -----
        faceList: MIntArray
        	[in] -> array of face component IDs to be extracted 

        translation: MFloatVector
        	[in] -> translation vector to apply to the extracted elements. This is a world-space translation. Use nullptr if not required.


        '''
        pass

    def collapseFaces(self, faceList: MIntArray): 
        '''
        collapseFaces(self, faceList: MIntArray)

        Synopsis
        -----
        This function collapse faces into vertices. Non-adjacent faces
        will be collapsed individually so that each pieces of adjacent
        faces turn into one vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        faceList: MIntArray
        	[in] -> array of face component IDs to be collapsed


        '''
        pass

    def collapseEdges(self, edgeList: MIntArray): 
        '''
        collapseEdges(self, edgeList: MIntArray)

        Synopsis
        -----
        This function collapse edges into vertices. The two vertices that
        create each given edge are replaced in turn by one vertex placed
        at the average of the two initial vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        edgeList: MIntArray
        	[in] -> array of edge component IDs to be collapsed


        '''
        pass

    def numVertices(self, ReturnStatus: MFnMesh.MStatus): 
        '''
        numVertices(self, ReturnStatus: MFnMesh.MStatus) -> int

        Synopsis
        -----
        Returns the number of vertices in the vertex list for this mesh.
        This number will be the same as the length of the vertex array
        returned with the getPoints method.

        Returns: 
        ----- 
        The number of vertices of the mesh

        Parameters:
        -----
        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def numEdges(self, ReturnStatus: MFnMesh.MStatus): 
        '''
        numEdges(self, ReturnStatus: MFnMesh.MStatus) -> int

        Synopsis
        -----
        Returns the number of edges for this mesh.

        Returns: 
        ----- 
        The number of edges for this mesh

        Parameters:
        -----
        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def numPolygons(self, ReturnStatus: MFnMesh.MStatus): 
        '''
        numPolygons(self, ReturnStatus: MFnMesh.MStatus) -> int

        Synopsis
        -----
        Returns the number of polygons for this mesh.

        Returns: 
        ----- 
        The number of polygons for this mesh

        Parameters:
        -----
        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def numFaceVertices(self, ReturnStatus: MFnMesh.MStatus): 
        '''
        numFaceVertices(self, ReturnStatus: MFnMesh.MStatus) -> int

        Synopsis
        -----
        Returns the number of face-vertices for this mesh.

        Returns: 
        ----- 
        The number of face-vertices for this mesh

        Parameters:
        -----
        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def polygonVertexCount(self, polygonId: int,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        polygonVertexCount(self, polygonId: int,
                        ReturnStatus: MFnMesh.MStatus) -> int

        Synopsis
        -----
        Returns the number of vertices for the specified polygon.

        Returns: 
        ----- 
        The number of vertices for the specified polygon

        Parameters:
        -----
        polygonId: int
        	[in] -> The polygon index 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def numUVs(self, ReturnStatus: MFnMesh.MStatus): 
        '''
        numUVs(self, ReturnStatus: MFnMesh.MStatus) -> int

        Synopsis
        -----
        Returns the number of texture (uv) coordinates for this mesh. The
        uv's are stored in a list which is referenced by polygons
        requiring textures on a per-polygon per-vertex basis. This method
        returns the number of elements in this list.

        Returns: 
        ----- 
        The number of texture coordinates

        Parameters:
        -----
        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def numUVs(self, uvSet: MString,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        numUVs(self, uvSet: MString,
                        ReturnStatus: MFnMesh.MStatus) -> int

        Synopsis
        -----
        Returns the number of texture (uv) coordinates for this mesh. The
        uv's are stored in a list which is referenced by polygons
        requiring textures on a per-polygon per-vertex basis. This method
        returns the number of elements in this list.

        Returns: 
        ----- 
        The number of texture coordinates

        Parameters:
        -----
        uvSet: MString
        	[in] -> UV set to work with 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def numColors(self, ReturnStatus: MFnMesh.MStatus): 
        '''
        numColors(self, ReturnStatus: MFnMesh.MStatus) -> int

        Synopsis
        -----
        Returns the number of (vertex) color for this mesh. The color are
        stored in a list which is referenced by polygons requiring color
        on a per-polygon per-vertex basis. This method returns the number
        of elements in this list.

        Returns: 
        ----- 
        The number of colors

        Parameters:
        -----
        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def numColors(self, colorSet: MString,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        numColors(self, colorSet: MString,
                        ReturnStatus: MFnMesh.MStatus) -> int

        Synopsis
        -----
        Returns the number of colors (vertex data) for this mesh. The
        colors are stored in a list which is referenced by polygons
        requiring textures on a per-polygon per-vertex basis. This method
        returns the number of elements in this list.

        Returns: 
        ----- 
        The number of colors

        Parameters:
        -----
        colorSet: MString
        	[in] -> Color set to work with 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def numNormals(self, ReturnStatus: MFnMesh.MStatus): 
        '''
        numNormals(self, ReturnStatus: MFnMesh.MStatus) -> int

        Synopsis
        -----
        Returns the number of per-polygon per-vertex normals for this
        mesh. This number will correspond to the length of the normal
        array returned by getNormals( normalArray, space ).This method is
        not threadsafe.

        Returns: 
        ----- 
        The number of per-polygon per-vertex normals

        Parameters:
        -----
        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def hasColorChannels(self, colorSet: MString,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        hasColorChannels(self, colorSet: MString,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        This method returns if the color set has RGB components.

        Returns: 
        ----- 
        true The color set has RGB components  false The color set
        doesn't have RGB components

        Parameters:
        -----
        colorSet: MString
        	[in] -> Color set to work with 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def hasAlphaChannels(self, colorSet: MString,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        hasAlphaChannels(self, colorSet: MString,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        This method returns true if the color set has Alpha component.

        Returns: 
        ----- 
        true The color set has Alpha component  false The color set
        doesn't have Alpha component

        Parameters:
        -----
        colorSet: MString
        	[in] -> Color set to work with 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def getColorRepresentation(self, colorSet: MString,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        getColorRepresentation(self, colorSet: MString,
                        ReturnStatus: MFnMesh.MStatus) -> MFnMesh.MFnMesh

        Synopsis
        -----
        This method returns the color representation (RGB/RGBA/A) of a
        color set.

        Returns: 
        ----- 
        kAlpha The color set contains only Alpha component  kRGB The
        color set contains only RGB components  kRGBA The color set
        contains RGBA components

        Parameters:
        -----
        colorSet: MString
        	[in] -> Color set to work with 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def isColorClamped(self, colorSet: MString,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        isColorClamped(self, colorSet: MString,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        This method returns if the color set has its R,G,B,and A
        components clamped in the range from 0 to 1.

        Returns: 
        ----- 
        true All components in the color set are clamped  false All
        components in the color set are not clamped

        Parameters:
        -----
        colorSet: MString
        	[in] -> Color set to work with 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def setIsColorClamped(self, colorSet: MString,
                        clamped: bool): 
        '''
        setIsColorClamped(self, colorSet: MString,
                        clamped: bool)

        Synopsis
        -----
        Set the color set to be clamped.

        Returns:
        -----
        None

        Parameters:
        -----
        colorSet: MString
        	[in] -> Color set to work with 

        clamped: bool
        	[in] -> If the color set should be set clamped


        '''
        pass

    def getTriangles(self, triangleCounts: MIntArray,
                        triangleVertices: MIntArray): 
        '''
        getTriangles(self, triangleCounts: MIntArray,
                        triangleVertices: MIntArray)

        Synopsis
        -----
        Returns the number of triangles for every polygon face and the
        vertex Ids of each triangle vertex. The triangleVertices array
        holds each vertex for each triangle in sequence, so it has three
        times as many elements as there are triangles. (i.e. three times
        the sum of the elements of the triangleCounts array)This method
        is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        triangleCounts: MIntArray
        	[out] -> The number of triangles for each polygon face 

        triangleVertices: MIntArray
        	[out] -> The triangle vertex Ids for each triangle


        '''
        pass

    def getTriangleOffsets(self, triangleCounts: MIntArray,
                        triangleIndices: MIntArray): 
        '''
        getTriangleOffsets(self, triangleCounts: MIntArray,
                        triangleIndices: MIntArray)

        Synopsis
        -----
        Returns the number of triangles for every polygon face and the
        offset into the vertex indices array for each triangle vertex
        (see getVertices()). The triangleVertices array holds each vertex
        for each triangle in sequence, so it has three times as many
        elements as there are triangles. (i.e. three times the sum of the
        elements of the triangleCounts array)This method is not
        threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        triangleCounts: MIntArray
        	[out] -> The number of triangles for each polygon face 

        triangleIndices: MIntArray
        	[out] -> The index array for each triangle in face vertex space


        '''
        pass

    def booleanOps(self, op: MFnMesh.BoolOperation,
                        meshes: MObjectArray,
                        useLegacy: bool,
                        classification: MFnMesh.BoolClassification): 
        '''
        booleanOps(self, op: MFnMesh.BoolOperation,
                        meshes: MObjectArray,
                        useLegacy: bool,
                        classification: MFnMesh.BoolClassification)

        Synopsis
        -----
        Changed in 2023.0 Computes the boolean between multiple
        meshes.The result is stored in the current MFnMesh instance. The
        current instance must point to a valid mesh, which can be empty.
        Such a mesh can result from using MFnMesh::create() for
        example.The union operation adds the meshes in the array
        together. The difference operation subtracts the proceeding
        meshes from the first mesh in the array. The intersection
        operation takes only the parts of the mesh volumes which overlap.
        The current MFnMesh instance is not used as input to the boolean
        operation.The operation is performed in object space, so
        transformations applied by the DAG hierarchy are ignored. If you
        want transformations to be taken into account then you will have
        to first bake them onto the geometry, for example by using the
        makeIdentity command.

        Returns:
        -----
        None

        Parameters:
        -----
        op: MFnMesh.BoolOperation
        	[in] -> Operation to perform (kUnion, kDifference or kIntersection) 

        meshes: MObjectArray
        	[in] -> The meshes for the boolean operation 

        useLegacy: bool
        	[out] -> Flag to indicate if Maya's legacy boolean algorithm should be used. The legacy algorithm produces lower quality results, and should only be used when required to match boolean results from versions of Maya prior to 2015. 

        classification: MFnMesh.BoolClassification
        	[in] -> Flag to indicate how intersections of open and closed manifolds are treated. This flag does not apply to the legacy algorithm and will be ignored when useLegacy is true.


        '''
        pass

    def uniformGridParams(self, xDiv: int,
                        yDiv: int,
                        zDiv: int): 
        '''
        uniformGridParams(self, xDiv: int,
                        yDiv: int,
                        zDiv: int) -> MMeshIsectAccelParams

        Synopsis
        -----
        Creates a MMeshIsectAccelParams configuration object that can be
        passed to several of the geometric query methods available on
        MFnMesh. For example, the MFnMesh closest point and intersection
        methods can optionally make use of this object to speed up their
        operation.This object specifies the number of voxel cells to be
        used in the x, y, and z dimensions. The grid acceleration
        structure will be cached with the mesh, so that if the same
        MMeshIsectAccelParams configuration is used on the next call, the
        acceleration structure will not need to be rebuilt.To see details
        of the acceleration structure, including build time and memory
        usage, refer to the cachedIntersectionAcceleratorInfo()
        method.Note that the cached data can become invalid and need to
        be explicitely freed when the mesh is modified. For example, if a
        mesh is skinned, then when the skin is deformed, the cached
        intersection data must be freed. It will be recalculated the next
        time the MMeshIsectAccelParams is used. Call
        MFnMesh::freeCachedIntersectionAccelerator() to free the cached
        information and force a recalculation.

        Returns: 
        ----- 
        Intersection accelerator object.

        Parameters:
        -----
        xDiv: int
        	[in] -> Number of voxels in the x direction 

        yDiv: int
        	[in] -> Number of voxels in the y direction 

        zDiv: int
        	[in] -> Number of voxels in the z direction


        '''
        pass

    def autoUniformGridParams(self): 
        '''
        autoUniformGridParams(self) -> MMeshIsectAccelParams

        Synopsis
        -----
        Creates a MMeshIsectAccelParams configuration object that can be
        passed to several of the geometric query methods on MFnMesh to
        speed up their operation. For example, the MFnMesh closest point
        and intersection methods can optionally make use of this
        object.This object specifies that a uniform voxel grid structure
        should be used by these routines, and that the system should
        automatically determine the number of voxel cells to use based on
        the density of triangles in the mesh. The grid acceleration
        structure will be cached with the mesh, so that if the same
        MMeshIsectAccelParams configuration is used on the next call, the
        acceleration structure will not need to be rebuilt.To see details
        of the acceleration structure, including build time and memory
        usage, refer to the cachedIntersectionAcceleratorInfo()
        method.Note that the cached data can become invalid and need to
        be explicitely freed when the mesh is modified. For example, if a
        mesh is skinned, then when the skin is deformed, the cached
        intersection data must be freed. It will be recalculated the next
        time the MMeshIsectAccelParams is used. Call
        MFnMesh::freeCachedIntersectionAccelerator() to free the cached
        information and force a recalculation.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def closestIntersection(self, raySource: MFloatPoint,
                        rayDirection: MFloatVector,
                        faceIds: MIntArray,
                        triIds: MIntArray,
                        idsSorted: bool,
                        space: MSpace.MSpace,
                        maxParam: float,
                        testBothDirections: bool,
                        accelParams: MMeshIsectAccelParams,
                        hitPoint: MFloatPoint,
                        hitRayParam: float,
                        hitFace: int,
                        hitTriangle: int,
                        hitBary1: float,
                        hitBary2: float,
                        tolerance: float,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        closestIntersection(self, raySource: MFloatPoint,
                        rayDirection: MFloatVector,
                        faceIds: MIntArray,
                        triIds: MIntArray,
                        idsSorted: bool,
                        space: MSpace.MSpace,
                        maxParam: float,
                        testBothDirections: bool,
                        accelParams: MMeshIsectAccelParams,
                        hitPoint: MFloatPoint,
                        hitRayParam: float,
                        hitFace: int,
                        hitTriangle: int,
                        hitBary1: float,
                        hitBary2: float,
                        tolerance: float,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        Finds the closest intersection of a ray starting at raySource and
        travelling in rayDirection with the mesh. If faceIds is non-
        nullptr and triIds is nullptr, then only the faces specified by
        faceIds will be considered for intersection. If both faceIds and
        triIds are non-nullptr, then each pair of entries will be taken
        as a (face,triangle) pair to be considered for intersection,
        where triangles are numbered on each face starting from 0. Thus,
        the face-triangle pair (10,0) means the first triangle on face
        10. If both faceIds and triIds are nullptr, then all face-
        triangles in the mesh will be considered.The maxParam and
        testBothDirections flags can be used to control the radius of the
        search around the raySource point.If accelParams is nullptr, the
        search proceeds by testing all applicable face-triangles looking
        for intersections. If an MMeshIsectAccelParams structure is
        passed in via this parameter, the mesh builds an intersection
        acceleration structure based on the description provided by the
        parameter object. This acceleration structure is used to speed up
        the intersection operation, sometimes by a factor of several
        hundred over the non-accelerated case. Once created, the
        acceleration structure is cached, and will be reused the next
        time this method (or anyIntersection() or allIntersections()) is
        called with an identically-configured MMeshIsectAccelParams
        object. If a different MMeshIsectAccelParams object is used, then
        the acceleration structure will be deleted and re-created
        according to the new settings. Once created, the acceleration
        structure will persist until either the object is destroyed (or
        rebuilt by a construction history operation), or if the
        freeCachedIntersectionAccelerator() method is called. The
        cachedIntersectionAcceleratorInfo() and
        globalIntersectionAcceleratorsInfo() methods provide useful
        information about the resource usage of individual acceleration
        structures, and of all such structures in the system.If the ray
        hits the mesh, the details of the closest intersection point to
        the raySource will be returned via the hitPoint, hitRayParam,
        hitFace, hitTriangle, hitBary1, and hitBary2 parameters. These
        parameters completely describe where the hit occurred.

        Returns:
        -----
        None

        Parameters:
        -----
        raySource: MFloatPoint
        	[in] -> 

        rayDirection: MFloatVector
        	[in] -> 

        faceIds: MIntArray
        	[in] -> 

        triIds: MIntArray
        	[in] -> 

        idsSorted: bool
        	[in] -> 

        space: MSpace.MSpace
        	[in] -> 

        maxParam: float
        	[in] -> 

        testBothDirections: bool
        	[in] -> 

        accelParams: MMeshIsectAccelParams
        	[in] -> 

        hitPoint: MFloatPoint
        	[in] -> 

        hitRayParam: float
        	[in] -> 

        hitFace: int
        	[in] -> 

        hitTriangle: int
        	[in] -> 

        hitBary1: float
        	[in] -> 

        hitBary2: float
        	[in] -> 

        tolerance: float
        	[in] -> 

        ReturnStatus: MFnMesh.MStatus
        	[in] -> 


        '''
        pass

    def anyIntersection(self, raySource: MFloatPoint,
                        rayDirection: MFloatVector,
                        faceIds: MIntArray,
                        triIds: MIntArray,
                        idsSorted: bool,
                        space: MSpace.MSpace,
                        maxParam: float,
                        testBothDirections: bool,
                        accelParams: MMeshIsectAccelParams,
                        hitPoint: MFloatPoint,
                        hitRayParam: float,
                        hitFace: int,
                        hitTriangle: int,
                        hitBary1: float,
                        hitBary2: float,
                        tolerance: float,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        anyIntersection(self, raySource: MFloatPoint,
                        rayDirection: MFloatVector,
                        faceIds: MIntArray,
                        triIds: MIntArray,
                        idsSorted: bool,
                        space: MSpace.MSpace,
                        maxParam: float,
                        testBothDirections: bool,
                        accelParams: MMeshIsectAccelParams,
                        hitPoint: MFloatPoint,
                        hitRayParam: float,
                        hitFace: int,
                        hitTriangle: int,
                        hitBary1: float,
                        hitBary2: float,
                        tolerance: float,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        Finds any intersection of a ray starting at raySource and
        travelling in rayDirection with the mesh. If faceIds is non-
        nullptr and triIds is nullptr, then only the faces specified by
        faceIds will be considered for intersection. If both faceIds and
        triIds are non-nullptr, then each pair of entries will be taken
        as a (face,triangle) pair to be considered for intersection,
        where triangles are numbered on each face starting from 0. Thus,
        the face-triangle pair (10,0) means the first triangle on face
        10. If both faceIds and triIds are nullptr, then all face-
        triangles in the mesh will be considered.The maxParam and
        testBothDirections flags can be used to control the radius of the
        search around the raySource point.If accelParams is nullptr, the
        search proceeds by testing all applicable face-triangles looking
        for intersections. If an MMeshIsectAccelParams structure is
        passed in via this parameter, the mesh builds an intersection
        acceleration structure based on the description provided by the
        parameter object. This acceleration structure is used to speed up
        the intersection operation, sometimes by a factor of several
        hundred over the non-accelerated case. Once created, the
        acceleration structure is cached, and will be reused the next
        time this method (or closestIntersection() or allIntersections())
        is called with an identically-configured MMeshIsectAccelParams
        object. If a different MMeshIsectAccelParams object is used, then
        the acceleration structure will be deleted and re-created
        according to the new settings. Once created, the acceleration
        structure will persist until either the object is destroyed (or
        rebuilt by a construction history operation), or if the
        freeCachedIntersectionAccelerator() method is called. The
        cachedIntersectionAcceleratorInfo() and
        globalIntersectionAcceleratorsInfo() methods provide useful
        information about the resource usage of individual acceleration
        structures, and of all such structures in the system.If the ray
        hits the mesh, the details of the found intersection point to the
        raySource will be returned via the hitPoint, hitRayParam,
        hitFace, hitTriangle, hitBary1, and hitBary2 parameters. These
        parameters completely describe where the hit occurred.

        Returns:
        -----
        None

        Parameters:
        -----
        raySource: MFloatPoint
        	[in] -> 

        rayDirection: MFloatVector
        	[in] -> 

        faceIds: MIntArray
        	[in] -> 

        triIds: MIntArray
        	[in] -> 

        idsSorted: bool
        	[in] -> 

        space: MSpace.MSpace
        	[in] -> 

        maxParam: float
        	[in] -> 

        testBothDirections: bool
        	[in] -> 

        accelParams: MMeshIsectAccelParams
        	[in] -> 

        hitPoint: MFloatPoint
        	[in] -> 

        hitRayParam: float
        	[in] -> 

        hitFace: int
        	[in] -> 

        hitTriangle: int
        	[in] -> 

        hitBary1: float
        	[in] -> 

        hitBary2: float
        	[in] -> 

        tolerance: float
        	[in] -> 

        ReturnStatus: MFnMesh.MStatus
        	[in] -> 


        '''
        pass

    def allIntersections(self, raySource: MFloatPoint,
                        rayDirection: MFloatVector,
                        faceIds: MIntArray,
                        triIds: MIntArray,
                        idsSorted: bool,
                        space: MSpace.MSpace,
                        maxParam: float,
                        testBothDirections: bool,
                        accelParams: MMeshIsectAccelParams,
                        sortHits: bool,
                        hitPoints: MFloatPointArray,
                        hitRayParams: MFloatArray,
                        hitFaces: MIntArray,
                        hitTriangles: MIntArray,
                        hitBary1s: MFloatArray,
                        hitBary2s: MFloatArray,
                        tolerance: float,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        allIntersections(self, raySource: MFloatPoint,
                        rayDirection: MFloatVector,
                        faceIds: MIntArray,
                        triIds: MIntArray,
                        idsSorted: bool,
                        space: MSpace.MSpace,
                        maxParam: float,
                        testBothDirections: bool,
                        accelParams: MMeshIsectAccelParams,
                        sortHits: bool,
                        hitPoints: MFloatPointArray,
                        hitRayParams: MFloatArray,
                        hitFaces: MIntArray,
                        hitTriangles: MIntArray,
                        hitBary1s: MFloatArray,
                        hitBary2s: MFloatArray,
                        tolerance: float,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        Finds all intersections of a ray starting at raySource and
        travelling in rayDirection with the mesh. If faceIds is non-
        nullptr and triIds is nullptr, then only the faces specified by
        faceIds will be considered for intersection. If both faceIds and
        triIds are non-nullptr, then each pair of entries will be taken
        as a (face,triangle) pair to be considered for intersection,
        where triangles are numbered on each face starting from 0. Thus,
        the face-triangle pair (10,0) means the first triangle on face
        10. If both faceIds and triIds are nullptr, then all face-
        triangles in the mesh will be considered.The maxParam and
        testBothDirections flags can be used to control the radius of the
        search around the raySource point.If accelParams is nullptr, the
        search proceeds by testing all applicable face-triangles looking
        for intersections. If an MMeshIsectAccelParams structure is
        passed in via this parameter, the mesh builds an intersection
        acceleration structure based on the description provided by the
        parameter object. This acceleration structure is used to speed up
        the intersection operation, sometimes by a factor of several
        hundred over the non-accelerated case. Once created, the
        acceleration structure is cached, and will be reused the next
        time this method (or anyIntersection() or allIntersections()) is
        called with an identically-configured MMeshIsectAccelParams
        object. If a different MMeshIsectAccelParams object is used, then
        the acceleration structure will be deleted and re-created
        according to the new settings. Once created, the acceleration
        structure will persist until either the object is destroyed (or
        rebuilt by a construction history operation), or if the
        freeCachedIntersectionAccelerator() method is called. The
        cachedIntersectionAcceleratorInfo() and
        globalIntersectionAcceleratorsInfo() methods provide useful
        information about the resource usage of individual acceleration
        structures, and of all such structures in the system.If the ray
        hits the mesh, the details of the intersection points will be
        returned via the hitPoint, hitRayParam, hitFace, hitTriangle,
        hitBary1, and hitBary2 parameters. These parameters completely
        describe where the hit occurred.

        Returns:
        -----
        None

        Parameters:
        -----
        raySource: MFloatPoint
        	[in] -> 

        rayDirection: MFloatVector
        	[in] -> 

        faceIds: MIntArray
        	[in] -> 

        triIds: MIntArray
        	[in] -> 

        idsSorted: bool
        	[in] -> 

        space: MSpace.MSpace
        	[in] -> 

        maxParam: float
        	[in] -> 

        testBothDirections: bool
        	[in] -> 

        accelParams: MMeshIsectAccelParams
        	[in] -> 

        sortHits: bool
        	[in] -> 

        hitPoints: MFloatPointArray
        	[in] -> 

        hitRayParams: MFloatArray
        	[in] -> 

        hitFaces: MIntArray
        	[in] -> 

        hitTriangles: MIntArray
        	[in] -> 

        hitBary1s: MFloatArray
        	[in] -> 

        hitBary2s: MFloatArray
        	[in] -> 

        tolerance: float
        	[in] -> 

        ReturnStatus: MFnMesh.MStatus
        	[in] -> 


        '''
        pass

    def sortIntersectionFaceTriIds(self, faceIds: MIntArray,
                        triIds: MIntArray): 
        '''
        sortIntersectionFaceTriIds(self, faceIds: MIntArray,
                        triIds: MIntArray)

        Synopsis
        -----
        Convenience routine for sorting faceIds or face/triangle ids
        before passing them into the closestIntersection(),
        allIntersections(), or anyIntersection() methods. When using an
        acceleration structure with the intersection operation, it is
        essential that any faceId or faceId/triId arrays be sorted
        properly to ensure optimal performance.

        Returns:
        -----
        None

        Parameters:
        -----
        faceIds: MIntArray
        	[in] -> 

        triIds: MIntArray
        	[in] -> 


        '''
        pass

    def freeCachedIntersectionAccelerator(self): 
        '''
        freeCachedIntersectionAccelerator(self)

        Synopsis
        -----
        If the mesh has a cached accelerator structure, then this routine
        forces it to be deleted. Ordinarily, these structures are cached
        so that series of calls to the geometric query methods that make
        use of it can reuse the same structure. Once the client is
        finished with a series of method calls, however, they are
        responsible for freeing the acceleration structure, which is what
        this method does.In particular, if the mesh is modified, then the
        cached accelerator structure must be freed. Otherwise, the
        intersection functions will return incorrect results.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cachedIntersectionAcceleratorInfo(self, ReturnStatus: MFnMesh.MStatus): 
        '''
        cachedIntersectionAcceleratorInfo(self, ReturnStatus: MFnMesh.MStatus) -> MString

        Synopsis
        -----
        Retrieves a string that describes the intersection acceleration
        structure for this object, if any. The string is formatted
        similar to:10x10x10 uniform grid, (build time 0.5s), (memory
        footprint 2000KB)It describes the configuration of the cached
        intersection accelerator, as well as how long it took to build
        it, and how much memory it is currently occupying. If the mesh
        has no cached intersection accelerator, the empty string is
        returned.

        Returns: 
        ----- 
        The description string

        Parameters:
        -----
        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code.


        '''
        pass

    def globalIntersectionAcceleratorsInfo(self): 
        '''
        globalIntersectionAcceleratorsInfo(self) -> MString

        Synopsis
        -----
        Retrieves a string that describes the systemwide resource usage
        for cached mesh intersection accelerators. The string will be
        formatted similar to:total 10 accelerators created (2 currently
        active - total current memory = 10000KB), total build time =
        10.2s, peak memory = 14567.1KBThis means that:Calling
        clearGlobalIntersectionAcceleratorInfo() will clear the "total
        count", "total build time", and "peak memory" fields from this
        information. It will not cause information about currently
        existing accelerators to be lost.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def clearGlobalIntersectionAcceleratorInfo(self): 
        '''
        clearGlobalIntersectionAcceleratorInfo(self)

        Synopsis
        -----
        As described above, clears the "total count", "total build time",
        and "peak memory" fields from the information string returned by
        globalIntersectionAcceleratorsInfo(). It will not cause
        information about currently existing accelerators to be lost.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def intersect(self, raySource: MPoint,
                        rayDirection: MVector,
                        points: MPointArray,
                        tolerance: double,
                        space: MSpace.MSpace,
                        polygonIds: MIntArray,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        intersect(self, raySource: MPoint,
                        rayDirection: MVector,
                        points: MPointArray,
                        tolerance: double,
                        space: MSpace.MSpace,
                        polygonIds: MIntArray,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        Determines whether the given ray intersects this polygon and if
        so, returns the points of intersection. The points of
        intersection will be in order of closest point to the
        raySource.If the polygonIds array is not nullptr then it will
        contain the polygon id's that correspond to the points of
        intersection.The tolerance parameter is the epsilon value that
        will be used in the point-in-polygon calculation.This method is
        not threadsafe when invoked by multiple threads on the same
        object at the same time. It is threadsafe as long as each thread
        operates on a different mesh object.

        Returns: 
        ----- 
        true The given ray intersects this polygon  false The given ray
        does not intersect this polygon

        Parameters:
        -----
        raySource: MPoint
        	[in] -> Starting point for the ray 

        rayDirection: MVector
        	[in] -> Direction of the ray 

        points: MPointArray
        	[out] -> Storage for any points of intersection 

        tolerance: double
        	[in] -> Tolerance used in intersection calculation 

        space: MSpace.MSpace
        	[in] -> specifies the coordinate system for this operation 

        polygonIds: MIntArray
        	[out] -> Storage for the polygon id's that correspond to the points of intersection. 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def getClosestPointAndNormal(self, toThisPoint: MPoint,
                        theClosestPoint: MPoint,
                        theNormal: MVector,
                        space: MSpace.MSpace,
                        closestPolygon: int,
                        accelParams: MMeshIsectAccelParams): 
        '''
        getClosestPointAndNormal(self, toThisPoint: MPoint,
                        theClosestPoint: MPoint,
                        theNormal: MVector,
                        space: MSpace.MSpace,
                        closestPolygon: int,
                        accelParams: MMeshIsectAccelParams)

        Synopsis
        -----
        Returns the closest point on this surface to the given point.
        This method also returns the surface normal at that point.If
        world space is specified then the returned point and normal will
        be in world space. In this case The test point (toThisPoint) is
        assumed to be in world space.This method is not threadsafe. For a
        threadsafe closest point implementation, use the MMeshIntersector
        class.

        Returns:
        -----
        None

        Parameters:
        -----
        toThisPoint: MPoint
        	[in] -> Point to be compared 

        theClosestPoint: MPoint
        	[out] -> Storage for the closest point 

        theNormal: MVector
        	[out] -> Storage for normal at the closest point 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation 

        closestPolygon: int
        	[out] -> Storage for the closest polygon id 

        accelParams: MMeshIsectAccelParams
        	[in] -> optional acceleration parameters


        '''
        pass

    def getClosestPoint(self, toThisPoint: MPoint,
                        theClosestPoint: MPoint,
                        space: MSpace.MSpace,
                        closestPolygon: int,
                        accelParams: MMeshIsectAccelParams): 
        '''
        getClosestPoint(self, toThisPoint: MPoint,
                        theClosestPoint: MPoint,
                        space: MSpace.MSpace,
                        closestPolygon: int,
                        accelParams: MMeshIsectAccelParams)

        Synopsis
        -----
        Returns the closest point on this surface to the given point. If
        world space is specified then the returned point will be in world
        space. In this case The test point (toThisPoint) is assumed to be
        in world space.This method is not threadsafe. For a threadsafe
        closest point implementation, use the MMeshIntersector class.

        Returns:
        -----
        None

        Parameters:
        -----
        toThisPoint: MPoint
        	[in] -> Point to be compared 

        theClosestPoint: MPoint
        	[out] -> Storage for the closest point 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation 

        closestPolygon: int
        	[out] -> Storage for the closest polygon id 

        accelParams: MMeshIsectAccelParams
        	[in] -> optional acceleration parameters


        '''
        pass

    def getClosestNormal(self, toThisPoint: MPoint,
                        theNormal: MVector,
                        space: MSpace.MSpace,
                        closestPolygon: int,
                        accelParams: MMeshIsectAccelParams): 
        '''
        getClosestNormal(self, toThisPoint: MPoint,
                        theNormal: MVector,
                        space: MSpace.MSpace,
                        closestPolygon: int,
                        accelParams: MMeshIsectAccelParams)

        Synopsis
        -----
        Returns the closest point on this surface to the given point.
        This method also returns the surface normal at that point.If
        world space is specified then the returned normal will be in
        world space. In this case The test point (toThisPoint) is assumed
        to be in world space.

        Returns:
        -----
        None

        Parameters:
        -----
        toThisPoint: MPoint
        	[in] -> Point to be compared 

        theNormal: MVector
        	[out] -> Storage for normal at the closest point 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation 

        closestPolygon: int
        	[out] -> Storage for the closest polygon id 

        accelParams: MMeshIsectAccelParams
        	[in] -> optional acceleration parameters


        '''
        pass

    def getClosestUVs(self, toThisUVPoint: float2,
                        uvIds: MIntArray,
                        uvSet: MString): 
        '''
        getClosestUVs(self, toThisUVPoint: float2,
                        uvIds: MIntArray,
                        uvSet: MString)

        Synopsis
        -----
        Returns the IDs of the UVs on this surface which are nearest in
        uv space to the given uv set and coordinate. All these UVs locate
        at the same distance to the given coordinate.

        Returns:
        -----
        None

        Parameters:
        -----
        toThisUVPoint: float2
        	[in] -> UV coordinate to be compared 

        uvIds: MIntArray
        	[out] -> The list of the closest uvs ids 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def intersectFaceAtUV(self, toThisUVPoint: float2,
                        faceId: int,
                        uvSet: MString): 
        '''
        intersectFaceAtUV(self, toThisUVPoint: float2,
                        faceId: int,
                        uvSet: MString)

        Synopsis
        -----
        Returns ID of the intersected face at given uv set and
        coordinate. If multiple faces are intersected, the first
        intersected one would be returned.This method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        toThisUVPoint: float2
        	[in] -> UV coordinate to be compared 

        faceId: int
        	[out] -> Intersected face ID 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def getConnectedShaders(self, instanceNumber: int,
                        shaders: MObjectArray,
                        indices: MIntArray): 
        '''
        getConnectedShaders(self, instanceNumber: int,
                        shaders: MObjectArray,
                        indices: MIntArray)

        Synopsis
        -----
        Returns all the shaders (sets) connected to the specified
        instance of this mesh, as well as an array of polygon/shader
        assignments. The indices array will hold, for each polygon in the
        mesh, an index into the shaders array. If a polygon does not have
        a shader assigned to it, the value of the index will be -1.The
        shader objects can be derived from the sets returned.Note: This
        method will only work with a MFnMesh function set which has been
        initialized with an MFn::kMesh.See also
        getConnectedSetsAndMembers.

        Returns:
        -----
        None

        Parameters:
        -----
        instanceNumber: int
        	[in] -> The instance number of the mesh to query 

        shaders: MObjectArray
        	[out] -> Storage for set objects (shader objects) 

        indices: MIntArray
        	[out] -> Storage for indices matching faces to shaders. For each face, this array contains the index into the shaders array for the shader assigned to the face.


        '''
        pass

    def copy(self, source: MObject,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        copy(self, source: MObject,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus) -> MObject

        Synopsis
        -----
        This method creates a copy of a given source mesh. After the copy
        this function set will operate on the new mesh.The parentOrOwner
        argument is used to specify the owner of the new surface.If the
        parentOrOwner is kMeshData then the created surface will be of
        type kMeshGeom and will be returned. The parentOrOwner will
        become the owner of the new mesh.If parentOrOwner is nullptr then
        a new transform will be created and returned which will be the
        parent for the mesh. The new transform will be added to the
        DAG.If parentOrOwner is a DAG node then the new mesh will be
        returned and the parentOrOwner will become its parent.

        Returns: 
        ----- 
        If parentOrOwner is nullptr then the transform for this surface
        is returned  If parentOrOwner is a DAG object then the new
        surface shape is returned  The surface geometry is returned if
        parentOrOwner is of type kMeshData

        Parameters:
        -----
        source: MObject
        	[in] -> the mesh to be copied 

        parentOrOwner: MObject
        	[in] -> the DAG parent or kMeshData the new mesh will belong to 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def updateSurface(self): 
        '''
        updateSurface(self)

        Synopsis
        -----
        Signal that this polygonal mesh has changed and needs to redraw
        itself.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def syncObject(self): 
        '''
        syncObject(self)

        Synopsis
        -----
        If a non-api operation happens that many have changed the
        underlying Maya object wrapped by this api object, make sure that
        the api object references a valid maya object. In particular this
        call should be used if you are calling mel commands from your
        plugin. Note that this only applies for mesh shapes: in a plugin
        node where the dataMesh is being accessed directly this is not
        necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getRawPoints(self, ReturnStatus: MFnMesh.MStatus): 
        '''
        getRawPoints(self, ReturnStatus: MFnMesh.MStatus) -> float*

        Synopsis
        -----
        This method returns a pointer to the internal vertex list for
        this mesh. The points are in local space.The points are stored in
        a single contiguous array of floats, first by coordinate, then by
        element (xyzxyz...) There are three coordinate values, so each
        vertex is stored in 12 bytes of data, and the total array length
        is 12*numVertices() bytes.This method is useful where performance
        is critical or memory resources are limited, as it avoids having
        to make a copy of the points as is done by getVertices. Care must
        be taken however as the returned pointer may become invalid if
        any changes are made to the mesh.

        Returns:
        -----
        None

        Parameters:
        -----
        ReturnStatus: MFnMesh.MStatus
        	[in] -> 


        '''
        pass

    def getRawDoublePoints(self, ReturnStatus: MFnMesh.MStatus): 
        '''
        getRawDoublePoints(self, ReturnStatus: MFnMesh.MStatus) -> double*

        Synopsis
        -----
        This method returns a pointer to the internal vertex list for
        this mesh. The points are in local space.The points are stored in
        a single contiguous array of doubles, first by coordinate, then
        by element (xyzxyz...) There are three coordinate values, so each
        vertex is stored in 24 bytes of data, and the total array length
        is 24*numVertices() bytes.This method is useful where performance
        is critical or memory resources are limited, as it avoids having
        to make a copy of the points as is done by getVertices. Care must
        be taken however as the returned pointer may become invalid if
        any changes are made to the mesh.

        Returns:
        -----
        None

        Parameters:
        -----
        ReturnStatus: MFnMesh.MStatus
        	[in] -> 


        '''
        pass

    def getRawNormals(self, ReturnStatus: MFnMesh.MStatus): 
        '''
        getRawNormals(self, ReturnStatus: MFnMesh.MStatus) -> float*

        Synopsis
        -----
        This method returns a pointer to the internal normal list for
        this mesh. The normals are in local space and are the per-polygon
        per-vertex normals. To find the normal for a particular vertex-
        face, use getFaceNormalIds() or MItMeshPolygon::normalIndex to
        get the index into the array.The normals are stored in a single
        contiguous array of floats, first by coordinate, then by element
        (xyzxyz...) There are three coordinate values, so each normal is
        stored in 12 bytes of data, and the total array length is
        12*numNormals() bytes.This method is useful where performance is
        critical or memory resources are limited, as it avoids having to
        make a copy of the normals as is done by getNormals. Care must be
        taken however as the returned pointer may become invalid if any
        changes are made to the mesh.This method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        ReturnStatus: MFnMesh.MStatus
        	[in] -> 


        '''
        pass

    def getRawUVs(self, ReturnStatus: MFnMesh.MStatus,
                        uvSet: MString): 
        '''
        getRawUVs(self, ReturnStatus: MFnMesh.MStatus,
                        uvSet: MString) -> float*

        Synopsis
        -----
        Introduced in 2023.0 This method returns a pointer to the
        internal texture coordinates for this mesh.This method is not
        threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        ReturnStatus: MFnMesh.MStatus
        	[in] -> 

        uvSet: MString
        	[in] -> 


        '''
        pass

    @overload
    def getPoints(self, vertexArray: MFloatPointArray,
                        space: MSpace.MSpace): 
        '''
        getPoints(self, vertexArray: MFloatPointArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        This method copies the vertex list for this mesh into the given
        point array.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexArray: MFloatPointArray
        	[out] -> Storage for the vertex list 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    @overload
    def getPoints(self, vertexArray: MPointArray,
                        space: MSpace.MSpace): 
        '''
        getPoints(self, vertexArray: MPointArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        This method copies the vertex list for this mesh into the given
        point array.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexArray: MPointArray
        	[out] -> Storage for the vertex list 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    @overload
    def setPoints(self, vertexArray: MFloatPointArray,
                        space: MSpace.MSpace): 
        '''
        setPoints(self, vertexArray: MFloatPointArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        This method copies the points in the given point array to the
        vertices of this polygon. To keep this method as fast as
        possible, no checking of the data is performed beyond ensuring
        that the total number of points passed in is correct. It is up to
        the caller to ensure that the points provide a valid mesh, for
        example by ensuring that there are no degenerate faces or non-
        manifold geometry.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexArray: MFloatPointArray
        	[out] -> Storage for the vertex list 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    @overload
    def setPoints(self, vertexArray: MPointArray,
                        space: MSpace.MSpace): 
        '''
        setPoints(self, vertexArray: MPointArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        This method copies the points in the given point array to the
        vertices of this mesh. To keep this method as fast as possible,
        no checking of the data is performed beyond ensuring that the
        total number of points passed in is correct. It is up to the
        caller to ensure that the points provide a valid mesh, for
        example by ensuring that there are no degenerate faces or non-
        manifold geometry.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexArray: MPointArray
        	[out] -> Storage for the vertex list 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def getVertices(self, vertexCount: MIntArray,
                        vertexList: MIntArray): 
        '''
        getVertices(self, vertexCount: MIntArray,
                        vertexList: MIntArray)

        Synopsis
        -----
        This method retrieves the object-relative (mesh-relative/global)
        vertex indices for all polygons. The indices refer to the
        elements in the array returned by the 'getPoints' method.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexCount: MIntArray
        	[out] -> Vertex count per polygon 

        vertexList: MIntArray
        	[out] -> Storage for the vertex list. NOTE: Global (mesh-relative/object-relative) vertex indices are returned.


        '''
        pass

    def getPolygonVertices(self, polygonId: int,
                        vertexList: MIntArray): 
        '''
        getPolygonVertices(self, polygonId: int,
                        vertexList: MIntArray)

        Synopsis
        -----
        This method retrieves the object-relative (mesh-relative/global)
        vertex indices for the specified polygon. The indices refer to
        the elements in the array returned by the 'getPoints' method.

        Returns:
        -----
        None

        Parameters:
        -----
        polygonId: int
        	[in] -> The polygon to examine 

        vertexList: MIntArray
        	[out] -> Storage for the vertex list. NOTE: Global (mesh-relative/object-relative) vertex indices are returned.


        '''
        pass

    def getPolygonTriangleVertices(self, polygonId: int,
                        triangleId: int,
                        vertexList: int3): 
        '''
        getPolygonTriangleVertices(self, polygonId: int,
                        triangleId: int,
                        vertexList: int3)

        Synopsis
        -----
        This method retrieves the object-relative (mesh-relative/global)
        vertex indices for the specified triangle in the specified
        polygon. The indices refer to the elements in the array returned
        by the 'getPoints' method.This method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        polygonId: int
        	[in] -> The polygon to examine 

        triangleId: int
        	[in] -> The triangle within the polygon to examine (numbered from zero) 

        vertexList: int3
        	[out] -> Storage for the vertex list. NOTE: Global (mesh-relative/object-relative) vertex indices are returned.


        '''
        pass

    def setPoint(self, vertexId: int,
                        pos: MPoint,
                        space: MSpace.MSpace): 
        '''
        setPoint(self, vertexId: int,
                        pos: MPoint,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Sets the position of specified vertex in the vertex list for this
        mesh. Note that if you modify the position of a vertex for a
        shape, a tweak will be created. If you have a shape with no
        history, the first time that a tweak is created, the underlying
        pointers under the MFnMesh object may change. You will need to
        call syncObject() to make sure that the object is valid.
        Subsequent calls to setPoint() on the same object do not require
        a syncObject call.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexId: int
        	[in] -> The object-relative (mesh-relative/global) index of the vertex to be changed 

        pos: MPoint
        	[in] -> The new value for the vertex 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def getPoint(self, vertexId: int,
                        pos: MPoint,
                        space: MSpace.MSpace): 
        '''
        getPoint(self, vertexId: int,
                        pos: MPoint,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Get the position of the specified vertex in this mesh's vertex
        list.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexId: int
        	[in] -> The object-relative (mesh-relative/global) index of the vertex to retrieve 

        pos: MPoint
        	[out] -> Storage for the vertex 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def getNormals(self, normals: MFloatVectorArray,
                        space: MSpace.MSpace): 
        '''
        getNormals(self, normals: MFloatVectorArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        This method copies the normal list for this mesh into the given
        array. The normals are the per-polygon per-vertex normals. To
        find the normal for a particular vertex-face, use
        getFaceNormalIds() or MItMeshPolygon::normalIndex to get the
        index into the array.This method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        normals: MFloatVectorArray
        	[out] -> Storage for the per-polygon per-vertex normal list 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def setNormals(self, normals: MFloatVectorArray,
                        space: MSpace.MSpace): 
        '''
        setNormals(self, normals: MFloatVectorArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the normal array (user normals)

        Returns:
        -----
        None

        Parameters:
        -----
        normals: MFloatVectorArray
        	[in] -> The normal array to set 

        space: MSpace.MSpace
        	[in] -> World space or Object space


        '''
        pass

    def getFaceVertexNormal(self, faceIndex: int,
                        vertexIndex: int,
                        normal: MVector,
                        space: MSpace.MSpace): 
        '''
        getFaceVertexNormal(self, faceIndex: int,
                        vertexIndex: int,
                        normal: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Return a per-vertex-per-face normal for a given face (polygon)
        and given vertex. This method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        faceIndex: int
        	[in] -> Index of the face of interest 

        vertexIndex: int
        	[in] -> The object-relative (mesh-relative/global) vertex index 

        normal: MVector
        	[out] -> Storage for the per-polygon-per-vertex normal 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def getFaceVertexNormals(self, faceIndex: int,
                        normals: MFloatVectorArray,
                        space: MSpace.MSpace): 
        '''
        getFaceVertexNormals(self, faceIndex: int,
                        normals: MFloatVectorArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Return all per-vertex-per-face normals for a given face. This
        method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        faceIndex: int
        	[in] -> Index of the face (polygon) for which to retrive the normals 

        normals: MFloatVectorArray
        	[out] -> Storage for the face normals 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def getNormalIds(self, normalCounts: MIntArray,
                        normals: MIntArray): 
        '''
        getNormalIds(self, normalCounts: MIntArray,
                        normals: MIntArray)

        Synopsis
        -----
        Get normal indices for all vertices of all faces. The normalIds
        can be used to index into an array returned by
        MFnMesh::getNormals();This method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        normalCounts: MIntArray
        	[out] -> Number of normals for each face 

        normals: MIntArray
        	[out] -> Storage for the per-polygon normal ids


        '''
        pass

    def getFaceNormalIds(self, faceIndex: int,
                        normals: MIntArray): 
        '''
        getFaceNormalIds(self, faceIndex: int,
                        normals: MIntArray)

        Synopsis
        -----
        Return normal indices for all vertices for a given face. The
        normalIds can be used to index into an array returned by
        MFnMesh::getNormals();This method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        faceIndex: int
        	[in] -> Index of face (polygon) of interest 

        normals: MIntArray
        	[out] -> Storage for the per-polygon normal ids


        '''
        pass

    def setFaceVertexNormal(self, normalIn: MVector,
                        faceId: int,
                        vertexId: int,
                        space: MSpace.MSpace,
                        modifier: MDGModifier): 
        '''
        setFaceVertexNormal(self, normalIn: MVector,
                        faceId: int,
                        vertexId: int,
                        space: MSpace.MSpace,
                        modifier: MDGModifier)

        Synopsis
        -----
        Set Normal for this face/vertex pair.

        Returns:
        -----
        None

        Parameters:
        -----
        normalIn: MVector
        	[in] -> 

        faceId: int
        	[in] -> 

        vertexId: int
        	[in] -> 

        space: MSpace.MSpace
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 


        '''
        pass

    def setVertexNormal(self, normalIn: MVector,
                        vertexId: int,
                        space: MSpace.MSpace,
                        modifier: MDGModifier): 
        '''
        setVertexNormal(self, normalIn: MVector,
                        vertexId: int,
                        space: MSpace.MSpace,
                        modifier: MDGModifier)

        Synopsis
        -----
        Set Shared Normal for this vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        normalIn: MVector
        	[in] -> 

        vertexId: int
        	[in] -> 

        space: MSpace.MSpace
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 


        '''
        pass

    def setFaceVertexNormals(self, normalsIn: MVectorArray,
                        faceList: MIntArray,
                        vertexList: MIntArray,
                        space: MSpace.MSpace): 
        '''
        setFaceVertexNormals(self, normalsIn: MVectorArray,
                        faceList: MIntArray,
                        vertexList: MIntArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set Normals for the given face/vertex pairs. Note that if there
        is a vertex-face mismatch anywhere in the list, this method will
        return an error, and not set any of the normals.

        Returns:
        -----
        None

        Parameters:
        -----
        normalsIn: MVectorArray
        	[in] -> The normals to set 

        faceList: MIntArray
        	[in] -> The faces to set them for 

        vertexList: MIntArray
        	[in] -> The object-relative (mesh-relative/global) vertex indices to set them for 

        space: MSpace.MSpace
        	[in] -> World space or Object space


        '''
        pass

    def setVertexNormals(self, normalsIn: MVectorArray,
                        vertexList: MIntArray,
                        space: MSpace.MSpace): 
        '''
        setVertexNormals(self, normalsIn: MVectorArray,
                        vertexList: MIntArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set Shared Normals for these vertices. The length of the
        normalsIn array should be same as the length of the vertexList
        array.

        Returns:
        -----
        None

        Parameters:
        -----
        normalsIn: MVectorArray
        	[in] -> The normals to set 

        vertexList: MIntArray
        	[in] -> The object-relative (mesh-relative/global) vertex indices to set them for 

        space: MSpace.MSpace
        	[in] -> World space or Object space


        '''
        pass

    def getVertexNormal(self, vertexId: int,
                        angleWeighted: bool,
                        normal: MVector,
                        space: MSpace.MSpace): 
        '''
        getVertexNormal(self, vertexId: int,
                        angleWeighted: bool,
                        normal: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Return the normal at the given vertex. The returned normal is a
        single per-vertex normal, so unshared normals at a vertex will be
        averaged. See the class description for more information on
        normals.If angleWeighted is set to true, the normals are computed
        by an average of surrounding face normals weighted by the angle
        subtended by the face at the vertex. If angleWeighted is set to
        false, a simple average of surround face normals is returned.The
        simple average evaluation is significantly faster than the angle-
        weighted average.This method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexId: int
        	[in] -> The object-relative (mesh-relative/global) vertex index to get the normal for 

        angleWeighted: bool
        	[in] -> Defines algorithm used to compute normal 

        normal: MVector
        	[out] -> Storage for the per-vertex normal 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def getVertexNormals(self, angleWeighted: bool,
                        normals: MFloatVectorArray,
                        space: MSpace.MSpace): 
        '''
        getVertexNormals(self, angleWeighted: bool,
                        normals: MFloatVectorArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Return all vertex normals. The returned normals are per-vertex
        normals, so unshared normals at a vertex will be averaged. See
        the class description for more information on normals.If
        angleWeighted is set to true, the normals are computed by an
        average of surrounding face normals weighted by the angle
        subtended by the face at the vertex. If angleWeighted is set to
        false, a simple average of surround face normals is returned.The
        simple average evaluation is significantly faster than the angle-
        weighted average.This method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        angleWeighted: bool
        	[in] -> Defines algorithm used to compute normal 

        normals: MFloatVectorArray
        	[out] -> Storage for the per-vertex normals 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def getPolygonNormal(self, polygonId: int,
                        normal: MVector,
                        space: MSpace.MSpace): 
        '''
        getPolygonNormal(self, polygonId: int,
                        normal: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Return the normal at the given polygon. The returned normal is a
        per-polygon normal. See the class description for more
        information on normals.This method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        polygonId: int
        	[in] -> The polygon (face) to get the normal for 

        normal: MVector
        	[out] -> Storage for the per-polygon normal 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def isNormalLocked(self, normalId: int,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        isNormalLocked(self, normalId: int,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        Test if the normal for a face/vertex pairs is locked (user
        defined).

        Returns: 
        ----- 
        true if the normal is locked. false if not locked.

        Parameters:
        -----
        normalId: int
        	[in] -> Normal to test. 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code.


        '''
        pass

    def lockVertexNormals(self, vertexList: MIntArray): 
        '''
        lockVertexNormals(self, vertexList: MIntArray)

        Synopsis
        -----
        Lock Shared Normals for these vertices.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexList: MIntArray
        	[in] -> The object-relative (global) verticex ides to lock normals for


        '''
        pass

    def lockFaceVertexNormals(self, faceList: MIntArray,
                        vertexList: MIntArray): 
        '''
        lockFaceVertexNormals(self, faceList: MIntArray,
                        vertexList: MIntArray)

        Synopsis
        -----
        Lock Normals for these face/vertex pairs.

        Returns:
        -----
        None

        Parameters:
        -----
        faceList: MIntArray
        	[in] -> The faces to lock normal in 

        vertexList: MIntArray
        	[in] -> The corresponding object-relative (global) vertex indices to lock them for


        '''
        pass

    def unlockVertexNormals(self, vertexList: MIntArray): 
        '''
        unlockVertexNormals(self, vertexList: MIntArray)

        Synopsis
        -----
        Unlock Shared Normals for these vertices.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexList: MIntArray
        	[in] -> The vertices to unlock normals for


        '''
        pass

    def unlockFaceVertexNormals(self, faceList: MIntArray,
                        vertexList: MIntArray): 
        '''
        unlockFaceVertexNormals(self, faceList: MIntArray,
                        vertexList: MIntArray)

        Synopsis
        -----
        Unlock Normals for these face/vertex pairs.

        Returns:
        -----
        None

        Parameters:
        -----
        faceList: MIntArray
        	[in] -> The faces to unlock normal in 

        vertexList: MIntArray
        	[in] -> The corresponding object-relative (global) vertex indices to unlock them for


        '''
        pass

    def getTangentId(self, faceIndex: int,
                        vertexIndex: int,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        getTangentId(self, faceIndex: int,
                        vertexIndex: int,
                        ReturnStatus: MFnMesh.MStatus) -> int

        Synopsis
        -----
        Return the tangent index for a given face vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        faceIndex: int
        	[in] -> Index of the face of interest. 

        vertexIndex: int
        	[in] -> The object-relative (mesh-relative/global) vertex index. 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def getTangents(self, tangents: MFloatVectorArray,
                        space: MSpace.MSpace,
                        uvSet: MString): 
        '''
        getTangents(self, tangents: MFloatVectorArray,
                        space: MSpace.MSpace,
                        uvSet: MString)

        Synopsis
        -----
        Return the tangent vectors for all face vertices. The tangent is
        defined as the surface tangent of the polygon running in the U
        direction defined by the uv map.This method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        tangents: MFloatVectorArray
        	[out] -> Storage for the tangents. 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation. 

        uvSet: MString
        	[in] -> The uv map set to calculate the tangents against.


        '''
        pass

    def getFaceVertexTangent(self, faceIndex: int,
                        vertexIndex: int,
                        tangent: MVector,
                        space: MSpace.MSpace,
                        uvSet: MString): 
        '''
        getFaceVertexTangent(self, faceIndex: int,
                        vertexIndex: int,
                        tangent: MVector,
                        space: MSpace.MSpace,
                        uvSet: MString)

        Synopsis
        -----
        Return the normalized tangent vector at a given face vertex. This
        method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        faceIndex: int
        	[in] -> Index of the face of interest. 

        vertexIndex: int
        	[in] -> The object-relative (mesh-relative/global) vertex index. 

        tangent: MVector
        	[out] -> Storage for the tangent. 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation. 

        uvSet: MString
        	[in] -> The uv map set to calculate the binormals aginst.


        '''
        pass

    def getFaceVertexTangents(self, faceIndex: int,
                        tangents: MFloatVectorArray,
                        space: MSpace.MSpace,
                        uvSet: MString): 
        '''
        getFaceVertexTangents(self, faceIndex: int,
                        tangents: MFloatVectorArray,
                        space: MSpace.MSpace,
                        uvSet: MString)

        Synopsis
        -----
        Return all per-vertex-per-face tangents for a given face. This
        method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        faceIndex: int
        	[in] -> Index of the face (polygon) for which to retrive the tangents 

        tangents: MFloatVectorArray
        	[out] -> Storage for the face tangents 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation 

        uvSet: MString
        	[in] -> The uv map set to calculate the tangents aginst.


        '''
        pass

    def getBinormals(self, binormals: MFloatVectorArray,
                        space: MSpace.MSpace,
                        uvSet: MString): 
        '''
        getBinormals(self, binormals: MFloatVectorArray,
                        space: MSpace.MSpace,
                        uvSet: MString)

        Synopsis
        -----
        Return the binormal vectors for all face vertices. This method is
        not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        binormals: MFloatVectorArray
        	[out] -> Storage for the binormals. 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation. 

        uvSet: MString
        	[in] -> The uv map set to calculate the binormals aginst.


        '''
        pass

    def getFaceVertexBinormal(self, faceIndex: int,
                        vertexIndex: int,
                        binormal: MVector,
                        space: MSpace.MSpace,
                        uvSet: MString): 
        '''
        getFaceVertexBinormal(self, faceIndex: int,
                        vertexIndex: int,
                        binormal: MVector,
                        space: MSpace.MSpace,
                        uvSet: MString)

        Synopsis
        -----
        Return the binormal vector at a given face vertex. This method is
        not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        faceIndex: int
        	[in] -> Index of the face of interest 

        vertexIndex: int
        	[in] -> The object-relative (mesh-relative/global) vertex index 

        binormal: MVector
        	[out] -> Storage for the binormal. 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation. 

        uvSet: MString
        	[in] -> The uv map set to calculate the binormals aginst.


        '''
        pass

    def getFaceVertexBinormals(self, faceIndex: int,
                        binormals: MFloatVectorArray,
                        space: MSpace.MSpace,
                        uvSet: MString): 
        '''
        getFaceVertexBinormals(self, faceIndex: int,
                        binormals: MFloatVectorArray,
                        space: MSpace.MSpace,
                        uvSet: MString)

        Synopsis
        -----
        Return all per-vertex-per-face binormals for a given face. This
        method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        faceIndex: int
        	[in] -> Index of the face (polygon) for which to retrive the binormals 

        binormals: MFloatVectorArray
        	[out] -> Storage for the face binormals 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation 

        uvSet: MString
        	[in] -> The uv map set to calculate the binormals aginst.


        '''
        pass

    def isRightHandedTangent(self, tangentId: int,
                        uvSetName: MString,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        isRightHandedTangent(self, tangentId: int,
                        uvSetName: MString,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        Returns true if the normal, tangent and binormal form a right
        handed coordinate system. By default, Maya uses a right-handed
        system. Mirrored geometry can introduce a left-handed system.

        Returns: 
        ----- 
        true normal, tangent, and binormal are right handed  false
        normal, tangent, and binormal are left handed

        Parameters:
        -----
        tangentId: int
        	[in] -> tangent index for a given face vertex 

        uvSetName: MString
        	[in] -> Name of uv set to use 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def isPolygonConvex(self, faceIndex: int,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        isPolygonConvex(self, faceIndex: int,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        This method determines if the specified polygon is convex.

        Returns: 
        ----- 
        true The polygon is convex  false The edge is concave

        Parameters:
        -----
        faceIndex: int
        	[in] -> The polygon to be tested 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def edgeBorderInfo(self, edgeId: int,
                        setId: int,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        edgeBorderInfo(self, edgeId: int,
                        setId: int,
                        ReturnStatus: MFnMesh.MStatus) -> MFnMesh.MFnMesh

        Synopsis
        -----
        Introduced in 2023.0 This method tells if the specified edge is
        on geom/UV shell border or has shared/unshared UVs.

        Returns:
        -----
        None

        Parameters:
        -----
        edgeId: int
        	[in] -> 

        setId: int
        	[in] -> 

        ReturnStatus: MFnMesh.MStatus
        	[in] -> 


        '''
        pass

    def getUVBorderEdges(self, setId: int,
                        edgeList: MIntArray): 
        '''
        getUVBorderEdges(self, setId: int,
                        edgeList: MIntArray)

        Synopsis
        -----
        Introduced in 2023.0 This method retrieves the edge indices for
        edges lying on a UV border.

        Returns:
        -----
        None

        Parameters:
        -----
        setId: int
        	[in] -> The UV set ID 

        edgeList: MIntArray
        	[out] -> Storage for the edge indices


        '''
        pass

    def getEdgeVertices(self, edgeId: int,
                        vertexList: int2): 
        '''
        getEdgeVertices(self, edgeId: int,
                        vertexList: int2)

        Synopsis
        -----
        This method retrieves the object-relative (mesh-relative/global)
        vertex indices corresponding to the specified edge. The indices
        can be used to refer to the elements in the array returned by the
        'getPoints' method.

        Returns:
        -----
        None

        Parameters:
        -----
        edgeId: int
        	[in] -> The edge to get the vertices for 

        vertexList: int2
        	[out] -> Storage for the 2 object-relative vertex indices


        '''
        pass

    def isEdgeSmooth(self, edgeId: int,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        isEdgeSmooth(self, edgeId: int,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        This method determines if the specified edge is smooth (soft).

        Returns: 
        ----- 
        true The edge is smooth (soft)  false The edge is hard

        Parameters:
        -----
        edgeId: int
        	[in] -> The edge to be tested 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def setEdgeSmoothing(self, edgeId: int,
                        smooth: bool): 
        '''
        setEdgeSmoothing(self, edgeId: int,
                        smooth: bool)

        Synopsis
        -----
        This method sets the specified edge to be hard or smooth (soft).
        You must use the cleanupEdgeSmoothing method after all the
        desired edges on your mesh have had setEdgeSmoothing done. Use
        the updateSurface method to indicate the mesh needs to be
        redrawn.

        Returns:
        -----
        None

        Parameters:
        -----
        edgeId: int
        	[in] -> The edge to set the smoothing information for 

        smooth: bool
        	[in] -> If true the edge will be smooth (soft), otherwise the edge will be hard.


        '''
        pass

    def setEdgeSmoothings(self, edgeIds: MIntArray,
                        smooths: MIntArray): 
        '''
        setEdgeSmoothings(self, edgeIds: MIntArray,
                        smooths: MIntArray)

        Synopsis
        -----
        This method sets the specified edges to be hard or smooth (soft).
        You must use the cleanupEdgeSmoothing method after all the
        desired edges on your mesh have had setEdgeSmoothing done. Use
        the updateSurface method to indicate the mesh needs to be
        redrawn.

        Returns:
        -----
        None

        Parameters:
        -----
        edgeIds: MIntArray
        	[in] -> The edges to set the smoothing information for 

        smooths: MIntArray
        	[in] -> If true the edges will be smooth (soft), otherwise the edges will be hard.


        '''
        pass

    def cleanupEdgeSmoothing(self): 
        '''
        cleanupEdgeSmoothing(self)

        Synopsis
        -----
        This method updates the mesh after setEdgeSmoothing has been
        done. This should be called only once, after all the desired
        edges have been had their soothing set. If you don't call this
        method, the normals may not be correct, and the object will look
        odd in shaded mode.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getCreaseEdges(self, edgeIds: MUintArray,
                        creaseData: MDoubleArray): 
        '''
        getCreaseEdges(self, edgeIds: MUintArray,
                        creaseData: MDoubleArray)

        Synopsis
        -----
        This method returns the crease edges of the mesh, and also the
        crease data associated with those edges. Please note that to make
        effective use of the creasing variable in software outside of
        Maya may require a license under patents owned by Pixar(R).

        Returns:
        -----
        None

        Parameters:
        -----
        edgeIds: MUintArray
        	[out] -> The list of crease edges ids. 

        creaseData: MDoubleArray
        	[out] -> The data related to the crease edges.


        '''
        pass

    def setCreaseEdges(self, edgeIds: MUintArray,
                        creaseData: MDoubleArray): 
        '''
        setCreaseEdges(self, edgeIds: MUintArray,
                        creaseData: MDoubleArray)

        Synopsis
        -----
        This method sets the specified edges of the mesh as crease edges.
        Please note that to make effective use of the creasing variable
        in software outside of Maya may require a license under patents
        owned by Pixar(R).

        Returns:
        -----
        None

        Parameters:
        -----
        edgeIds: MUintArray
        	[in] -> The list of crease edges ids. 

        creaseData: MDoubleArray
        	[in] -> The data related to the crease edges.


        '''
        pass

    def getInvisibleFaces(self, ReturnStatus: MFnMesh.MStatus): 
        '''
        getInvisibleFaces(self, ReturnStatus: MFnMesh.MStatus) -> MUintArray

        Synopsis
        -----
        This method returns the invisible faces of the mesh. Invisible
        faces are like lightweight holes in that they are not rendered
        but do not require additional geometry the way that holes do.
        They have the advantage over holes that if the mesh is smoothed
        then their edges will be smoothed as well, while holes will
        retain their hard edges.Invisible faces can be set using the
        setInvisibleFaces() method or the polyHole command.

        Returns: 
        ----- 
        The list of invisible face ids.

        Parameters:
        -----
        ReturnStatus: MFnMesh.MStatus
        	[out] -> status code


        '''
        pass

    def setInvisibleFaces(self, faceIds: MUintArray,
                        makeVisible: bool): 
        '''
        setInvisibleFaces(self, faceIds: MUintArray,
                        makeVisible: bool)

        Synopsis
        -----
        This method sets the specified faces of the mesh to be visible or
        invisible. See the getInvisibleFaces() method for a description
        of invisible faces.

        Returns:
        -----
        None

        Parameters:
        -----
        faceIds: MUintArray
        	[in] -> The list of face ids to be made visible/invisible. 

        makeVisible: bool
        	[in] -> If true the faces will be made visible. The default is false, which will make them invisible.


        '''
        pass

    def getCreaseVertices(self, vertexIds: MUintArray,
                        creaseData: MDoubleArray): 
        '''
        getCreaseVertices(self, vertexIds: MUintArray,
                        creaseData: MDoubleArray)

        Synopsis
        -----
        This method returns the crease vertices of the mesh, and also the
        crease data associated with those vertices. Please note that to
        make effective use of the creasing variable in software outside
        of Maya may require a license under patents owned by Pixar(R).

        Returns:
        -----
        None

        Parameters:
        -----
        vertexIds: MUintArray
        	[out] -> The list of crease vertices ids. 

        creaseData: MDoubleArray
        	[out] -> The data related to the crease vertices.


        '''
        pass

    def setCreaseVertices(self, vertexIds: MUintArray,
                        creaseData: MDoubleArray): 
        '''
        setCreaseVertices(self, vertexIds: MUintArray,
                        creaseData: MDoubleArray)

        Synopsis
        -----
        This method sets the specified vertices of the mesh as crease
        vertices. Please note that to make effective use of the creasing
        variable in software outside of Maya may require a license under
        patents owned by Pixar(R).

        Returns:
        -----
        None

        Parameters:
        -----
        vertexIds: MUintArray
        	[in] -> The list of crease vertices ids. 

        creaseData: MDoubleArray
        	[in] -> The data related to the crease vertices.


        '''
        pass

    def numUVSets(self, ReturnStatus: MFnMesh.MStatus): 
        '''
        numUVSets(self, ReturnStatus: MFnMesh.MStatus) -> int

        Synopsis
        -----
        Returns the number of uv sets for an object.

        Returns: 
        ----- 
        The number of uv sets for the object

        Parameters:
        -----
        ReturnStatus: MFnMesh.MStatus
        	[out] -> return status value


        '''
        pass

    def createUVSetWithName(self, uvSetName: MString,
                        modifier: MDGModifier,
                        ReturnStatus: MFnMesh.MStatus,
                        instances: MUintArray): 
        '''
        createUVSetWithName(self, uvSetName: MString,
                        modifier: MDGModifier,
                        ReturnStatus: MFnMesh.MStatus,
                        instances: MUintArray) -> MString

        Synopsis
        -----
        Create a new empty uv set for this mesh. If the name passed in is
        empty (zero length), or a uv set with the same name already
        exists, then a new unique name is generated and used as the new
        uvset's name.In the case where the name is empty, the new name
        will be of the format "uvSet#" where # is a number that makes the
        name unique for this mesh.In the case where a uvset already
        exists with the same name as the name passed in, then the new
        name will be of the format "userName#", where "userName" was the
        name specified, and # is a number appended on to "userName" to
        make the name unique for this mesh.This operation will only work
        when the MFnMesh refers to a shape.

        Returns:
        -----
        None

        Parameters:
        -----
        uvSetName: MString
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 

        ReturnStatus: MFnMesh.MStatus
        	[in] -> 

        instances: MUintArray
        	[in] -> 


        '''
        pass

    def copyUVSetWithName(self, fromName: MString,
                        toName: MString,
                        modifier: MDGModifier,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        copyUVSetWithName(self, fromName: MString,
                        toName: MString,
                        modifier: MDGModifier,
                        ReturnStatus: MFnMesh.MStatus) -> MString

        Synopsis
        -----
        Copies a uv set from one to another for this mesh. The source
        must exist. The following cases can occur:1) If the destination
        name is the same as the source than no copy will be made. 2) If
        the destination name exists a copy will be made to the
        destination. 3) If the destination name does not exist, then a
        new uv set will be created with a unique name, and then the copy
        will be made. The name generated will be "destinationName>#",
        where "destinationName" is the original name sent in, and "#" is
        a ascending number appended to the end of the original name.This
        operation will only work when the MFnMesh refers to a shape.

        Returns:
        -----
        None

        Parameters:
        -----
        fromName: MString
        	[in] -> 

        toName: MString
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 

        ReturnStatus: MFnMesh.MStatus
        	[in] -> 


        '''
        pass

    def renameUVSet(self, origName: MString,
                        newName: MString,
                        modifier: MDGModifier): 
        '''
        renameUVSet(self, origName: MString,
                        newName: MString,
                        modifier: MDGModifier)

        Synopsis
        -----
        Renames a uv set from one name to another for this mesh. The
        original name must exist, and the new name cannot be the same
        name as one that already exists. In these cases the uv set will
        not be renamed.This operation will only work when the MFnMesh
        refers to a shape.

        Returns:
        -----
        None

        Parameters:
        -----
        origName: MString
        	[in] -> 

        newName: MString
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 


        '''
        pass

    def deleteUVSet(self, setName: MString,
                        modifier: MDGModifier,
                        currentSelection: MSelectionList): 
        '''
        deleteUVSet(self, setName: MString,
                        modifier: MDGModifier,
                        currentSelection: MSelectionList)

        Synopsis
        -----
        Deletes a named uv set from the object. If a uv set with the
        given name cannot be found, then no uv set will be deleted.This
        operation only works when the MFnMesh refers to a shape.

        Returns:
        -----
        None

        Parameters:
        -----
        setName: MString
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 

        currentSelection: MSelectionList
        	[in] -> 


        '''
        pass

    def setCurrentUVSetName(self, setName: MString,
                        modifier: MDGModifier,
                        currentSelection: MSelectionList): 
        '''
        setCurrentUVSetName(self, setName: MString,
                        modifier: MDGModifier,
                        currentSelection: MSelectionList)

        Synopsis
        -----
        Set the "current" uv set for this object. The "current" uv set is
        the uv set to use when no uv set name is specified for a uv set
        operation. If the uv set does not exist then the "current" uv set
        will not be changed.This operation only works when the MFnMesh is
        a shape.

        Returns:
        -----
        None

        Parameters:
        -----
        setName: MString
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 

        currentSelection: MSelectionList
        	[in] -> 


        '''
        pass

    def currentUVSetName(self, ReturnStatus: MFnMesh.MStatus,
                        instance: int): 
        '''
        currentUVSetName(self, ReturnStatus: MFnMesh.MStatus,
                        instance: int) -> MString

        Synopsis
        -----
        Get the name of the "current" uv set. The "current" uv set is the
        uv set which is used for uv operations when no uv set is
        explicitly specified.On instanced meshes, uv sets may be applied
        on a per-instance basis or may be shared across all instances.
        When the uv sets are per-instance, the concept of the current uv
        set has two levels of granularity. Namely, the current uv set
        applies to one or more instances, plus there are other uv sets in
        the same uv set family that apply to different instances. The
        instance arguement is used to indicate that if this is a per-
        instance uv set, you are interested in the name of the uv set
        that applies to the specified instance. When the index is not
        specified, the current uv set will be returned regardless of
        which instance it is for.If there is no current uv set, then a
        empty string will be returned on the string argument passed in.

        Returns: 
        ----- 
        UV set name.

        Parameters:
        -----
        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code 

        instance: int
        	[in] -> Instance of the mesh whose set we are interested in, or kMFnMeshInstanceUnspecified for the set which is shared across all instances.


        '''
        pass

    def getUVSetNames(self, setNames: MStringArray): 
        '''
        getUVSetNames(self, setNames: MStringArray)

        Synopsis
        -----
        Get the names of all of the uv sets on this object.

        Returns:
        -----
        None

        Parameters:
        -----
        setNames: MStringArray
        	[out] -> Array of uv set names found


        '''
        pass

    def getUVSetFamilyNames(self, familyNames: MStringArray): 
        '''
        getUVSetFamilyNames(self, familyNames: MStringArray)

        Synopsis
        -----
        Get the names of all of the uv set families on this object. A uv
        set family is a set of per-instance sets with the same name with
        each individual set applying to one or more instances. A set
        which is shared across all instances will be the sole member of
        its family.Given a uv set family name, the method
        getUVSetsInFamily may be used to determine the names of the
        associated individual sets.

        Returns:
        -----
        None

        Parameters:
        -----
        familyNames: MStringArray
        	[out] -> Array of uv set names found


        '''
        pass

    def getUVSetsInFamily(self, familyName: MString,
                        setNames: MStringArray): 
        '''
        getUVSetsInFamily(self, familyName: MString,
                        setNames: MStringArray)

        Synopsis
        -----
        Get the names of the uv sets that belong to this set family. Per-
        instance sets will have multiple sets in a family, with each
        individual set applying to one or more instances. A set which is
        shared across all instances will be the sole member of its family
        and will share the same name as its family.

        Returns:
        -----
        None

        Parameters:
        -----
        familyName: MString
        	[in] -> The uv set family name 

        setNames: MStringArray
        	[out] -> Array of uv set names in the family


        '''
        pass

    def isUVSetPerInstance(self, name: MString,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        isUVSetPerInstance(self, name: MString,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        Return true if this set is per-instance, and false if it is
        shared across all instances. The name provided may be an
        individual set name or a set family name.

        Returns: 
        ----- 
        true if the set is per-instance

        Parameters:
        -----
        name: MString
        	[in] -> The set name or set family name 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def getFaceUVSetNames(self, polygonId: int,
                        setNames: MStringArray): 
        '''
        getFaceUVSetNames(self, polygonId: int,
                        setNames: MStringArray)

        Synopsis
        -----
        This method returns the list of UV sets mapped to a face. This
        method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        polygonId: int
        	[in] -> The polygon ID of the face of interest 

        setNames: MStringArray
        	[out] -> The string array to return the UV sets names in


        '''
        pass

    def getAssociatedUVSetTextures(self, uvSetName: MString,
                        textures: MObjectArray): 
        '''
        getAssociatedUVSetTextures(self, uvSetName: MString,
                        textures: MObjectArray)

        Synopsis
        -----
        Get a list of texture nodes which are using a given uv set. If
        the texture has a 2d texture placement, the texture, and not the
        placement will be returned.

        Returns:
        -----
        None

        Parameters:
        -----
        uvSetName: MString
        	[in] -> Name of uv set to use 

        textures: MObjectArray
        	[out] -> Texture nodes using the uv set


        '''
        pass

    def getAssociatedUVSetInstances(self, uvSetName: MString,
                        instances: MIntArray): 
        '''
        getAssociatedUVSetInstances(self, uvSetName: MString,
                        instances: MIntArray)

        Synopsis
        -----
        Get a list of the instance numbers associated with this uv map.
        If the uv map is shared across all instances, an empty array will
        be returned.Note, this method may only be used on an MFnMesh that
        is initialized using a mesh shape. It will return failure if used
        on an MFnMesh that has no associated shape.

        Returns:
        -----
        None

        Parameters:
        -----
        uvSetName: MString
        	[in] -> Name of uv set to use 

        instances: MIntArray
        	[out] -> Instances associated with this uv set


        '''
        pass

    def setUVs(self, uArray: MFloatArray,
                        vArray: MFloatArray,
                        uvSet: MString): 
        '''
        setUVs(self, uArray: MFloatArray,
                        vArray: MFloatArray,
                        uvSet: MString)

        Synopsis
        -----
        Sets all of the texture coordinates (uv's) for this mesh. The uv
        arrays must be of equal size and must be at least as large as the
        current UV set size. You can determine the UV set size by calling
        numUVs() for the default UV set, or numUVs(uvSet) for a named UV
        set.If the arrays are larger than the UV set size, then the uv
        list for this mesh will be grown to accommodate the new uv
        values.After using this method to set the UV values, you must
        call one of the assignUV methods to assign the corresponding UV
        ids to the geometry.In order to shrink the uvs array, do the
        following:These steps will let you to create an array of uvs
        which is smaller than the original one.

        Returns:
        -----
        None

        Parameters:
        -----
        uArray: MFloatArray
        	[in] -> The array of u values to be set 

        vArray: MFloatArray
        	[in] -> The array of v values to be set 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def setSomeUVs(self, uvIds: MIntArray,
                        uArray: MFloatArray,
                        vArray: MFloatArray,
                        uvSet: MString): 
        '''
        setSomeUVs(self, uvIds: MIntArray,
                        uArray: MFloatArray,
                        vArray: MFloatArray,
                        uvSet: MString)

        Synopsis
        -----
        Sets the specified texture coordinates (UV's) for this mesh. The
        uv arrays and uvId array must be of equal size. If the largest
        uvId in the array is larger than numUVs() then the uv list for
        this mesh will be grown to accommodate the new uv values. If a
        named uv set is given, the array will be grown when the largest
        uvId is larger than numUVs(uvSet).If you have added new uvIds,
        you must call one of the assignUV methods to assign the uvIds to
        the geometry. If you are modifying existing UVs, you do not need
        to call one of the assignUV methods.

        Returns:
        -----
        None

        Parameters:
        -----
        uvIds: MIntArray
        	[in] -> The array of uvIds to set values for 

        uArray: MFloatArray
        	[in] -> The array of u values to be set 

        vArray: MFloatArray
        	[in] -> The array of v values to be set 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def getUVs(self, uArray: MFloatArray,
                        vArray: MFloatArray,
                        uvSet: MString): 
        '''
        getUVs(self, uArray: MFloatArray,
                        vArray: MFloatArray,
                        uvSet: MString)

        Synopsis
        -----
        This method copies the texture coordinate list for this mesh into
        the given uv arrays.

        Returns:
        -----
        None

        Parameters:
        -----
        uArray: MFloatArray
        	[out] -> Storage for the u texture coordinate list 

        vArray: MFloatArray
        	[out] -> Storage for the v texture coordinate list 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def setUV(self, uvId: int,
                        u: float,
                        v: float,
                        uvSet: MString): 
        '''
        setUV(self, uvId: int,
                        u: float,
                        v: float,
                        uvSet: MString)

        Synopsis
        -----
        Sets the specified texture coordinate. The uvId is the element in
        the uv list that will be set. If the uvId is greater than or
        equal to numUVs() then the uv list will be grown to accommodate
        the specified uv. If a named uv set is given, the largest uvId
        must be larger than numUVs(uvSet).If the UV being added is new,
        then you must call one of the assignUV methods in order to update
        the geometry.

        Returns:
        -----
        None

        Parameters:
        -----
        uvId: int
        	[in] -> The element in the uv list to be set 

        u: float
        	[in] -> The new u value that is to be set 

        v: float
        	[in] -> The new v value that is to be set 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def getUV(self, uvId: int,
                        u: float,
                        v: float,
                        uvSet: MString): 
        '''
        getUV(self, uvId: int,
                        u: float,
                        v: float,
                        uvSet: MString)

        Synopsis
        -----
        Get the value of the specified texture coordinate from this
        mesh's uv list. The uvId is the element in the uv list that will
        be retrieved.

        Returns:
        -----
        None

        Parameters:
        -----
        uvId: int
        	[in] -> The element in the uv list to examine 

        u: float
        	[out] -> Storage for the u value 

        v: float
        	[out] -> Storage for the v value 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def getPointAtUV(self, polygonId: int,
                        toThisPoint: MPoint,
                        uvPoint: float2,
                        space: MSpace.MSpace,
                        uvSet: MString,
                        tolerance: float): 
        '''
        getPointAtUV(self, polygonId: int,
                        toThisPoint: MPoint,
                        uvPoint: float2,
                        space: MSpace.MSpace,
                        uvSet: MString,
                        tolerance: float)

        Synopsis
        -----
        Return the position of the point at the given UV value in the
        current polygon. This method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        polygonId: int
        	[in] -> Search for uv on this face 

        toThisPoint: MPoint
        	[out] -> Space for the point 

        uvPoint: float2
        	[in] -> The UV value to try to locate 

        space: MSpace.MSpace
        	[in] -> The coordinate system to return "toThisPoint" in 

        uvSet: MString
        	[in] -> UV set to work with 

        tolerance: float
        	[in] -> barycentric tolerance


        '''
        pass

    def getPointsAtUV(self, polygonIds: MIntArray,
                        points: MPointArray,
                        uvPoint: float2,
                        space: MSpace.MSpace,
                        uvSet: MString,
                        tolerance: float): 
        '''
        getPointsAtUV(self, polygonIds: MIntArray,
                        points: MPointArray,
                        uvPoint: float2,
                        space: MSpace.MSpace,
                        uvSet: MString,
                        tolerance: float)

        Synopsis
        -----
        Return the positions of the points at the given UV value on the
        mesh.

        Returns:
        -----
        None

        Parameters:
        -----
        polygonIds: MIntArray
        	[out] -> Storage for polygon ids to the return points. 

        points: MPointArray
        	[out] -> Storage for the points on this surface to the given uv set and coordinate 

        uvPoint: float2
        	[in] -> UV coordinate to be compared 

        space: MSpace.MSpace
        	[in] -> The coordinate system to return "points" in 

        uvSet: MString
        	[in] -> UV set to work with 

        tolerance: float
        	[in] -> tolerance value to compare float data type


        '''
        pass

    def getUVAtPoint(self, pt: MPoint,
                        uvPoint: float2,
                        space: MSpace.MSpace,
                        uvSet: MString,
                        closestPolygon: int): 
        '''
        getUVAtPoint(self, pt: MPoint,
                        uvPoint: float2,
                        space: MSpace.MSpace,
                        uvSet: MString,
                        closestPolygon: int)

        Synopsis
        -----
        Find the point closest to the given point, and return the UV
        value at that point. This method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        pt: MPoint
        	[in] -> The point to try to get UV for 

        uvPoint: float2
        	[out] -> Space for the UV value 

        space: MSpace.MSpace
        	[in] -> The coordinate system for this operation 

        uvSet: MString
        	[in] -> UV set to work with 

        closestPolygon: int
        	[out] -> polygon id of the closest polygon


        '''
        pass

    def getAxisAtPoint(self, pt: MPoint,
                        normal: MVector,
                        uTangent: MVector,
                        vTangent: MVector,
                        space: MSpace.MSpace,
                        uvSet: MString,
                        closestPolygon: int): 
        '''
        getAxisAtPoint(self, pt: MPoint,
                        normal: MVector,
                        uTangent: MVector,
                        vTangent: MVector,
                        space: MSpace.MSpace,
                        uvSet: MString,
                        closestPolygon: int)

        Synopsis
        -----
        Find the point on the mesh which is closest to the given point,
        and return the axis at that point. The axis or affine space is
        defined by non-normalized and non-orthogonized U tangent, V
        tangent and normal. It's useful to detect local surface
        deformation for meshes with similar UV mapping.This method is not
        threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        pt: MPoint
        	[in] -> The point to be queried 

        normal: MVector
        	[out] -> Space for the normal 

        uTangent: MVector
        	[out] -> Space for the U tangent 

        vTangent: MVector
        	[out] -> Space for the V tangent 

        space: MSpace.MSpace
        	[in] -> The coordinate system for this operation 

        uvSet: MString
        	[in] -> UV set to work with 

        closestPolygon: int
        	[out] -> polygon id of the closest polygon


        '''
        pass

    def getPolygonUV(self, polygonId: int,
                        vertexIndex: int,
                        u: float,
                        v: float,
                        uvSet: MString): 
        '''
        getPolygonUV(self, polygonId: int,
                        vertexIndex: int,
                        u: float,
                        v: float,
                        uvSet: MString)

        Synopsis
        -----
        Get the value of the specified texture coordinate for a vertex in
        a polygon. Since texture coordinates (uv's) are stored per-
        polygon per-vertex you must specify both the polygon and the
        vertex that the u and v values are mapped to.This method is not
        threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        polygonId: int
        	[in] -> The polygon (face) to examine 

        vertexIndex: int
        	[in] -> The face-relative (local) vertex id to examine 

        u: float
        	[out] -> Storage for the u value 

        v: float
        	[out] -> Storage for the v value 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def getPolygonUVid(self, polygonId: int,
                        vertexIndex: int,
                        uvId: int,
                        uvSet: MString): 
        '''
        getPolygonUVid(self, polygonId: int,
                        vertexIndex: int,
                        uvId: int,
                        uvSet: MString)

        Synopsis
        -----
        Get the id of the specified texture coordinate for a vertex in a
        polygon. This method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        polygonId: int
        	[in] -> The polygon (face) to examine 

        vertexIndex: int
        	[in] -> The face-relative (local) vertex id to examine 

        uvId: int
        	[out] -> Storage for the uv index 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def assignUV(self, polygonId: int,
                        vertexIndex: int,
                        uvId: int,
                        uvSet: MString): 
        '''
        assignUV(self, polygonId: int,
                        vertexIndex: int,
                        uvId: int,
                        uvSet: MString)

        Synopsis
        -----
        Maps a texture coordinate to a specified vertex of a polygon.
        Since texture coordinates (uv's) are stored per-polygon per-
        vertex you must specify both the polygon and the vertex that the
        uv entry is mapped to.The vertexIndex (face-relative/local) is
        the vertex within the polygon that the uv will be mapped to. This
        index must be in the range 0 to polygonVertexCount(polygonId).

        Returns:
        -----
        None

        Parameters:
        -----
        polygonId: int
        	[in] -> The polygon (face) to map to 

        vertexIndex: int
        	[in] -> The face-relative (local) vertex id of the polygon to map to 

        uvId: int
        	[in] -> The uv entry from the uv list that will be mapped 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def assignUVs(self, uvCounts: MIntArray,
                        uvIds: MIntArray,
                        uvSet: MString): 
        '''
        assignUVs(self, uvCounts: MIntArray,
                        uvIds: MIntArray,
                        uvSet: MString)

        Synopsis
        -----
        This method maps all texture coordinates for the mesh. The
        setUV/setUVs method is used to create the texture coordinate
        table for the mesh. After the table is created, this method is
        used to map those values to each polygon on a per-vertex basis.
        The setUV/setUVs method should be called before the assignUVs
        method.The uvCounts array should contain the number of uv's per
        polygon. Since uv's are mapped per-polygon per-vertex, the
        entries in this array should match the vertex counts for each
        polygon in the mesh. For example, the array for a cube would be {
        4, 4, 4, 4, 4, 4 } since there are 6 polygons each with 4
        vertices.If an entry in this array is '0' then the corresponding
        polygon will not be mapped. The sum of all the entries in the
        uvCounts array must be equal to the size of the uvIds array or
        this method will fail.The uvIds array should contain the UV
        indices that will be mapped to each polygon-vertex in the mesh.
        The entries in this array specify which uv's in the mesh's uv
        table are mapped to each polygon-vertex. Each entry in the uvIds
        array must be less than numUVs(), or numUVs(uvSet) for a named
        uvSet. The size of the uvIds array is equivalent to adding up all
        of the entries in the uvCounts array, so for a cube with all
        polygons mapped there would be 24 entries.

        Returns:
        -----
        None

        Parameters:
        -----
        uvCounts: MIntArray
        	[in] -> The uv counts for each polygon (face) in the mesh 

        uvIds: MIntArray
        	[in] -> The uv indices to be mapped to each polygon-vertex 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def clearUVs(self, uvSet: MString): 
        '''
        clearUVs(self, uvSet: MString)

        Synopsis
        -----
        This method clears out all texture coordinates for the mesh, and
        leaves behind an empty UVset. This method should be used if it is
        needed to shrink the actual size of the UV table. In this case,
        the user should call clearUVs, setUVs and then assignUVs to
        rebuild the mapping info.When called on a dataMesh, the UVs are
        removed. When called on a shape with no history, the UVs are
        removed and the attributes are set on the shape. When called on a
        shape with history, the polyMapDel command is invoked and a
        polyMapDel node is created.

        Returns:
        -----
        None

        Parameters:
        -----
        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def getAssignedUVs(self, uvCounts: MIntArray,
                        uvIds: MIntArray,
                        uvSet: MString): 
        '''
        getAssignedUVs(self, uvCounts: MIntArray,
                        uvIds: MIntArray,
                        uvSet: MString)

        Synopsis
        -----
        Get assigned UVs. This method finds all texture coordinates for
        the mesh that have been mapped, and returns them in the same
        format as the assignUVs.The uvCounts array that is returned will
        contain the number of uv's per polygon. Since uv's are mapped
        per-polygon per-vertex, the entries in this array will match the
        vertex counts for each polygon in the mesh. For example, the
        array for a cube would be { 4, 4, 4, 4, 4, 4 } since there are 6
        polygons each with 4 vertices.The uvIds array will contain the UV
        indices that are mapped to each polygon-vertex in the mesh. The
        entries in this array indicate which uv's in the mesh's uv table
        are mapped to each polygon-vertex. Each entry in the uvIds array
        will be less than numUVs(), or numUVs(uvSet) for a named uvSet.
        The size of the uvIds array is equivalent to adding up all of the
        entries in the uvCounts array, so for a cube with all polygons
        mapped there will be 24 entries.This method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        uvCounts: MIntArray
        	[out] -> The container for the uv counts for each polygon in the mesh 

        uvIds: MIntArray
        	[out] -> The container for the uv indices mapped to each polygon-vertex 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def getUvShellsIds(self, uvShellIds: MIntArray,
                        nbUvShells: int,
                        uvSet: MString): 
        '''
        getUvShellsIds(self, uvShellIds: MIntArray,
                        nbUvShells: int,
                        uvSet: MString)

        Synopsis
        -----
        Constructs an array of unique integer for each UV shell. This
        method let the user identify each connected piece of UV.The
        uvShellIds array that is returned will contain a UV shell number
        for each UV in the given UV set. This number uniquely identifies
        a connected piece in the UV set. Numbers are positive, starting
        at 0.For example, the array { 0, 0, 0, 1, 1, 1, 1, 0} would
        represent an object where UVs 0, 1, 2 and 7 are connected
        together (UV shell number 0), and UVs 3 to 6 belong to shell
        number 1.

        Returns:
        -----
        None

        Parameters:
        -----
        uvShellIds: MIntArray
        	[out] -> The container for the uv shell Ids 

        nbUvShells: int
        	[out] -> The number of UV shells in this UV set. 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def getMeshShellsIds(self, compType: MFn.MFn,
                        meshShellIds: MIntArray,
                        nbMeshShells: int): 
        '''
        getMeshShellsIds(self, compType: MFn.MFn,
                        meshShellIds: MIntArray,
                        nbMeshShells: int)

        Synopsis
        -----
        Introduced in 2023.0 Constructs an array of unique integer for
        each mesh shell.This method let the user identify each connected
        piece of mesh.The meshShellIds array that is returned will
        contain a mesh shell number for each face. This number uniquely
        identifies a connected set of components. Numbers are positive,
        starting at 0.For example, the array { 0, 0, 0, 1, 1, 1, 1, 0}
        would represent an object where components 0, 1, 2 and 7 are
        connected together (mesh shell number 0), and components 3 to 6
        belong to shell number 1.

        Returns:
        -----
        None

        Parameters:
        -----
        compType: MFn.MFn
        	[in] -> The type of component we query for: kMeshPolygonComponent, kMeshVertComponent, kMeshEdgeComponent 

        meshShellIds: MIntArray
        	[out] -> The container for the mesh shell Ids 

        nbMeshShells: int
        	[out] -> The number of mesh shells.


        '''
        pass

    def getPinUVs(self, uvIds: MUintArray,
                        pinData: MDoubleArray,
                        uvSet: MString): 
        '''
        getPinUVs(self, uvIds: MUintArray,
                        pinData: MDoubleArray,
                        uvSet: MString)

        Synopsis
        -----
        This method returns the pin uvs of the mesh, and also the pin
        data associated with those uvs.

        Returns:
        -----
        None

        Parameters:
        -----
        uvIds: MUintArray
        	[out] -> The list of pin uvs ids. 

        pinData: MDoubleArray
        	[out] -> The list of pin weights. 

        uvSet: MString
        	[in] -> UV set to work with.


        '''
        pass

    def setPinUVs(self, uvIds: MUintArray,
                        pinData: MDoubleArray,
                        uvSet: MString): 
        '''
        setPinUVs(self, uvIds: MUintArray,
                        pinData: MDoubleArray,
                        uvSet: MString)

        Synopsis
        -----
        This method sets the specified uvs of the mesh as "pinned" uvs, a
        "pinned" uv is one which should not be modified. If pin weight is
        set to 1.0 then it becomes fully pinned and uv tools should not
        modify that uv. If the pin weight is set to a value between 0.0
        and 1.0 then uv tools should weight their changes to that uv
        accordingly.

        Returns:
        -----
        None

        Parameters:
        -----
        uvIds: MUintArray
        	[in] -> The list of pin uvs ids. 

        pinData: MDoubleArray
        	[in] -> The list of pin weights. 

        uvSet: MString
        	[in] -> UV set to work with.


        '''
        pass

    def isPolygonUVReversed(self, polygonId: int,
                        uvSet: MString,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        isPolygonUVReversed(self, polygonId: int,
                        uvSet: MString,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        This method determines if the winding order of texture
        coordinates (uv's) for specified polygon are reversed (clockwise)

        Returns: 
        ----- 
        true The texture coordinates (uv's) are reversed (clockwise)
        false The texture coordinates (uv's) are not reversed (counter
        clockwise)

        Parameters:
        -----
        polygonId: int
        	[in] -> The polygon to be tested 

        uvSet: MString
        	[in] -> UV set to work with 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def numColorSets(self, ReturnStatus: MFnMesh.MStatus): 
        '''
        numColorSets(self, ReturnStatus: MFnMesh.MStatus) -> int

        Synopsis
        -----
        Returns the number of color sets for an object.

        Returns: 
        ----- 
        The number of color sets for the object

        Parameters:
        -----
        ReturnStatus: MFnMesh.MStatus
        	[out] -> return status value


        '''
        pass

    def createColorSetWithName(self, colorSetName: MString,
                        modifier: MDGModifier,
                        instances: MUintArray,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        createColorSetWithName(self, colorSetName: MString,
                        modifier: MDGModifier,
                        instances: MUintArray,
                        ReturnStatus: MFnMesh.MStatus) -> MString

        Synopsis
        -----
        Create a new empty color set for this mesh. If the name passed in
        is empty (zero length), or a color set with the same name already
        exists, then a new unique name is generated and used as the new
        color set's name.In the case where the name is empty, the new
        name will be of the format "colorSet#" where # is a number that
        makes the name unique for this mesh.In the case where a color set
        already exists with the same name as the name passed in, then the
        new name will be of the format "userName#", where "userName" was
        the name specified, and # is a number appended on to "userName"
        to make the name unique for this mesh.This operation will only
        work when the MFnMesh refers to a shape.

        Returns:
        -----
        None

        Parameters:
        -----
        colorSetName: MString
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 

        instances: MUintArray
        	[in] -> 

        ReturnStatus: MFnMesh.MStatus
        	[in] -> 


        '''
        pass

    def deleteColorSet(self, colorSetName: MString,
                        modifier: MDGModifier,
                        currentSelection: MSelectionList): 
        '''
        deleteColorSet(self, colorSetName: MString,
                        modifier: MDGModifier,
                        currentSelection: MSelectionList)

        Synopsis
        -----
        Deletes a named color set from the object. If a color set with
        the given name cannot be found, then no color set will be
        deleted.This operation only works when the MFnMesh refers to a
        shape.

        Returns:
        -----
        None

        Parameters:
        -----
        colorSetName: MString
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 

        currentSelection: MSelectionList
        	[in] -> 


        '''
        pass

    def setCurrentColorSetName(self, setName: MString,
                        modifier: MDGModifier,
                        currentSelection: MSelectionList): 
        '''
        setCurrentColorSetName(self, setName: MString,
                        modifier: MDGModifier,
                        currentSelection: MSelectionList)

        Synopsis
        -----
        Set the "current" or "working" color set for this object. The
        "current" color set is the set to use by functions that do not
        have a specific color set defined.This operation only works when
        the MFnMesh is a shape.

        Returns:
        -----
        None

        Parameters:
        -----
        setName: MString
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 

        currentSelection: MSelectionList
        	[in] -> 


        '''
        pass

    def currentColorSetName(self, instance: int,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        currentColorSetName(self, instance: int,
                        ReturnStatus: MFnMesh.MStatus) -> MString

        Synopsis
        -----
        Get the name of the "current" or "working" color set. The
        "current" color set is the color set which is used for color
        operations when no color set is explcitly specified.If there is
        no current color set, then a empty string will be returned on the
        string argument passed on.On instanced meshes, color sets may be
        applied on a per-instance basis or may be shared across all
        instances. When the color sets are per-instance, the concept of
        the current color set has two levels of granularity. Namely, the
        current color set applies to one or more instances, plus there
        are other color sets in the same color set family that apply to
        different instances. The instance arguement is used to indicate
        that if this is a per-instance color set, you are interested in
        the name of the color set that applies to the specified instance.
        When the index is not specified, the current color set will be
        returned regardless of which instance it is for.

        Returns: 
        ----- 
        Name of the "current" color set, if any.

        Parameters:
        -----
        instance: int
        	[in] -> Instance of the mesh whose set we are interested in, or kMFnMeshInstanceUnspecified for the set which is shared across all instances. 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code. See below.


        '''
        pass

    def getColorSetNames(self, setNames: MStringArray): 
        '''
        getColorSetNames(self, setNames: MStringArray)

        Synopsis
        -----
        Get the names of all of the colors sets on this object.

        Returns:
        -----
        None

        Parameters:
        -----
        setNames: MStringArray
        	[out] -> Array of color set names found


        '''
        pass

    def getColorSetFamilyNames(self, familyNames: MStringArray): 
        '''
        getColorSetFamilyNames(self, familyNames: MStringArray)

        Synopsis
        -----
        Get the names of all of the color set families on this object. A
        color set family is a set of per-instance sets with the same name
        with each individual set applying to one or more instances. A set
        which is shared across all instances will be the sole member of
        its family.Given a color set family name, the method
        getColorSetsInFamily may be used to determine the names of the
        associated individual sets.

        Returns:
        -----
        None

        Parameters:
        -----
        familyNames: MStringArray
        	[out] -> Array of color set names found


        '''
        pass

    def getColorSetsInFamily(self, familyName: MString,
                        setNames: MStringArray): 
        '''
        getColorSetsInFamily(self, familyName: MString,
                        setNames: MStringArray)

        Synopsis
        -----
        Get the names of the color sets that belong to this set family.
        Per-instance sets will have multiple sets in a family, with each
        individual set applying to one or more instances. A set which is
        shared across all instances will be the sole member of its family
        and will share the same name as its family.

        Returns:
        -----
        None

        Parameters:
        -----
        familyName: MString
        	[out] -> The color set family name 

        setNames: MStringArray
        	[out] -> Array of color set names in the family


        '''
        pass

    def isColorSetPerInstance(self, name: MString,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        isColorSetPerInstance(self, name: MString,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        Return true if this color set is per-instance, and false if it is
        shared across all instances. The name provided may be an
        individual set name or a set family name.

        Returns: 
        ----- 
        true if the set is per-instance

        Parameters:
        -----
        name: MString
        	[in] -> The set name or set family name 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    def getAssociatedColorSetInstances(self, colorSetName: MString,
                        instances: MIntArray): 
        '''
        getAssociatedColorSetInstances(self, colorSetName: MString,
                        instances: MIntArray)

        Synopsis
        -----
        Get a list of the instance numbers associated with this color
        map. If the color map is shared across all instances, an empty
        array will be returned.Note, this method may only be used on an
        MFnMesh that is initialized using a mesh shape. It will return
        failure if used on an MFnMesh that has no associated shape.

        Returns:
        -----
        None

        Parameters:
        -----
        colorSetName: MString
        	[in] -> Name of color set to use 

        instances: MIntArray
        	[out] -> Instances associated with this color set


        '''
        pass

    @overload
    def setFaceColor(self, color: MColor,
                        faceIndex: int): 
        '''
        setFaceColor(self, color: MColor,
                        faceIndex: int)

        Synopsis
        -----
        Set vertex-face Color for all vertices on this face.

        Returns:
        -----
        None

        Parameters:
        -----
        color: MColor
        	[in] -> The color to set 

        faceIndex: int
        	[in] -> The face to set it for


        '''
        pass

    @overload
    def setFaceColor(self, color: MColor,
                        faceIndex: int,
                        rep: MFnMesh.MColorRepresentation): 
        '''
        setFaceColor(self, color: MColor,
                        faceIndex: int,
                        rep: MFnMesh.MColorRepresentation)

        Synopsis
        -----
        Set vertex-face Color of specified channels for all vertices on
        this face.

        Returns:
        -----
        None

        Parameters:
        -----
        color: MColor
        	[in] -> The color to set 

        faceIndex: int
        	[in] -> The face to set it for 

        rep: MFnMesh.MColorRepresentation
        	[in] -> The RGB/RGBA/A channel(s) to set


        '''
        pass

    @overload
    def setVertexColor(self, color: MColor,
                        vertexIndex: int,
                        modifier: MDGModifier): 
        '''
        setVertexColor(self, color: MColor,
                        vertexIndex: int,
                        modifier: MDGModifier)

        Synopsis
        -----
        Set color for this vertex. The color is set for the vertex-face
        in each face that the vertex belongs to.NOTE: To change the
        colors of many vertices, it is more efficient to use the batch
        updating method setVertexColors() instead.

        Returns:
        -----
        None

        Parameters:
        -----
        color: MColor
        	[in] -> 

        vertexIndex: int
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 


        '''
        pass

    @overload
    def setVertexColor(self, color: MColor,
                        vertexIndex: int,
                        modifier: MDGModifier,
                        rep: MFnMesh.MColorRepresentation): 
        '''
        setVertexColor(self, color: MColor,
                        vertexIndex: int,
                        modifier: MDGModifier,
                        rep: MFnMesh.MColorRepresentation)

        Synopsis
        -----
        Set color of specified channels for this vertex. The color is set
        for the vertex-face in each face that the vertex belongs to.NOTE:
        To change the colors of many vertices, it is more efficient to
        use the batch updating method setVertexColors() instead.

        Returns:
        -----
        None

        Parameters:
        -----
        color: MColor
        	[in] -> 

        vertexIndex: int
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 

        rep: MFnMesh.MColorRepresentation
        	[in] -> 


        '''
        pass

    @overload
    def setFaceVertexColor(self, color: MColor,
                        faceIndex: int,
                        vertexIndex: int,
                        modifier: MDGModifier): 
        '''
        setFaceVertexColor(self, color: MColor,
                        faceIndex: int,
                        vertexIndex: int,
                        modifier: MDGModifier)

        Synopsis
        -----
        Set color for this vertex in this face.

        Returns:
        -----
        None

        Parameters:
        -----
        color: MColor
        	[in] -> 

        faceIndex: int
        	[in] -> 

        vertexIndex: int
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 


        '''
        pass

    @overload
    def setFaceVertexColor(self, color: MColor,
                        faceIndex: int,
                        vertexIndex: int,
                        modifier: MDGModifier,
                        rep: MFnMesh.MColorRepresentation): 
        '''
        setFaceVertexColor(self, color: MColor,
                        faceIndex: int,
                        vertexIndex: int,
                        modifier: MDGModifier,
                        rep: MFnMesh.MColorRepresentation)

        Synopsis
        -----
        Set color of specified channels for this vertex in this face.

        Returns:
        -----
        None

        Parameters:
        -----
        color: MColor
        	[in] -> 

        faceIndex: int
        	[in] -> 

        vertexIndex: int
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 

        rep: MFnMesh.MColorRepresentation
        	[in] -> 


        '''
        pass

    @overload
    def setFaceVertexColor(self, faceIndex: int,
                        localVertexIndex: int,
                        color: MColor,
                        modifier: MDGModifier): 
        '''
        setFaceVertexColor(self, faceIndex: int,
                        localVertexIndex: int,
                        color: MColor,
                        modifier: MDGModifier)

        Synopsis
        -----
        Set color for this vertex in this face.

        Returns:
        -----
        None

        Parameters:
        -----
        faceIndex: int
        	[in] -> 

        localVertexIndex: int
        	[in] -> 

        color: MColor
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 


        '''
        pass

    @overload
    def setFaceVertexColor(self, faceIndex: int,
                        localVertexIndex: int,
                        color: MColor,
                        modifier: MDGModifier,
                        rep: MFnMesh.MColorRepresentation): 
        '''
        setFaceVertexColor(self, faceIndex: int,
                        localVertexIndex: int,
                        color: MColor,
                        modifier: MDGModifier,
                        rep: MFnMesh.MColorRepresentation)

        Synopsis
        -----
        Set color of specified channels for this vertex in this face.

        Returns:
        -----
        None

        Parameters:
        -----
        faceIndex: int
        	[in] -> 

        localVertexIndex: int
        	[in] -> 

        color: MColor
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 

        rep: MFnMesh.MColorRepresentation
        	[in] -> 


        '''
        pass

    @overload
    def setFaceColors(self, colors: MColorArray,
                        faceList: MIntArray): 
        '''
        setFaceColors(self, colors: MColorArray,
                        faceList: MIntArray)

        Synopsis
        -----
        Set color for these faces. The color will be set for each vertex-
        face component of a face.

        Returns:
        -----
        None

        Parameters:
        -----
        colors: MColorArray
        	[in] -> The colors to set 

        faceList: MIntArray
        	[in] -> The faces to set it for


        '''
        pass

    @overload
    def setFaceColors(self, colors: MColorArray,
                        faceList: MIntArray,
                        rep: MFnMesh.MColorRepresentation): 
        '''
        setFaceColors(self, colors: MColorArray,
                        faceList: MIntArray,
                        rep: MFnMesh.MColorRepresentation)

        Synopsis
        -----
        Set color of specified channels for these faces. The color will
        be set for each vertex-face component of a face.

        Returns:
        -----
        None

        Parameters:
        -----
        colors: MColorArray
        	[in] -> The colors to set 

        faceList: MIntArray
        	[in] -> The faces to set it for 

        rep: MFnMesh.MColorRepresentation
        	[in] -> The RGB/RGBA/A channel(s) to set


        '''
        pass

    @overload
    def setVertexColors(self, colors: MColorArray,
                        vertexList: MIntArray,
                        modifier: MDGModifier): 
        '''
        setVertexColors(self, colors: MColorArray,
                        vertexList: MIntArray,
                        modifier: MDGModifier)

        Synopsis
        -----
        Set color for these vertices.

        Returns:
        -----
        None

        Parameters:
        -----
        colors: MColorArray
        	[in] -> 

        vertexList: MIntArray
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 


        '''
        pass

    @overload
    def setVertexColors(self, colors: MColorArray,
                        vertexList: MIntArray,
                        modifier: MDGModifier,
                        rep: MFnMesh.MColorRepresentation): 
        '''
        setVertexColors(self, colors: MColorArray,
                        vertexList: MIntArray,
                        modifier: MDGModifier,
                        rep: MFnMesh.MColorRepresentation)

        Synopsis
        -----
        Set color of specified channels for these vertices.

        Returns:
        -----
        None

        Parameters:
        -----
        colors: MColorArray
        	[in] -> 

        vertexList: MIntArray
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 

        rep: MFnMesh.MColorRepresentation
        	[in] -> 


        '''
        pass

    @overload
    def setFaceVertexColors(self, colors: MColorArray,
                        faceList: MIntArray,
                        vertexList: MIntArray,
                        modifier: MDGModifier): 
        '''
        setFaceVertexColors(self, colors: MColorArray,
                        faceList: MIntArray,
                        vertexList: MIntArray,
                        modifier: MDGModifier)

        Synopsis
        -----
        Set colors for these face/vertex pairs.

        Returns:
        -----
        None

        Parameters:
        -----
        colors: MColorArray
        	[in] -> 

        faceList: MIntArray
        	[in] -> 

        vertexList: MIntArray
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 


        '''
        pass

    @overload
    def setFaceVertexColors(self, colors: MColorArray,
                        faceList: MIntArray,
                        vertexList: MIntArray,
                        modifier: MDGModifier,
                        rep: MFnMesh.MColorRepresentation): 
        '''
        setFaceVertexColors(self, colors: MColorArray,
                        faceList: MIntArray,
                        vertexList: MIntArray,
                        modifier: MDGModifier,
                        rep: MFnMesh.MColorRepresentation)

        Synopsis
        -----
        Set colors of specified channels for these face/vertex pairs.

        Returns:
        -----
        None

        Parameters:
        -----
        colors: MColorArray
        	[in] -> 

        faceList: MIntArray
        	[in] -> 

        vertexList: MIntArray
        	[in] -> 

        modifier: MDGModifier
        	[in] -> 

        rep: MFnMesh.MColorRepresentation
        	[in] -> 


        '''
        pass

    def removeFaceColors(self, faceList: MIntArray): 
        '''
        removeFaceColors(self, faceList: MIntArray)

        Synopsis
        -----
        Remove previously set color these faces. For each face, the color
        will be unset for each vertex-face component in the face.

        Returns:
        -----
        None

        Parameters:
        -----
        faceList: MIntArray
        	[in] -> The faces to remove color from


        '''
        pass

    def removeVertexColors(self, vertexList: MIntArray): 
        '''
        removeVertexColors(self, vertexList: MIntArray)

        Synopsis
        -----
        Remove color from these vertices.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexList: MIntArray
        	[in] -> The object-relative (mesh-relative/global) vertex indices to remove color from


        '''
        pass

    def removeFaceVertexColors(self, faceList: MIntArray,
                        vertexList: MIntArray): 
        '''
        removeFaceVertexColors(self, faceList: MIntArray,
                        vertexList: MIntArray)

        Synopsis
        -----
        Remove colors for these face/vertex pairs.

        Returns:
        -----
        None

        Parameters:
        -----
        faceList: MIntArray
        	[in] -> The faces to remove color for 

        vertexList: MIntArray
        	[in] -> The corresponding object-relative (mesh-relative/global) vertex indices to remove color for


        '''
        pass

    def getVertexColors(self, colors: MColorArray,
                        colorSet: MString,
                        defaultUnsetColor: MColor): 
        '''
        getVertexColors(self, colors: MColorArray,
                        colorSet: MString,
                        defaultUnsetColor: MColor)

        Synopsis
        -----
        Get colors for all Vertices of the given colorSet. If the
        colorSet is not specified, the default color set will be used. If
        no vertex/face has color for that vertex, the entry returned will
        be defaultUnsetColor. If the defaultUnsetColor is not given, then
        (-1, -1, -1, -1) will be used. If a color was set for some or all
        the faces for that vertex, an average of those verted/face values
        where the color has been set will be returned.

        Returns:
        -----
        None

        Parameters:
        -----
        colors: MColorArray
        	[out] -> Storage for the colors to be returned. 

        colorSet: MString
        	[in] -> Color set name 

        defaultUnsetColor: MColor
        	[in] -> Default Unset color


        '''
        pass

    def getFaceVertexColors(self, colors: MColorArray,
                        colorSet: MString,
                        defaultUnsetColor: MColor): 
        '''
        getFaceVertexColors(self, colors: MColorArray,
                        colorSet: MString,
                        defaultUnsetColor: MColor)

        Synopsis
        -----
        Get colors for all vertex/faces of the given color set. If the
        color set is not specified, the default color set will be used.
        If no vertex/face has color for that vertex, the entry returned
        will be defaultUnsetColor. If defaultUnsetColor is not given,
        then (-1, -1, -1, -1) will be used. If a color was set for some
        but not all the faces for that vertex, the ones where the color
        has not been explicitly set will have (0,0,0). If a vertex has
        shared color, the same value will be set for all its
        vertes/faces.The colors are returned in face order: e.g. F0V0,
        F0V1.. F0Vn, F1V0, etc... Use the index returned by
        getFaceVertexColorIndex if you wish to index directly into the
        returned color array.This method is not threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        colors: MColorArray
        	[out] -> Storage for the colors to be returned. 

        colorSet: MString
        	[in] -> Color set name 

        defaultUnsetColor: MColor
        	[in] -> Default unset color


        '''
        pass

    def getFaceVertexColorIndex(self, faceIndex: int,
                        localVertexIndex: int,
                        colorIndex: int,
                        colorSet: MString): 
        '''
        getFaceVertexColorIndex(self, faceIndex: int,
                        localVertexIndex: int,
                        colorIndex: int,
                        colorSet: MString)

        Synopsis
        -----
        Get an index into the array returned by getFaceVertexColors. So
        that you can index into the array directly, instead of walking it
        in face-vertex order.

        Returns:
        -----
        None

        Parameters:
        -----
        faceIndex: int
        	[in] -> The face to look for 

        localVertexIndex: int
        	[in] -> The face-relative (local) vertex id to look for 

        colorIndex: int
        	[out] -> Storage for the color index to be returned. 

        colorSet: MString
        	[in] -> Color set to work with


        '''
        pass

    @overload
    def setColors(self, colorArray: MColorArray,
                        colorSet: MString): 
        '''
        setColors(self, colorArray: MColorArray,
                        colorSet: MString)

        Synopsis
        -----
        Sets all of the colors for this mesh. The color array must be at
        least as large as the current color set size. You can determine
        the color set size by calling numColors() for the default color
        set, or numColors(colorSet) for a named color set.If the array is
        larger than the color set size, then the color list for this mesh
        will be grown to accommodate the new color values.After using
        this method to set the color values, you can call assignColors to
        assign the corresponding color ids to the geometry.In order to
        shrink the color array, do the following:These steps will let you
        to create an array of colors which is smaller than the original
        one.

        Returns:
        -----
        None

        Parameters:
        -----
        colorArray: MColorArray
        	[in] -> The array of color values to be set 

        colorSet: MString
        	[in] -> The color set to work with


        '''
        pass

    @overload
    def setColors(self, colorArray: MColorArray,
                        colorSet: MString,
                        rep: MFnMesh.MColorRepresentation): 
        '''
        setColors(self, colorArray: MColorArray,
                        colorSet: MString,
                        rep: MFnMesh.MColorRepresentation)

        Synopsis
        -----
        Sets all of the colors of specified channels for this mesh. The
        color array must be at least as large as the current color set
        size. You can determine the color set size by calling numColors()
        for the default color set, or numColors(colorSet) for a named
        color set.If the array is larger than the color set size, then
        the color list for this mesh will be grown to accommodate the new
        color values.After using this method to set the color values, you
        can call assignColors to assign the corresponding color ids to
        the geometry.In order to shrink the color array, do the
        following:These steps will let you to create an array of colors
        which is smaller than the original one.

        Returns:
        -----
        None

        Parameters:
        -----
        colorArray: MColorArray
        	[in] -> The array of color values to be set 

        colorSet: MString
        	[in] -> The color set to work with 

        rep: MFnMesh.MColorRepresentation
        	[in] -> The RGB/RGBA/A channel(s) to set


        '''
        pass

    @overload
    def setSomeColors(self, colorIds: MIntArray,
                        colorArray: MColorArray,
                        colorSet: MString): 
        '''
        setSomeColors(self, colorIds: MIntArray,
                        colorArray: MColorArray,
                        colorSet: MString)

        Synopsis
        -----
        Sets the specified colors for this mesh. If the largest colorId
        in the array is larger than numColors() then the color list for
        this mesh will be grown to accommodate the new color values.If
        you have added new colorIds, you can call assignColors to assign
        the colorIds to the geometry. If you are modifying existing
        colors, they will already be referenced by the existing mesh
        data.

        Returns:
        -----
        None

        Parameters:
        -----
        colorIds: MIntArray
        	[in] -> The array of colorIds to set values for 

        colorArray: MColorArray
        	[in] -> The array of color values to be set 

        colorSet: MString
        	[in] -> Color set to work with


        '''
        pass

    @overload
    def setSomeColors(self, colorIds: MIntArray,
                        colorArray: MColorArray,
                        colorSet: MString,
                        rep: MFnMesh.MColorRepresentation): 
        '''
        setSomeColors(self, colorIds: MIntArray,
                        colorArray: MColorArray,
                        colorSet: MString,
                        rep: MFnMesh.MColorRepresentation)

        Synopsis
        -----
        Sets the specified colors of specified channels for this mesh. If
        the largest colorId in the array is larger than numColors() then
        the color list for this mesh will be grown to accommodate the new
        color values.If you have added new colorIds, you can call
        assignColors to assign the colorIds to the geometry. If you are
        modifying existing colors, they will already be referenced by the
        existing mesh data.

        Returns:
        -----
        None

        Parameters:
        -----
        colorIds: MIntArray
        	[in] -> The array of colorIds to set values for 

        colorArray: MColorArray
        	[in] -> The array of color values to be set 

        colorSet: MString
        	[in] -> Color set to work with 

        rep: MFnMesh.MColorRepresentation
        	[in] -> The RGB/RGBA/A channel(s) to set


        '''
        pass

    def getColors(self, colorArray: MColorArray,
                        colorSet: MString,
                        defaultUnsetColor: MColor): 
        '''
        getColors(self, colorArray: MColorArray,
                        colorSet: MString,
                        defaultUnsetColor: MColor)

        Synopsis
        -----
        This method copies the color array for this mesh into the given
        color array. Use the index returned by getColorIndex to access
        the array. If the color is not set for a vertex,
        defaultUnsetColor will be returned. If defaultUnsetColor is not
        set, (0,0,0,1) will be returned.

        Returns:
        -----
        None

        Parameters:
        -----
        colorArray: MColorArray
        	[out] -> Storage for the color values list 

        colorSet: MString
        	[in] -> Color set to work with 

        defaultUnsetColor: MColor
        	[in] -> Default unset color


        '''
        pass

    def getColorIndex(self, faceIndex: int,
                        localVertexIndex: int,
                        colorIndex: int,
                        colorSet: MString): 
        '''
        getColorIndex(self, faceIndex: int,
                        localVertexIndex: int,
                        colorIndex: int,
                        colorSet: MString)

        Synopsis
        -----
        Get an index into the array returned by getColors.

        Returns:
        -----
        None

        Parameters:
        -----
        faceIndex: int
        	[in] -> The face to look for 

        localVertexIndex: int
        	[in] -> The face-relative (local) vertex id to look for 

        colorIndex: int
        	[out] -> Storage for the color index to be returned. 

        colorSet: MString
        	[in] -> Color set to work with


        '''
        pass

    @overload
    def setColor(self, colorId: int,
                        color: MColor,
                        colorSet: MString): 
        '''
        setColor(self, colorId: int,
                        color: MColor,
                        colorSet: MString)

        Synopsis
        -----
        Sets the specified color values. The colorId is the element in
        the color list that will be set. If the colorId is greater than
        or equal to numColors() then the color list will be grown to
        accommodate the specified color.

        Returns:
        -----
        None

        Parameters:
        -----
        colorId: int
        	[in] -> The element in the color list to be set 

        color: MColor
        	[in] -> The new color value that is to be set 

        colorSet: MString
        	[in] -> Color set to work with


        '''
        pass

    @overload
    def setColor(self, colorId: int,
                        color: MColor,
                        colorSet: MString,
                        rep: MFnMesh.MColorRepresentation): 
        '''
        setColor(self, colorId: int,
                        color: MColor,
                        colorSet: MString,
                        rep: MFnMesh.MColorRepresentation)

        Synopsis
        -----
        Sets the specified color values of specified channels. The
        colorId is the element in the color list that will be set. If the
        colorId is greater than or equal to numColors() then the color
        list will be grown to accommodate the specified color.

        Returns:
        -----
        None

        Parameters:
        -----
        colorId: int
        	[in] -> The element in the color list to be set 

        color: MColor
        	[in] -> The new color value that is to be set 

        colorSet: MString
        	[in] -> Color set to work with 

        rep: MFnMesh.MColorRepresentation
        	[in] -> The RGB/RGBA/A channel(s) to set


        '''
        pass

    def getColor(self, colorId: int,
                        color: MColor,
                        colorSet: MString,
                        defaultUnsetColor: MColor): 
        '''
        getColor(self, colorId: int,
                        color: MColor,
                        colorSet: MString,
                        defaultUnsetColor: MColor)

        Synopsis
        -----
        Get the value of the specified texture coordinate from this
        mesh's color list. The colorId is the element in the color list
        that will be retrieved. If the color is not set,
        defaultUnsetColor will be return. If defaultUnsetColor is not
        set, (0,0,0,1) will be return.

        Returns:
        -----
        None

        Parameters:
        -----
        colorId: int
        	[in] -> The element in the color list to examine 

        color: MColor
        	[out] -> Storage for the color value 

        colorSet: MString
        	[in] -> Color set to work with 

        defaultUnsetColor: MColor
        	[in] -> default unset color


        '''
        pass

    def assignColor(self, polygonId: int,
                        vertexIndex: int,
                        colorId: int,
                        colorSet: MString): 
        '''
        assignColor(self, polygonId: int,
                        vertexIndex: int,
                        colorId: int,
                        colorSet: MString)

        Synopsis
        -----
        Maps a color value to a specified vertex of a polygon. Since
        color (vertex data) are stored per-polygon per-vertex you must
        specify both the polygon and the vertex that the color entry is
        mapped to.The vertexIndex (face-relative/local) is the vertex
        within the polygon that the color will be mapped to. This index
        must be in the range 0 to polygonVertexCount(polygonId).

        Returns:
        -----
        None

        Parameters:
        -----
        polygonId: int
        	[in] -> The polygon (face) to map to 

        vertexIndex: int
        	[in] -> The face-relative (local) vertex id of the polygon to map to 

        colorId: int
        	[in] -> The color entry from the color list that will be mapped 

        colorSet: MString
        	[in] -> Color set to work with


        '''
        pass

    def assignColors(self, colorIds: MIntArray,
                        colorSet: MString): 
        '''
        assignColors(self, colorIds: MIntArray,
                        colorSet: MString)

        Synopsis
        -----
        This method maps all colors for the mesh. The setColor/setColors
        method is used to create a color table for the mesh. After the
        table is created, this method is used to map those values to each
        polygon on a per-vertex basis. The setColor/setColors method
        should be called before the assignColors method.The colorIds
        array should contain the color indices that will be mapped to
        each polygon-vertex in the mesh. The entries in this array
        specify which colors in the mesh's color table are mapped to each
        polygon-vertex. Each entry in the colorIds array must be less
        than numColors(), or numColors(colorSet) for a named colorSet.
        The size of the colorIds array is equivalent to the number of
        polygon-vertices, so for a cube with all polygons mapped there
        would be 24 entries.

        Returns:
        -----
        None

        Parameters:
        -----
        colorIds: MIntArray
        	[in] -> The color indices to be mapped to each polygon-vertex 

        colorSet: MString
        	[in] -> Color set to work with


        '''
        pass

    def clearColors(self, colorSet: MString): 
        '''
        clearColors(self, colorSet: MString)

        Synopsis
        -----
        This method clears out all color for the mesh, and leaves behind
        an empty color set. This method should be used if it is needed to
        shrink the actual size of the color table. In this case, the user
        should call clearColors, setColors and then assignColors to
        rebuild the color mapping info.When called on a dataMesh, the
        colors are removed. When called on a shape with no history, the
        colors are removed and the attributes are set on the shape. When
        called on a shape with history, the polyColorDel command is
        invoked and a polyColorDel node is created.

        Returns:
        -----
        None

        Parameters:
        -----
        colorSet: MString
        	[in] -> Color set to work with


        '''
        pass

    def displayColors(self, ReturnStatus: MFnMesh.MStatus): 
        '''
        displayColors(self, ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        Determine if the mesh node is set to display vertex colors. The
        display of vertex colors is controlled by the mesh node itself.
        It is not part of the mesh data. Therefore this method is only
        valid when the function set is operating on a mesh node. It will
        return a failure status if called when the function set is
        operating on mesh data.

        Returns: 
        ----- 
        True if the mesh node is set to display vertex colors. False
        otherwise.

        Parameters:
        -----
        ReturnStatus: MFnMesh.MStatus
        	[out] -> The return status of the method


        '''
        pass

    def setDisplayColors(self, enable: bool): 
        '''
        setDisplayColors(self, enable: bool)

        Synopsis
        -----
        Set whether the mesh node should display vertex colors. The
        display of vertex colors is controlled by the mesh node itself.
        It is not part of the mesh data. Therefore this method is only
        valid when the function set is operating on a mesh node. It will
        return a failure status if called when the function set is
        operating on mesh data.

        Returns:
        -----
        None

        Parameters:
        -----
        enable: bool
        	[in] -> True to turn on color display, false to turn it off.


        '''
        pass

    def getHoles(self, holeInfoArray: MIntArray,
                        holeVertexArray: MIntArray,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        getHoles(self, holeInfoArray: MIntArray,
                        holeVertexArray: MIntArray,
                        ReturnStatus: MFnMesh.MStatus) -> int

        Synopsis
        -----
        Retrieves a list of the holes in the polygon.

        Returns: 
        ----- 
        The number of holes in the mesh.

        Parameters:
        -----
        holeInfoArray: MIntArray
        	[out] -> Receives an array of integer triples, one for each hole in the mesh. The first element in each triple represents the index of the holed face. The next two elements represent the number of vertices in the hole and the hole's start index in list of hole vertices in 

        holeVertexArray: MIntArray
        	[out] -> Receives an array consisting of the vertex indices of every hole in the mesh. The third element of each triple in 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code.


        '''
        pass

    def onBoundary(self, polygonId: int,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        onBoundary(self, polygonId: int,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        A method to determines whether the specified face in the mesh is
        a boundary face.

        Returns: 
        ----- 
        true If the specified edge is on the border of the object.  false
        If the specified edge is not on the boundary of the object.

        Parameters:
        -----
        polygonId: int
        	[in] -> The polygon (face) to examine 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> The return status of the method


        '''
        pass

    def isBlindDataTypeUsed(self, blindDataId: int,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        isBlindDataTypeUsed(self, blindDataId: int,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        Is this BlindData type id is already in use in this scene?

        Returns: 
        ----- 
        true: Id in use, false: id not in use

        Parameters:
        -----
        blindDataId: int
        	[in] -> The blind data id to check for 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status Code


        '''
        pass

    def createBlindDataType(self, blindDataId: int,
                        longNames: MStringArray,
                        shortNames: MStringArray,
                        formatNames: MStringArray): 
        '''
        createBlindDataType(self, blindDataId: int,
                        longNames: MStringArray,
                        shortNames: MStringArray,
                        formatNames: MStringArray)

        Synopsis
        -----
        Create a new blind data type. If the type id is already in use,
        this method will fail. Format names must be one of "int" "float"
        "double" "boolean" "string" "binary".

        Returns:
        -----
        None

        Parameters:
        -----
        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        longNames: MStringArray
        	[in] -> Attribute long names 

        shortNames: MStringArray
        	[in] -> Attribute short names 

        formatNames: MStringArray
        	[in] -> Names of the data types.


        '''
        pass

    @overload
    def hasBlindDataComponentId(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        hasBlindDataComponentId(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        Does this component have blind data with the given ID.

        Returns: 
        ----- 
        true: has the specified blind data, false: does not

        Parameters:
        -----
        compID: int
        	[in] -> The component to check for blind data om When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The blind data id to check for 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status Code


        '''
        pass

    @overload
    def hasBlindData(self, compType: MFn.MFn,
                        blindDataId: int,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        hasBlindData(self, compType: MFn.MFn,
                        blindDataId: int,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        Returns true if any component of the given type on this mesh have
        blind data with the given ID.

        Returns: 
        ----- 
        true: has the specified blind data, false: does not

        Parameters:
        -----
        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The blind data id to check for 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status Code


        '''
        pass

    @overload
    def hasBlindDataComponentId(self, compID: int,
                        compType: MFn.MFn,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        hasBlindDataComponentId(self, compID: int,
                        compType: MFn.MFn,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        Does this component have any kind of blind data.

        Returns: 
        ----- 
        true: has the specified blind data, false: does not

        Parameters:
        -----
        compID: int
        	[in] -> The component to check for blind data on When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status Code


        '''
        pass

    @overload
    def hasBlindData(self, compType: MFn.MFn,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        hasBlindData(self, compType: MFn.MFn,
                        ReturnStatus: MFnMesh.MStatus) -> bool

        Synopsis
        -----
        Does any component of this type have any blind data. (.e. is
        there any vertex blind data on this mesh?)

        Returns: 
        ----- 
        true: has the specified blind data, false: does not

        Parameters:
        -----
        compType: MFn.MFn
        	[in] -> The component type e.g. 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status Code


        '''
        pass

    def getBlindDataTypes(self, compType: MFn.MFn,
                        blindDataIds: MIntArray): 
        '''
        getBlindDataTypes(self, compType: MFn.MFn,
                        blindDataIds: MIntArray)

        Synopsis
        -----
        Get the list of blind data ID's associated with the given
        component type on this mesh. (e.g. all blind data ID's present on
        vertex compontents)

        Returns:
        -----
        None

        Parameters:
        -----
        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataIds: MIntArray
        	[out] -> space for this list of blind data id values.


        '''
        pass

    def getBlindDataAttrNames(self, blindDataId: int,
                        longNames: MStringArray,
                        shortNames: MStringArray,
                        formatNames: MStringArray): 
        '''
        getBlindDataAttrNames(self, blindDataId: int,
                        longNames: MStringArray,
                        shortNames: MStringArray,
                        formatNames: MStringArray)

        Synopsis
        -----
        Get the blind data attribute names and types for the specified
        blind data type id. Format names will be one of "int" "float"
        "double" "boolean" "string" "binary".

        Returns:
        -----
        None

        Parameters:
        -----
        blindDataId: int
        	[in] -> The blind data id to check for 

        longNames: MStringArray
        	[out] -> Space for the attribute long names 

        shortNames: MStringArray
        	[out] -> Space for the attribute short names 

        formatNames: MStringArray
        	[out] -> Space for the data format names


        '''
        pass

    def getFaceVertexBlindDataIndex(self, faceIndex: int,
                        vertexIndex: int,
                        blindDataIndex: int): 
        '''
        getFaceVertexBlindDataIndex(self, faceIndex: int,
                        vertexIndex: int,
                        blindDataIndex: int)

        Synopsis
        -----
        Get the single index to retrieve face-vertex blind data.

        Returns:
        -----
        None

        Parameters:
        -----
        faceIndex: int
        	[in] -> The face index to look for 

        vertexIndex: int
        	[in] -> The object-relative (mesh-relative/global) vertex index 

        blindDataIndex: int
        	[out] -> The component index for face vertex blind data storage to be returned


        '''
        pass

    def getBlindDataFaceVertexIndices(self, blindDataIndex: int,
                        faceIndex: int,
                        vertexIndex: int): 
        '''
        getBlindDataFaceVertexIndices(self, blindDataIndex: int,
                        faceIndex: int,
                        vertexIndex: int)

        Synopsis
        -----
        Get the face and vertex indices from the face-vertex blind data
        index.

        Returns:
        -----
        None

        Parameters:
        -----
        blindDataIndex: int
        	[out] -> The component index for face vertex blind data storage to decompose 

        faceIndex: int
        	[out] -> The corresponding face index to be returned 

        vertexIndex: int
        	[out] -> The object-relative (mesh-relative/global) vertex index to be returned


        '''
        pass

    @overload
    def getIntBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: int): 
        '''
        getIntBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: int)

        Synopsis
        -----
        Get the blind data value for the specified blind data attribute
        of the specified component. If the type of the attribute is not
        correct, this method will fail.

        Returns:
        -----
        None

        Parameters:
        -----
        compID: int
        	[in] -> The component to get for blind data on. When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The blind data id to check for 

        attrName: MString
        	[in] -> The attribute name 

        data: int
        	[out] -> Space for the data item


        '''
        pass

    @overload
    def getIntBlindData(self, compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        compIDs: MIntArray,
                        data: MIntArray): 
        '''
        getIntBlindData(self, compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        compIDs: MIntArray,
                        data: MIntArray)

        Synopsis
        -----
        Get the blind data value for the specified blind data attribute
        of the given type of component. If the type of the attribute is
        not correct, this method will fail.

        Returns:
        -----
        None

        Parameters:
        -----
        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The blind data id to check for 

        attrName: MString
        	[in] -> The attribute name 

        compIDs: MIntArray
        	[out] -> Space for the component indexes of the items When 

        data: MIntArray
        	[out] -> Space for the data items


        '''
        pass

    @overload
    def getFloatBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: float): 
        '''
        getFloatBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: float)

        Synopsis
        -----
        Get the blind data value for the specified blind data attribute
        of the specified component. If the type of the attribute is not
        correct, this method will fail.

        Returns:
        -----
        None

        Parameters:
        -----
        compID: int
        	[in] -> The component to get for blind data on When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The blind data id to check for 

        attrName: MString
        	[in] -> The attribute name 

        data: float
        	[out] -> Space for the data item


        '''
        pass

    @overload
    def getFloatBlindData(self, compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        compIDs: MIntArray,
                        data: MFloatArray): 
        '''
        getFloatBlindData(self, compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        compIDs: MIntArray,
                        data: MFloatArray)

        Synopsis
        -----
        Get the blind data value for the specified blind data attribute
        for all components of the given type. If the type of the
        attribute is not correct, this method will fail.

        Returns:
        -----
        None

        Parameters:
        -----
        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The blind data id to check for 

        attrName: MString
        	[in] -> The attribute name 

        compIDs: MIntArray
        	[out] -> Space for the component indexes of the items When 

        data: MFloatArray
        	[out] -> Space for the data items


        '''
        pass

    @overload
    def getDoubleBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: double): 
        '''
        getDoubleBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: double)

        Synopsis
        -----
        Get the blind data value for the specified blind data attribute
        of the specified component. If the type of the attribute is not
        correct, this method will fail.

        Returns:
        -----
        None

        Parameters:
        -----
        compID: int
        	[in] -> The component to get for blind data on When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The blind data id to check for 

        attrName: MString
        	[in] -> The attribute name 

        data: double
        	[out] -> Space for the data item


        '''
        pass

    @overload
    def getDoubleBlindData(self, compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        compIDs: MIntArray,
                        data: MDoubleArray): 
        '''
        getDoubleBlindData(self, compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        compIDs: MIntArray,
                        data: MDoubleArray)

        Synopsis
        -----
        Get the blind data value for the specified blind data attribute
        for all components of the given type. If the type of the
        attribute is not correct, this method will fail.

        Returns:
        -----
        None

        Parameters:
        -----
        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The blind data id to check for 

        attrName: MString
        	[in] -> The attribute name 

        compIDs: MIntArray
        	[out] -> Space for the component indexes of the items When 

        data: MDoubleArray
        	[out] -> Space for the data items


        '''
        pass

    @overload
    def getBoolBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: bool): 
        '''
        getBoolBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: bool)

        Synopsis
        -----
        Get the blind data value for the specified blind data attribute
        of the specified component. If the type of the attribute is not
        correct, this method will fail.

        Returns:
        -----
        None

        Parameters:
        -----
        compID: int
        	[in] -> The component to get for blind data on When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The blind data id to check for 

        attrName: MString
        	[in] -> The attribute name 

        data: bool
        	[out] -> Space for the data item


        '''
        pass

    @overload
    def getBoolBlindData(self, compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        compIDs: MIntArray,
                        data: MIntArray): 
        '''
        getBoolBlindData(self, compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        compIDs: MIntArray,
                        data: MIntArray)

        Synopsis
        -----
        Get the blind data value for the specified blind data attribute
        for all components of the given type. If the type of the
        attribute is not correct, this method will fail.

        Returns:
        -----
        None

        Parameters:
        -----
        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The blind data id to check for 

        attrName: MString
        	[in] -> The attribute name 

        compIDs: MIntArray
        	[out] -> Space for the component indexes of the items When 

        data: MIntArray
        	[out] -> Space for the data items (note that we return the bool data as an 


        '''
        pass

    def stringBlindDataComponentId(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        stringBlindDataComponentId(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        ReturnStatus: MFnMesh.MStatus) -> MString

        Synopsis
        -----
        Get the blind data value for the specified blind data attribute
        of the specified component. If the type of the attribute is not
        correct, this method will fail.

        Returns: 
        ----- 
        Blind data.

        Parameters:
        -----
        compID: int
        	[in] -> The component to get for blind data on When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The blind data id to check for 

        attrName: MString
        	[in] -> The attribute name 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code. See below.


        '''
        pass

    def getStringBlindData(self, compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        compIDs: MIntArray,
                        data: MStringArray): 
        '''
        getStringBlindData(self, compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        compIDs: MIntArray,
                        data: MStringArray)

        Synopsis
        -----
        Get the blind data value for the specified blind data attribute
        for all components of the given type. If the type of the
        attribute is not correct, this method will fail.

        Returns:
        -----
        None

        Parameters:
        -----
        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The blind data id to check for 

        attrName: MString
        	[in] -> The attribute name 

        compIDs: MIntArray
        	[out] -> Space for the component indexes of the items When 

        data: MStringArray
        	[out] -> Space for the data items (note that we return the bool data as an 


        '''
        pass

    def binaryBlindDataComponentId(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        binaryBlindDataComponentId(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        ReturnStatus: MFnMesh.MStatus) -> MString

        Synopsis
        -----
        Get the blind data value for the specified blind data attribute
        of the specified component. If the type of the attribute is not
        correct, this method will fail.

        Returns: 
        ----- 
        The data item.

        Parameters:
        -----
        compID: int
        	[in] -> The component to get for blind data on When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The blind data id to check for 

        attrName: MString
        	[in] -> The attribute name 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code. See below.


        '''
        pass

    def getBinaryBlindData(self, compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        compIDs: MIntArray,
                        data: MStringArray): 
        '''
        getBinaryBlindData(self, compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        compIDs: MIntArray,
                        data: MStringArray)

        Synopsis
        -----
        Get the blind data value for the specified blind data attribute
        for all components of the given type. If the type of the
        attribute is not correct, this method will fail.

        Returns:
        -----
        None

        Parameters:
        -----
        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The blind data id to check for 

        attrName: MString
        	[in] -> The attribute name 

        compIDs: MIntArray
        	[out] -> Space for the component indexes of the items When 

        data: MStringArray
        	[out] -> Space for the data items (note that we return the bool data as an 


        '''
        pass

    @overload
    def setIntBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: int): 
        '''
        setIntBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: int)

        Synopsis
        -----
        Set a value for an integer blind data attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        compID: int
        	[in] -> The component to set the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        attrName: MString
        	[in] -> Attribute name 

        data: int
        	[in] -> Attribute value


        '''
        pass

    @overload
    def setIntBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: int): 
        '''
        setIntBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: int)

        Synopsis
        -----
        Set a value for an integer blind data on an array of components.

        Returns:
        -----
        None

        Parameters:
        -----
        compIDs: MIntArray
        	[in] -> The components to set the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        attrName: MString
        	[in] -> Attribute name 

        data: int
        	[in] -> Attribute value


        '''
        pass

    @overload
    def setIntBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MIntArray): 
        '''
        setIntBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MIntArray)

        Synopsis
        -----
        Set a values for an integer blind data on an array of components.
        The arrays of values and components must be the same size.

        Returns:
        -----
        None

        Parameters:
        -----
        compIDs: MIntArray
        	[in] -> The components to set the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        attrName: MString
        	[in] -> Attribute name 

        data: MIntArray
        	[in] -> The attribute values for each component


        '''
        pass

    @overload
    def setFloatBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: float): 
        '''
        setFloatBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: float)

        Synopsis
        -----
        Set a value for a float blind data attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        compID: int
        	[in] -> The component to set the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        attrName: MString
        	[in] -> Attribute name 

        data: float
        	[in] -> Attribute value


        '''
        pass

    @overload
    def setFloatBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: float): 
        '''
        setFloatBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: float)

        Synopsis
        -----
        Set a value for float blind data on an array of components.

        Returns:
        -----
        None

        Parameters:
        -----
        compIDs: MIntArray
        	[in] -> The components to set the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        attrName: MString
        	[in] -> Attribute name 

        data: float
        	[in] -> Attribute value


        '''
        pass

    @overload
    def setFloatBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MFloatArray): 
        '''
        setFloatBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MFloatArray)

        Synopsis
        -----
        Set a values for a float blind data on an array of components.
        The arrays of values and components must be the same size.

        Returns:
        -----
        None

        Parameters:
        -----
        compIDs: MIntArray
        	[in] -> The components to set the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        attrName: MString
        	[in] -> Attribute name 

        data: MFloatArray
        	[in] -> The attribute values for each component


        '''
        pass

    @overload
    def setDoubleBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: double): 
        '''
        setDoubleBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: double)

        Synopsis
        -----
        Set a value for a double blind data attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        compID: int
        	[in] -> The component to set the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        attrName: MString
        	[in] -> Attribute name 

        data: double
        	[in] -> Attribute value


        '''
        pass

    @overload
    def setDoubleBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: double): 
        '''
        setDoubleBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: double)

        Synopsis
        -----
        Set a value for double blind data on an array of components.

        Returns:
        -----
        None

        Parameters:
        -----
        compIDs: MIntArray
        	[in] -> The components to set the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        attrName: MString
        	[in] -> Attribute name 

        data: double
        	[in] -> Attribute value


        '''
        pass

    @overload
    def setDoubleBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MDoubleArray): 
        '''
        setDoubleBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MDoubleArray)

        Synopsis
        -----
        Set a values for a double blind data on an array of components.
        The arrays of values and components must be the same size.

        Returns:
        -----
        None

        Parameters:
        -----
        compIDs: MIntArray
        	[in] -> The components to set the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        attrName: MString
        	[in] -> Attribute name 

        data: MDoubleArray
        	[in] -> The attribute values for each component


        '''
        pass

    @overload
    def setBoolBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: bool): 
        '''
        setBoolBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: bool)

        Synopsis
        -----
        Set a value for a boolean blind data attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        compID: int
        	[in] -> The component to set the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        attrName: MString
        	[in] -> Attribute name 

        data: bool
        	[in] -> Attribute value


        '''
        pass

    @overload
    def setBoolBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: bool): 
        '''
        setBoolBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: bool)

        Synopsis
        -----
        Set a value for boolean blind data on an array of components.

        Returns:
        -----
        None

        Parameters:
        -----
        compIDs: MIntArray
        	[in] -> The components to set the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        attrName: MString
        	[in] -> Attribute name 

        data: bool
        	[in] -> Attribute value


        '''
        pass

    @overload
    def setBoolBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MIntArray): 
        '''
        setBoolBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MIntArray)

        Synopsis
        -----
        Set a values for a boolean blind data on an array of components.
        The arrays of values and components must be the same size.

        Returns:
        -----
        None

        Parameters:
        -----
        compIDs: MIntArray
        	[in] -> The components to set the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        attrName: MString
        	[in] -> Attribute name 

        data: MIntArray
        	[in] -> The attribute values for each component


        '''
        pass

    @overload
    def setStringBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MString): 
        '''
        setStringBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MString)

        Synopsis
        -----
        Set a value for a string blind data attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        compID: int
        	[in] -> The component to set the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        attrName: MString
        	[in] -> Attribute name 

        data: MString
        	[in] -> Attribute value


        '''
        pass

    @overload
    def setStringBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MString): 
        '''
        setStringBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MString)

        Synopsis
        -----
        Set a value for string blind data on an array of components.

        Returns:
        -----
        None

        Parameters:
        -----
        compIDs: MIntArray
        	[in] -> The components to set the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        attrName: MString
        	[in] -> Attribute name 

        data: MString
        	[in] -> Attribute value


        '''
        pass

    @overload
    def setStringBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MStringArray): 
        '''
        setStringBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MStringArray)

        Synopsis
        -----
        Set a values for a string blind data on an array of components.
        The arrays of values and components must be the same size.

        Returns:
        -----
        None

        Parameters:
        -----
        compIDs: MIntArray
        	[in] -> The components to set the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        attrName: MString
        	[in] -> Attribute name 

        data: MStringArray
        	[in] -> The attribute values for each component


        '''
        pass

    @overload
    def setBinaryBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MString): 
        '''
        setBinaryBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MString)

        Synopsis
        -----
        Set a value for a binary blind data attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        compID: int
        	[in] -> The component to set the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        attrName: MString
        	[in] -> Attribute name 

        data: MString
        	[in] -> Attribute value as an 


        '''
        pass

    @overload
    def setBinaryBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MString): 
        '''
        setBinaryBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MString)

        Synopsis
        -----
        Set a value for binary blind data on an array of components.

        Returns:
        -----
        None

        Parameters:
        -----
        compIDs: MIntArray
        	[in] -> The components to set the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        attrName: MString
        	[in] -> Attribute name 

        data: MString
        	[in] -> Attribute value


        '''
        pass

    @overload
    def setBinaryBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MStringArray): 
        '''
        setBinaryBlindData(self, compIDs: MIntArray,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: MStringArray)

        Synopsis
        -----
        Set a values for a binary blind data on an array of components.
        The arrays of values and components must be the same size.

        Returns:
        -----
        None

        Parameters:
        -----
        compIDs: MIntArray
        	[in] -> The components to set the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        attrName: MString
        	[in] -> Attribute name 

        data: MStringArray
        	[in] -> The attribute values for each component


        '''
        pass

    @overload
    def setBinaryBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: char,
                        length: int): 
        '''
        setBinaryBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString,
                        data: char,
                        length: int)

        Synopsis
        -----
        Set a value for a binary blind data attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        compID: int
        	[in] -> The component to set the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The desired id for the new blind data type 

        attrName: MString
        	[in] -> Attribute name 

        data: char
        	[in] -> Attribute value as a char string 

        length: int
        	[in] -> Length of char string to use


        '''
        pass

    @overload
    def clearBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString): 
        '''
        clearBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString)

        Synopsis
        -----
        Delete a value for a binary blind data attribute on a particular
        componenr.

        Returns:
        -----
        None

        Parameters:
        -----
        compID: int
        	[in] -> The component to clear the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The id for the blind data to be cleared 

        attrName: MString
        	[in] -> Attribute name


        '''
        pass

    @overload
    def clearBlindData(self, compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString): 
        '''
        clearBlindData(self, compType: MFn.MFn,
                        blindDataId: int,
                        attrName: MString)

        Synopsis
        -----
        Delete the values for the given attribute on the given binary
        blind data type from all components of the given type.

        Returns:
        -----
        None

        Parameters:
        -----
        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The id for the blind data to be cleared 

        attrName: MString
        	[in] -> The attribute to clear the blind data for


        '''
        pass

    @overload
    def clearBlindData(self, compType: MFn.MFn): 
        '''
        clearBlindData(self, compType: MFn.MFn)

        Synopsis
        -----
        Delete all blind data from components of the given type, e.g. all
        edges from a particular component.

        Returns:
        -----
        None

        Parameters:
        -----
        compType: MFn.MFn
        	[in] -> The component type e.g. 


        '''
        pass

    @overload
    def clearBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int): 
        '''
        clearBlindData(self, compID: int,
                        compType: MFn.MFn,
                        blindDataId: int)

        Synopsis
        -----
        Delete the values for a binary blind data type (all its
        attributes) from a particular component.

        Returns:
        -----
        None

        Parameters:
        -----
        compID: int
        	[in] -> The component to clear the blind data for When 

        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The id for the blind data to be cleared


        '''
        pass

    @overload
    def clearBlindData(self, compType: MFn.MFn,
                        blindDataId: int): 
        '''
        clearBlindData(self, compType: MFn.MFn,
                        blindDataId: int)

        Synopsis
        -----
        Delete the values for a binary blind data type (all its
        attributes) from all components of the given type.

        Returns:
        -----
        None

        Parameters:
        -----
        compType: MFn.MFn
        	[in] -> The component type e.g. 

        blindDataId: int
        	[in] -> The id for the blind data to be cleared


        '''
        pass

    def componentTypeName(self, compType: MFn.MFn,
                        status: MFnMesh.MStatus): 
        '''
        componentTypeName(self, compType: MFn.MFn,
                        status: MFnMesh.MStatus) -> MString

        Synopsis
        -----
        Get a string representing a particular component type.

        Returns: 
        ----- 
        String representing the component type, empty string if invalid

        Parameters:
        -----
        compType: MFn.MFn
        	[in] -> The type of component to fetch 

        status: MFnMesh.MStatus
        	[out] -> Status Code


        '''
        pass

    def componentTypeFromName(self, assocName: MString): 
        '''
        componentTypeFromName(self, assocName: MString) -> MFn.MFn

        Synopsis
        -----
        Get a component type from its string name.

        Returns: 
        ----- 
        MFn::kInvalid The method failed to match the type.
        MFn::kMeshEdgeComponent The component type is 'edge'.
        MFn::kMeshPolygonComponent The component type is 'face'.
        MFn::kMeshVertComponent The component type is 'vertex'.
        MFn::kMeshFaceVertComponent The component type is 'faceVertex'.

        Parameters:
        -----
        assocName: MString
        	[in] -> String representing the component type


        '''
        pass

    def setCheckSamePointTwice(self, check: bool): 
        '''
        setCheckSamePointTwice(self, check: bool)

        Synopsis
        -----
        This method allows the turning on or off of duplicate point
        checking when polygons are created or added using this class.
        Checking for duplicates, is the default state.

        Returns:
        -----
        None

        Parameters:
        -----
        check: bool
        	[in] -> true for checking, false otherwise 


        '''
        pass

    def getCheckSamePointTwice(self): 
        '''
        getCheckSamePointTwice(self) -> bool

        Synopsis
        -----
        Return true if checking for duplicate points is turned on. Return
        false otherwise.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def createInPlace(self, numVertices: int,
                        numPolygons: int,
                        vertexArray: MFloatPointArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray): 
        '''
        createInPlace(self, numVertices: int,
                        numPolygons: int,
                        vertexArray: MFloatPointArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray)

        Synopsis
        -----
        Replaces the existing polygonal mesh with a new one specified by
        array of vertices and polygon connection information. This
        function will then operate on the replacement surface.This method
        is meant to be as efficient as possible and thus assumes that all
        the given data is topologically correct.If the functionset is
        operating on a mesh node with construction history, this method
        will fail as the node will continue to get its geometry from its
        history connection. To use this method you must first break the
        history connection.

        Returns:
        -----
        None

        Parameters:
        -----
        numVertices: int
        	[in] -> number of vertices 

        numPolygons: int
        	[in] -> number of polygons 

        vertexArray: MFloatPointArray
        	[in] -> point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), (1,-1,-1), (1,-1,1), (-1,-1,1), (-1,1,-1), (-1,1,1), (1,1,1), (1,1,-1) } 

        polygonCounts: MIntArray
        	[in] -> array of vertex counts for each polygon. For example the cube would have 6 faces, each of which had 4 verts, so the polygonCounts would be {4,4,4,4,4,4}. 

        polygonConnects: MIntArray
        	[in] -> array of vertex connections for each polygon. For example, in the cube, we have 4 vertices for every face, so we list the vertices for face0, face1, etc consecutively in the array. These are specified by indexes in the vertexArray: e.g for the cube: { 0, 1, 2, 3, 4, 5, 6, 7, 3, 2, 6, 5, 0, 3, 5, 4, 0, 4, 7, 1, 1, 7, 6, 2 }


        '''
        pass

    def copyInPlace(self, source: MObject): 
        '''
        copyInPlace(self, source: MObject)

        Synopsis
        -----
        This method creates copies the given source mesh onto the current
        surface. After the copy this function set continues operate on
        the original mesh.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MObject
        	[in] -> the mesh to be copied


        '''
        pass

    @overload
    def polyTriangulate(self, pointsAndHoles: float,
                        pointsCount: int,
                        outerPointsCount: int,
                        holesCount: int,
                        considerNormal: bool,
                        normals: float,
                        triangles: short,
                        trianglesCount: int): 
        '''
        polyTriangulate(self, pointsAndHoles: float,
                        pointsCount: int,
                        outerPointsCount: int,
                        holesCount: int,
                        considerNormal: bool,
                        normals: float,
                        triangles: short,
                        trianglesCount: int)

        Synopsis
        -----
        Triangulates a polygon. The polygon consists of 2D positions with
        optional 3D normals and holes. These 2D positions can be in any
        coordinate system. 3D positions can be projected to a 2D plane by
        its face normal. 3D normals are references to help triangulation.
        This function can work without normals but normals can improve
        the quality. This function works with pointers and is more
        efficient than the other variant.

        Returns:
        -----
        None

        Parameters:
        -----
        pointsAndHoles: float
        	[in] -> Array of 2D positions and hole description. The array contains 2D positions (x,y) followed by the hole offsets. For example, if pointsAndHoles = [x1, y1, x2, y2, ..., x9, y9, o1, o1, o2, o2], then this means that (x1, y1) ~ (x9, y9) are positions, o1 is the offset for the first loop and o2 is the offset for the second loop. 

        pointsCount: int
        	[in] -> The number of 2D positions in pointsAndHoles 

        outerPointsCount: int
        	[in] -> The number of outer (non-hole) 2D positions in pointsAndHoles 

        holesCount: int
        	[in] -> The number of holes in pointsAndHoles 

        considerNormal: bool
        	[in] -> If true then normals are considered during triangulation 

        normals: float
        	[in] -> Array of 3D normals. If considerNormal is false, this array can be nullptr. If considerNormal is true, then there must be one normal per point. 

        triangles: short
        	[out] -> Array of triangle indices into pointsAndHoles array. The size of this array is trianglesCount * 3 

        trianglesCount: int
        	[out] -> The number of triangles written in triangles array


        '''
        pass

    @overload
    def polyTriangulate(self, points: MFloatPointArray,
                        holes: MIntArray,
                        outerPointsCount: int,
                        normals: MFloatVectorArray,
                        triangles: MIntArray): 
        '''
        polyTriangulate(self, points: MFloatPointArray,
                        holes: MIntArray,
                        outerPointsCount: int,
                        normals: MFloatVectorArray,
                        triangles: MIntArray)

        Synopsis
        -----
        Triangulates a polygon. The polygon consists of positions with
        optional normals and holes. Normals are references to help
        triangulation. This function can work without normals but normals
        can improve the quality. A simple example:MFloatPointArray
        Points; MIntArray Holes; MFloatVectorArray Normals; MIntArray
        Triangles;Points.append(MFloatPoint(-1, 0, -1));
        Points.append(MFloatPoint(-1, 0, 1));
        Points.append(MFloatPoint(1, 0, 1)); Points.append(MFloatPoint(1,
        0, -1)); Points.append(MFloatPoint(0.5, 0, -0.5));
        Points.append(MFloatPoint(0.5, 0, 0.5));
        Points.append(MFloatPoint(-0.5, 0, 0.5));
        Points.append(MFloatPoint(-0.5, 0, -0.5)); Holes.append(4) // the
        1st hole starts at 4th in Points for (unsigned int i = 0; i < 8;
        i++) Normals.append(MFloatVector(0, 1,
        0));MFnMesh::polyTriangulate(Points, Holes, 4, Normals,
        Triangles)

        Returns:
        -----
        None

        Parameters:
        -----
        points: MFloatPointArray
        	[in] -> Array of 3D points. The poly's outer vertices come first, followed by the vertices for each hole. 

        holes: MIntArray
        	[in] -> Array of offsets into the 'points' array indicating where each hole's vertices start. 

        outerPointsCount: int
        	[in] -> The number of outer (non-hole) positions in points array 

        normals: MFloatVectorArray
        	[in] -> Array of normals. This array can be empty. If this array is not empty, then there must be one normal per point. 

        triangles: MIntArray
        	[out] -> Array of triangle indices into points array


        '''
        pass

    @overload
    def create(self, vertexArray: MPointArray,
                        edgeArray: MIntArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        create(self, vertexArray: MPointArray,
                        edgeArray: MIntArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus) -> MObject

        Synopsis
        -----
        Introduced in 2023.0 Creates a new polygonal mesh given an array
        of vertices, edge and polygon connection data and sets this
        function set to operate on the new surface.This mesh creation
        path mirrors the creation method for mayaAscii and mayaBinary
        file readers.This method is meant to be as efficient as possible
        and thus assumes that all the given data is topologically
        correct.The parentOrOwner argument is used to specify the owner
        of the new surface.If the parentOrOwner is kMeshData then the
        created surface will be of type kMeshGeom and will be returned.
        The parentOrOwner will become the owner of the new mesh.If
        parentOrOwner is nullptr then a new transform will be created and
        returned which will be the parent for the mesh. The new transform
        will be added to the DAG.If parentOrOwner is a DAG node then the
        new mesh will be returned and the parentOrOwner will become its
        parent.

        Returns: 
        ----- 
        If parentOrOwner is nullptr then the transform for this surface
        is returned  If parentOrOwner is a DAG object then the new
        surface shape is returned  The surface geometry is returned if
        parentOrOwner is of type kMeshData

        Parameters:
        -----
        vertexArray: MPointArray
        	[in] -> point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), ( 1,-1,-1), (1,-1, 1), (-1,-1, 1), (-1, 1,-1), (-1, 1, 1), (1, 1, 1), ( 1, 1,-1) } 

        edgeArray: MIntArray
        	[in] -> array of vertex connections that define each edge. Each consecutive set of 3 of integers represents the [startVertex,endVertex,smooth] data of an edge. For example, a cube could have the following edges: { 0, 1, 0, 1, 2, 0, 2, 3, 0, 3, 0, 0, 4, 5, 0, 5, 6, 0, 6, 7, 0, 7, 4, 0, 2, 6, 0, 5, 3, 0, 4, 0, 0, 7, 1, 0, } 

        polygonCounts: MIntArray
        	[in] -> array of edge counts for each polygon. For example the cube would have 6 faces, each of which had 4 edges, so the polygonCounts would be {4,4,4,4,4,4}. 

        polygonConnects: MIntArray
        	[in] -> array of edge connections for each polygon. For example, in the cube, we have 4 edges for each face, so we list the edges for face0, face1, etc consecutively in the array. These are specified by indexes in the edgeArray: e.g for the cube: { 0, 1, 2, 3, 4, 5, 6, 7, -3, 8, -6, 9, -4,-10, -5, 10, -11, -8, 11, -1, -12, -7, -9, -2 } Negative index values are supported and indicate that the edge direction for this edge index entry should be reversed. These negative indices are 1-based. That means: Reversed edgeId 0 == -1 Reversed edgeId 1 == -2 ... Reversed edgeId n == -(n+1) 

        parentOrOwner: MObject
        	[in] -> parent of the polygon that will be created 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def create(self, vertexArray: MFloatPointArray,
                        edgeArray: MIntArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        create(self, vertexArray: MFloatPointArray,
                        edgeArray: MIntArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus) -> MObject

        Synopsis
        -----
        Introduced in 2023.0 Creates a new polygonal mesh given an array
        of vertices, edge and polygon connection data and sets this
        function set to operate on the new surface.This mesh creation
        path mirrors the creation method for mayaAscii and mayaBinary
        file readers.This method is meant to be as efficient as possible
        and thus assumes that all the given data is topologically
        correct.The parentOrOwner argument is used to specify the owner
        of the new surface.If the parentOrOwner is kMeshData then the
        created surface will be of type kMeshGeom and will be returned.
        The parentOrOwner will become the owner of the new mesh.If
        parentOrOwner is nullptr then a new transform will be created and
        returned which will be the parent for the mesh. The new transform
        will be added to the DAG.If parentOrOwner is a DAG node then the
        new mesh will be returned and the parentOrOwner will become its
        parent.

        Returns: 
        ----- 
        If parentOrOwner is nullptr then the transform for this surface
        is returned  If parentOrOwner is a DAG object then the new
        surface shape is returned  The surface geometry is returned if
        parentOrOwner is of type kMeshData

        Parameters:
        -----
        vertexArray: MFloatPointArray
        	[in] -> point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), ( 1,-1,-1), (1,-1, 1), (-1,-1, 1), (-1, 1,-1), (-1, 1, 1), (1, 1, 1), ( 1, 1,-1) } 

        edgeArray: MIntArray
        	[in] -> array of vertex connections that define each edge. Each consecutive set of 3 of integers represents the [startVertex,endVertex,smooth] data of an edge. For example, a cube could have the following edges: { 0, 1, 0, 1, 2, 0, 2, 3, 0, 3, 0, 0, 4, 5, 0, 5, 6, 0, 6, 7, 0, 7, 4, 0, 2, 6, 0, 5, 3, 0, 4, 0, 0, 7, 1, 0, } 

        polygonCounts: MIntArray
        	[in] -> array of edge counts for each polygon. For example the cube would have 6 faces, each of which had 4 edges, so the polygonCounts would be {4,4,4,4,4,4}. 

        polygonConnects: MIntArray
        	[in] -> array of edge connections for each polygon. For example, in the cube, we have 4 edges for each face, so we list the edges for face0, face1, etc consecutively in the array. These are specified by indexes in the edgeArray: e.g for the cube: { 0, 1, 2, 3, 4, 5, 6, 7, -3, 8, -6, 9, -4,-10, -5, 10, -11, -8, 11, -1, -12, -7, -9, -2 } Negative index values are supported and indicate that the edge direction for this edge index entry should be reversed. These negative indices are 1-based. That means: Reversed edgeId 0 == -1 Reversed edgeId 1 == -2 ... Reversed edgeId n == -(n+1) 

        parentOrOwner: MObject
        	[in] -> parent of the polygon that will be created 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def create(self, vertexArray: MPointArray,
                        edgeArray: MIntArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray,
                        uArray: MFloatArray,
                        vArray: MFloatArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        create(self, vertexArray: MPointArray,
                        edgeArray: MIntArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray,
                        uArray: MFloatArray,
                        vArray: MFloatArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus) -> MObject

        Synopsis
        -----
        Introduced in 2023.0 Creates a new polygonal mesh given an array
        of vertices, edge and polygon connection data and sets this
        function set to operate on the new surface.This mesh creation
        path mirrors the creation method for mayaAscii and mayaBinary
        file readers.This method is meant to be as efficient as possible
        and thus assumes that all the given data is topologically
        correct.The parentOrOwner argument is used to specify the owner
        of the new surface.If the parentOrOwner is kMeshData then the
        created surface will be of type kMeshGeom and will be returned.
        The parentOrOwner will become the owner of the new mesh.If
        parentOrOwner is nullptr then a new transform will be created and
        returned which will be the parent for the mesh. The new transform
        will be added to the DAG.If parentOrOwner is a DAG node then the
        new mesh will be returned and the parentOrOwner will become its
        parent.

        Returns: 
        ----- 
        If parentOrOwner is nullptr then the transform for this surface
        is returned  If parentOrOwner is a DAG object then the new
        surface shape is returned  The surface geometry is returned if
        parentOrOwner is of type kMeshData

        Parameters:
        -----
        vertexArray: MPointArray
        	[in] -> point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), ( 1,-1,-1), (1,-1, 1), (-1,-1, 1), (-1, 1,-1), (-1, 1, 1), (1, 1, 1), ( 1, 1,-1) } 

        edgeArray: MIntArray
        	[in] -> array of vertex connections that define each edge. Each consecutive set of 3 of integers represents the [startVertex,endVertex,smooth] data of an edge. For example, a cube could have the following edges: { 0, 1, 0, 1, 2, 0, 2, 3, 0, 3, 0, 0, 4, 5, 0, 5, 6, 0, 6, 7, 0, 7, 4, 0, 2, 6, 0, 5, 3, 0, 4, 0, 0, 7, 1, 0, } 

        polygonCounts: MIntArray
        	[in] -> array of edge counts for each polygon. For example the cube would have 6 faces, each of which had 4 edges, so the polygonCounts would be {4,4,4,4,4,4}. 

        polygonConnects: MIntArray
        	[in] -> array of edge connections for each polygon. For example, in the cube, we have 4 edges for each face, so we list the edges for face0, face1, etc consecutively in the array. These are specified by indexes in the edgeArray: e.g for the cube: { 0, 1, 2, 3, 4, 5, 6, 7, -3, 8, -6, 9, -4,-10, -5, 10, -11, -8, 11, -1, -12, -7, -9, -2 } Negative index values are supported and indicate that the edge direction for this edge index entry should be reversed. These negative indices are 1-based. That means: Reversed edgeId 0 == -1 Reversed edgeId 1 == -2 ... Reversed edgeId n == -(n+1) 

        uArray: MFloatArray
        	[in] -> The array of u values to be set 

        vArray: MFloatArray
        	[in] -> The array of v values to be set 

        parentOrOwner: MObject
        	[in] -> parent of the polygon that will be created 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def create(self, vertexArray: MFloatPointArray,
                        edgeArray: MIntArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray,
                        uArray: MFloatArray,
                        vArray: MFloatArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus): 
        '''
        create(self, vertexArray: MFloatPointArray,
                        edgeArray: MIntArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray,
                        uArray: MFloatArray,
                        vArray: MFloatArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnMesh.MStatus) -> MObject

        Synopsis
        -----
        Introduced in 2023.0 Creates a new polygonal mesh given an array
        of vertices, edge and polygon connection data and sets this
        function set to operate on the new surface.This mesh creation
        path mirrors the creation method for mayaAscii and mayaBinary
        file readers.This method is meant to be as efficient as possible
        and thus assumes that all the given data is topologically
        correct.The parentOrOwner argument is used to specify the owner
        of the new surface.If the parentOrOwner is kMeshData then the
        created surface will be of type kMeshGeom and will be returned.
        The parentOrOwner will become the owner of the new mesh.If
        parentOrOwner is nullptr then a new transform will be created and
        returned which will be the parent for the mesh. The new transform
        will be added to the DAG.If parentOrOwner is a DAG node then the
        new mesh will be returned and the parentOrOwner will become its
        parent.

        Returns: 
        ----- 
        If parentOrOwner is nullptr then the transform for this surface
        is returned  If parentOrOwner is a DAG object then the new
        surface shape is returned  The surface geometry is returned if
        parentOrOwner is of type kMeshData

        Parameters:
        -----
        vertexArray: MFloatPointArray
        	[in] -> point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), ( 1,-1,-1), (1,-1, 1), (-1,-1, 1), (-1, 1,-1), (-1, 1, 1), (1, 1, 1), ( 1, 1,-1) } 

        edgeArray: MIntArray
        	[in] -> array of vertex connections that define each edge. Each consecutive set of 3 of integers represents the [startVertex,endVertex,smooth] data of an edge. For example, a cube could have the following edges: { 0, 1, 0, 1, 2, 0, 2, 3, 0, 3, 0, 0, 4, 5, 0, 5, 6, 0, 6, 7, 0, 7, 4, 0, 2, 6, 0, 5, 3, 0, 4, 0, 0, 7, 1, 0, } 

        polygonCounts: MIntArray
        	[in] -> array of edge counts for each polygon. For example the cube would have 6 faces, each of which had 4 edges, so the polygonCounts would be {4,4,4,4,4,4}. 

        polygonConnects: MIntArray
        	[in] -> array of edge connections for each polygon. For example, in the cube, we have 4 edges for each face, so we list the edges for face0, face1, etc consecutively in the array. These are specified by indexes in the edgeArray: e.g for the cube: { 0, 1, 2, 3, 4, 5, 6, 7, -3, 8, -6, 9, -4,-10, -5, 10, -11, -8, 11, -1, -12, -7, -9, -2 } Negative index values are supported and indicate that the edge direction for this edge index entry should be reversed. These negative indices are 1-based. That means: Reversed edgeId 0 == -1 Reversed edgeId 1 == -2 ... Reversed edgeId n == -(n+1) 

        uArray: MFloatArray
        	[in] -> The array of u values to be set 

        vArray: MFloatArray
        	[in] -> The array of v values to be set 

        parentOrOwner: MObject
        	[in] -> parent of the polygon that will be created 

        ReturnStatus: MFnMesh.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def createInPlace(self, vertexArray: MPointArray,
                        edgeArray: MIntArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray): 
        '''
        createInPlace(self, vertexArray: MPointArray,
                        edgeArray: MIntArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray)

        Synopsis
        -----
        Introduced in 2023.0 Replaces the existing polygonal mesh with a
        new one specified by array of vertices, edge and polygon
        connection data.This function will then operate on the
        replacement surface.This method is meant to be as efficient as
        possible and thus assumes that all the given data is
        topologically correct.If the functionset is operating on a mesh
        node with construction history, this method will fail as the node
        will continue to get its geometry from its history connection. To
        use this method you must first break the history connection.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexArray: MPointArray
        	[in] -> point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), (1,-1,-1), (1,-1,1), (-1,-1,1), (-1,1,-1), (-1,1,1), (1,1,1), (1,1,-1) } 

        edgeArray: MIntArray
        	[in] -> array of vertex connections that define each edge. Each consecutive set of 3 of integers represents the [startVertex,endVertex,smooth] data of an edge. For example, a cube could have the following edges: { 0, 1, 0, 1, 2, 0, 2, 3, 0, 3, 0, 0, 4, 5, 0, 5, 6, 0, 6, 7, 0, 7, 4, 0, 2, 6, 0, 5, 3, 0, 4, 0, 0, 7, 1, 0, } 

        polygonCounts: MIntArray
        	[in] -> array of edge counts for each polygon. For example the cube would have 6 faces, each of which had 4 edges, so the polygonCounts would be {4,4,4,4,4,4}. 

        polygonConnects: MIntArray
        	[in] -> array of edge connections for each polygon. For example, in the cube, we have 4 edges for each face, so we list the edges for face0, face1, etc consecutively in the array. These are specified by indexes in the edgeArray: e.g for the cube: { 0, 1, 2, 3, 4, 5, 6, 7, -3, 8, -6, 9, -4,-10, -5, 10, -11, -8, 11, -1, -12, -7, -9, -2 } Negative index values are supported and indicate that the edge direction for this edge index entry should be reversed. These negative indices are 1-based. That means: Reversed edgeId 0 == -1 Reversed edgeId 1 == -2 ... Reversed edgeId n == -(n+1)


        '''
        pass

    @overload
    def createInPlace(self, vertexArray: MFloatPointArray,
                        edgeArray: MIntArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray): 
        '''
        createInPlace(self, vertexArray: MFloatPointArray,
                        edgeArray: MIntArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray)

        Synopsis
        -----
        Introduced in 2023.0 Replaces the existing polygonal mesh with a
        new one specified by array of vertices, edge and polygon
        connection data.This function will then operate on the
        replacement surface.This method is meant to be as efficient as
        possible and thus assumes that all the given data is
        topologically correct.If the functionset is operating on a mesh
        node with construction history, this method will fail as the node
        will continue to get its geometry from its history connection. To
        use this method you must first break the history connection.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexArray: MFloatPointArray
        	[in] -> point (vertex) array. This should include all the vertices in the mesh, and no extras. For example, a cube could have the vertices: { (-1,-1,-1), (1,-1,-1), (1,-1,1), (-1,-1,1), (-1,1,-1), (-1,1,1), (1,1,1), (1,1,-1) } 

        edgeArray: MIntArray
        	[in] -> array of vertex connections that define each edge. Each consecutive set of 3 of integers represents the [startVertex,endVertex,smooth] data of an edge. For example, a cube could have the following edges: { 0, 1, 0, 1, 2, 0, 2, 3, 0, 3, 0, 0, 4, 5, 0, 5, 6, 0, 6, 7, 0, 7, 4, 0, 2, 6, 0, 5, 3, 0, 4, 0, 0, 7, 1, 0, } 

        polygonCounts: MIntArray
        	[in] -> array of edge counts for each polygon. For example the cube would have 6 faces, each of which had 4 edges, so the polygonCounts would be {4,4,4,4,4,4}. 

        polygonConnects: MIntArray
        	[in] -> array of edge connections for each polygon. For example, in the cube, we have 4 edges for each face, so we list the edges for face0, face1, etc consecutively in the array. These are specified by indexes in the edgeArray: e.g for the cube: { 0, 1, 2, 3, 4, 5, 6, 7, -3, 8, -6, 9, -4,-10, -5, 10, -11, -8, 11, -1, -12, -7, -9, -2 } Negative index values are supported and indicate that the edge direction for this edge index entry should be reversed. These negative indices are 1-based. That means: Reversed edgeId 0 == -1 Reversed edgeId 1 == -2 ... Reversed edgeId n == -(n+1)


        '''
        pass

class MColorRepresentation:
    '''Specifies which color components are used by a colorSet. 
    Non-functional class.  Values for this enum:
    kAlpha
    kRGB
    kRGBA
    '''

    def __init__(self):
        pass

    def kAlpha(self):
        '''This is an enum of MColorRepresentation.
        - Description: Alpha only. 
        - Value: 1
        '''
        pass

    def kRGB(self):
        '''This is an enum of MColorRepresentation.
        - Description: Red, green and blue only. 
        - Value: 3
        '''
        pass

    def kRGBA(self):
        '''This is an enum of MColorRepresentation.
        - Description: Red, green, blue and alpha. 
        - Value: 4
        '''
        pass

class SplitPlacement:
    '''Specifies how a point along split is to be determined. 
    Non-functional class.  Values for this enum:
    kOnEdge
    kInternalPoint
    kInvalid
    '''

    def __init__(self):
        pass

    def kOnEdge(self):
        '''This is an enum of SplitPlacement.
        - Description: Split at a position along an edge. 
        - Value: 0
        '''
        pass

    def kInternalPoint(self):
        '''This is an enum of SplitPlacement.
        - Description: Split at a point within a face. 
        - Value: 1
        '''
        pass

    def kInvalid(self):
        '''This is an enum of SplitPlacement.
        - Description:  
        - Value: 2
        '''
        pass

class BoolOperation:
    '''Boolean operators. 
    Non-functional class.  Values for this enum:
    kUnion
    kDifference
    kIntersection
    '''

    def __init__(self):
        pass

    def kUnion(self):
        '''This is an enum of BoolOperation.
        - Description: Boolean union. 
        - Value: 1
        '''
        pass

    def kDifference(self):
        '''This is an enum of BoolOperation.
        - Description: Boolean difference. 
        - Value: 2
        '''
        pass

    def kIntersection(self):
        '''This is an enum of BoolOperation.
        - Description: Boolean intersection. 
        - Value: 3
        '''
        pass

class BoolClassification:
    '''Introduced in 2023.0 
    Non-functional class.  Values for this enum:
    kEdgeClassification
    kNormalClassification
    '''

    def __init__(self):
        pass

    def kEdgeClassification(self):
        '''This is an enum of BoolClassification.
        - Description: Edge Classification. 
        - Value: 1
        '''
        pass

    def kNormalClassification(self):
        '''This is an enum of BoolClassification.
        - Description: Normal Classification. 
        - Value: 2
        '''
        pass

class BorderInfo:
    '''Introduced in 2023.0 
    Non-functional class.  Values for this enum:
    kGeomBorder
    kUVBorder
    kSharedUV
    kUnsharedUV
    '''

    def __init__(self):
        pass

    def kGeomBorder(self):
        '''This is an enum of BorderInfo.
        - Description: The edge lies on a geometry border. 
        - Value: -2
        '''
        pass

    def kUVBorder(self):
        '''This is an enum of BorderInfo.
        - Description: The edge lies on a UV border. 
        - Value: -1
        '''
        pass

    def kSharedUV(self):
        '''This is an enum of BorderInfo.
        - Description: The faces around the edge share the UVs. 
        - Value: 0
        '''
        pass

    def kUnsharedUV(self):
        '''This is an enum of BorderInfo.
        - Description: The faces around the edge have different UVs. 
        - Value: 1
        '''
        pass

class MFnMeshData:
    '''Mesh function set for dependency node data.
MFnMeshData allows the creation and manipulation of Mesh data objects for
use in the dependency graph.
If a user written dependency node either accepts or produces
Meshes, then this class is used to create data blocks into which
Meshes can be constructed before being passed to other dependency
graph nodes. The
MDataHandle::type method will return kMesh when data of this type is present.
If a node is receiving a Mesh via an input attribute, the asMesh
method of
MDataHandle can be used to access that input Mesh.
If a node is to create a Mesh and send it via an output
attribute, a new
MFnMeshData must be instantiated and then the create method called to build
the actual data block as an
MObject. This
MObject should be passed to the
MFnMesh::create method as the parentOrOwner parameter so that the Mesh will be
constructed inside the data block. The
MDataHandle::set routine is then used to pass the data block down the connection.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kMeshData.Reimplemented from MFnGeometryData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnMeshData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnMeshData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, ReturnStatus: MFnMeshData.MStatus): 
        '''
        create(self, ReturnStatus: MFnMeshData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance and initialize
        it with a data block capable of holding a Mesh.

        Returns: 
        ----- 
        The new MObject

        Parameters:
        -----
        ReturnStatus: MFnMeshData.MStatus
        	[out] -> kSuccess


        '''
        pass

class MFnMessageAttribute:
    '''Message attribute function set.
Function set for message attributes. A message attribute is a
dependency node attribute that does not transmit data. Message
attributes only exist to formally declare relationships between
nodes. By connecting two nodes via message attributes, a
relationship between those nodes is expressed. Message attribute
connections can be traversed in the same manner as any other
connection in the dependency graph. Message attributes cannot be
stored as they do not contain data.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kMessageAttribute.Reimplemented from MFnAttribute.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnMessageAttribute.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnMessageAttribute".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, fullName: MString,
                        briefName: MString,
                        ReturnStatus: MFnMessageAttribute.MStatus): 
        '''
        create(self, fullName: MString,
                        briefName: MString,
                        ReturnStatus: MFnMessageAttribute.MStatus) -> MObject

        Synopsis
        -----
        Creates a Message attribute object. The create method needs to be
        called on a per node basis. That means if you want to create and
        add the same attribute to multiple nodes, you need to call the
        create method for each node to get a unique MObject back. If you
        call create just once and add the attribute to multiple nodes,
        Maya will encounter a fatal error.

        Returns: 
        ----- 
        The newly created Message attribute object.

        Parameters:
        -----
        fullName: MString
        	[in] -> The full name of the attribute 

        briefName: MString
        	[in] -> The brief name of the attribute 

        ReturnStatus: MFnMessageAttribute.MStatus
        	[out] -> Status code for the operation.


        '''
        pass

class MFnNonAmbientLight:
    '''Manage Non-ambient Light dependency Nodes.
MFnNonAmbientLight facilitates modification of dependency graph nodes representing
non-ambient lights. This includes area lights, linear lights, and
non-extended lights.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kNonAmbientLight.Reimplemented from MFnLight.Reimplemented
        in MFnSpotLight, MFnNonExtendedLight, MFnAreaLight,
        MFnDirectionalLight, MFnPointLight, and MFnVolumeLight.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnNonAmbientLight.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnNonAmbientLight".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def decayRate(self, ReturnStatus: MFnNonAmbientLight.MStatus): 
        '''
        decayRate(self, ReturnStatus: MFnNonAmbientLight.MStatus) -> short

        Synopsis
        -----
        Retrieves the value of the "decayRate" attribute of a non-ambient
        light node. This attribute determines the type of decay for the
        light.The decay rate is with respect to the distance between the
        light and the surface point being shaded. The decay values range
        from 0 - 3. The light intensity decays according to (I / d ** v),
        where I is the light intensity, d is the distance between the
        light and the surface point being shaded, and v is the decay rate
        value. A decay rate of 0 means there is no decay in intensity, a
        value of 1 indicates linear decay. A decay rate of 2 is the most
        physically accurate behaviour.

        Returns: 
        ----- 
        The value of the "decayRate" attribute of the non-ambient light
        node.

        Parameters:
        -----
        ReturnStatus: MFnNonAmbientLight.MStatus
        	[out] -> return status


        '''
        pass

    def setDecayRate(self, decay_rate: short): 
        '''
        setDecayRate(self, decay_rate: short)

        Synopsis
        -----
        Sets the value of the "decayRate" attribute of a non-ambient
        light node.

        Returns:
        -----
        None

        Parameters:
        -----
        decay_rate: short
        	[in] -> value to which the attribute will be set.


        '''
        pass

class MFnNonExtendedLight:
    '''Manage Non-extended Light dependency Nodes.
MFnNonExtendedLight facilitates manipulation of dependency graph nodes representing
non-extended lights. This includes point lights, directional
lights, and spotlights.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kNonExtendedLight.Reimplemented from
        MFnNonAmbientLight.Reimplemented in MFnSpotLight, MFnAreaLight,
        MFnDirectionalLight, MFnPointLight, and MFnVolumeLight.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnNonExtendedLight.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnNonExtendedLight".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def shadowRadius(self, ReturnStatus: MFnNonExtendedLight.MStatus): 
        '''
        shadowRadius(self, ReturnStatus: MFnNonExtendedLight.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "shadowRadius" attribute of a non-
        extended light node. This attribute represents the radius of the
        light used when computing soft shadows. Higher radius values
        result in more extended soft shadows.

        Returns: 
        ----- 
        The value of the "shadowRadius" attribute of the non-extended
        light node.

        Parameters:
        -----
        ReturnStatus: MFnNonExtendedLight.MStatus
        	[out] -> return status


        '''
        pass

    def setShadowRadius(self, shadow_radius: float): 
        '''
        setShadowRadius(self, shadow_radius: float)

        Synopsis
        -----
        Sets the value of the "shadowRadius" attribute of a non-extended
        light node.

        Returns:
        -----
        None

        Parameters:
        -----
        shadow_radius: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def castSoftShadows(self, ReturnStatus: MFnNonExtendedLight.MStatus): 
        '''
        castSoftShadows(self, ReturnStatus: MFnNonExtendedLight.MStatus) -> bool

        Synopsis
        -----
        Retrieves the value of the "castSoftShadows" attribute of a non-
        extended light node. This attribute determines whether or not the
        light casts soft shadows.

        Returns: 
        ----- 
        The value of the "castSoftShadows" attribute of the non-extended
        light node.

        Parameters:
        -----
        ReturnStatus: MFnNonExtendedLight.MStatus
        	[out] -> return status


        '''
        pass

    def setCastSoftShadows(self, cast_soft_shadows: bool): 
        '''
        setCastSoftShadows(self, cast_soft_shadows: bool)

        Synopsis
        -----
        Sets the value of the "castSoftShadows" attribute of a non-
        extended light node.

        Returns:
        -----
        None

        Parameters:
        -----
        cast_soft_shadows: bool
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def useDepthMapShadows(self, ReturnStatus: MFnNonExtendedLight.MStatus): 
        '''
        useDepthMapShadows(self, ReturnStatus: MFnNonExtendedLight.MStatus) -> bool

        Synopsis
        -----
        Retrieves the value of the "useDepthMapShadows" attribute of a
        non-extended light node. This attribute determines whether or not
        a depth map will be used in shadow computations for this light.

        Returns: 
        ----- 
        The value of the "useDepthMapShadows" attribute of the non-
        extended light node.

        Parameters:
        -----
        ReturnStatus: MFnNonExtendedLight.MStatus
        	[out] -> return status


        '''
        pass

    def setUseDepthMapShadows(self, use_depth_map: bool): 
        '''
        setUseDepthMapShadows(self, use_depth_map: bool)

        Synopsis
        -----
        Sets the value of the "useDepthMapShadows" attribute of a non-
        extended light node.

        Returns:
        -----
        None

        Parameters:
        -----
        use_depth_map: bool
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def depthMapFilterSize(self, ReturnStatus: MFnNonExtendedLight.MStatus): 
        '''
        depthMapFilterSize(self, ReturnStatus: MFnNonExtendedLight.MStatus) -> short

        Synopsis
        -----
        Retrieves the value of the "depthMapFilterSize" attribute of a
        light node. This attribute determines the size of the filter used
        in depth map shadow computations for the light.

        Returns: 
        ----- 
        The value of the "depthMapFilterSize" attribute of the light
        node.

        Parameters:
        -----
        ReturnStatus: MFnNonExtendedLight.MStatus
        	[out] -> return status


        '''
        pass

    def setDepthMapFilterSize(self, depth_map_filter_size: short): 
        '''
        setDepthMapFilterSize(self, depth_map_filter_size: short)

        Synopsis
        -----
        Sets the value of the "depthMapFilterSize" attribute of a light
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        depth_map_filter_size: short
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def depthMapResolution(self, ReturnStatus: MFnNonExtendedLight.MStatus): 
        '''
        depthMapResolution(self, ReturnStatus: MFnNonExtendedLight.MStatus) -> short

        Synopsis
        -----
        Retrieves the value of the "depthMapResolution" attribute of a
        light node. This attribute determines the resolution of the depth
        map for this light.

        Returns: 
        ----- 
        The value of the "depthMapResolution" attribute of the light
        node.

        Parameters:
        -----
        ReturnStatus: MFnNonExtendedLight.MStatus
        	[out] -> return status


        '''
        pass

    def setDepthMapResolution(self, depth_map_resolution: short): 
        '''
        setDepthMapResolution(self, depth_map_resolution: short)

        Synopsis
        -----
        Sets the value of the "depthMapResolution" attribute of a light
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        depth_map_resolution: short
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def depthMapBias(self, ReturnStatus: MFnNonExtendedLight.MStatus): 
        '''
        depthMapBias(self, ReturnStatus: MFnNonExtendedLight.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "depthMapBias" attribute of a light
        node. This attribute represents the depth bias applied in depth
        map shadow computations to prevent self-shadowing artifacts.

        Returns: 
        ----- 
        The value of the "depthMapBias" attribute of the light node.

        Parameters:
        -----
        ReturnStatus: MFnNonExtendedLight.MStatus
        	[out] -> return status


        '''
        pass

    def setDepthMapBias(self, depth_map_bias: float): 
        '''
        setDepthMapBias(self, depth_map_bias: float)

        Synopsis
        -----
        Sets the value of the "depthMapBias" attribute of a light node.

        Returns:
        -----
        None

        Parameters:
        -----
        depth_map_bias: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def useDepthMapAutoFocus(self, ReturnStatus: MFnNonExtendedLight.MStatus): 
        '''
        useDepthMapAutoFocus(self, ReturnStatus: MFnNonExtendedLight.MStatus) -> bool

        Synopsis
        -----
        Retrieves the value of the "useDepthMapAutoFocus" attribute of a
        non-extended light node. This attribute determines whether to
        automatically scale the depth map so that it only fills the area
        of the light's illumination that contains shadow casting objects.

        Returns: 
        ----- 
        The value of the "useDepthMapAutoFocus" attribute of the non-
        extended light node.

        Parameters:
        -----
        ReturnStatus: MFnNonExtendedLight.MStatus
        	[out] -> return status


        '''
        pass

    def setUseDepthMapAutoFocus(self, use_depth_map_auto_focus: bool): 
        '''
        setUseDepthMapAutoFocus(self, use_depth_map_auto_focus: bool)

        Synopsis
        -----
        Sets the value of the "useDepthMapAutoFocus" attribute of a non-
        extended light node.

        Returns:
        -----
        None

        Parameters:
        -----
        use_depth_map_auto_focus: bool
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def depthMapWidthFocus(self, ReturnStatus: MFnNonExtendedLight.MStatus): 
        '''
        depthMapWidthFocus(self, ReturnStatus: MFnNonExtendedLight.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "depthMapWidthFocus" attribute of a
        light node. This attribute is used to scale the depth map within
        the area of the light's illumination.

        Returns: 
        ----- 
        The value of the "depthMapWidthFocus" attribute of the light
        node.

        Parameters:
        -----
        ReturnStatus: MFnNonExtendedLight.MStatus
        	[out] -> return status


        '''
        pass

    def setDepthMapWidthFocus(self, depth_map_width_focus: float): 
        '''
        setDepthMapWidthFocus(self, depth_map_width_focus: float)

        Synopsis
        -----
        Sets the value of the "depthMapWidthFocus" attribute of a light
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        depth_map_width_focus: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def depthMapFocus(self, ReturnStatus: MFnNonExtendedLight.MStatus): 
        '''
        depthMapFocus(self, ReturnStatus: MFnNonExtendedLight.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "depthMapFocus" attribute of a light
        node. This attribute represents the depth map's field of view.

        Returns: 
        ----- 
        The value of the "depthMapFocus" attribute of the light node.

        Parameters:
        -----
        ReturnStatus: MFnNonExtendedLight.MStatus
        	[out] -> return status


        '''
        pass

    def setDepthMapFocus(self, depth_map_focus: float): 
        '''
        setDepthMapFocus(self, depth_map_focus: float)

        Synopsis
        -----
        Sets the value of the "depthMapFocus" attribute of a light node.

        Returns:
        -----
        None

        Parameters:
        -----
        depth_map_focus: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

class MFnNumericAttribute:
    '''Numeric attribute function set.
MFnNumericAttribute is the function set for dependency node attributes that store
one, two or three untyped numeric values. A numeric attribute
supports both a "hard" maximum/minimum and a soft
maximum/minimum. The soft maximum/minimum are used by the
Attribute Editor as the limits on its slider, but values within
the hard range can be typed in the input box.
As a convenience,
MFnNumericAttribute will set the flags of child attributes as well when the flags of
the parent attribute are set. This is important when creating a
numeric pair or triplet. For example, if
MFnNumericAttribute is used to create a 3 double attribute and the attribute is set
to be keyable, then the three child attributes will also be
marked as keyable.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kNumericAttribute.Reimplemented from MFnAttribute.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnNumericAttribute".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def create(self, full: MString,
                        brief: MString,
                        unitType: MFnNumericData.MFnNumericData,
                        defaultValue: double,
                        ReturnStatus: MFnNumericAttribute.MStatus): 
        '''
        create(self, full: MString,
                        brief: MString,
                        unitType: MFnNumericData.MFnNumericData,
                        defaultValue: double,
                        ReturnStatus: MFnNumericAttribute.MStatus) -> MObject

        Synopsis
        -----
        Create a new numeric attribute and return it as an MObject. If
        the attribute create is of a type that stores two or more values,
        then a compound attribute will be created. The names of child
        attributes will have "0", "1" and "2" appended to both the full
        and brief names. As well, each child will use the defaultValue
        parameter as its default.The create method needs to be called on
        a per node basis. That means if you want to create and add the
        same attribute to multiple nodes, you need to call the create
        method for each node to get a unique MObject back. If you call
        create just once and add the attribute to multiple nodes, Maya
        will encounter a fatal error.

        Returns: 
        ----- 
        An MObject representing the new attribute

        Parameters:
        -----
        full: MString
        	[in] -> the full (or long) name of the attribute 

        brief: MString
        	[in] -> the brief (or short) name of the attribute 

        unitType: MFnNumericData.MFnNumericData
        	[in] -> an element of the 

        defaultValue: double
        	[in] -> the default value for the new attribute 

        ReturnStatus: MFnNumericAttribute.MStatus
        	[out] -> 



        '''
        pass

    def createColor(self, full: MString,
                        brief: MString,
                        ReturnStatus: MFnNumericAttribute.MStatus): 
        '''
        createColor(self, full: MString,
                        brief: MString,
                        ReturnStatus: MFnNumericAttribute.MStatus) -> MObject

        Synopsis
        -----
        Create a new color attribute and return it as an MObject. The
        names of child attributes will have "r", "g" and "b" appended to
        both the full and brief names.The create method needs to be
        called on a per node basis. That means if you want to create and
        add the same attribute to multiple nodes, you need to call the
        create method for each node to get a unique MObject back. If you
        call create just once and add the attribute to multiple nodes,
        Maya will encounter a fatal error.They type of the created
        attribute will be MFnNumericData::k3Float.

        Returns: 
        ----- 
        An MObject representing the new attribute

        Parameters:
        -----
        full: MString
        	[in] -> the full (or long) name of the attribute 

        brief: MString
        	[in] -> the brief (or short) name of the attribute 

        ReturnStatus: MFnNumericAttribute.MStatus
        	[out] -> 



        '''
        pass

    def createPoint(self, full: MString,
                        brief: MString,
                        ReturnStatus: MFnNumericAttribute.MStatus): 
        '''
        createPoint(self, full: MString,
                        brief: MString,
                        ReturnStatus: MFnNumericAttribute.MStatus) -> MObject

        Synopsis
        -----
        Create a new point attribute and return it as an MObject. The
        names of child attributes will have "x", "y" and "z" appended to
        both the full and brief names.The create method needs to be
        called on a per node basis. That means if you want to create and
        add the same attribute to multiple nodes, you need to call the
        create method for each node to get a unique MObject back. If you
        call create just once and add the attribute to multiple nodes,
        Maya will encounter a fatal error.They type of the created
        attribute will be MFnNumericData::k3Float.

        Returns: 
        ----- 
        An MObject representing the new attribute

        Parameters:
        -----
        full: MString
        	[in] -> the full (or long) name of the attribute 

        brief: MString
        	[in] -> the brief (or short) name of the attribute 

        ReturnStatus: MFnNumericAttribute.MStatus
        	[out] -> 



        '''
        pass

    def createAddr(self, fullName: MString,
                        briefName: MString,
                        defaultValue: void,
                        ReturnStatus: MFnNumericAttribute.MStatus): 
        '''
        createAddr(self, fullName: MString,
                        briefName: MString,
                        defaultValue: void,
                        ReturnStatus: MFnNumericAttribute.MStatus) -> MObject

        Synopsis
        -----
        Create a new address attribute and return it as an MObject. The
        create method needs to be called on a per node basis. That means
        if you want to create and add the same attribute to multiple
        nodes, you need to call the create method for each node to get a
        unique MObject back. If you call create just once and add the
        attribute to multiple nodes, Maya will encounter a fatal error.

        Returns: 
        ----- 
        An MObject representing the new attribute

        Parameters:
        -----
        fullName: MString
        	[in] -> the full (or long) name of the attribute 

        briefName: MString
        	[in] -> the brief (or short) name of the attribute 

        defaultValue: void
        	[in] -> the default value for the new attribute 

        ReturnStatus: MFnNumericAttribute.MStatus
        	[out] -> 



        '''
        pass

    @overload
    def create(self, fullName: MString,
                        briefName: MString,
                        child1: MObject,
                        child2: MObject,
                        child3: MObject,
                        ReturnStatus: MFnNumericAttribute.MStatus): 
        '''
        create(self, fullName: MString,
                        briefName: MString,
                        child1: MObject,
                        child2: MObject,
                        child3: MObject,
                        ReturnStatus: MFnNumericAttribute.MStatus) -> MObject

        Synopsis
        -----
        Create a new numeric attribute and return it as an MObject. This
        form of the create method allows the creation of a compound
        attribute having two or three numeric child attributes. All of
        the child attributes must be of the same type (eg all of type
        kDouble) and must already have been created but not yet added to
        the node.It is also possible to use angle and distance attributes
        created with MFnUnitAttribute. These attributes will act the same
        as a double attribute.

        Returns: 
        ----- 
        An MObject representing the new attribute

        Parameters:
        -----
        fullName: MString
        	[in] -> the full (or long) name of the attribute 

        briefName: MString
        	[in] -> the brief (or short) name of the attribute 

        child1: MObject
        	[in] -> a numeric attribute 

        child2: MObject
        	[in] -> a numeric attribute 

        child3: MObject
        	[in] -> a numeric attribute (optional) 

        ReturnStatus: MFnNumericAttribute.MStatus
        	[out] -> 



        '''
        pass

    @overload
    def create(self, fullName: MString,
                        briefName: MString,
                        child1: MObject,
                        child2: MObject,
                        child3: MObject,
                        child4: MObject,
                        ReturnStatus: MFnNumericAttribute.MStatus): 
        '''
        create(self, fullName: MString,
                        briefName: MString,
                        child1: MObject,
                        child2: MObject,
                        child3: MObject,
                        child4: MObject,
                        ReturnStatus: MFnNumericAttribute.MStatus) -> MObject

        Synopsis
        -----
        Introduced in 2019.0 Create a new numeric attribute and return it
        as an MObject.This form of the create method allows the creation
        of a compound attribute having four numeric child attributes. All
        of the child attributes must be of the same type (eg all of type
        kDouble) and must already have been created but not yet added to
        the node.It is also possible to use angle and distance attributes
        created with MFnUnitAttribute. These attributes will act the same
        as a double attribute.

        Returns: 
        ----- 
        An MObject representing the new attribute

        Parameters:
        -----
        fullName: MString
        	[in] -> the full (or long) name of the attribute 

        briefName: MString
        	[in] -> the brief (or short) name of the attribute 

        child1: MObject
        	[in] -> the first of the four numeric attributes 

        child2: MObject
        	[in] -> the second of the four numeric attributes 

        child3: MObject
        	[in] -> the third of the four numeric attributes 

        child4: MObject
        	[in] -> the fourth of the four numeric attributes 

        ReturnStatus: MFnNumericAttribute.MStatus
        	[out] -> 



        '''
        pass

    def unitType(self, ReturnStatus: MFnNumericAttribute.MStatus): 
        '''
        unitType(self, ReturnStatus: MFnNumericAttribute.MStatus) -> MFnNumericData.MFnNumericData

        Synopsis
        -----
        Return the unit type of this attribute.

        Returns: 
        ----- 
        An element of the MFnNumericData::Type enum

        Parameters:
        -----
        ReturnStatus: MFnNumericAttribute.MStatus
        	[out] -> 



        '''
        pass

    def child(self, index: int,
                        ReturnStatus: MFnNumericAttribute.MStatus): 
        '''
        child(self, index: int,
                        ReturnStatus: MFnNumericAttribute.MStatus) -> MObject

        Synopsis
        -----
        Return the indicated child attribute as an MObject. No index
        checking is done by this routine, so you must ensure that the
        index provided is valid.

        Returns: 
        ----- 
        An MObject representing the child attribute

        Parameters:
        -----
        index: int
        	[in] -> the full (or long) name of the attribute 

        ReturnStatus: MFnNumericAttribute.MStatus
        	[out] -> 



        '''
        pass

    def hasMin(self, ReturnStatus: MFnNumericAttribute.MStatus): 
        '''
        hasMin(self, ReturnStatus: MFnNumericAttribute.MStatus) -> bool

        Synopsis
        -----
        Determine whether or not this attribute has a minimum value set.

        Returns: 
        ----- 
        true if the attribute has a minimum value, and false otherwise

        Parameters:
        -----
        ReturnStatus: MFnNumericAttribute.MStatus
        	[out] -> 



        '''
        pass

    def hasMax(self, ReturnStatus: MFnNumericAttribute.MStatus): 
        '''
        hasMax(self, ReturnStatus: MFnNumericAttribute.MStatus) -> bool

        Synopsis
        -----
        Determine whether or not this attribute has a maximum value set.

        Returns: 
        ----- 
        true if the attribute has a maximum value, and false otherwise

        Parameters:
        -----
        ReturnStatus: MFnNumericAttribute.MStatus
        	[out] -> 



        '''
        pass

    def hasSoftMin(self, ReturnStatus: MFnNumericAttribute.MStatus): 
        '''
        hasSoftMin(self, ReturnStatus: MFnNumericAttribute.MStatus) -> bool

        Synopsis
        -----
        Determine whether or not this double attribute has a soft minimum
        value set.

        Returns: 
        ----- 
        true if the attribute has a soft minimum value, and false
        otherwise

        Parameters:
        -----
        ReturnStatus: MFnNumericAttribute.MStatus
        	[out] -> 



        '''
        pass

    def hasSoftMax(self, ReturnStatus: MFnNumericAttribute.MStatus): 
        '''
        hasSoftMax(self, ReturnStatus: MFnNumericAttribute.MStatus) -> bool

        Synopsis
        -----
        Determine whether or not this double attribute has a soft maximum
        value set.

        Returns: 
        ----- 
        true if the attribute has a soft maximum value, and false
        otherwise

        Parameters:
        -----
        ReturnStatus: MFnNumericAttribute.MStatus
        	[out] -> 



        '''
        pass

    @overload
    def getMin(self, min: double): 
        '''
        getMin(self, min: double)

        Synopsis
        -----
        Return the minimum value for this double attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        min: double
        	[out] -> the minimum value for this attribute


        '''
        pass

    @overload
    def getMin(self, min1: double,
                        min2: double): 
        '''
        getMin(self, min1: double,
                        min2: double)

        Synopsis
        -----
        Return the minimum values for the two children (both double
        attributes) of this compound attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        min1: double
        	[out] -> the minimum value for the first child attribute 

        min2: double
        	[out] -> the minimum value for the second child attribute


        '''
        pass

    @overload
    def getMin(self, min1: double,
                        min2: double,
                        min3: double): 
        '''
        getMin(self, min1: double,
                        min2: double,
                        min3: double)

        Synopsis
        -----
        Return the minimum values for the three children (all double
        attributes) of this compound attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        min1: double
        	[out] -> the minimum value for the first child attribute 

        min2: double
        	[out] -> the minimum value for the second child attribute 

        min3: double
        	[out] -> the minimum value for the third child attribute


        '''
        pass

    @overload
    def getMin(self, min1: double,
                        min2: double,
                        min3: double,
                        min4: double): 
        '''
        getMin(self, min1: double,
                        min2: double,
                        min3: double,
                        min4: double)

        Synopsis
        -----
        Introduced in 2019.0 Return the minimum values for the four
        children (all double attributes) of this compound attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        min1: double
        	[out] -> the minimum value for the first child attribute 

        min2: double
        	[out] -> the minimum value for the second child attribute 

        min3: double
        	[out] -> the minimum value for the third child attribute 

        min4: double
        	[out] -> the minimum value for the fourth child attribute


        '''
        pass

    @overload
    def getMax(self, max: double): 
        '''
        getMax(self, max: double)

        Synopsis
        -----
        Return the maximum value for this double attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        max: double
        	[out] -> the maximum value for this attribute


        '''
        pass

    @overload
    def getMax(self, max1: double,
                        max2: double): 
        '''
        getMax(self, max1: double,
                        max2: double)

        Synopsis
        -----
        Return the maximum values for the two children (both double
        attributes) of this compound attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        max1: double
        	[out] -> the maximum value for the first child attribute 

        max2: double
        	[out] -> the maximum value for the second child attribute


        '''
        pass

    @overload
    def getMax(self, max1: double,
                        max2: double,
                        max3: double): 
        '''
        getMax(self, max1: double,
                        max2: double,
                        max3: double)

        Synopsis
        -----
        Return the maximum values for the three children (all double
        attributes) of this compound attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        max1: double
        	[out] -> the maximum value for the first child attribute 

        max2: double
        	[out] -> the maximum value for the second child attribute 

        max3: double
        	[out] -> the maximum value for the third child attribute


        '''
        pass

    @overload
    def getMax(self, max1: double,
                        max2: double,
                        max3: double,
                        max4: double): 
        '''
        getMax(self, max1: double,
                        max2: double,
                        max3: double,
                        max4: double)

        Synopsis
        -----
        Introduced in 2019.0 Return the maximum values for the four
        children (all double attributes) of this compound attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        max1: double
        	[out] -> the maximum value for the first child attribute 

        max2: double
        	[out] -> the maximum value for the second child attribute 

        max3: double
        	[out] -> the maximum value for the third child attribute 

        max4: double
        	[out] -> the maximum value for the fourth child attribute


        '''
        pass

    def getSoftMin(self, min: double): 
        '''
        getSoftMin(self, min: double)

        Synopsis
        -----
        Return the minimum value for this double attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        min: double
        	[out] -> the minimum value for this attribute


        '''
        pass

    def getSoftMax(self, max: double): 
        '''
        getSoftMax(self, max: double)

        Synopsis
        -----
        Return the maximum value for this double attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        max: double
        	[out] -> the soft maximum value for this attribute


        '''
        pass

    @overload
    def setMin(self, min: double): 
        '''
        setMin(self, min: double)

        Synopsis
        -----
        Set the minimum value for this double attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        min: double
        	[in] -> the minimum value for this attribute


        '''
        pass

    @overload
    def setMin(self, min1: double,
                        min2: double): 
        '''
        setMin(self, min1: double,
                        min2: double)

        Synopsis
        -----
        Set the minimum values for the two children (both double
        attributes) of this compound attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        min1: double
        	[in] -> the minimum value for the first child attribute 

        min2: double
        	[in] -> the minimum value for the second child attribute


        '''
        pass

    @overload
    def setMin(self, min1: double,
                        min2: double,
                        min3: double): 
        '''
        setMin(self, min1: double,
                        min2: double,
                        min3: double)

        Synopsis
        -----
        Set the minimum values for the three children (all double
        attributes) of this compound attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        min1: double
        	[in] -> the minimum value for the first child attribute 

        min2: double
        	[in] -> the minimum value for the second child attribute 

        min3: double
        	[in] -> the minimum value for the third child attribute


        '''
        pass

    @overload
    def setMin(self, min1: double,
                        min2: double,
                        min3: double,
                        min4: double): 
        '''
        setMin(self, min1: double,
                        min2: double,
                        min3: double,
                        min4: double)

        Synopsis
        -----
        Introduced in 2019.0 Set the minimum values for the four children
        (all double attributes) of this compound attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        min1: double
        	[in] -> the minimum value for the first child attribute 

        min2: double
        	[in] -> the minimum value for the second child attribute 

        min3: double
        	[in] -> the minimum value for the third child attribute 

        min4: double
        	[in] -> the minimum value for the fourth child attribute


        '''
        pass

    @overload
    def setMax(self, max: double): 
        '''
        setMax(self, max: double)

        Synopsis
        -----
        Set the maximum value for this double attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        max: double
        	[in] -> the maximum value for this attribute


        '''
        pass

    @overload
    def setMax(self, max1: double,
                        max2: double): 
        '''
        setMax(self, max1: double,
                        max2: double)

        Synopsis
        -----
        Set the maximum values for the two children (both double
        attributes) of this compound attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        max1: double
        	[in] -> the maximum value for the first child attribute 

        max2: double
        	[in] -> the maximum value for the second child attribute


        '''
        pass

    @overload
    def setMax(self, max1: double,
                        max2: double,
                        max3: double): 
        '''
        setMax(self, max1: double,
                        max2: double,
                        max3: double)

        Synopsis
        -----
        Set the maximum values for the three children (all double
        attributes) of this compound attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        max1: double
        	[in] -> the maximum value for the first child attribute 

        max2: double
        	[in] -> the maximum value for the second child attribute 

        max3: double
        	[in] -> the maximum value for the third child attribute


        '''
        pass

    @overload
    def setMax(self, max1: double,
                        max2: double,
                        max3: double,
                        max4: double): 
        '''
        setMax(self, max1: double,
                        max2: double,
                        max3: double,
                        max4: double)

        Synopsis
        -----
        Introduced in 2019.0 Set the maximum values for the four children
        (all double attributes) of this compound attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        max1: double
        	[in] -> the maximum value for the first child attribute 

        max2: double
        	[in] -> the maximum value for the second child attribute 

        max3: double
        	[in] -> the maximum value for the third child attribute 

        max4: double
        	[in] -> the maximum value for the fourth child attribute


        '''
        pass

    def setSoftMin(self, min: double): 
        '''
        setSoftMin(self, min: double)

        Synopsis
        -----
        Set the soft minimum value for this double attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        min: double
        	[in] -> the minimum value for this attribute


        '''
        pass

    def setSoftMax(self, max: double): 
        '''
        setSoftMax(self, max: double)

        Synopsis
        -----
        Set the soft maximum value for this double attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        max: double
        	[in] -> the soft maximum value for this attribute


        '''
        pass

    @overload
    def getDefault(self, def1: bool): 
        '''
        getDefault(self, def1: bool)

        Synopsis
        -----
        Get the default value for this boolean attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: bool
        	[out] -> returns the default value for this attribute


        '''
        pass

    @overload
    def getDefault(self, def1: char): 
        '''
        getDefault(self, def1: char)

        Synopsis
        -----
        Get the default value for this character attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: char
        	[out] -> returns the default value for this attribute


        '''
        pass

    @overload
    def getDefault(self, def1: int): 
        '''
        getDefault(self, def1: int)

        Synopsis
        -----
        Gets the default value for this integral attribute. This method
        can be used to get default values for attributes of type byte,
        short or int.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: int
        	[out] -> returns the default value for this attribute


        '''
        pass

    @overload
    def getDefault(self, def1: int,
                        def2: int): 
        '''
        getDefault(self, def1: int,
                        def2: int)

        Synopsis
        -----
        Gets the default value for the integral attributes of the two
        children of this attribute. This method is used to query the
        default values for attributes of type byte, short or int.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: int
        	[out] -> returns the default value for first child of this attribute 

        def2: int
        	[out] -> returns the default value for second child of this attribute


        '''
        pass

    @overload
    def getDefault(self, def1: int,
                        def2: int,
                        def3: int): 
        '''
        getDefault(self, def1: int,
                        def2: int,
                        def3: int)

        Synopsis
        -----
        Gets the default value for the integral attributes of the three
        children of this attribute. This method is used to get the
        default values for attributes of type byte, short or int.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: int
        	[out] -> returns the default value for first child of this attribute 

        def2: int
        	[out] -> returns the default value for second child of this attribute 

        def3: int
        	[out] -> returns the default value for third child of this attribute


        '''
        pass

    @overload
    def getDefault(self, def1: MFnNumericAttribute.MInt64): 
        '''
        getDefault(self, def1: MFnNumericAttribute.MInt64)

        Synopsis
        -----
        Gets the default value for this integral attribute and returns it
        as a 64-bit int. This method can be used to get default values
        for attributes of type byte, short, int or MInt64.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: MFnNumericAttribute.MInt64
        	[out] -> returns the default value for this attribute


        '''
        pass

    @overload
    def getDefault(self, def1: float): 
        '''
        getDefault(self, def1: float)

        Synopsis
        -----
        Gets the default value for this float attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: float
        	[out] -> returns the default value for this attribute


        '''
        pass

    @overload
    def getDefault(self, def1: float,
                        def2: float): 
        '''
        getDefault(self, def1: float,
                        def2: float)

        Synopsis
        -----
        Gets the default value for the float attributes of the two
        children of this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: float
        	[out] -> returns the default value for first child of this attribute 

        def2: float
        	[out] -> returns the default value for second child of this attribute


        '''
        pass

    @overload
    def getDefault(self, def1: float,
                        def2: float,
                        def3: float): 
        '''
        getDefault(self, def1: float,
                        def2: float,
                        def3: float)

        Synopsis
        -----
        Gets the default value for the float attributes of the three
        children of this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: float
        	[out] -> returns the default value for first child of this attribute 

        def2: float
        	[out] -> returns the default value for second child of this attribute 

        def3: float
        	[out] -> returns the default value for third child of this attribute


        '''
        pass

    @overload
    def getDefault(self, def1: double): 
        '''
        getDefault(self, def1: double)

        Synopsis
        -----
        Get the default value for this double attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: double
        	[out] -> returns the default value for this attribute


        '''
        pass

    @overload
    def getDefault(self, def1: double,
                        def2: double): 
        '''
        getDefault(self, def1: double,
                        def2: double)

        Synopsis
        -----
        Gets the default value for the double attributes of the two
        children of this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: double
        	[out] -> returns the default value for first child of this attribute 

        def2: double
        	[out] -> returns the default value for second child of this attribute


        '''
        pass

    @overload
    def getDefault(self, def1: double,
                        def2: double,
                        def3: double): 
        '''
        getDefault(self, def1: double,
                        def2: double,
                        def3: double)

        Synopsis
        -----
        Gets the default value for the double attributes of the three
        children of this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: double
        	[out] -> returns the default value for first child of this attribute 

        def2: double
        	[out] -> returns the default value for second child of this attribute 

        def3: double
        	[out] -> returns the default value for third child of this attribute


        '''
        pass

    @overload
    def getDefault(self, def1: double,
                        def2: double,
                        def3: double,
                        def4: double): 
        '''
        getDefault(self, def1: double,
                        def2: double,
                        def3: double,
                        def4: double)

        Synopsis
        -----
        Gets the default value for the double attributes of the four
        children of this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: double
        	[out] -> returns the default value for first child of this attribute 

        def2: double
        	[out] -> returns the default value for second child of this attribute 

        def3: double
        	[out] -> returns the default value for third child of this attribute 

        def4: double
        	[out] -> returns the default value for fourth child of this attribute


        '''
        pass

    @overload
    def getDefault(self, def1: void): 
        '''
        getDefault(self, def1: void)

        Synopsis
        -----
        Get the default value for this address attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: void
        	[out] -> returns the default value for this attribute


        '''
        pass

    @overload
    def setDefault(self, def1: bool): 
        '''
        setDefault(self, def1: bool)

        Synopsis
        -----
        Set a new default value for this boolean attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: bool
        	[in] -> new the default value for this attribute


        '''
        pass

    @overload
    def setDefault(self, def1: char): 
        '''
        setDefault(self, def1: char)

        Synopsis
        -----
        Set a new default value for this character attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: char
        	[in] -> new the default value for this attribute


        '''
        pass

    @overload
    def setDefault(self, def1: int): 
        '''
        setDefault(self, def1: int)

        Synopsis
        -----
        Set a new default value for this integral attribute. This method
        can be used to set default values for byte, short or int
        attributes.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: int
        	[in] -> new the default value for this attribute


        '''
        pass

    @overload
    def setDefault(self, def1: int,
                        def2: int): 
        '''
        setDefault(self, def1: int,
                        def2: int)

        Synopsis
        -----
        Set a new default value for the integral attributes of the two
        children of this attribute. This method is used to set default
        values for byte, short or int attributes.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: int
        	[in] -> new the default value for first child of this attribute 

        def2: int
        	[in] -> new the default value for second child of this attribute


        '''
        pass

    @overload
    def setDefault(self, def1: int,
                        def2: int,
                        def3: int): 
        '''
        setDefault(self, def1: int,
                        def2: int,
                        def3: int)

        Synopsis
        -----
        Set a new default value for the integral attributes of the three
        children of this attribute. This method is used to set default
        values for byte, short or int attributes.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: int
        	[in] -> new the default value for first child of this attribute 

        def2: int
        	[in] -> new the default value for second child of this attribute 

        def3: int
        	[in] -> new the default value for third child of this attribute


        '''
        pass

    @overload
    def setDefault(self, def1: MFnNumericAttribute.MInt64): 
        '''
        setDefault(self, def1: MFnNumericAttribute.MInt64)

        Synopsis
        -----
        Set a new default value for this integral attribute. This method
        can be used to set default values for byte, short, int or MInt64
        attributes.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: MFnNumericAttribute.MInt64
        	[in] -> new the default value for this attribute


        '''
        pass

    @overload
    def setDefault(self, def1: float): 
        '''
        setDefault(self, def1: float)

        Synopsis
        -----
        Set a new default value for this float attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: float
        	[in] -> new the default value for this attribute


        '''
        pass

    @overload
    def setDefault(self, def1: float,
                        def2: float): 
        '''
        setDefault(self, def1: float,
                        def2: float)

        Synopsis
        -----
        Set a new default value for the float attributes of the two
        children of this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: float
        	[in] -> new the default value for first child of this attribute 

        def2: float
        	[in] -> new the default value for second child of this attribute


        '''
        pass

    @overload
    def setDefault(self, def1: float,
                        def2: float,
                        def3: float): 
        '''
        setDefault(self, def1: float,
                        def2: float,
                        def3: float)

        Synopsis
        -----
        Set a new default value for the float attributes of the three
        children of this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: float
        	[in] -> new the default value for first child of this attribute 

        def2: float
        	[in] -> new the default value for second child of this attribute 

        def3: float
        	[in] -> new the default value for third child of this attribute


        '''
        pass

    @overload
    def setDefault(self, def1: double): 
        '''
        setDefault(self, def1: double)

        Synopsis
        -----
        Set a new default value for this double attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: double
        	[in] -> new the default value for this attribute


        '''
        pass

    @overload
    def setDefault(self, def1: double,
                        def2: double): 
        '''
        setDefault(self, def1: double,
                        def2: double)

        Synopsis
        -----
        Set a new default value for the double attributes of the two
        children of this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: double
        	[in] -> new the default value for first child of this attribute 

        def2: double
        	[in] -> new the default value for second child of this attribute


        '''
        pass

    @overload
    def setDefault(self, def1: double,
                        def2: double,
                        def3: double): 
        '''
        setDefault(self, def1: double,
                        def2: double,
                        def3: double)

        Synopsis
        -----
        Set a new default value for the double attributes of the three
        children of this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: double
        	[in] -> new the default value for first child of this attribute 

        def2: double
        	[in] -> new the default value for second child of this attribute 

        def3: double
        	[in] -> new the default value for third child of this attribute


        '''
        pass

    @overload
    def setDefault(self, def1: double,
                        def2: double,
                        def3: double,
                        def4: double): 
        '''
        setDefault(self, def1: double,
                        def2: double,
                        def3: double,
                        def4: double)

        Synopsis
        -----
        Set a new default value for the double attributes of the four
        children of this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: double
        	[in] -> new the default value for first child of this attribute 

        def2: double
        	[in] -> new the default value for second child of this attribute 

        def3: double
        	[in] -> new the default value for third child of this attribute 

        def4: double
        	[in] -> new the default value for fourth child of this attribute


        '''
        pass

    @overload
    def setDefault(self, def1: void): 
        '''
        setDefault(self, def1: void)

        Synopsis
        -----
        Set a new default value for this address attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        def1: void
        	[in] -> new the default value for this attribute


        '''
        pass

class MFnNumericData:
    '''Numeric data function set.
MFnNumericData allows the creation and manipulation of numeric data objects for
use in the dependency graph. Normally, data objects are not
required for the transmission of numeric data. The graph supports
numeric types directly (see the methods of
MDataHandle).
Numeric data objects are useful if you have an attribute that
accepts generic data. A generic attribute can accept multiple
types of data, so you cannot hardwire it to accept a specific
type of numeric data. So, generic attributes can only accept
numeric data in the form of actual data objects.
This function set only supports numeric data with multiple
components, such as a pair of floats or a triple of integers.
Single numeric values can be retrieved directly using
MPlug or
MDataHandle.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kNumericData.Reimplemented from MFnData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnNumericData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnNumericData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, dataType: MFnNumericData.Type,
                        ReturnStatus: MFnNumericData.MStatus): 
        '''
        create(self, dataType: MFnNumericData.Type,
                        ReturnStatus: MFnNumericData.MStatus) -> MObject

        Synopsis
        -----
        Creates a new data object of the given type. Only pair and
        triples of numeric data may be created (eg k3Float).

        Returns: 
        ----- 
        A pointer to the new object

        Parameters:
        -----
        dataType: MFnNumericData.Type
        	[in] -> data type of object to create 

        ReturnStatus: MFnNumericData.MStatus
        	[out] -> return status


        '''
        pass

    def numericType(self, ReturnStatus: MFnNumericData.MStatus): 
        '''
        numericType(self, ReturnStatus: MFnNumericData.MStatus) -> MFnNumericData.MFnNumericData

        Synopsis
        -----
        Returns the type of the numeric data object.

        Returns: 
        ----- 
        Type of data

        Parameters:
        -----
        ReturnStatus: MFnNumericData.MStatus
        	[out] -> return status


        '''
        pass

    def getData2Short(self, val1: short,
                        val2: short): 
        '''
        getData2Short(self, val1: short,
                        val2: short)

        Synopsis
        -----
        Gets the stored value of this data object as a pair of short
        integers. The data object must have been created as a pair of
        short integers for this to succeed.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: short
        	[out] -> storage for the first element 

        val2: short
        	[out] -> storage for the second element


        '''
        pass

    def getData2Int(self, val1: int,
                        val2: int): 
        '''
        getData2Int(self, val1: int,
                        val2: int)

        Synopsis
        -----
        Gets the stored value of this data object as a pair of int
        integers. The data object must have been created as a pair of int
        integers for this to succeed.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: int
        	[out] -> storage for the first element 

        val2: int
        	[out] -> storage for the second element


        '''
        pass

    def getData2Float(self, val1: float,
                        val2: float): 
        '''
        getData2Float(self, val1: float,
                        val2: float)

        Synopsis
        -----
        Gets the stored value of this data object as a pair of floats.
        The data object must have been created as a pair of floats for
        this to succeed.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: float
        	[out] -> storage for the first element 

        val2: float
        	[out] -> storage for the second element


        '''
        pass

    def getData2Double(self, val1: double,
                        val2: double): 
        '''
        getData2Double(self, val1: double,
                        val2: double)

        Synopsis
        -----
        Gets the stored value of this data object as a pair of doubles.
        The data object must have been created as a pair of doubles for
        this to succeed.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: double
        	[out] -> storage for the first element 

        val2: double
        	[out] -> storage for the second element


        '''
        pass

    def getData3Short(self, val1: short,
                        val2: short,
                        val3: short): 
        '''
        getData3Short(self, val1: short,
                        val2: short,
                        val3: short)

        Synopsis
        -----
        Gets the stored value of this data object as a triple of short
        integers. The data object must have been created as a pair of
        short integers for this to succeed.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: short
        	[out] -> storage for the first element 

        val2: short
        	[out] -> storage for the second element 

        val3: short
        	[out] -> storage for the third element


        '''
        pass

    def getData3Int(self, val1: int,
                        val2: int,
                        val3: int): 
        '''
        getData3Int(self, val1: int,
                        val2: int,
                        val3: int)

        Synopsis
        -----
        Gets the stored value of this data object as a triple of int
        integers. The data object must have been created as a triple of
        int integers for this to succeed.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: int
        	[out] -> storage for the first element 

        val2: int
        	[out] -> storage for the second element 

        val3: int
        	[out] -> storage for the third element


        '''
        pass

    def getData3Float(self, val1: float,
                        val2: float,
                        val3: float): 
        '''
        getData3Float(self, val1: float,
                        val2: float,
                        val3: float)

        Synopsis
        -----
        Gets the stored value of this data object as a triple of floats.
        The data object must have been created as a triple of floats for
        this to succeed.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: float
        	[out] -> storage for the first element 

        val2: float
        	[out] -> storage for the second element 

        val3: float
        	[out] -> storage for the third element


        '''
        pass

    def getData3Double(self, val1: double,
                        val2: double,
                        val3: double): 
        '''
        getData3Double(self, val1: double,
                        val2: double,
                        val3: double)

        Synopsis
        -----
        Gets the stored value of this data object as a triple of doubles.
        The data object must have been created as a triple of doubles for
        this to succeed.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: double
        	[out] -> storage for the first element 

        val2: double
        	[out] -> storage for the second element 

        val3: double
        	[out] -> storage for the third element


        '''
        pass

    def getData4Double(self, val1: double,
                        val2: double,
                        val3: double,
                        val4: double): 
        '''
        getData4Double(self, val1: double,
                        val2: double,
                        val3: double,
                        val4: double)

        Synopsis
        -----
        Gets the stored value of this data object as a quadruple of
        doubles. The data object must have been created as a quadruple of
        doubles for this to succeed.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: double
        	[out] -> storage for the first element 

        val2: double
        	[out] -> storage for the second element 

        val3: double
        	[out] -> storage for the third element 

        val4: double
        	[out] -> storage for the fourth element


        '''
        pass

    def setData2Short(self, val1: short,
                        val2: short): 
        '''
        setData2Short(self, val1: short,
                        val2: short)

        Synopsis
        -----
        Sets the stored value of this data object as a pair of short
        integers. The data object must have been created as a pair of
        short integers for this to succeed.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: short
        	[in] -> the first element 

        val2: short
        	[in] -> the second element


        '''
        pass

    def setData2Int(self, val1: int,
                        val2: int): 
        '''
        setData2Int(self, val1: int,
                        val2: int)

        Synopsis
        -----
        Sets the stored value of this data object as a pair of int
        integers. The data object must have been created as a pair of int
        integers for this to succeed.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: int
        	[in] -> the first element 

        val2: int
        	[in] -> the second element


        '''
        pass

    def setData2Float(self, val1: float,
                        val2: float): 
        '''
        setData2Float(self, val1: float,
                        val2: float)

        Synopsis
        -----
        Sets the stored value of this data object as a pair of floats.
        The data object must have been created as a pair of floats for
        this to succeed.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: float
        	[in] -> the first element 

        val2: float
        	[in] -> the second element


        '''
        pass

    def setData2Double(self, val1: double,
                        val2: double): 
        '''
        setData2Double(self, val1: double,
                        val2: double)

        Synopsis
        -----
        Sets the stored value of this data object as a pair of doubles.
        The data object must have been created as a pair of doubles for
        this to succeed.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: double
        	[in] -> the first element 

        val2: double
        	[in] -> the second element


        '''
        pass

    def setData3Short(self, val1: short,
                        val2: short,
                        val3: short): 
        '''
        setData3Short(self, val1: short,
                        val2: short,
                        val3: short)

        Synopsis
        -----
        Sets the stored value of this data object as a triple of short
        integers. The data object must have been created as a triple of
        short integers for this to succeed.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: short
        	[in] -> the first element 

        val2: short
        	[in] -> the second element 

        val3: short
        	[in] -> the third element


        '''
        pass

    def setData3Int(self, val1: int,
                        val2: int,
                        val3: int): 
        '''
        setData3Int(self, val1: int,
                        val2: int,
                        val3: int)

        Synopsis
        -----
        Sets the stored value of this data object as a triple of int
        integers. The data object must have been created as a triple of
        int integers for this to succeed.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: int
        	[in] -> the first element 

        val2: int
        	[in] -> the second element 

        val3: int
        	[in] -> the third element


        '''
        pass

    def setData3Float(self, val1: float,
                        val2: float,
                        val3: float): 
        '''
        setData3Float(self, val1: float,
                        val2: float,
                        val3: float)

        Synopsis
        -----
        Sets the stored value of this data object as a triple of floats.
        The data object must have been created as a triple of floats for
        this to succeed.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: float
        	[in] -> the first element 

        val2: float
        	[in] -> the second element 

        val3: float
        	[in] -> the third element


        '''
        pass

    def setData3Double(self, val1: double,
                        val2: double,
                        val3: double): 
        '''
        setData3Double(self, val1: double,
                        val2: double,
                        val3: double)

        Synopsis
        -----
        Sets the stored value of this data object as a triple of doubles.
        The data object must have been created as a triple of doubles for
        this to succeed.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: double
        	[in] -> the first element 

        val2: double
        	[in] -> the second element 

        val3: double
        	[in] -> the third element


        '''
        pass

    def setData4Double(self, val1: double,
                        val2: double,
                        val3: double,
                        val4: double): 
        '''
        setData4Double(self, val1: double,
                        val2: double,
                        val3: double,
                        val4: double)

        Synopsis
        -----
        Sets the stored value of this data object as a quadruple of
        doubles. The data object must have been created as a quadruple of
        doubles for this to succeed.

        Returns:
        -----
        None

        Parameters:
        -----
        val1: double
        	[in] -> the first element 

        val2: double
        	[in] -> the second element 

        val3: double
        	[in] -> the third element 

        val4: double
        	[in] -> the fourth element


        '''
        pass

class Type:
    '''Supported numerical types. 
    Non-functional class.  Values for this enum:
    kInvalid
    kBoolean
    kByte
    kChar
    kShort
    k2Short
    k3Short
    kLong
    kInt
    k2Long
    k2Int
    k3Long
    k3Int
    kInt64
    kFloat
    k2Float
    k3Float
    kDouble
    k2Double
    k3Double
    k4Double
    kAddr
    kLast
    '''

    def __init__(self):
        pass

    def kInvalid(self):
        '''This is an enum of Type.
        - Description: Invalid data. 
        - Value: 0
        '''
        pass

    def kBoolean(self):
        '''This is an enum of Type.
        - Description: Boolean. 
        - Value: 1
        '''
        pass

    def kByte(self):
        '''This is an enum of Type.
        - Description: One byte. 
        - Value: 2
        '''
        pass

    def kChar(self):
        '''This is an enum of Type.
        - Description: One character. 
        - Value: 3
        '''
        pass

    def kShort(self):
        '''This is an enum of Type.
        - Description: One short. 
        - Value: 4
        '''
        pass

    def k2Short(self):
        '''This is an enum of Type.
        - Description: Two shorts. 
        - Value: 5
        '''
        pass

    def k3Short(self):
        '''This is an enum of Type.
        - Description: Three shorts. 
        - Value: 6
        '''
        pass

    def kLong(self):
        '''This is an enum of Type.
        - Description: One long. Same as int since "long" is not platform-consistent. 
        - Value: 7
        '''
        pass

    def kInt(self):
        '''This is an enum of Type.
        - Description: One int. 
        - Value: 7
        '''
        pass

    def k2Long(self):
        '''This is an enum of Type.
        - Description: Two longs. Same as 2 ints since "long" is not platform-consistent. 
        - Value: 8
        '''
        pass

    def k2Int(self):
        '''This is an enum of Type.
        - Description: Two ints. 
        - Value: 8
        '''
        pass

    def k3Long(self):
        '''This is an enum of Type.
        - Description: Three longs. Same as 3 ints since "long" is not platform-consistent. 
        - Value: 9
        '''
        pass

    def k3Int(self):
        '''This is an enum of Type.
        - Description: Three ints. 
        - Value: 9
        '''
        pass

    def kInt64(self):
        '''This is an enum of Type.
        - Description: One 64-bit int. 
        - Value: 10
        '''
        pass

    def kFloat(self):
        '''This is an enum of Type.
        - Description: One float. 
        - Value: 11
        '''
        pass

    def k2Float(self):
        '''This is an enum of Type.
        - Description: Two floats. 
        - Value: 12
        '''
        pass

    def k3Float(self):
        '''This is an enum of Type.
        - Description: Three floats. 
        - Value: 13
        '''
        pass

    def kDouble(self):
        '''This is an enum of Type.
        - Description: One double. 
        - Value: 14
        '''
        pass

    def k2Double(self):
        '''This is an enum of Type.
        - Description: Two doubles. 
        - Value: 15
        '''
        pass

    def k3Double(self):
        '''This is an enum of Type.
        - Description: Three doubles. 
        - Value: 16
        '''
        pass

    def k4Double(self):
        '''This is an enum of Type.
        - Description: Four doubles. 
        - Value: 17
        '''
        pass

    def kAddr(self):
        '''This is an enum of Type.
        - Description: An address. 
        - Value: 18
        '''
        pass

    def kLast(self):
        '''This is an enum of Type.
        - Description: Last value. Does not represent a real type, but can be used to loop on all possible types. 
        - Value: 19
        '''
        pass

class MFnNurbsCurve:
    '''NURBS curve function set.
This is the function set for NURBS (Non-Uniform Rational
B-Spline) curves.
The shape of a NURBS curve is defined by an array of CVs (control
vertices), an array of knot values, a degree, and a form. There
are 3 possible "forms" for the curve:
,
 and
.
The
 and
 forms are quite similar, and in fact a closed curve will become
an open curve if either the first or last CV is moved so that
they are no longer coincident. To create an open or closed curve
of degree N with M spans, you must provide M+N CVs. This implies
that for a degree N curve, you must specify at least N+1 CVs to
get a curve with a single span.
The number of knots required for a curve is M + 2N - 1. If you
want the curve to start exactly at the first CV and end exactly
at the last CV, then the knot vector must be structured to have
degree N "multiplicity" at the beginning and end. This means that
the first N knots must be identical, and the last N knots must be
identical.
A
 curve is a special case of a closed curve. Instead of having
just the first and last CVs coincident, the last N CVs in the
curve must overlap the first N CVs. This results in a curve with
no tangent break at the seam where the ends meet. The last N CVs
in a periodic curve are permanently bound to the first N CVs, and
Maya will not allow those last N CVs to be repositioned. If one
or more of the first N CVs of the curve are repositioned, the
overlapping CV's will remain bound, and will also be moved.
In order to create a periodic curve, you must specify at least
2N+1 CVs, so that that last N can overlap the first N and you
still have 1 non-overlapping CV left. The number of CVs required
to create a periodic curve is still N+M (with a lower limit of
2N+1), but you must ensure that the positions of the last N CVs
are identical to the positions of the first N.
You still need M + 2N - 1 knots for a periodic curve, but the
knot values required are more restrictive than for open or closed
curves because of the overlap at the ends, The difference between
the first N pairs of knots values should be equal to the
difference between the last N pairs. Additionally there can be no
knot multiplicity at the ends of the curve, because that would
compromise the tangent continuity property. So an example knot
sequence could begin with knots at { -(N-2), -(N-1), ... , 0}.
Note that some third party applications use a different format
for knots, where the number of knots required for a curve is
M+2N+1 rather than M+2N-1 as used in Maya. Both knot
representations are equivalent mathematically. To convert from
one of these external representations into the Maya
representation, simply omit the first and last knots from the
external representation when creating the Maya representation. To
convert from the Maya representation into the external
representation, add two new knots at the beginning and end of the
Maya knot sequence. The value of these new knots depends on the
existing knot sequence. For a knot sequence with multiple end
knots, simply duplicate the existing first and last knots once
more, for example:
Maya representation: {0,0,0,...,N,N,N}
 External representation: {0,0,0,0,...,N,N,N,N}
For a knot sequence with uniform end knots, create the new knots
offset at an interval equal to the existing first and last knot
intervals, for example:
Maya representation: {0,1,2,...,N,N+1,N+2}
 External representation: {-1,0,1,2,...,N,N+1,N+2,N+3}
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kNurbsCurve.Reimplemented from MFnDagNode.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnNurbsCurve".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def create(self, controlVertices: MPointArray,
                        knots: MDoubleArray,
                        degree: int,
                        form: MFnNurbsCurve.Form,
                        create2D: bool,
                        createRational: bool,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        create(self, controlVertices: MPointArray,
                        knots: MDoubleArray,
                        degree: int,
                        form: MFnNurbsCurve.Form,
                        create2D: bool,
                        createRational: bool,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> MObject

        Synopsis
        -----
        This method creates a nurbs curve from the given control vertices
        and knot vector and sets this function set to operate on the new
        curve. The parentOrOwner argument is used to specify the owner of
        the new curve.If the parentOrOwner is kNurbsCurveData then the
        created curve will be of type kNurbsCurveGeom and will be
        returned. The parentOrOwner will become the owner of the new
        curve.If parentOrOwner is NULL then a new transform will be
        created and returned which will be the parent for the curve. The
        new transform will be added to the DAG.If parentOrOwner is a DAG
        node then the new curve will be returned and the parentOrOwner
        will become its parent.The knot vector is valid if it is non-
        decreasing and of length spans + 2 * degree - 1. The cvs are
        assumed to be in rational form (as opposed to homogeneous)If the
        form specified is kClosed and the endpoints are not close then a
        new span will be created inorder to close the curve.

        Returns: 
        ----- 
        If parentOrOwner is NULL then the transform for this curve is
        returned  If parentOrOwner is a DAG object then the curve shape
        is returned  The curve geometry is returned if parentOrOwner is
        of type kNurbsCurveData

        Parameters:
        -----
        controlVertices: MPointArray
        	[in] -> an array of control vertices 

        knots: MDoubleArray
        	[in] -> an array of knots 

        degree: int
        	[in] -> the degree to create the curve with 

        form: MFnNurbsCurve.Form
        	[in] -> either kOpen, kClosed, kPeriodic 

        create2D: bool
        	[in] -> true means that the Z-coordinates of the controlVertices will be ignored, giving a curve in the local XY plane 

        createRational: bool
        	[in] -> true means curve being created will be rational 

        parentOrOwner: MObject
        	[in] -> the DAG parent or kNurbsCurveData the new curve will belong to 

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    def createWithEditPoints(self, editPoints: MPointArray,
                        degree: int,
                        form: MFnNurbsCurve.Form,
                        create2D: bool,
                        createRational: bool,
                        uniformParam: bool,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        createWithEditPoints(self, editPoints: MPointArray,
                        degree: int,
                        form: MFnNurbsCurve.Form,
                        create2D: bool,
                        createRational: bool,
                        uniformParam: bool,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> MObject

        Synopsis
        -----
        This method creates a nurbs curve from the given edit points and
        sets this function set to operate on the new curve. The
        parentOrOwner argument is used to specify the owner of the new
        curve.If the parentOrOwner is kNurbsCurveData then the created
        curve will be of type kNurbsCurveGeom and will be returned. The
        parentOrOwner will become the owner of the new curve.If
        parentOrOwner is NULL then a new transform will be created and
        returned which will be the parent for the curve. The new
        transform will be added to the DAG.If parentOrOwner is a DAG node
        then the new curve will be returned and the parentOrOwner will
        become its parent.If the form specified is kClosed and the
        endpoints are not close then a new span will be created inorder
        to close the curve.

        Returns: 
        ----- 
        If parentOrOwner is NULL then the transform for this curve is
        returned  If parentOrOwner is a DAG object then the curve shape
        is returned  The curve geometry is returned if parentOrOwner is
        of type kNurbsCurveData

        Parameters:
        -----
        editPoints: MPointArray
        	[in] -> an array of edit points 

        degree: int
        	[in] -> the degree to create the curve with 

        form: MFnNurbsCurve.Form
        	[in] -> either kOpen, kClosed, kPeriodic 

        create2D: bool
        	[in] -> true means that the Z-coordinates of the controlVertices will be ignored, giving a curve in the local XY plane 

        createRational: bool
        	[in] -> true means curve being created will be rational 

        uniformParam: bool
        	[in] -> true means curve being created will have uniform parameterization, false means chord length 

        parentOrOwner: MObject
        	[in] -> the DAG parent or kNurbsCurveData the new curve will belong to 

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def create(self, sources: MObjectArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        create(self, sources: MObjectArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> MObject

        Synopsis
        -----
        This method creates a single curve that combines all the curves
        in the MObjectArray. The method assumes the curves in the sources
        are good for building a single curve: It is good enough to be C0
        continouns (tangent breaks are okay).

        Returns: 
        ----- 
        If parentOrOwner is NULL then the transform for this curve is
        returned  If parentOrOwner is a DAG object then the curve shape
        is returned  The curve geometry is returned if parentOrOwner is
        of type kNurbsCurveData

        Parameters:
        -----
        sources: MObjectArray
        	[in] -> Input array of souce curves. 

        parentOrOwner: MObject
        	[in] -> the DAG parent or kNurbsCurveData the new curve will belong to 

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    def copy(self, source: MObject,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        copy(self, source: MObject,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> MObject

        Synopsis
        -----
        This method creates a copy of a nurbs curve. The parentOrOwner
        argument is used to specify the owner of the new curve.If the
        parentOrOwner is kNurbsCurveData then the created curve will be
        of type kNurbsCurveGeom and will be returned. The parentOrOwner
        will become the owner of the new curve.If parentOrOwner is NULL
        then a new transform will be created and returned which will be
        the parent for the curve. The new transform will be added to the
        DAG.If parentOrOwner is a DAG node then the new curve will be
        returned and the parentOrOwner will become its parent.

        Returns: 
        ----- 
        If parentOrOwner is NULL then the transform for this curve is
        returned  If parentOrOwner is a DAG object then the curve shape
        is returned  The curve geometry is returned if parentOrOwner is
        of type kNurbsCurveData

        Parameters:
        -----
        source: MObject
        	[in] -> the curve to be copied 

        parentOrOwner: MObject
        	[in] -> the DAG parent or kNurbsCurveData the new curve will belong to 

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    def reverse(self, constructionHistory: bool): 
        '''
        reverse(self, constructionHistory: bool)

        Synopsis
        -----
        This method reverse the curve direction.

        Returns:
        -----
        None

        Parameters:
        -----
        constructionHistory: bool
        	[in] -> This parameter has no effect. Regardless of how it is set, if the function set was initialized with the DAG path of a curve node which already has history, then the reverse operation will be added into that history, otherwise the reverse operation will be applied directly to the curve's data and no history will be left behind.


        '''
        pass

    def makeMultipleEndKnots(self): 
        '''
        makeMultipleEndKnots(self)

        Synopsis
        -----
        This method gives end knots full multiplicity. This ensures the
        end points of the curve interpolate the first and last CVs. It
        can also be used to convert a periodic curve to a closed curve.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cv(self, index: int,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        cv(self, index: int,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> MObject

        Synopsis
        -----
        Returns a CV as a component. MItCurveCV can be used to examine or
        modify the returned CV.Any modifications to the CV will affect
        the curve. After all modifications are done, updateCurve should
        be called to have the curve recalculate its cached geometry.

        Returns: 
        ----- 
        A handle to the CVs requested

        Parameters:
        -----
        index: int
        	[out] -> Index of the CV 

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    def getCV(self, index: int,
                        pt: MPoint,
                        space: MSpace.MSpace): 
        '''
        getCV(self, index: int,
                        pt: MPoint,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Get the CV at the given index.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of the CV that will be retrieved 

        pt: MPoint
        	[out] -> Storage for the CV 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def setCV(self, index: int,
                        pt: MPoint,
                        space: MSpace.MSpace): 
        '''
        setCV(self, index: int,
                        pt: MPoint,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the CV at the given index to the given point. The method
        updateCurve should be called to trigger changes in the curve.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of the CV that will be changed 

        pt: MPoint
        	[in] -> The new value that the CV will take 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def form(self, ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        form(self, ReturnStatus: MFnNurbsCurve.MStatus) -> MFnNurbsCurve.MFnNurbsCurve

        Synopsis
        -----
        This method returns the form of the curve. The curve can be open,
        closed, or periodic.

        Returns: 
        ----- 
        MFnNurbsCurve::kOpen  MFnNurbsCurve::kClosed
        MFnNurbsCurve::kPeriodic

        Parameters:
        -----
        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    def degree(self, ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        degree(self, ReturnStatus: MFnNurbsCurve.MStatus) -> int

        Synopsis
        -----
        Return the degree of this curve. If the degree cannot be
        determined then 0 is returned.

        Returns: 
        ----- 
        The degree of this curve.

        Parameters:
        -----
        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    def numCVs(self, ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        numCVs(self, ReturnStatus: MFnNurbsCurve.MStatus) -> int

        Synopsis
        -----
        Return the number of CVs for this curve. If the number of CVs
        cannot be determined then 0 is returned.

        Returns: 
        ----- 
        The number of CVs for this curve.

        Parameters:
        -----
        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    def numSpans(self, ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        numSpans(self, ReturnStatus: MFnNurbsCurve.MStatus) -> int

        Synopsis
        -----
        Return the number of spans for this curve. If the number of spans
        cannot be determined then 0 is returned.

        Returns: 
        ----- 
        The number of spans for this curve.

        Parameters:
        -----
        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    def numKnots(self, ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        numKnots(self, ReturnStatus: MFnNurbsCurve.MStatus) -> int

        Synopsis
        -----
        Return the number of knots for this curve. If the number of knots
        cannot be determined then 0 is returned.

        Returns: 
        ----- 
        The number of knots for this curve.

        Parameters:
        -----
        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    def getKnotDomain(self, start: double,
                        end: double): 
        '''
        getKnotDomain(self, start: double,
                        end: double)

        Synopsis
        -----
        Return the range corresponding to the maximum and minimum
        parameter values for this curve.

        Returns:
        -----
        None

        Parameters:
        -----
        start: double
        	[out] -> storage for the max parameter value 

        end: double
        	[out] -> storage for the min parameter value


        '''
        pass

    def getKnots(self, array: MDoubleArray): 
        '''
        getKnots(self, array: MDoubleArray)

        Synopsis
        -----
        This method retrieves a copy of the knot array for this curve.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MDoubleArray
        	[out] -> storage where the parameter values of the knots for this curve will be copied


        '''
        pass

    def setKnots(self, array: MDoubleArray,
                        startIndex: int,
                        endIndex: int): 
        '''
        setKnots(self, array: MDoubleArray,
                        startIndex: int,
                        endIndex: int)

        Synopsis
        -----
        This method is used to set the values of a contiguous group of
        knots of the curve. The range of knots to set is specified using
        the start and end index. The knots of index startIndex to
        endIndex inclusive will be set using the value in the double
        array.Knot indices range from 0 to numKnots() - 1

        Returns:
        -----
        None

        Parameters:
        -----
        array: MDoubleArray
        	[in] -> a double array of knot points 

        startIndex: int
        	[in] -> the starting index of the knots to be altered. 

        endIndex: int
        	[in] -> the ending index of the knots to be altered.


        '''
        pass

    def setKnot(self, index: int,
                        param: double): 
        '''
        setKnot(self, index: int,
                        param: double)

        Synopsis
        -----
        Set the given knot's parameter value. Knot indices range from 0
        to numKnots() - 1.If a knot value is set that breaks the non-
        decreasing requirement for the knot array, the knot value will be
        changed and a kInvalidParameter error will be returned.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> Index of the knot to be set 

        param: double
        	[in] -> The parameter value that the knot will take


        '''
        pass

    def cvs(self, startIndex: int,
                        endIndex: int,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        cvs(self, startIndex: int,
                        endIndex: int,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> MObject

        Synopsis
        -----
        Returns a contiguous group of CVs as a component. MItCurveCV can
        be used to examine or modify the returned CVs.Any modifications
        to these CVs will affect the curve. After all modifications are
        done, updateCurve should be called to have the curve recalculate
        its cached geometry.

        Returns: 
        ----- 
        An MObject providing direct-access to the specified CVs

        Parameters:
        -----
        startIndex: int
        	[in] -> the start index for the CVs to return 

        endIndex: int
        	[in] -> the end index for the CVs to return 

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    def getCVs(self, array: MPointArray,
                        space: MSpace.MSpace): 
        '''
        getCVs(self, array: MPointArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Get the positions of the CVs of this curve. The returned group
        can be accessed via the MPointArray class. Any modifications to
        these CVs will not affect this curve. setCVs should be called to
        modify the original curve. updateCurve should be called to cause
        the curve to redraw itself.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MPointArray
        	[out] -> The array of point values for the CVs 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def setCVs(self, array: MPointArray,
                        space: MSpace.MSpace): 
        '''
        setCVs(self, array: MPointArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the CVs for this curve to the given points.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MPointArray
        	[in] -> The array of point values for the CVs 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def knot(self, index: int,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        knot(self, index: int,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> double

        Synopsis
        -----
        Get the parameter value of the specified knot for this curve.
        Knot indices range from 0 to numKnots() - 1

        Returns: 
        ----- 
        The parameter value for the knot at index.

        Parameters:
        -----
        index: int
        	[in] -> The knot index 

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    def removeKnot(self, atThisParam: double,
                        removeAll: bool): 
        '''
        removeKnot(self, atThisParam: double,
                        removeAll: bool)

        Synopsis
        -----
        Remove one or more knots at the given parameter. If there are
        multiple knots at the given parameter then removeAll determines
        the number to be removed. If it is true then they will all be
        removed. If it is false then all but one will be removed.

        Returns:
        -----
        None

        Parameters:
        -----
        atThisParam: double
        	[in] -> Status code 

        removeAll: bool
        	[in] -> How to handle multiple knots at the same param.


        '''
        pass

    def isPointOnCurve(self, point: MPoint,
                        tolerance: double,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        isPointOnCurve(self, point: MPoint,
                        tolerance: double,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> bool

        Synopsis
        -----
        Determines whether the given point is on this curve.

        Returns: 
        ----- 
        true if the given point is on the curve, false otherwise.

        Parameters:
        -----
        point: MPoint
        	[in] -> The point to test 

        tolerance: double
        	[in] -> The amount of error (epsilon value) in the calculation 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation 

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    def getPointAtParam(self, param: double,
                        point: MPoint,
                        space: MSpace.MSpace): 
        '''
        getPointAtParam(self, param: double,
                        point: MPoint,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Returns the point in space that is at the given parameter value
        of the curve. If the parameter value does not give a valid point
        on the curve, then MS::kInvalidParameter is returned.

        Returns:
        -----
        None

        Parameters:
        -----
        param: double
        	[in] -> The parameter value that we are examining 

        point: MPoint
        	[out] -> Storage for the point being returned 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    @overload
    def getParamAtPoint(self, atThisPoint: MPoint,
                        param: double,
                        space: MSpace.MSpace): 
        '''
        getParamAtPoint(self, atThisPoint: MPoint,
                        param: double,
                        space: MSpace.MSpace)

        Synopsis
        -----
        This method retrieves the parameter value corresponding to the
        given point on the curve.

        Returns:
        -----
        None

        Parameters:
        -----
        atThisPoint: MPoint
        	[in] -> Point to check 

        param: double
        	[out] -> storage for the parameter value 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    @overload
    def getParamAtPoint(self, atThisPoint: MPoint,
                        param: double,
                        tolerance: double,
                        space: MSpace.MSpace): 
        '''
        getParamAtPoint(self, atThisPoint: MPoint,
                        param: double,
                        tolerance: double,
                        space: MSpace.MSpace)

        Synopsis
        -----
        This method retrieves the parameter value corresponding to the
        given point on the curve.

        Returns:
        -----
        None

        Parameters:
        -----
        atThisPoint: MPoint
        	[in] -> Point to check 

        param: double
        	[out] -> storage for the parameter value 

        tolerance: double
        	[in] -> tolerance used for operation 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def isParamOnCurve(self, param: double,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        isParamOnCurve(self, param: double,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> bool

        Synopsis
        -----
        Determines whether the specified parameter value is within the
        bounds of the knot vector of this curve.

        Returns: 
        ----- 
        true The parameter is on this curve.  false Parameter is NOT on
        this curve.

        Parameters:
        -----
        param: double
        	[in] -> The parameter value to check 

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    def normal(self, param: double,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        normal(self, param: double,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> MVector

        Synopsis
        -----
        This method returns the normal at the given parameter value on
        the curve. For degree 1 curves the normal is the vector at right
        angles to the curve that lies in the average plane of the curve.
        For higher degrees the normal is defined by the local curvature
        at param.

        Returns: 
        ----- 
        The normal vector for the given parameter

        Parameters:
        -----
        param: double
        	[in] -> The parameter of the point on the curve from which to get the normal 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation 

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    def tangent(self, param: double,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        tangent(self, param: double,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> MVector

        Synopsis
        -----
        This method returns the tangent at the given parameter value on
        the curve. The resulting tangent vector is normalized.

        Returns: 
        ----- 
        The tangent vector for the given parameter

        Parameters:
        -----
        param: double
        	[in] -> The parameter of the point on the curve from which to get the tangent 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation 

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    def getDerivativesAtParm(self, param: double,
                        pos: MPoint,
                        dU: MVector,
                        space: MSpace.MSpace,
                        dUU: MVector): 
        '''
        getDerivativesAtParm(self, param: double,
                        pos: MPoint,
                        dU: MVector,
                        space: MSpace.MSpace,
                        dUU: MVector)

        Synopsis
        -----
        Evaluate the curve at the given parameter returning the position,
        first derivative and optionally the second derivative.
        Derivatives are not normalized.

        Returns:
        -----
        None

        Parameters:
        -----
        param: double
        	[in] -> U parameter value to evaluate 

        pos: MPoint
        	[out] -> Storage for the XYZ position of the curve 

        dU: MVector
        	[out] -> Storage for the first order partial derivative with respect to u 

        space: MSpace.MSpace
        	[in] -> Coordinate space for the returned vectors 

        dUU: MVector
        	[out] -> Pointer to storage for the second order partial derivative with respect to u


        '''
        pass

    def isPlanar(self, planeNormal: MVector,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        isPlanar(self, planeNormal: MVector,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> bool

        Synopsis
        -----
        This method determines if this curve is a planar curve. If
        planeNormal is non-NULL then the normal to the plane containing
        this curve is returned in this location.

        Returns: 
        ----- 
        Status code

        Parameters:
        -----
        planeNormal: MVector
        	[in] -> Normal to the plane containing this curve 

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def closestPoint(self, toThisPoint: MPoint,
                        param: double,
                        tolerance: double,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        closestPoint(self, toThisPoint: MPoint,
                        param: double,
                        tolerance: double,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> MPoint

        Synopsis
        -----
        This method determines the closest point on the curve to the
        given point.

        Returns: 
        ----- 
        The point on the curve closest to the given point.

        Parameters:
        -----
        toThisPoint: MPoint
        	[in] -> The point to test 

        param: double
        	[in] -> If non-null, on successful returns this will contain the parameter value of the returned point. 

        tolerance: double
        	[in] -> The amount of error (epsilon value) to allow in the calculation 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def closestPoint(self, toThisPoint: MPoint,
                        paramAsGuess: bool,
                        param: double,
                        tolerance: double,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        closestPoint(self, toThisPoint: MPoint,
                        paramAsGuess: bool,
                        param: double,
                        tolerance: double,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> MPoint

        Synopsis
        -----
        This method determines the closest point on the curve to the
        given point. Performance can be greatly increased by supplying a
        starting parameter value that is reasonably close to the final
        point.

        Returns:
        -----
        None

        Parameters:
        -----
        toThisPoint: MPoint
        	[in] -> 

        paramAsGuess: bool
        	[in] -> 

        param: double
        	[in] -> 

        tolerance: double
        	[in] -> 

        space: MSpace.MSpace
        	[in] -> 

        ReturnStatus: MFnNurbsCurve.MStatus
        	[in] -> 


        '''
        pass

    def distanceToPoint(self, pt: MPoint,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        distanceToPoint(self, pt: MPoint,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> double

        Synopsis
        -----
        Returns the distance from the given point to the point on the
        curve which is closest to it.

        Returns: 
        ----- 
        Status code

        Parameters:
        -----
        pt: MPoint
        	[in] -> The point to calculate the distance to 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation 

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    def area(self, tolerance: double,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        area(self, tolerance: double,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> double

        Synopsis
        -----
        This method returns the area bounded by this curve. The curve
        must be closed and planar.A value of 0.0 will be returned if area
        cannot be determined.

        Returns: 
        ----- 
        Status code

        Parameters:
        -----
        tolerance: double
        	[in] -> The amount of error (epsilon value) in the calculation 

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    def length(self, tolerance: double,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        length(self, tolerance: double,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> double

        Synopsis
        -----
        Return the arc length of this curve or 0.0 if it cannot be
        computed.

        Returns: 
        ----- 
        Status code

        Parameters:
        -----
        tolerance: double
        	[in] -> The amount of error (epsilon value) in the calculation 

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def findParamFromLength(self, partLength: double,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        findParamFromLength(self, partLength: double,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> double

        Synopsis
        -----
        Returns the parameter value corresponding to a given length along
        the curve. If the parameter value cannot be found for the given
        length then ReturnStatus is set to kInvalidParameter and the
        parameter for the end point of the curve is returned.

        Returns: 
        ----- 
        The parameter value corresponding to the given length. If a
        parameter cannot be found for the given length then the parameter
        for the end point of the curve is returned.

        Parameters:
        -----
        partLength: double
        	[in] -> Length along the curve to find parameter value at 

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def findParamFromLength(self, partLength: double,
                        tolerance: double,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        findParamFromLength(self, partLength: double,
                        tolerance: double,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> double

        Synopsis
        -----
        Introduced in 2022.0 Returns the parameter value corresponding to
        a given length along the curve with the given tolerance.If the
        parameter value cannot be found for the given length then
        ReturnStatus is set to kInvalidParameter and the parameter for
        the end point of the curve is returned.Note: The default
        tolerance for findParamFromLength is 1.0e-6 and would only need
        to be changed when working at extremely large or small scales.

        Returns: 
        ----- 
        The parameter value corresponding to the given length. If a
        parameter cannot be found for the given length then the parameter
        for the end point of the curve is returned.

        Parameters:
        -----
        partLength: double
        	[in] -> Length along the curve to find parameter value at 

        tolerance: double
        	[in] -> The search tolerance 

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    def findLengthFromParam(self, param: double,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        findLengthFromParam(self, param: double,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> double

        Synopsis
        -----
        Returns the length along the curve corresponding to a given
        parameter value on the curve. If the length cannot be found for
        the given parameter value then ReturnStatus is set to
        kInvalidParameter and a length of zero is returned.

        Returns: 
        ----- 
        The length corresponding to the given parameter value. If the
        given parameter value cannot be found then a length of zero is
        returned.

        Parameters:
        -----
        param: double
        	[in] -> Parameter value on the curve 

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

    def hasHistoryOnCreate(self, ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        hasHistoryOnCreate(self, ReturnStatus: MFnNurbsCurve.MStatus) -> bool

        Synopsis
        -----
        This method determines if the shape was created with history. If
        the object that this function set is attached to is not a shape
        then this method will fail.

        Returns: 
        ----- 
        true shape has history  false shape does not have history

        Parameters:
        -----
        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> 


        '''
        pass

    def updateCurve(self): 
        '''
        updateCurve(self)

        Synopsis
        -----
        This method signals that this curve has changed and needs to be
        recalculated. This method is useful when a large number of CVs
        for the curve are being modified. Instead of updating the curve
        every time a CV is changed it is more efficient to call this
        method once after updating all of the CVs.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def rebuild(self, spans: int,
                        degree: int,
                        keepRange: int,
                        endKnots: int,
                        keepEndPoints: bool,
                        keepTangents: bool,
                        keepControlPoints: bool,
                        tolerance: float,
                        ReturnStatus: MFnNurbsCurve.MStatus): 
        '''
        rebuild(self, spans: int,
                        degree: int,
                        keepRange: int,
                        endKnots: int,
                        keepEndPoints: bool,
                        keepTangents: bool,
                        keepControlPoints: bool,
                        tolerance: float,
                        ReturnStatus: MFnNurbsCurve.MStatus) -> MObject

        Synopsis
        -----
        This method rebuilds a new curve based on the current curve and
        parameters. This method does not change current curve, but put
        the newly rebuilt curve data inside a MFnNurbsCurveData and then
        return it back.This method is useful when you want to use Maya
        native algorithm to do nurbs curve rebuilding.It uses same
        algorithm and similar controls as command 'rebuildCurve'.

        Returns: 
        ----- 
        The new MObject containing the rebuilt curve

        Parameters:
        -----
        spans: int
        	[out] -> The number of spans in resulting curve

        degree: int
        	[out] -> The degree of the resulting curve 1 - linear, 2 - quadratic, 3 - cubic, 5 - quintic, 7 - heptic

        keepRange: int
        	[out] -> Determine the parameterization for the resulting curve. 0 - reparameterize the resulting curve from 0 to 1, 1 - keep the original curve parameterization, 2 - reparameterize the result from 0 to number of spans

        endKnots: int
        	[in] -> End conditions for the curve 0 - uniform end knots, 1 - multiple end knots

        keepEndPoints: bool
        	[in] -> If true, keep the endpoints the same

        keepTangents: bool
        	[in] -> If true, keep the end tangents the same

        keepControlPoints: bool
        	[in] -> If true, the CVs will remain the same.

        tolerance: float
        	[in] -> The tolerance with which to rebuild

        ReturnStatus: MFnNurbsCurve.MStatus
        	[out] -> Status code


        '''
        pass

class Form:
    '''Forms that a curve may take. 
    Non-functional class.  Values for this enum:
    kInvalid
    kOpen
    kClosed
    kPeriodic
    kLast
    '''

    def __init__(self):
        pass

    def kInvalid(self):
        '''This is an enum of Form.
        - Description:  
        - Value: 0
        '''
        pass

    def kOpen(self):
        '''This is an enum of Form.
        - Description: Ends are independent. 
        - Value: 1
        '''
        pass

    def kClosed(self):
        '''This is an enum of Form.
        - Description: Endpoints are coincident. 
        - Value: 2
        '''
        pass

    def kPeriodic(self):
        '''This is an enum of Form.
        - Description: Ends overlap such that there is no break in tangency. 
        - Value: 3
        '''
        pass

    def kLast(self):
        '''This is an enum of Form.
        - Description:  
        - Value: 4
        '''
        pass

class MFnNurbsCurveData:
    '''Nurbs Curve function set for dependency node data.
MFnNurbsCurveData allows the creation and manipulation of NurbsCurve data objects
for use in the dependency graph.
If a user written dependency node either accepts or produces
Nurbs Curves, then this class is used to create data blocks into
which Nurbs Curves can be constructed before being passed to
other dependency graph nodes. The
MDataHandle::type method will return kNurbsCurve when data of this type is
present.
If a node is receiving a Nurbs Curve via an input attribute, the
asNurbsCurve method of
MDataHandle can be used to access that input Nurbs Curve.
If a node is to create a Nurbs Curve and send it via an output
attribute, a new
MFnNurbsCurveData must be instantiated and then the create method called to build
the actual data block as an
MObject. This
MObject should be passed to the
MFnNurbsCurve::create method as the parentOrOwner parameter so that the Nurbs Curve
will be constructed inside the data block. The
MDataHandle::set routine is then used to pass the data block down the connection.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kNurbsCurveData.Reimplemented from MFnGeometryData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnNurbsCurveData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnNurbsCurveData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, ReturnStatus: MFnNurbsCurveData.MStatus): 
        '''
        create(self, ReturnStatus: MFnNurbsCurveData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance and initialize
        it with a data block capable of holding a Nurbs Curve.

        Returns: 
        ----- 
        The new MObject

        Parameters:
        -----
        ReturnStatus: MFnNurbsCurveData.MStatus
        	[out] -> kSuccess


        '''
        pass

class MFnNurbsSurface:
    '''NURBS surface function set.
This is the function set for NURBS (Non-Uniform Rational
B-spline) surfaces.
The shape of a NURBS surface is defined by an array of CVs
(control vertices), an array of knot values in the U direction
and an array of knot values in the V direction, a degree in U and
in V, and a form in U and in V.
The U and V knot vectors for NURBS surfaces are of size
 and
. Note: spans = numCVs - degree.
There are 3 possible "forms" for the surface in the U and V
directions:
,
 and
. These forms are described below. Note that the descriptions
below apply to both the U and V directions.
The
 and
 forms are quite similar, and in fact a closed surface will
become an open surface if either the first or last CV is moved so
that they are no longer coincident. To create an open or closed
surface, of degree N, with M spans, you must provide M+N CVs.
This implies that for a degree N surface, you must specify at
least N+1 CVs to get a surface with a single span.
The number of knots required for the surface is M + 2N - 1. If
you want the surface to start exactly at the first CV and end
exactly at the last CV, then the knot vector must be structured
to have degree N "multiplicity" at the beginning and end. This
means that the first N knots must be identical, and the last N
knots must be identical.
A
 surface is a special case of a closed surface. Instead of having
just the first and last CVs coincident, the last N CVs in the
surface, where N is equal to the degree, overlap the first N CVs.
This results in a surface with no tangent break where the ends
meet. The last N CVs in a periodic surface are permanently bound
to the first N CVs, and Maya will not allow those last N CVs to
be repositioned. If one or more of the first N CVs of the surface
are repositioned, the overlapping CV's will remain bound, and
will also be moved.
In order to create a periodic surface, you must specify at least
2N+1 CVs, so that that last N can overlap the first N and you
still have 1 non-overlapping CV left. The number of CVs required
to create a periodic surface is still N+M (with a lower limit of
2N+1), but you must ensure that the positions of the last N CVs
are identical to the positions of the first N.
You still need M + 2N - 1 knots for a periodic surface, but the
knot values required are more restrictive than for open or closed
surfaces because of the overlap of the last N CVs. The first N
knots should be specified at the beginning of the knot array as
values { -(N-1), -(N-2), ... 0 } in order to implement the
overlap. Additionally there can be no knot multiplicity at the
end of the surface, because that would compromise the tangent
continuity property.
Note that some third party applications use a different format
for knots, where the number of knots required for a surface is
M+2N+1 rather than M+2N-1 as used in Maya. Both knot
representations are equivalent mathematically. To convert from
one of these external representations into the Maya
representation, simply omit the first and last knots from the
external representation when creating the Maya representation. To
convert from the Maya representation into the external
representation, add two new knots at the beginning and end of the
Maya knot sequence. The value of these new knots depends on the
existing knot sequence. For a knot sequence with multiple end
knots, simply duplicate the existing first and last knots once
more, for example:
Maya representation: {0,0,0,...,N,N,N} External representation:
{0,0,0,0,...,N,N,N,N}
For a knot sequence with uniform end knots, create the new knots
offset at an interval equal to the existing first and last knot
intervals, for example:
Maya representation: {0,1,2,...,N,N+1,N+2} External
representation: {-1,0,1,2,...,N,N+1,N+2,N+3}
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kNurbsSurface.Reimplemented from MFnDagNode.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnNurbsSurface".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, controlVertices: MPointArray,
                        uKnotSequences: MDoubleArray,
                        vKnotSequences: MDoubleArray,
                        degreeInU: int,
                        degreeInV: int,
                        formU: MFnNurbsSurface.MFnNurbsSurface,
                        formV: MFnNurbsSurface.MFnNurbsSurface,
                        createRational: bool,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        create(self, controlVertices: MPointArray,
                        uKnotSequences: MDoubleArray,
                        vKnotSequences: MDoubleArray,
                        degreeInU: int,
                        degreeInV: int,
                        formU: MFnNurbsSurface.MFnNurbsSurface,
                        formV: MFnNurbsSurface.MFnNurbsSurface,
                        createRational: bool,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> MObject

        Synopsis
        -----
        Creates a nurbs surface from the specified data and sets this
        function set to operate on the new surface. The parentOrOwner
        argument is used to specify the owner of the new surface.If the
        parentOrOwner is kNurbsSurfaceData then the created surface will
        be of type kNurbsSurfaceGeom and will be returned. The
        parentOrOwner will become the owner of the new surface.If
        parentOrOwner is nullptr then a new transform will be created and
        returned which will be the parent for the surface. The new
        transform will be added to the DAG.If parentOrOwner is a DAG node
        then the new surface will be returned and the parentOrOwner will
        become its parent.Note that the knot vectors must be of length
        spans + 2*degree - 1.

        Returns: 
        ----- 
        If parentOrOwner is nullptr then the transform for this surface
        is returned  If parentOrOwner is a DAG object then the new
        surface shape is returned  The surface geometry is returned if
        parentOrOwner is of type kNurbsSurfaceData

        Parameters:
        -----
        controlVertices: MPointArray
        	[in] -> an array of control vertices 

        uKnotSequences: MDoubleArray
        	[in] -> an array of U knot values 

        vKnotSequences: MDoubleArray
        	[in] -> an array of V knot values 

        degreeInU: int
        	[in] -> degree of first set of basis functions 

        degreeInV: int
        	[in] -> degree of second set of basis functions 

        formU: MFnNurbsSurface.MFnNurbsSurface
        	[in] -> open, closed, periodic in U 

        formV: MFnNurbsSurface.MFnNurbsSurface
        	[in] -> open, closed, periodic in V 

        createRational: bool
        	[in] -> create as rational (true) or non-rational (false) surface 

        parentOrOwner: MObject
        	[in] -> specifies what to do with the surface. If a DAG object or nullptr is given then a transform will be created for the new surface and placed under the specified (optional)parent. If kNurbsSurfaceData is given then the surface will become its data. 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def copy(self, source: MObject,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        copy(self, source: MObject,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> MObject

        Synopsis
        -----
        This method creates a copy of a nurbs surface. The parentOrOwner
        argument is used to specify the owner of the new surface.If the
        parentOrOwner is kNurbsSurfaceData then the created surface will
        be of type kNurbsSurfaceGeom and will be returned. The
        parentOrOwner will become the owner of the new surface.If
        parentOrOwner is nullptr then a new transform will be created and
        returned which will be the parent for the surface. The new
        transform will be added to the DAG.If parentOrOwner is a DAG node
        then the new surface will be returned and the parentOrOwner will
        become its parent.

        Returns: 
        ----- 
        If parentOrOwner is nullptr then the transform for this surface
        is returned  If parentOrOwner is a DAG object then the new
        surface shape is returned  The surface geometry is returned if
        parentOrOwner is of type kNurbsSurfaceData

        Parameters:
        -----
        source: MObject
        	[in] -> the surface to be copied 

        parentOrOwner: MObject
        	[in] -> the DAG parent or kNurbsSurfaceData the new surface will belong to 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def getDataObject(self): 
        '''
        getDataObject(self) -> MObject

        Synopsis
        -----
        Returns an MObject if the class has been constructed with an
        MFn::kNurbsSurfaceData entity, otherwise MObject::kNullObj is
        returned.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cv(self, indexU: int,
                        indexV: int,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        cv(self, indexU: int,
                        indexV: int,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> MObject

        Synopsis
        -----
        Returns a component for the specified CV. Components are used to
        specify one or more CVs and are usefull in operating on groups of
        non-contiguous CVs for a curve or surface. Components do not
        contain any information about the surface that they refer to so
        an MDagPath must be specified when dealing with components.

        Returns: 
        ----- 
        The cv component

        Parameters:
        -----
        indexU: int
        	[in] -> U index of CV 

        indexV: int
        	[in] -> V index of CV 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def cvsInU(self, startIndex: int,
                        endIndex: int,
                        rowIndex: int,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        cvsInU(self, startIndex: int,
                        endIndex: int,
                        rowIndex: int,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> MObject

        Synopsis
        -----
        Returns a component for the specified CVs. Components are used to
        specify one or more CVs and are usefull in operating on groups of
        non-contiguous CVs for a curve or surface. Components do not
        contain any information about the surface that they refer to so
        an MDagPath must be specified when dealing with components.

        Returns: 
        ----- 
        The component for the CVs on the given U direction.

        Parameters:
        -----
        startIndex: int
        	[in] -> start CV index in U 

        endIndex: int
        	[in] -> end CV index in U 

        rowIndex: int
        	[in] -> row index 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def cvsInV(self, startIndex: int,
                        endIndex: int,
                        rowIndex: int,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        cvsInV(self, startIndex: int,
                        endIndex: int,
                        rowIndex: int,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> MObject

        Synopsis
        -----
        Returns a component for the specified CVs on the given V
        direction. Components are used to specify one or more CVs and are
        usefull in operating on groups of non-contiguous CVs for a curve
        or surface. Components do not contain any information about the
        surface that they refer to so an MDagPath must be specified when
        dealing with components.

        Returns: 
        ----- 
        The component for the CVs

        Parameters:
        -----
        startIndex: int
        	[in] -> start CV index in V 

        endIndex: int
        	[in] -> end CV index in V 

        rowIndex: int
        	[in] -> row index 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def getCVs(self, array: MPointArray,
                        space: MSpace.MSpace): 
        '''
        getCVs(self, array: MPointArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Get the positions of the CVs on this surface. The returned group
        can be accessed via the MPointArray class. numCVsInU() *
        numCVsInV() points will be returned. Converting from uIndex,
        vIndex is done by "index = numCVsInV() * uIndex + vIndex".Any
        modifications to these CVs will not affect this surface. setCVs
        should be called to modify the original surface. updateSurface
        should be called to cause the surface to redraw itself.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MPointArray
        	[out] -> the array of point values for the CVs 

        space: MSpace.MSpace
        	[in] -> specifies the coordinate system for this operation


        '''
        pass

    def setCVs(self, array: MPointArray,
                        space: MSpace.MSpace): 
        '''
        setCVs(self, array: MPointArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the CVs for this surface to the given points. numCVsInU() *
        numCVsInV() points must be provided. Converting from uIndex,
        vIndex is done by "index = numCVsInV() * uIndex + vIndex".To keep
        this method as fast as possible, no checking of the data is
        performed beyond ensuring that the total number of CVs passed in
        is correct. It is up to the caller to ensure that the CVs provide
        a valid surface, for example by ensuring that overlapping CVs in
        periodic surfaces have the same positions.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MPointArray
        	[in] -> The array of point values of the CVs 

        space: MSpace.MSpace
        	[in] -> specifies the coordinate system for this operation


        '''
        pass

    def getCV(self, indexU: int,
                        indexV: int,
                        pnt: MPoint,
                        space: MSpace.MSpace): 
        '''
        getCV(self, indexU: int,
                        indexV: int,
                        pnt: MPoint,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Get the location of the specified CV.

        Returns:
        -----
        None

        Parameters:
        -----
        indexU: int
        	[in] -> U index of CV 

        indexV: int
        	[in] -> V index of CV 

        pnt: MPoint
        	[out] -> storage for the CV location 

        space: MSpace.MSpace
        	[in] -> coordinate space for the CV


        '''
        pass

    def setCV(self, indexU: int,
                        indexV: int,
                        pt: MPoint,
                        space: MSpace.MSpace): 
        '''
        setCV(self, indexU: int,
                        indexV: int,
                        pt: MPoint,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the location of the specified CV. If the surface is periodic
        then overlapping CVs will be ignored, that is, only indices in U
        and V that are less that the number of spans in U and V
        respectively will be considered.

        Returns:
        -----
        None

        Parameters:
        -----
        indexU: int
        	[in] -> U index of CV 

        indexV: int
        	[in] -> V index of CV 

        pt: MPoint
        	[in] -> new location for the CV 

        space: MSpace.MSpace
        	[in] -> coordinate space for the CV


        '''
        pass

    def formInU(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        formInU(self, ReturnStatus: MFnNurbsSurface.MStatus) -> MFnNurbsSurface.MFnNurbsSurface

        Synopsis
        -----
        Return the form of this surface in U. Form can be kOpen, kClosed,
        kPeriodic, or kUnknownForm.

        Returns: 
        ----- 
        The form of this surface in U

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def formInV(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        formInV(self, ReturnStatus: MFnNurbsSurface.MStatus) -> MFnNurbsSurface.MFnNurbsSurface

        Synopsis
        -----
        Return the form of this surface in V. Form can be kOpen, kClosed,
        kPeriodic, or kUnknownForm.

        Returns: 
        ----- 
        The form of this surface in V

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def isBezier(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        isBezier(self, ReturnStatus: MFnNurbsSurface.MStatus) -> bool

        Synopsis
        -----
        Determine if the knot spacing gives us Bezier surface.

        Returns: 
        ----- 
        true Bezier surface  false B-spline surface

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def isUniform(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        isUniform(self, ReturnStatus: MFnNurbsSurface.MStatus) -> bool

        Synopsis
        -----
        Determine if the knot spacing is uniform.

        Returns: 
        ----- 
        true Uniform knot spacing  false Non-uniform knot spacing

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def isKnotU(self, param: double,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        isKnotU(self, param: double,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> bool

        Synopsis
        -----
        Check if the specified parameter value is a knot value.

        Returns: 
        ----- 
        Boolean value: true if the parameter value is a knot value, false
        otherwise.

        Parameters:
        -----
        param: double
        	[in] -> parameter value to test 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def isKnotV(self, param: double,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        isKnotV(self, param: double,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> bool

        Synopsis
        -----
        Check if the specified parameter value is a knot value.

        Returns: 
        ----- 
        Boolean value: true if the parameter value is a knot value, false
        otherwise.

        Parameters:
        -----
        param: double
        	[in] -> parameter value to test 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def isParamOnSurface(self, paramU: double,
                        paramV: double,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        isParamOnSurface(self, paramU: double,
                        paramV: double,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> bool

        Synopsis
        -----
        Check if the specified parameter is on this surface.

        Returns: 
        ----- 
        Boolean value: true if the parameter value on this surface, false
        otherwise.

        Parameters:
        -----
        paramU: double
        	[in] -> U parameter value 

        paramV: double
        	[in] -> V parameter value 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def getKnotDomain(self, startU: double,
                        endU: double,
                        startV: double,
                        endV: double): 
        '''
        getKnotDomain(self, startU: double,
                        endU: double,
                        startV: double,
                        endV: double)

        Synopsis
        -----
        Returns the maximum and minimum U and V paramter values for this
        surface.

        Returns:
        -----
        None

        Parameters:
        -----
        startU: double
        	[out] -> Start U parameter value 

        endU: double
        	[out] -> End U parameter value 

        startV: double
        	[out] -> Start V parameter value 

        endV: double
        	[out] -> End V parameter value


        '''
        pass

    def degreeU(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        degreeU(self, ReturnStatus: MFnNurbsSurface.MStatus) -> int

        Synopsis
        -----
        Returns the degree of the surface in U (1 - 3).

        Returns: 
        ----- 
        The degree in U

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def degreeV(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        degreeV(self, ReturnStatus: MFnNurbsSurface.MStatus) -> int

        Synopsis
        -----
        Returns the degree of the surface in V (1 - 3).

        Returns: 
        ----- 
        The degree in V

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def numSpansInU(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        numSpansInU(self, ReturnStatus: MFnNurbsSurface.MStatus) -> int

        Synopsis
        -----
        Returns the number of spans in the u direction.

        Returns: 
        ----- 
        The number of spans in U

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def numSpansInV(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        numSpansInV(self, ReturnStatus: MFnNurbsSurface.MStatus) -> int

        Synopsis
        -----
        Returns the number of spans in the v direction.

        Returns: 
        ----- 
        The number of spans in V

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def numNonZeroSpansInU(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        numNonZeroSpansInU(self, ReturnStatus: MFnNurbsSurface.MStatus) -> int

        Synopsis
        -----
        Returns the number of non-zero spans in the U direction. This
        value will be equivalent to the value returned by numSpansInU()
        if all of the internal (non-end) knots are of multiplicity 1. If
        some of the internal knots have higher multiplicity, this value
        will be lower than that returned by numSpansInU(). You can use
        the number of non-zero spans to count the number of visual spans
        on the surface in the U direction, since the empty (zero) spans
        do not appear as a separate span/patch in the display.Further,
        the NURBS face components have the valid index range bounded by
        this value in U direction (i.e., the NURBS face component index
        runs from 0 to numNonZeroSpansInU()-1 inclusivelly.)

        Returns: 
        ----- 
        The number of non-empty (non-zero, visual) spans in U

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def numNonZeroSpansInV(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        numNonZeroSpansInV(self, ReturnStatus: MFnNurbsSurface.MStatus) -> int

        Synopsis
        -----
        Returns the number of non-zero spans in the V direction. This
        value will be equivalent to the value returned by numSpansInV()
        if all of the internal (non-end) knots are of multiplicity 1. If
        some of the internal knots have higher multiplicity, this value
        will be lower than that returned by numSpansInV(). You can use
        the number of non-zero spans to count the number of visual spans
        on the surface in the V direction, since the empty (zero) spans
        do not appear as a separate span/patch in the display.Further,
        the NURBS face components have the valid index range bounded by
        this value in V direction (i.e., the NURBS face component index
        runs from 0 to numNonZeroSpansInV()-1 inclusivelly.)

        Returns: 
        ----- 
        The number of non-empty (non-zero, visual) spans in V

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def numCVsInU(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        numCVsInU(self, ReturnStatus: MFnNurbsSurface.MStatus) -> int

        Synopsis
        -----
        Returns the number of CVs in the U direction (degree + spans).

        Returns: 
        ----- 
        The number of CVs in U

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def numCVsInV(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        numCVsInV(self, ReturnStatus: MFnNurbsSurface.MStatus) -> int

        Synopsis
        -----
        Returns the number of CVs in the V direction (degree + spans).

        Returns: 
        ----- 
        The number of CVs in V

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def numKnotsInU(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        numKnotsInU(self, ReturnStatus: MFnNurbsSurface.MStatus) -> int

        Synopsis
        -----
        Returns the number of knots in U including multiple end knots
        (spans + 2 * degree - 1).

        Returns: 
        ----- 
        The number of knots in U

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def numKnotsInV(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        numKnotsInV(self, ReturnStatus: MFnNurbsSurface.MStatus) -> int

        Synopsis
        -----
        Returns the number of knots in V including multiple end knots
        (spans + 2 * degree - 1).

        Returns: 
        ----- 
        The number of knots in V

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def getKnotsInU(self, array: MDoubleArray): 
        '''
        getKnotsInU(self, array: MDoubleArray)

        Synopsis
        -----
        Get the knots along the U direction for this surface.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MDoubleArray
        	[out] -> Storage for the knot values


        '''
        pass

    def getKnotsInV(self, array: MDoubleArray): 
        '''
        getKnotsInV(self, array: MDoubleArray)

        Synopsis
        -----
        Get the knots along the V direction for this surface.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MDoubleArray
        	[out] -> Storage for the knot values


        '''
        pass

    def setKnotsInU(self, array: MDoubleArray,
                        startIndex: int,
                        endIndex: int): 
        '''
        setKnotsInU(self, array: MDoubleArray,
                        startIndex: int,
                        endIndex: int)

        Synopsis
        -----
        Set the specified U knot values for this surface.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MDoubleArray
        	[in] -> The knot values to be set 

        startIndex: int
        	[in] -> The start knot index 

        endIndex: int
        	[in] -> The end knot index


        '''
        pass

    def setKnotsInV(self, array: MDoubleArray,
                        startIndex: int,
                        endIndex: int): 
        '''
        setKnotsInV(self, array: MDoubleArray,
                        startIndex: int,
                        endIndex: int)

        Synopsis
        -----
        Set the specified V knot values for this surface.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MDoubleArray
        	[in] -> The knot values to be set 

        startIndex: int
        	[in] -> The start knot index 

        endIndex: int
        	[in] -> The end knot index


        '''
        pass

    def knotInU(self, index: int,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        knotInU(self, index: int,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> double

        Synopsis
        -----
        Retrieve the given knot value from this surface at the specified
        U index. U knots are indexed from 0 to numKnotsInU()-1.

        Returns: 
        ----- 
        The knot value

        Parameters:
        -----
        index: int
        	[in] -> The U index of the knot value to get 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def knotInV(self, index: int,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        knotInV(self, index: int,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> double

        Synopsis
        -----
        Retrieve the given knot value from this surface at the specified
        V index. V knots are indexed from 0 to numKnotsInV()-1.

        Returns: 
        ----- 
        The knot value

        Parameters:
        -----
        index: int
        	[in] -> The V index of the knot value to get 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def setKnotInU(self, index: int,
                        param: double): 
        '''
        setKnotInU(self, index: int,
                        param: double)

        Synopsis
        -----
        Set the value of the given existing knot at the specified U
        index. U knots are indexed from 0 to numKnotsInU()-1. Note that
        this method does not insert a new knot, it simply changes the
        value of a knot that already exists.If a knot value is set that
        breaks the non-decreasing requirement for the knot array, the
        knot value will be changed and a kInvalidParameter error will be
        returned.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The U index of the existing knot to be set 

        param: double
        	[out] -> The new parameter value for the knot


        '''
        pass

    def setKnotInV(self, index: int,
                        param: double): 
        '''
        setKnotInV(self, index: int,
                        param: double)

        Synopsis
        -----
        Set the value of the given existing knot at the specified V
        index. V knots are indexed from 0 to numKnotsInV()-1. Note that
        this routine does not insert a new knot, it simply changes the
        value of a knot that already exists.If a knot value is set that
        breaks the non-decreasing requirement for the knot array, the
        knot value will be changed and a kInvalidParameter error will be
        returned.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The V index of the existing knot to be set 

        param: double
        	[in] -> The new value for the knot


        '''
        pass

    def removeKnotInU(self, atThisParam: double,
                        removeAll: bool): 
        '''
        removeKnotInU(self, atThisParam: double,
                        removeAll: bool)

        Synopsis
        -----
        Remove the U knot(s) at the specified parameter value from this
        surface. If there are multiple knots at this parameter then
        removeAll is used to specify how to do the removal.

        Returns:
        -----
        None

        Parameters:
        -----
        atThisParam: double
        	[in] -> Parameter of knot to be removed 

        removeAll: bool
        	[in] -> If true then remove all the knots at the given parameter, otherwise remove all except one knot


        '''
        pass

    def removeKnotInV(self, atThisParam: double,
                        removeAll: bool): 
        '''
        removeKnotInV(self, atThisParam: double,
                        removeAll: bool)

        Synopsis
        -----
        Remove the V knot(s) at the specified parameter value from this
        surface. If there are multiple knots at this parameter then
        removeAll is used to specify how to do the removal.

        Returns:
        -----
        None

        Parameters:
        -----
        atThisParam: double
        	[in] -> Parameter of knot to be removed 

        removeAll: bool
        	[in] -> If true then remove all the knots at the given parameter, otherwise remove all except one knot


        '''
        pass

    def removeOneKnotInU(self, atThisParam: double): 
        '''
        removeOneKnotInU(self, atThisParam: double)

        Synopsis
        -----
        Remove one U knot at the specified parameter value from this
        surface.

        Returns:
        -----
        None

        Parameters:
        -----
        atThisParam: double
        	[in] -> Parameter of knot to be removed


        '''
        pass

    def removeOneKnotInV(self, atThisParam: double): 
        '''
        removeOneKnotInV(self, atThisParam: double)

        Synopsis
        -----
        Remove one V knot at the specified parameter value from this
        surface.

        Returns:
        -----
        None

        Parameters:
        -----
        atThisParam: double
        	[in] -> Parameter of knot to be removed


        '''
        pass

    def normal(self, paramInU: double,
                        paramInV: double,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        normal(self, paramInU: double,
                        paramInV: double,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> MVector

        Synopsis
        -----
        Retrieve the normal at the given parameter value on the surface.

        Returns: 
        ----- 
        The normal vector

        Parameters:
        -----
        paramInU: double
        	[in] -> U parameter at which to obtain normal 

        paramInV: double
        	[in] -> V parameter at which to obtain normal 

        space: MSpace.MSpace
        	[in] -> Coordinate space for the returned vector 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def getTangents(self, paramInU: double,
                        paramInV: double,
                        vectorInU: MVector,
                        vectorInV: MVector,
                        space: MSpace.MSpace): 
        '''
        getTangents(self, paramInU: double,
                        paramInV: double,
                        vectorInU: MVector,
                        vectorInV: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Retrieve the tangents in the U and V directions at the given
        parameter value on the surface. The returned tangent vectors are
        normalized.This method does not fail if the given parameter lies
        within a trimmed away region of a trimmed surface. Use the
        'isPointInTrimmedRegion' method to determine if the uv point lies
        within such a region.

        Returns:
        -----
        None

        Parameters:
        -----
        paramInU: double
        	[in] -> U parameter value at which to obtain tangents 

        paramInV: double
        	[in] -> V parameter value at which to obtain tangents 

        vectorInU: MVector
        	[out] -> Storage for the U tangent vector 

        vectorInV: MVector
        	[out] -> Storage for the V tangent vector 

        space: MSpace.MSpace
        	[in] -> Coordinate space for the returned vectors


        '''
        pass

    def getDerivativesAtParm(self, paramInU: double,
                        paramInV: double,
                        pos: MPoint,
                        dU: MVector,
                        dV: MVector,
                        space: MSpace.MSpace,
                        dUU: MVector,
                        dVV: MVector,
                        dUV: MVector): 
        '''
        getDerivativesAtParm(self, paramInU: double,
                        paramInV: double,
                        pos: MPoint,
                        dU: MVector,
                        dV: MVector,
                        space: MSpace.MSpace,
                        dUU: MVector,
                        dVV: MVector,
                        dUV: MVector)

        Synopsis
        -----
        Evaluate the surface at the given (u,v) coordinate returning
        position, first derivatives and optionally second derivative
        information. The returned derivative vectors are not normalized.
        If either dUU, dVV, or dUV is set to nullptr, the second
        derivatives will not be computed and execution time wil be
        faster.

        Returns:
        -----
        None

        Parameters:
        -----
        paramInU: double
        	[in] -> U parameter value to evaluate 

        paramInV: double
        	[in] -> V parameter value to evaluate 

        pos: MPoint
        	[out] -> Storage for the XYZ position of (u,v) 

        dU: MVector
        	[out] -> Storage for the first order partial derivative with respect to u 

        dV: MVector
        	[out] -> Storage for the first order partial derivative with respect to v 

        space: MSpace.MSpace
        	[in] -> Coordinate space for the returned vectors 

        dUU: MVector
        	[out] -> Pointer to storage for the second order partial derivative with respect to u 

        dVV: MVector
        	[out] -> Pointer to storage for the second order partial derivative with respect to v 

        dUV: MVector
        	[out] -> Pointer to storage for the second order partial derivative with respect to u then v


        '''
        pass

    def isFoldedOnBispan(self): 
        '''
        isFoldedOnBispan(self) -> bool

        Synopsis
        -----
        Evaluate the surface to determine if it contains any folds or
        creases. The entire surface including trimmed regions is
        examined. This function will only check for folds on bispan
        boundaries and thus will not catch all cases.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def area(self, tolerance: double,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        area(self, tolerance: double,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> double

        Synopsis
        -----
        Calculates the surface area of this nurbs surface. A value of 0.0
        will be returned if the area cannot be determined successfully.

        Returns: 
        ----- 
        The area of this surface

        Parameters:
        -----
        tolerance: double
        	[in] -> tolerance value to be used for computations 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def area(self, space: MSpace.MSpace,
                        tolerance: double,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        area(self, space: MSpace.MSpace,
                        tolerance: double,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> double

        Synopsis
        -----
        Calculates the surface area of this nurbs surface in world or
        local space. A value of 0.0 will be returned if the area cannot
        be determined successfully.

        Returns: 
        ----- 
        The area of this surface

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> Coordinate space for the returned vectors 

        tolerance: double
        	[in] -> Tolerance value to be used for computations 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def closestPoint(self, toThisPoint: MPoint,
                        paramU: double,
                        paramV: double,
                        ignoreTrimBoundaries: bool,
                        tolerance: double,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        closestPoint(self, toThisPoint: MPoint,
                        paramU: double,
                        paramV: double,
                        ignoreTrimBoundaries: bool,
                        tolerance: double,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> MPoint

        Synopsis
        -----
        Return the closest point on this surface to the given point.

        Returns: 
        ----- 
        The closest point on this surface to the given point

        Parameters:
        -----
        toThisPoint: MPoint
        	[in] -> Point to be compared. 

        paramU: double
        	[out] -> U parameter value of the closest point. Ignored if null. 

        paramV: double
        	[out] -> V parameter value of the closest point. Ignored if null. 

        ignoreTrimBoundaries: bool
        	[in] -> If this is true and the surface is trimmed, look for the point on the entire, untrimmed surface ignoring any trim curves. 

        tolerance: double
        	[in] -> Tolerance value to be used for computations. 

        space: MSpace.MSpace
        	[in] -> Coordinate space in which perform this operation, 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code.


        '''
        pass

    @overload
    def closestPoint(self, toThisPoint: MPoint,
                        paramAsStart: bool,
                        paramU: double,
                        paramV: double,
                        ignoreTrimBoundaries: bool,
                        tolerance: double,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        closestPoint(self, toThisPoint: MPoint,
                        paramAsStart: bool,
                        paramU: double,
                        paramV: double,
                        ignoreTrimBoundaries: bool,
                        tolerance: double,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> MPoint

        Synopsis
        -----
        Return the closest point on this surface to the given point.
        Performance can be greatly increased by supplying a starting
        parameter value that is reasonably close to the final point and
        setting 'paramAsStart' to true. However great care must be taken
        with the use of this parameter and the choice of starting
        value.If 'paramAsStart' is true, the algorithm will begin to
        search for the closest point at the given parameter value, and
        will check the local surface to see which direction will bring it
        closer to the given point. It then offsets in this direction and
        repeats the process, iteratively traversing the surface until it
        finds the closest point.This algorithm will fail if it encounters
        a seam before reaching the closest point, or if it finds a local
        closest point, such as a bulge on a mesh where an offset in any
        direction will take it further from the given point, even if that
        is not the true closest point on the mesh. For this reason it is
        advisable to avoid using this option unless absolutely sure that
        the initial point will be a good enough approximation to the
        final point that these conditions will not occur.

        Returns:
        -----
        None

        Parameters:
        -----
        toThisPoint: MPoint
        	[in] -> 

        paramAsStart: bool
        	[in] -> 

        paramU: double
        	[in] -> 

        paramV: double
        	[in] -> 

        ignoreTrimBoundaries: bool
        	[in] -> 

        tolerance: double
        	[in] -> 

        space: MSpace.MSpace
        	[in] -> 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[in] -> 


        '''
        pass

    def isPointOnSurface(self, point: MPoint,
                        tolerance: double,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        isPointOnSurface(self, point: MPoint,
                        tolerance: double,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> bool

        Synopsis
        -----
        Check if the given point is on this surface.

        Returns: 
        ----- 
        Boolean value: true if the given point is on this surface, false
        otherwise.

        Parameters:
        -----
        point: MPoint
        	[in] -> Point to test 

        tolerance: double
        	[in] -> tolerance value to be used for computations 

        space: MSpace.MSpace
        	[in] -> Coordinate space for this operation 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def getParamAtPoint(self, atThisPoint: MPoint,
                        paramU: double,
                        paramV: double,
                        ignoreTrimBoundaries: bool,
                        space: MSpace.MSpace,
                        tolerance: double): 
        '''
        getParamAtPoint(self, atThisPoint: MPoint,
                        paramU: double,
                        paramV: double,
                        ignoreTrimBoundaries: bool,
                        space: MSpace.MSpace,
                        tolerance: double)

        Synopsis
        -----
        Get the parameter value corresponding to the given point on the
        surface (or underlying surface). Note, when ignoreTrimBoundaries
        if false, the UV parameters will still be returned if found on
        the untrimmed surface even though MS::kFailure is returned. This
        may be useful in cases where you are walking a trim edge and
        points are determined to be trimmed away because of slight
        differences between the trim edge and the actual trimmed surface.

        Returns:
        -----
        None

        Parameters:
        -----
        atThisPoint: MPoint
        	[in] -> Location of parameter to obtain 

        paramU: double
        	[out] -> storage for the U parameter value 

        paramV: double
        	[out] -> storage for the V parameter value 

        ignoreTrimBoundaries: bool
        	[in] -> if this is true and the surface is trimmed, look for the param on the entire, untrimmed surface ignoring any trim curves. 

        space: MSpace.MSpace
        	[in] -> Coordinate space in which to perform this operation 

        tolerance: double
        	[in] -> tolerance used in this operation


        '''
        pass

    def getPointAtParam(self, paramU: double,
                        paramV: double,
                        point: MPoint,
                        space: MSpace.MSpace): 
        '''
        getPointAtParam(self, paramU: double,
                        paramV: double,
                        point: MPoint,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Finds the point corresponding to the given parameter value on the
        surface. This method does not fail if the given parameter lies
        within a trimmed away region of a trimmed surface. Use the
        'isPointInTrimmedRegion' method to determine if the uv point lies
        within such a region.

        Returns:
        -----
        None

        Parameters:
        -----
        paramU: double
        	[in] -> U parameter value 

        paramV: double
        	[in] -> V parameter value 

        point: MPoint
        	[out] -> storage for the found point 

        space: MSpace.MSpace
        	[in] -> Coordinate space in which to perform this operation


        '''
        pass

    def distanceToPoint(self, pt: MPoint,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        distanceToPoint(self, pt: MPoint,
                        space: MSpace.MSpace,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> double

        Synopsis
        -----
        Returns the distance from the given point to the closest point on
        the surface.

        Returns: 
        ----- 
        The distance to the given point from this surface

        Parameters:
        -----
        pt: MPoint
        	[in] -> Point to calculate distance from 

        space: MSpace.MSpace
        	[in] -> Coordinate space for which to perform operation 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def tesselate(self, parms: MTesselationParams,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        tesselate(self, parms: MTesselationParams,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> MObject

        Synopsis
        -----
        Performs tesselation on this surface and create a new mesh in the
        DAG. The type of tesselation can be controlled by providing the
        tesselation parameters (see MTesselationParams).The parentOrOwner
        argument is used to specify the owner of the new surface.If the
        parentOrOwner is kMeshData then the created surface will be of
        type kMeshGeom and will be returned. The parentOrOwner will
        become the owner of the new mesh.If parentOrOwner is nullptr then
        a new transform will be created and returned which will be the
        parent for the mesh. The new transform will be added to the
        DAG.If parentOrOwner is a DAG node then the new mesh will be
        returned and the parentOrOwner will become its parent.

        Returns: 
        ----- 
        If parentOrOwner is nullptr then the transform for this surface
        is returned  If parentOrOwner is a DAG object then the new
        surface shape is returned  The surface geometry is returned if
        parentOrOwner is of type kMeshData

        Parameters:
        -----
        parms: MTesselationParams
        	[in] -> Tesselation parameters 

        parentOrOwner: MObject
        	[in] -> the DAG parent or kMeshData the new mesh will belong to 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def intersect(self, rayStartingPoint: MPoint,
                        alongThisDirection: MVector,
                        u: double,
                        v: double,
                        pntOfIntersection: MPoint,
                        tolerance: double,
                        space: MSpace.MSpace,
                        calculateDistance: bool,
                        distance: double,
                        calculateExactHit: bool,
                        wasExactHit: bool,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        intersect(self, rayStartingPoint: MPoint,
                        alongThisDirection: MVector,
                        u: double,
                        v: double,
                        pntOfIntersection: MPoint,
                        tolerance: double,
                        space: MSpace.MSpace,
                        calculateDistance: bool,
                        distance: double,
                        calculateExactHit: bool,
                        wasExactHit: bool,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> bool

        Synopsis
        -----
        This function determines the closest point of intersection of
        this spline surface with a ray (a vector at a point).

        Returns: 
        ----- 
        Boolean value: true if an intersection point has been found,
        false otherwise.

        Parameters:
        -----
        rayStartingPoint: MPoint
        	[in] -> Starting location of ray to test. 

        alongThisDirection: MVector
        	[in] -> Direction of ray to test. 

        u: double
        	[out] -> U parameter of intersection (if any). 

        v: double
        	[out] -> V parameter of intersection (if any). 

        pntOfIntersection: MPoint
        	[out] -> Closest point of intersection (if any). 

        tolerance: double
        	[in] -> The epsilon value in the calculation. 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation. 

        calculateDistance: bool
        	[in] -> Specifies whether to calculate the distance of the startPoint to the point of intersection 

        distance: double
        	[out] -> Distance of intersection point from startPoint. Ignored if 'calculateDistance' is false. 

        calculateExactHit: bool
        	[in] -> Specifies whether to determine if the point of intersection actually hit the object or just came within tolerance of it. 

        wasExactHit: bool
        	[out] -> Returns true if the point of intersection is an exact hit, false otherwise. Ignored if 'calculateExactHit' if false. 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code.


        '''
        pass

    @overload
    def intersect(self, rayStartingPoint: MPoint,
                        alongThisDirection: MVector,
                        uArray: MDoubleArray,
                        vArray: MDoubleArray,
                        points: MPointArray,
                        tolerance: double,
                        space: MSpace.MSpace,
                        calculateDistance: bool,
                        distances: MDoubleArray,
                        calculateExactHit: bool,
                        wasExactHit: bool,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        intersect(self, rayStartingPoint: MPoint,
                        alongThisDirection: MVector,
                        uArray: MDoubleArray,
                        vArray: MDoubleArray,
                        points: MPointArray,
                        tolerance: double,
                        space: MSpace.MSpace,
                        calculateDistance: bool,
                        distances: MDoubleArray,
                        calculateExactHit: bool,
                        wasExactHit: bool,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> bool

        Synopsis
        -----
        This function determines all the points of intersection of this
        spline surface with a ray (a vector at a point).

        Returns: 
        ----- 
        Boolean value: true if an intersection point has been found,
        false otherwise.

        Parameters:
        -----
        rayStartingPoint: MPoint
        	[in] -> Starting location of ray to test. 

        alongThisDirection: MVector
        	[in] -> Direction of ray to test. 

        uArray: MDoubleArray
        	[out] -> U parameters of intersections. 

        vArray: MDoubleArray
        	[out] -> V parameters of intersections. 

        points: MPointArray
        	[out] -> Points of intersection. 

        tolerance: double
        	[in] -> The epsilon value in the calculation. 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation. 

        calculateDistance: bool
        	[in] -> Specifies whether to calculate the distances of the startPoint to the all the points of intersection. 

        distances: MDoubleArray
        	[out] -> Distances of intersection points from startPoint. Ignored if 'calculateDistance' is false. 

        calculateExactHit: bool
        	[in] -> Specifies whether to determine if the point of intersection actually hit the object or just came within tolerance of it. 

        wasExactHit: bool
        	[out] -> Returns true if the point of intersection is an exact hit, false otherwise. Ignored if 'calculateExactHit' if false. 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code.


        '''
        pass

    def hasHistoryOnCreate(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        hasHistoryOnCreate(self, ReturnStatus: MFnNurbsSurface.MStatus) -> bool

        Synopsis
        -----
        This method determines if the shape was created with history. If
        the object that this function set is attached to is not a shape
        then this method will fail.

        Returns: 
        ----- 
        Boolean value: true if the shape has history, false otherwise.

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> 


        '''
        pass

    def updateSurface(self): 
        '''
        updateSurface(self)

        Synopsis
        -----
        This method signals that this surface has changed and needs to be
        recalculated. This method is useful when a large number of CVs
        for the surface are being modified. Instead of updating the
        surface every time a CV is changed it is more efficient to call
        this method once after updating all of the CVs.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isTrimmedSurface(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        isTrimmedSurface(self, ReturnStatus: MFnNurbsSurface.MStatus) -> bool

        Synopsis
        -----
        This method determines if this surface is a trimmed surface.

        Returns: 
        ----- 
        Boolean value: true if the surface is trimmed, false otherwise.

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> 


        '''
        pass

    def numRegions(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        numRegions(self, ReturnStatus: MFnNurbsSurface.MStatus) -> int

        Synopsis
        -----
        Returns the number of trimmed regions for this surface or 0 if
        the surface is not a trimmed surface. For each region there may
        be several boundary curves, an outer curve and possibly several
        inner boundary curves which define holes. These boundary curves
        are made up of one or more curves called edges.

        Returns: 
        ----- 
        The number of regions for this surface

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> 


        '''
        pass

    def isFlipNorm(self, region: int,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        isFlipNorm(self, region: int,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> bool

        Synopsis
        -----
        Determines whether the normal for the specified region is
        flipped. This method is only valid for trimmed surfaces.

        Returns: 
        ----- 
        true normal = -dS/du X dS/dv  false normal = dS/du X dS/dv

        Parameters:
        -----
        region: int
        	[in] -> Trimmed region to check. Must be in the range 0 to 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def numBoundaries(self, region: int,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        numBoundaries(self, region: int,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> int

        Synopsis
        -----
        Returns the number of boundaries for the specified region. The
        surface must be a trimmed surface.For each region there may be
        several boundary curves, an outer curve and possibly several
        inner boundary curves which define holes. These boundary curves
        are made up of one or more curves called edges.

        Returns: 
        ----- 
        The number of boundaries for the specified region

        Parameters:
        -----
        region: int
        	[in] -> The trimmed region to examine 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> status code


        '''
        pass

    def boundaryType(self, region: int,
                        boundary: int,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        boundaryType(self, region: int,
                        boundary: int,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> MFnNurbsSurface.MFnNurbsSurface

        Synopsis
        -----
        Returns the type of the specified boundary. The surface must be a
        trimmed surface.Possible boundary types are Inner, kOuter,
        kSegment, kClosedSegment, and kInvalidBoundary

        Returns: 
        ----- 
        The boundary type:  kInner an inner boundary, clockwise  kOuter
        an outer boundary, counter clockwise  kSegment a boundary segment
        (a curve on face)  kClosedSegment a closed boundary segment (a
        closed curve on face)  kInvalidBoundary an invalid boundary type

        Parameters:
        -----
        region: int
        	[in] -> the region to examine 

        boundary: int
        	[in] -> the boundary to examine 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> status code


        '''
        pass

    def numEdges(self, region: int,
                        boundary: int,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        numEdges(self, region: int,
                        boundary: int,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> int

        Synopsis
        -----
        Return the number of edges for the specified trim boundary. For
        each region there may be several boundary curves, an outer curve
        and possibly several inner boundary curves which define holes.
        These boundary curves are made up of one or more curves called
        edges.

        Returns: 
        ----- 
        The number of edges for the specified boundary

        Parameters:
        -----
        region: int
        	[in] -> Region to examine 

        boundary: int
        	[in] -> Boundary to examine 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def edge(self, region: int,
                        boundary: int,
                        edge: int,
                        paramEdge: bool,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        edge(self, region: int,
                        boundary: int,
                        edge: int,
                        paramEdge: bool,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> MObjectArray

        Synopsis
        -----
        Return the specified edge of a trim boundary. For each region of
        a trimmed surface there may be several boundary curves: an outer
        curve and possibly several inner boundary curves (which define
        holes). These boundary curves are made up of one or more curves
        called edges. The edge is returned as an MObjectArray as the edge
        may consist of more than one curve. The returned edge, or trim
        curve, can be a 2D parameter edge or a 3D edge curve. To identify
        an edge you must specify the trimmed region, the boundary of that
        region, and the edge of that boundary.Note that for closed
        surfaces some of the 3d edges may be 0 length in which case an
        empty MObjectArray is returned. An example of this is the poles
        of a sphere.

        Returns: 
        ----- 
        A curve for the specified edge

        Parameters:
        -----
        region: int
        	[in] -> the trimmed region containing the edge 

        boundary: int
        	[in] -> the boundary to examine 

        edge: int
        	[in] -> the boundary edge to examine 

        paramEdge: bool
        	[in] -> if true then 2D param edges are returned, otherwise a 3D edge is returned. 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> status code


        '''
        pass

    def isPointInTrimmedRegion(self, u: double,
                        v: double,
                        ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        isPointInTrimmedRegion(self, u: double,
                        v: double,
                        ReturnStatus: MFnNurbsSurface.MStatus) -> bool

        Synopsis
        -----
        Returns true if the given point is in a trimmed away region of a
        trimmed surface. A trimmed away region is the part of the surface
        that is cut away as a result of a trim operation.

        Returns: 
        ----- 
        Boolean value: true if the point on surface is within a trimmed
        away region, false otherwise.

        Parameters:
        -----
        u: double
        	[in] -> u parameter of point on surface to test 

        v: double
        	[in] -> v parameter of point on surface to test 

        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> status code


        '''
        pass

    def getTrimBoundaries(self, result: MTrimBoundaryArray,
                        region: int,
                        paramEdge: bool): 
        '''
        getTrimBoundaries(self, result: MTrimBoundaryArray,
                        region: int,
                        paramEdge: bool)

        Synopsis
        -----
        Returns all trim boundaries of a region on this surface.

        Returns:
        -----
        None

        Parameters:
        -----
        result: MTrimBoundaryArray
        	[out] -> All trim boundaries of the given region in this surface. 

        region: int
        	[in] -> the trimmed region containing the boundaries 

        paramEdge: bool
        	[in] -> If true, then 2D curves are returned, otherwise 3D curves.


        '''
        pass

    def trimWithBoundaries(self, mBoundaries: MTrimBoundaryArray,
                        flipNormal: bool,
                        e_tol: double,
                        pe_tol: double,
                        createNewRegion: bool): 
        '''
        trimWithBoundaries(self, mBoundaries: MTrimBoundaryArray,
                        flipNormal: bool,
                        e_tol: double,
                        pe_tol: double,
                        createNewRegion: bool)

        Synopsis
        -----
        This function trims this surface with given trim boundaries.
        NOTE: The curves specified in the MTrimBoundaryArray are in UV
        space. As a result, they must be 2D curves. The MFnNurbsCurve
        functionset provides a method for creating 2D curves.

        Returns:
        -----
        None

        Parameters:
        -----
        mBoundaries: MTrimBoundaryArray
        	[in] -> The boundaries used for the trim. A boundary may consist of several curves. They must present a closed boundary, must be in UV (parameter) space, and must be on the surface. Boundaries[0] is the outer boundary which goes counterclockwise around the surface normal. All other boundaries must be inner boundaries inside the outer boundary defined region. A clockwise inner boundary defines a hole. Boundaries[0] can be empty. In this case, the native boundary is used as outer boundary. The boundaries should not intersect each other or themselves. 

        flipNormal: bool
        	[in] -> Whether to flip the trimmed surface normal 

        e_tol: double
        	[in] -> The 3d edge tolerance with which to trim 

        pe_tol: double
        	[in] -> The parameter edge tolerance with which to trim 

        createNewRegion: bool
        	[in] -> Whether to create a new region on the trimmed surface. A region is a disjoint area of a trimmed surface.


        '''
        pass

    def projectCurve(self, curve: MDagPath,
                        direction: MVector,
                        constructionHistory: bool): 
        '''
        projectCurve(self, curve: MDagPath,
                        direction: MVector,
                        constructionHistory: bool)

        Synopsis
        -----
        Project the given curve onto this surface creating a curve on
        surface. Projection will be done using the surface normals unless
        a direction vector to project along is given.

        Returns:
        -----
        None

        Parameters:
        -----
        curve: MDagPath
        	[in] -> curve to be projected 

        direction: MVector
        	[in] -> direction of projection. If this is null then the surface normals is used 

        constructionHistory: bool
        	[in] -> keep construction history


        '''
        pass

    def trim(self, locatorU: MDoubleArray,
                        locatorV: MDoubleArray,
                        constructionHistory: bool): 
        '''
        trim(self, locatorU: MDoubleArray,
                        locatorV: MDoubleArray,
                        constructionHistory: bool)

        Synopsis
        -----
        Trim this surface to its curves on surface. Regions which are
        kept are specified by passing in two arrays of u,v
        parameters.This method will create a new trimmed surface in the
        DAG. The surface attached to this function set will remain
        unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        locatorU: MDoubleArray
        	[in] -> array of U parameters indicating regions to keep 

        locatorV: MDoubleArray
        	[in] -> array of V parameters indicating regions to keep 

        constructionHistory: bool
        	[in] -> keep construction history


        '''
        pass

    def numPatches(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        numPatches(self, ReturnStatus: MFnNurbsSurface.MStatus) -> int

        Synopsis
        -----
        Returns the number of non-zero patches in this surface.

        Returns: 
        ----- 
        The number of non-zero patches in this surface.

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def numPatchesInU(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        numPatchesInU(self, ReturnStatus: MFnNurbsSurface.MStatus) -> int

        Synopsis
        -----
        Returns the number of non-zero patches along u, in this surface.

        Returns: 
        ----- 
        The number of non-zero patches along u, in this surface.

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def numPatchesInV(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        numPatchesInV(self, ReturnStatus: MFnNurbsSurface.MStatus) -> int

        Synopsis
        -----
        Returns the number of non-zero patches along v, in this surface.

        Returns: 
        ----- 
        The number of non-zero patches along v, in this surface.

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def numUVs(self, ReturnStatus: MFnNurbsSurface.MStatus): 
        '''
        numUVs(self, ReturnStatus: MFnNurbsSurface.MStatus) -> int

        Synopsis
        -----
        Returns the number of texture (uv) coordinates for this surface.
        The uv's are stored in a list which is referenced by patches
        requiring textures on a per-patch per-patchCorner basis. This
        method returns the number of elements in this list.

        Returns: 
        ----- 
        The number of texture coordinates

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurface.MStatus
        	[out] -> Status code


        '''
        pass

    def setUVs(self, uArray: MFloatArray,
                        vArray: MFloatArray): 
        '''
        setUVs(self, uArray: MFloatArray,
                        vArray: MFloatArray)

        Synopsis
        -----
        Sets all of the texture coordinates (uvs) for this surface. The
        uv arrays must be of equal size and must be at least of length
        numUVs(). If the arrays are larger than numUVs() then the uv list
        for this surface will be grown to accommodate the new uv
        values.After using this method to set the UV values, you can call
        assignUVs to assign the corresponding UVids to the geometry.Also,
        note that API methods that modify uv data, work correctly either
        when called through a plug-in node that is in the history of the
        shape, or when used on a surface shape that does not have
        history. Modifying uvs directly on a shape with history will
        result in the modifications getting over-written by the next
        evaluation of the history attached to the shape.

        Returns:
        -----
        None

        Parameters:
        -----
        uArray: MFloatArray
        	[in] -> The array of u values to be set 

        vArray: MFloatArray
        	[in] -> The array of v values to be set


        '''
        pass

    def getUVs(self, uArray: MFloatArray,
                        vArray: MFloatArray): 
        '''
        getUVs(self, uArray: MFloatArray,
                        vArray: MFloatArray)

        Synopsis
        -----
        This method copies the texture coordinate list for this surface
        into the given uv arrays.

        Returns:
        -----
        None

        Parameters:
        -----
        uArray: MFloatArray
        	[out] -> Storage for the u texture coordinate list 

        vArray: MFloatArray
        	[out] -> Storage for the v texture coordinate list


        '''
        pass

    def setUV(self, uvId: int,
                        u: float,
                        v: float): 
        '''
        setUV(self, uvId: int,
                        u: float,
                        v: float)

        Synopsis
        -----
        Sets the specified texture coordinate. The uvId is the element in
        the uv list that will be set. If the uvId is greater than or
        equal to numUVs() then the uv list will be grown to accommodate
        the specified uv.Also, note that API methods that modify uv data,
        work correctly either when called through a plug-in node that is
        in the history of the shape, or when used on a surface shape that
        does not have history. Modifying uvs directly on a shape with
        history will result in the modifications getting over-written by
        the next evaluation of the history attached to the shape.

        Returns:
        -----
        None

        Parameters:
        -----
        uvId: int
        	[in] -> the element in the uv list to be set 

        u: float
        	[in] -> the new u value that is to be set 

        v: float
        	[in] -> the new v value that is to be set


        '''
        pass

    def getUV(self, uvId: int,
                        u: float,
                        v: float): 
        '''
        getUV(self, uvId: int,
                        u: float,
                        v: float)

        Synopsis
        -----
        Get the value of the specified texture coordinate from this
        surface's uv list. The uvId is the element in the uv list that
        will be retrieved.

        Returns:
        -----
        None

        Parameters:
        -----
        uvId: int
        	[in] -> the element in the uv list to examine 

        u: float
        	[out] -> storage for the u value 

        v: float
        	[out] -> storage for the v value


        '''
        pass

    def getPatchUV(self, patchId: int,
                        cornerIndex: int,
                        u: float,
                        v: float): 
        '''
        getPatchUV(self, patchId: int,
                        cornerIndex: int,
                        u: float,
                        v: float)

        Synopsis
        -----
        Get the value of the specified texture coordinate for a patch
        corner in a patch. Since texture coordinates (uv's) are stored
        per-patch per-corner you must specify both the patch and the
        corner that the u and v values are mapped to.

        Returns:
        -----
        None

        Parameters:
        -----
        patchId: int
        	[in] -> The patch to examine 

        cornerIndex: int
        	[in] -> The patch-relative corner to examine 

        u: float
        	[out] -> storage for the u value 

        v: float
        	[out] -> storage for the v value


        '''
        pass

    def getPatchUVs(self, patchId: int,
                        uArray: MFloatArray,
                        vArray: MFloatArray): 
        '''
        getPatchUVs(self, patchId: int,
                        uArray: MFloatArray,
                        vArray: MFloatArray)

        Synopsis
        -----
        Get the values of the texture coordinate on a specified patch.
        Since texture coordinates (uvs) are stored per-patch per-corner,
        the u and v values mapped to all corners of the specified patch
        are returned.

        Returns:
        -----
        None

        Parameters:
        -----
        patchId: int
        	[in] -> The patch to examine 

        uArray: MFloatArray
        	[out] -> storage for u values 

        vArray: MFloatArray
        	[out] -> storage for v values


        '''
        pass

    def getPatchUVid(self, patchId: int,
                        cornerIndex: int,
                        uvId: int): 
        '''
        getPatchUVid(self, patchId: int,
                        cornerIndex: int,
                        uvId: int)

        Synopsis
        -----
        Get the id of the specified texture coordinate for a corner in a
        patch.

        Returns:
        -----
        None

        Parameters:
        -----
        patchId: int
        	[in] -> The patch to examine 

        cornerIndex: int
        	[in] -> The patch-relative corner to examine (local index) 

        uvId: int
        	[out] -> storage for the uv index


        '''
        pass

    def assignUV(self, patchId: int,
                        cornerIndex: int,
                        uvId: int): 
        '''
        assignUV(self, patchId: int,
                        cornerIndex: int,
                        uvId: int)

        Synopsis
        -----
        Maps a texture coordinate to a the specified corner of a patch.
        Since texture coordinates (uvs) are stored per-patch per-
        patchCorner you must specify both the patch and the patchCorner
        that the uv entry is mapped to.The cornerIndex is the corner
        within the patch that the uv will be mapped to. This index must
        be in the range 0 to patchCornerCount(patchId).Also, note that
        API methods that modify uv data, work correctly either when
        called through a plug-in node that is in the history of the
        shape, or when used on a surface shape that does not have
        history. Modifying uvs directly on a shape with history will
        result in the modifications getting over-written by the next
        evaluation of the history attached to the shape.

        Returns:
        -----
        None

        Parameters:
        -----
        patchId: int
        	[in] -> The patch to map to 

        cornerIndex: int
        	[in] -> The corner of the patch to map to 

        uvId: int
        	[in] -> The uv entry from the uv list that will be mapped


        '''
        pass

    def assignUVs(self, uvCounts: MIntArray,
                        uvIds: MIntArray): 
        '''
        assignUVs(self, uvCounts: MIntArray,
                        uvIds: MIntArray)

        Synopsis
        -----
        This method maps all texture coordinates for the surface. The
        setUV/setUVs method is used to create the texture coordinate
        table for the surface. After the table is created, this method is
        used to map those values to each patch on a per-corner basis. The
        setUV/setUVs method should be called before the assignUVs
        method.The uvCounts array should contain the number of uvs per
        patch. Since uvs are mapped per-patch per-corner, the entries in
        this array should match the corner counts for each patch in the
        surface.If an entry in this array is '0' then the corresponding
        patch will not be mapped. The sum of all the entries in the
        uvCounts array must be equal to the size of the uvIds array or
        this method will fail.The uvIds array should contain the UV
        indices that will be mapped to each patch-corner in the surface.
        The entries in this array specify which uvs in the surface's uv
        table are mapped to each patch-corner. Each entry in the uvIds
        array must be less than numUVs(). The size of the uvIds array is
        equivalent to adding up all of the entries in the uvCounts array,
        so for a cube with all patches mapped there would be 24
        entries.Also, note that API methods that modify uv data, work
        correctly either when called through a plug-in node that is in
        the history of the shape, or when used on a surface shape that
        does not have history. Modifying uvs directly on a shape with
        history will result in the modifications getting over-written by
        the next evaluation of the history attached to the shape.

        Returns:
        -----
        None

        Parameters:
        -----
        uvCounts: MIntArray
        	[in] -> The uv counts for each patch in the surface 

        uvIds: MIntArray
        	[in] -> The uv indices to be mapped to each patch-corner


        '''
        pass

    def clearUVs(self): 
        '''
        clearUVs(self)

        Synopsis
        -----
        This method clears out all texture coordinates for the
        nurbsSurface, and leaves behind an empty UVset. This method
        should be used if it is needed to shrink the actual size of the
        UV table. In this case, the user should call clearUVs, setUVs and
        then assignUVs to rebuild the mapping info.When called on a
        dataNurbsSurface, the UVs are removed. When called on a shape
        with no history, the UVs are removed and the attributes are set
        on the shape. When called on a shape with history, the polyDelMap
        command is invoked and a polyMapDel node is created.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getAssignedUVs(self, uvCounts: MIntArray,
                        uvIds: MIntArray): 
        '''
        getAssignedUVs(self, uvCounts: MIntArray,
                        uvIds: MIntArray)

        Synopsis
        -----
        Get assigned UVs. This method finds all texture coordinates for
        the surface that have been mapped, and returns them in the same
        format as assignUVs. The setUV/setUVs method is used to create
        the texture coordinate table for the surface and this method is
        used to map those values to each patch on a per-corner basis.The
        uvCounts array should contain the number of uv's per patch. Since
        uvs are mapped per-patch per-corner, the entries returned in this
        array will match the corner counts for each patch in the surface.
        For example, suppose that we have a cube with 2 of the faces
        mapped: the array for this cube would be { 4, 4, 0, 0, 0, 0 }
        since there are 6 patches each with 4 vertices. A face either has
        all its vertives mapped, or noneThe uvIds array will contain the
        UV indices that will be mapped to each patch-corner in the
        surface. Use the getUV method to get the actual uv values for
        these id's.

        Returns:
        -----
        None

        Parameters:
        -----
        uvCounts: MIntArray
        	[out] -> The uv counts for each patch in the surface 

        uvIds: MIntArray
        	[out] -> The uv indices to be mapped to each patch-corner


        '''
        pass

    def getConnectedShaders(self, instanceNumber: int,
                        shaders: MObjectArray,
                        indices: MIntArray): 
        '''
        getConnectedShaders(self, instanceNumber: int,
                        shaders: MObjectArray,
                        indices: MIntArray)

        Synopsis
        -----
        Returns all the shaders (sets) connected to the specified
        instance of this surface, as well as an array of patch/shader
        assignments. The indices array will hold, for each patch in the
        surface, an index into the shaders array. If a patch does not
        have a shader assigned to it, the value of the index will be
        -1.The shader objects can be derived from the sets returned.Note:
        This method will only work with a MFnNurbsSurface function set
        which has been initialized with an MFn::kNurbsSurface.See also
        getConnectedSetsAndMembers.

        Returns:
        -----
        None

        Parameters:
        -----
        instanceNumber: int
        	[in] -> The instance number of the surface to query 

        shaders: MObjectArray
        	[out] -> Storage for set objects (shader objects) 

        indices: MIntArray
        	[out] -> Storage for indices matching patches to shaders. For each patch, this array contains the index into the shaders array for the shader assigned to the patch.


        '''
        pass

class Form:
    '''Forms that a surface may take in a given parametric direction. 
    Non-functional class.  Values for this enum:
    kInvalid
    kOpen
    kClosed
    kPeriodic
    kLast
    '''

    def __init__(self):
        pass

    def kInvalid(self):
        '''This is an enum of Form.
        - Description:  
        - Value: 0
        '''
        pass

    def kOpen(self):
        '''This is an enum of Form.
        - Description: Edges are independent. 
        - Value: 1
        '''
        pass

    def kClosed(self):
        '''This is an enum of Form.
        - Description: Edges are coincident. 
        - Value: 2
        '''
        pass

    def kPeriodic(self):
        '''This is an enum of Form.
        - Description: Edges overlap such that there is no break in tangency. 
        - Value: 3
        '''
        pass

    def kLast(self):
        '''This is an enum of Form.
        - Description:  
        - Value: 4
        '''
        pass

class BoundaryType:
    '''Boundary types for trimmed surfaces. 
    Non-functional class.  Values for this enum:
    kInvalidBoundary
    kOuter
    kInner
    kSegment
    kClosedSegment
    '''

    def __init__(self):
        pass

    def kInvalidBoundary(self):
        '''This is an enum of BoundaryType.
        - Description:  
        - Value: 0
        '''
        pass

    def kOuter(self):
        '''This is an enum of BoundaryType.
        - Description: Outer boundary, counter clockwise. 
        - Value: 1
        '''
        pass

    def kInner(self):
        '''This is an enum of BoundaryType.
        - Description: Inner boundary, clockwise. 
        - Value: 2
        '''
        pass

    def kSegment(self):
        '''This is an enum of BoundaryType.
        - Description: Curve on a face. 
        - Value: 3
        '''
        pass

    def kClosedSegment(self):
        '''This is an enum of BoundaryType.
        - Description: Closed curve on a face. 
        - Value: 4
        '''
        pass

class MFnNurbsSurfaceData:
    '''Nurbs Surface function set for dependency node data.
MFnNurbsSurfaceData allows the creation and manipulation of NurbsSurface data
objects for use in the dependency graph.
If a user written dependency node either accepts or produces
Nurbs Surfaces, then this class is used to extract or create the
data that comes from or goes to other dependency graph nodes. The
MDataHandle::type method will return kNurbsSurface when data of this type is
present.
If a node is receiving a Nurbs Surface via an input attribute,
the asNurbsSurface method of
MDataHandle can be used to access that input Nurbs Surface.
If a node is to create a Nurbs Surface and send it via an output
attribute, a new
MFnNurbsSurfaceData must be instantiated and then the create method called to build
the actual data block as an
MObject. This
MObject should be passed to the
MFnNurbsSurface::create method as the parentOrOwner parameter so that the Nurbs Surface
will be constructed inside the data block. The
MDataHandle::set routine is then used to pass the data block down the connection.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kNurbsSurfaceData.Reimplemented from MFnGeometryData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnNurbsSurfaceData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnNurbsSurfaceData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, ReturnStatus: MFnNurbsSurfaceData.MStatus): 
        '''
        create(self, ReturnStatus: MFnNurbsSurfaceData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance and initialize
        it with a data block capable of holding a Nurbs Surface.

        Returns: 
        ----- 
        The new MObject

        Parameters:
        -----
        ReturnStatus: MFnNurbsSurfaceData.MStatus
        	[out] -> kSuccess


        '''
        pass

class MFnPartition:
    '''Function set for partitions of objects.
MFnPartition is the function set that is used for manipulating partitions of
objects.
A partition is a list of dependency nodes and dag nodes.
Partitions are useful for keeping track of lists of objects for
many purposes such as selection or applying common rendering
parameters. Partitions in Maya are also dependency nodes, so it
is possible for one partition to contain others.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kPartition.Reimplemented from MFnDependencyNode.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnPartition.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnPartition".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, isRenderPartition: bool,
                        ReturnStatus: MFnPartition.MStatus): 
        '''
        create(self, isRenderPartition: bool,
                        ReturnStatus: MFnPartition.MStatus) -> MObject

        Synopsis
        -----
        Creates a new partition dependency node and puts it in the
        dependency graph.

        Returns: 
        ----- 
        A handle for the new partition object

        Parameters:
        -----
        isRenderPartition: bool
        	[in] -> determines whether this partition is a render partition 

        ReturnStatus: MFnPartition.MStatus
        	[out] -> return status


        '''
        pass

    def isRenderPartition(self, ReturnStatus: MFnPartition.MStatus): 
        '''
        isRenderPartition(self, ReturnStatus: MFnPartition.MStatus) -> bool

        Synopsis
        -----
        Returns true if this partition is a render partition.

        Returns: 
        ----- 
        A boolean value indicating whether the object is a member

        Parameters:
        -----
        ReturnStatus: MFnPartition.MStatus
        	[out] -> return status


        '''
        pass

    def addMember(self, set: MObject): 
        '''
        addMember(self, set: MObject)

        Synopsis
        -----
        Add a set to this partition. To be added to a partition, a set
        must be mutually exclusive with all of the other sets in the
        partition. If there are any conflicting elements, then the add
        will fail.

        Returns:
        -----
        None

        Parameters:
        -----
        set: MObject
        	[in] -> new set to be added to this partiton.


        '''
        pass

    def removeMember(self, set: MObject): 
        '''
        removeMember(self, set: MObject)

        Synopsis
        -----
        Remove a set from this partition.

        Returns:
        -----
        None

        Parameters:
        -----
        set: MObject
        	[in] -> old set to be removed from this partiton.


        '''
        pass

class MFnPhongEShader:
    '''Manage phongE shaders.
MFnPhongEShader facilitates creation and manipulation of dependency graph nodes
representing phongE shaders.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kPhongExplorer.Reimplemented from MFnDependencyNode.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnPhongEShader.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnPhongEShader".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, UIvisible: bool,
                        ReturnStatus: MFnPhongEShader.MStatus): 
        '''
        create(self, UIvisible: bool,
                        ReturnStatus: MFnPhongEShader.MStatus) -> MObject

        Synopsis
        -----
        Creates a new layered shader dependency graph node and adds it to
        the dependency graph. If the UIvisible parameter is true, the new
        node will be connected to the shader classification node (which
        allows the UI to recognize the node as a shader). If UIvisible is
        false, the node will be created in isolation.

        Returns: 
        ----- 
        MObject representing the new dependency node.

        Parameters:
        -----
        UIvisible: bool
        	[in] -> determines whether or not the new node will be connected to the shader classification node. 

        ReturnStatus: MFnPhongEShader.MStatus
        	[out] -> return status


        '''
        pass

    def roughness(self, ReturnStatus: MFnPhongEShader.MStatus): 
        '''
        roughness(self, ReturnStatus: MFnPhongEShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "roughness" attribute of a shader
        node.

        Returns: 
        ----- 
        The value of the "roughness" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnPhongEShader.MStatus
        	[out] -> return status


        '''
        pass

    def setRoughness(self, roughness: float): 
        '''
        setRoughness(self, roughness: float)

        Synopsis
        -----
        Sets the value of the "roughness" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        roughness: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def highlightSize(self, ReturnStatus: MFnPhongEShader.MStatus): 
        '''
        highlightSize(self, ReturnStatus: MFnPhongEShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "highlightSize" attribute of a shader
        node. This attribute represents the surface color of the shader.

        Returns: 
        ----- 
        The value of the "highlightSize" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnPhongEShader.MStatus
        	[out] -> return status


        '''
        pass

    def setHighlightSize(self, highlight_size: float): 
        '''
        setHighlightSize(self, highlight_size: float)

        Synopsis
        -----
        Sets the value of the "highlightSize" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        highlight_size: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def whiteness(self, ReturnStatus: MFnPhongEShader.MStatus): 
        '''
        whiteness(self, ReturnStatus: MFnPhongEShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "whiteness" attribute of a shader
        node. This attribute represents the surface transparency of the
        shader.

        Returns: 
        ----- 
        The value of the "whiteness" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnPhongEShader.MStatus
        	[out] -> return status


        '''
        pass

    def setWhiteness(self, whiteness: MColor): 
        '''
        setWhiteness(self, whiteness: MColor)

        Synopsis
        -----
        Sets the value of the "whiteness" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        whiteness: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

class MFnPhongShader:
    '''Manage Phong Shaders.
MFnPhongShader facilitates the creation and manipulation of dependency graph
nodes representing Phong shaders.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kPhong.Reimplemented from MFnReflectShader.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnPhongShader.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnPhongShader".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, UIvisible: bool,
                        ReturnStatus: MFnPhongShader.MStatus): 
        '''
        create(self, UIvisible: bool,
                        ReturnStatus: MFnPhongShader.MStatus) -> MObject

        Synopsis
        -----
        Creates a new phong shader dependency graph node and adds it to
        the dependency graph. If the UIvisible parameter is true, the new
        node will be connected to the shader classification node (which
        allows the UI to recognize the node as a shader). If UIvisible is
        false, the node will be created in isolation.

        Returns: 
        ----- 
        MObject representing the new dependency node.

        Parameters:
        -----
        UIvisible: bool
        	[in] -> determines whether or not the new node will be connected to the shader classification node. 

        ReturnStatus: MFnPhongShader.MStatus
        	[out] -> return status


        '''
        pass

    def cosPower(self, ReturnStatus: MFnPhongShader.MStatus): 
        '''
        cosPower(self, ReturnStatus: MFnPhongShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "cosPower" attribute of a phong shader
        node. This attribute determines the size of specular highlights
        produced by the shader.

        Returns: 
        ----- 
        The value of the "cosPower" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnPhongShader.MStatus
        	[out] -> return status


        '''
        pass

    def setCosPower(self, cos_power: float): 
        '''
        setCosPower(self, cos_power: float)

        Synopsis
        -----
        Sets the value of the "cosPower" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        cos_power: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

class MFnPlugin:
    '''Register and deregister plug-in services with Maya.
This class is used in the initializePlugin and uninitializePlugin
functions of a Maya plug-in to respectively register and
deregister the plug-in's services (commands, node types, etc)
with Maya. The constructor for this class must be passed the
MObject that Maya provides as an argument to initializePlugin and
uninitializePlugin.
MFnPlugin provides various registration methods for use inside
initializePlugin, when the plug-in is being loaded, and
deregistration methods for use inside uninitializePlugin, when
the plug-in is being unloaded. In general it is good practice to
have uninitializePlugin deregister the plug-in's services in the
reverse order in which they were registered in initializePlugin.
This ensures, for example, that a custom datatype is not
deregistered before the node types which use it.
A plug-in's uninitializePlugin function is only called when the
plug-in is explicitly unloaded. It is
 called when Maya exits. Normally this is not a problem because
system resources such as memory and open file handles are
automatically released by the operating system when Maya exits.
However, if there are cleanup tasks which a plug-in must perform
even when Maya exits, for example deleting a temporary file, then
the plug-in's initializePlugin can use the
MSceneMessage::addCallback method with a message of "kMayaExiting" to register a callback
function that will be executed when Maya is about to exit. The
callback function can then handle any cleanup activities which
the operating system won't handle automatically on exit.
A side effect of including MFnPlugin.h in a source file is to
embed an API version string into the corresponding compiled
object file. Because of this, including MFnPlugin.h in more than
one source file in the same plug-in will lead to conflicts when
the plug-in is linked. If it is necessary to include MFnPlugin.h
in more than one of a plug-in's source files the preprocessor
macro
 should be defined in all but one of those files prior to the
inclusion of MFnPlugin.h. Normally, this issue will not arise as
only the file that contains the
 and
 routines should need to include MFnPlugin.h.
It is unusual, but possible, to instantiate several
MFnPlugin objects within a single plug-in binary. In this case the vendor
and version information that is set for the plug-in is taken from
the first instance as this information works per binary rather
than per command/node etc.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Return the type of this function set. Reimplemented from MFnBase.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def vendor(self, ReturnStatus: MFnPlugin.MStatus): 
        '''
        vendor(self, ReturnStatus: MFnPlugin.MStatus) -> MString

        Synopsis
        -----
        Return the vendor string supplied in the MFnPlugin constructor.

        Returns: 
        ----- 
        An MString containing the vendor name

        Parameters:
        -----
        ReturnStatus: MFnPlugin.MStatus
        	[out] -> the return status


        '''
        pass

    def version(self, ReturnStatus: MFnPlugin.MStatus): 
        '''
        version(self, ReturnStatus: MFnPlugin.MStatus) -> MString

        Synopsis
        -----
        Return the version string supplied in the MFnPlugin constructor.

        Returns: 
        ----- 
        An MString containing the version string

        Parameters:
        -----
        ReturnStatus: MFnPlugin.MStatus
        	[out] -> the return status


        '''
        pass

    def apiVersion(self, ReturnStatus: MFnPlugin.MStatus): 
        '''
        apiVersion(self, ReturnStatus: MFnPlugin.MStatus) -> MString

        Synopsis
        -----
        Return the required API version string supplied in the MFnPlugin
        constructor.

        Returns: 
        ----- 
        An MString containing the required API version string

        Parameters:
        -----
        ReturnStatus: MFnPlugin.MStatus
        	[out] -> the return status


        '''
        pass

    def name(self, ReturnStatus: MFnPlugin.MStatus): 
        '''
        name(self, ReturnStatus: MFnPlugin.MStatus) -> MString

        Synopsis
        -----
        Return the name by which Maya knows this plug-in.

        Returns: 
        ----- 
        An MString containing the plug-in name

        Parameters:
        -----
        ReturnStatus: MFnPlugin.MStatus
        	[out] -> the return status


        '''
        pass

    def loadPath(self, ReturnStatus: MFnPlugin.MStatus): 
        '''
        loadPath(self, ReturnStatus: MFnPlugin.MStatus) -> MString

        Synopsis
        -----
        Determine the path where the plugin was loaded.

        Returns: 
        ----- 
        An MString containing path name to the location of the plugin.

        Parameters:
        -----
        ReturnStatus: MFnPlugin.MStatus
        	[out] -> the return status


        '''
        pass

    def setName(self, newName: MString,
                        makeUnique: bool): 
        '''
        setName(self, newName: MString,
                        makeUnique: bool)

        Synopsis
        -----
        Set the name by which Maya knows this plug-in.

        Returns:
        -----
        None

        Parameters:
        -----
        newName: MString
        	[in] -> the new name 

        makeUnique: bool
        	[in] -> if true and the requested name is already in use, then Maya will create an unused name for this plug-in. If false, and the name is in use, do not change the current name.


        '''
        pass

    def setVersion(self, newVersion: MString): 
        '''
        setVersion(self, newVersion: MString)

        Synopsis
        -----
        Set the version name for this plug-in.

        Returns:
        -----
        None

        Parameters:
        -----
        newVersion: MString
        	[in] -> the new version


        '''
        pass

    def registerCommand(self, commandName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        createSyntaxFunction: MFnPlugin.MCreateSyntaxFunction): 
        '''
        registerCommand(self, commandName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        createSyntaxFunction: MFnPlugin.MCreateSyntaxFunction)

        Synopsis
        -----
        Register a new command with Maya. Once registered, the command
        can be invoked from MEL in a manner identical to built-in Maya
        commands.

        Returns:
        -----
        None

        Parameters:
        -----
        commandName: MString
        	[in] -> the name of the command to register 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from 

        createSyntaxFunction: MFnPlugin.MCreateSyntaxFunction
        	[in] -> a pointer to a function that will return a new instance of a syntax object (


        '''
        pass

    def deregisterCommand(self, commandName: MString): 
        '''
        deregisterCommand(self, commandName: MString)

        Synopsis
        -----
        Deregister the user defined command from Maya. Once deregistered
        the command can no longer be invoked from MEL.

        Returns:
        -----
        None

        Parameters:
        -----
        commandName: MString
        	[in] -> the name of the command to deregister


        '''
        pass

    def registerControlCommand(self, commandName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction): 
        '''
        registerControlCommand(self, commandName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction)

        Synopsis
        -----
        Register a new control command with Maya. Once registered, the
        command can be invoked from MEL in a manner identical to built-in
        Maya commands.

        Returns:
        -----
        None

        Parameters:
        -----
        commandName: MString
        	[in] -> the name of the control to register 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class(derived from 


        '''
        pass

    def deregisterControlCommand(self, commandName: MString): 
        '''
        deregisterControlCommand(self, commandName: MString)

        Synopsis
        -----
        Deregister the user defined control command from Maya. Once
        deregistered the command can no longer be invoked from MEL.

        Returns:
        -----
        None

        Parameters:
        -----
        commandName: MString
        	[in] -> the name of the command to deregister


        '''
        pass

    def registerModelEditorCommand(self, commandName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        viewCreatorFunction: MFnPlugin.MCreatorFunction): 
        '''
        registerModelEditorCommand(self, commandName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        viewCreatorFunction: MFnPlugin.MCreatorFunction)

        Synopsis
        -----
        Register a new model editor command with Maya. Once registered,
        the command can be invoked from MEL in a manner identical to
        built-in Maya commands.

        Returns:
        -----
        None

        Parameters:
        -----
        commandName: MString
        	[in] -> the name of the command to register 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from MPxEditorCommand) that implements the new command. 

        viewCreatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from 


        '''
        pass

    def deregisterModelEditorCommand(self, commandName: MString): 
        '''
        deregisterModelEditorCommand(self, commandName: MString)

        Synopsis
        -----
        Deregister the user defined editor command from Maya. Once
        deregistered the command can no longer be invoked from MEL.

        Returns:
        -----
        None

        Parameters:
        -----
        commandName: MString
        	[in] -> the name of the command to deregister


        '''
        pass

    def registerConstraintCommand(self, commandName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction): 
        '''
        registerConstraintCommand(self, commandName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction)

        Synopsis
        -----
        Register a new constraint command with Maya. Once registered, the
        command can be invoked from MEL in a manner identical to built-in
        Maya commands.

        Returns:
        -----
        None

        Parameters:
        -----
        commandName: MString
        	[in] -> the name of the command to register 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from 


        '''
        pass

    def deregisterConstraintCommand(self, commandName: MString): 
        '''
        deregisterConstraintCommand(self, commandName: MString)

        Synopsis
        -----
        Deregister the user defined constraint command from Maya. Once
        deregistered the command can no longer be invoked from MEL.

        Returns:
        -----
        None

        Parameters:
        -----
        commandName: MString
        	[in] -> the name of the command to deregister


        '''
        pass

    @overload
    def registerContextCommand(self, commandName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction): 
        '''
        registerContextCommand(self, commandName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction)

        Synopsis
        -----
        Register a new context command with Maya. Once registered, the
        context can be used to create a new tool that can be used in a
        manner identical to built-in Maya tools.

        Returns:
        -----
        None

        Parameters:
        -----
        commandName: MString
        	[in] -> the name of the context command to register 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from 


        '''
        pass

    @overload
    def registerContextCommand(self, commandName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        toolCmdName: MString,
                        toolCmdCreator: MFnPlugin.MCreatorFunction,
                        toolCmdSyntax: MFnPlugin.MCreateSyntaxFunction): 
        '''
        registerContextCommand(self, commandName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        toolCmdName: MString,
                        toolCmdCreator: MFnPlugin.MCreatorFunction,
                        toolCmdSyntax: MFnPlugin.MCreateSyntaxFunction)

        Synopsis
        -----
        Register a new context command and a new tool command with Maya.
        This version of registerContextCommand must be used if a tool
        command (a class derived from MPxToolCommand) is used within the
        context. The method newToolCommand of MPxContext will return a
        new instance of the tool command that can be used in the
        context.Once registered, the context can be used to create a new
        tool that can be used in a manner identical to built-in Maya
        tools. The tool command can also be used as a MEL command.

        Returns:
        -----
        None

        Parameters:
        -----
        commandName: MString
        	[in] -> the name of the context command to register 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from 

        toolCmdName: MString
        	[in] -> the name of the tool command to register 

        toolCmdCreator: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from 

        toolCmdSyntax: MFnPlugin.MCreateSyntaxFunction
        	[in] -> a pointer to a function that will return a new instance of a syntax object (


        '''
        pass

    @overload
    def deregisterContextCommand(self, commandName: MString): 
        '''
        deregisterContextCommand(self, commandName: MString)

        Synopsis
        -----
        Deregister the given user defined context command from Maya. Once
        deregistered the user defined tool can no longer be used.

        Returns:
        -----
        None

        Parameters:
        -----
        commandName: MString
        	[in] -> the name of the context command to deregister


        '''
        pass

    @overload
    def deregisterContextCommand(self, commandName: MString,
                        toolCmdName: MString): 
        '''
        deregisterContextCommand(self, commandName: MString,
                        toolCmdName: MString)

        Synopsis
        -----
        Deregister the given user defined context command and tool
        command from Maya. Once deregistered the user defined tool can no
        longer be used and the tool command can no longer be invoked from
        MEL.

        Returns:
        -----
        None

        Parameters:
        -----
        commandName: MString
        	[in] -> the name of the context command to deregister 

        toolCmdName: MString
        	[in] -> the name of the command to deregister


        '''
        pass

    def registerNode(self, typeName: MString,
                        typeId: MTypeId,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        initFunction: MFnPlugin.MInitializeFunction,
                        type: MPxNode.MPxNode,
                        classification: MString): 
        '''
        registerNode(self, typeName: MString,
                        typeId: MTypeId,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        initFunction: MFnPlugin.MInitializeFunction,
                        type: MPxNode.MPxNode,
                        classification: MString)

        Synopsis
        -----
        Register a new dependency node with Maya. Once registered, the
        node can be used from MEL in a manner identical to built-in Maya
        nodes.

        Returns:
        -----
        None

        Parameters:
        -----
        typeName: MString
        	[in] -> the name of the new type of node 

        typeId: MTypeId
        	[in] -> a unique id that identifies this node 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from 

        initFunction: MFnPlugin.MInitializeFunction
        	[in] -> a pointer to a function that will initialize all the attributes of the new node type 

        type: MPxNode.MPxNode
        	[in] -> the type of plugin node to be registered 

        classification: MString
        	[in] -> a string that determines how the node will be categorized in various rendering-related UI, such as the Create Render Node and HyperShade windows. See the documentation for the 


        '''
        pass

    def deregisterNode(self, typeId: MTypeId): 
        '''
        deregisterNode(self, typeId: MTypeId)

        Synopsis
        -----
        Deregister the given user defined dependency node type Maya. Once
        deregistered new instances of the user defined dependency node
        can no longer be created. Additionally, any existing instances of
        the node type will be changed to the special type Unknown and
        will no longer evaluate in the dependency graph although they
        will be saved correctly if the scene is written.

        Returns:
        -----
        None

        Parameters:
        -----
        typeId: MTypeId
        	[in] -> the unique type id of the node type to deregister


        '''
        pass

    def registerEvaluator(self, evaluatorName: MString,
                        uniquePriority: int,
                        creatorFunction: MFnPlugin.MCustomEvaluatorCreatorFunction): 
        '''
        registerEvaluator(self, evaluatorName: MString,
                        uniquePriority: int,
                        creatorFunction: MFnPlugin.MCustomEvaluatorCreatorFunction)

        Synopsis
        -----
        Register a new evaluator with Maya. Once registered, the
        evaluator can be turned on and off via the command line like any
        other evaluator.

        Returns:
        -----
        None

        Parameters:
        -----
        evaluatorName: MString
        	[in] -> the name of the evaluator 

        uniquePriority: int
        	[in] -> a priority that needs to be unique. The custom evaluator with highest priority order will get the chance to claim nodes first. 

        creatorFunction: MFnPlugin.MCustomEvaluatorCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the evaluator


        '''
        pass

    def deregisterEvaluator(self, evaluatorName: MString): 
        '''
        deregisterEvaluator(self, evaluatorName: MString)

        Synopsis
        -----
        Deregister the given user defined evaluator. Once deregistered,
        the evaluator can no longer be used until registered again.

        Returns:
        -----
        None

        Parameters:
        -----
        evaluatorName: MString
        	[in] -> the name of the evaluator.


        '''
        pass

    def registerTopologyEvaluator(self, evaluatorName: MString,
                        uniquePriority: int,
                        creatorFunction: MFnPlugin.MTopologyEvaluatorCreatorFunction): 
        '''
        registerTopologyEvaluator(self, evaluatorName: MString,
                        uniquePriority: int,
                        creatorFunction: MFnPlugin.MTopologyEvaluatorCreatorFunction)

        Synopsis
        -----
        Introduced in 2019.0 Register a new evaluator with Maya.Once
        registered, the evaluator can be turned on and off via the
        command line like any other evaluator.

        Returns:
        -----
        None

        Parameters:
        -----
        evaluatorName: MString
        	[in] -> the name of the evaluator 

        uniquePriority: int
        	[in] -> a priority that needs to be unique. The custom evaluator with highest priority order will get the chance to claim nodes first. 

        creatorFunction: MFnPlugin.MTopologyEvaluatorCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the evaluator


        '''
        pass

    def deregisterTopologyEvaluator(self, evaluatorName: MString): 
        '''
        deregisterTopologyEvaluator(self, evaluatorName: MString)

        Synopsis
        -----
        Introduced in 2019.0 Deregister the given user defined
        evaluator.Once deregistered, the evaluator can no longer be used
        until registered again.

        Returns:
        -----
        None

        Parameters:
        -----
        evaluatorName: MString
        	[in] -> the name of the evaluator.


        '''
        pass

    @overload
    def registerShape(self, typeName: MString,
                        typeId: MTypeId,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        initFunction: MFnPlugin.MInitializeFunction,
                        uiCreatorFunction: MFnPlugin.MCreatorFunction,
                        classification: MString): 
        '''
        registerShape(self, typeName: MString,
                        typeId: MTypeId,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        initFunction: MFnPlugin.MInitializeFunction,
                        uiCreatorFunction: MFnPlugin.MCreatorFunction,
                        classification: MString)

        Synopsis
        -----
        Registers the given user defined shape node with Maya. Once
        registered, the shape can be used from MEL in a manner identical
        to built-in Maya nodes.This method will be deprecated. Please use
        alternate registerShape overload instead.To deregister the shape
        node use the MFnPlugin::deregisterNode() method.

        Returns:
        -----
        None

        Parameters:
        -----
        typeName: MString
        	[in] -> the name of the new type of user defined shape node 

        typeId: MTypeId
        	[in] -> a unique id that identifies this node 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from MPxSurfaceNode) that implements the new shape node type 

        initFunction: MFnPlugin.MInitializeFunction
        	[in] -> a pointer to a function that will initialize all the attributes of the new shape node type 

        uiCreatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> This parameter is deprecated. A pointer to a function that will return a pointer to a new instance of the class (derived from MGxSurfaceShapeUI) that is used to implement the drawing and selection functions of the user defined shape. 

        classification: MString
        	[in] -> a string that determines how the node will be categorized in various rendering-related UI, such as the Create Render Node and HyperShade windows. See the documentation for the 


        '''
        pass

    @overload
    def registerShape(self, typeName: MString,
                        typeId: MTypeId,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        initFunction: MFnPlugin.MInitializeFunction,
                        classification: MString): 
        '''
        registerShape(self, typeName: MString,
                        typeId: MTypeId,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        initFunction: MFnPlugin.MInitializeFunction,
                        classification: MString)

        Synopsis
        -----
        Registers the given user defined shape node with Maya. Once
        registered, the shape can be used from MEL in a manner identical
        to built-in Maya nodes. To deregister the shape node use the
        MFnPlugin::deregisterNode() method.

        Returns:
        -----
        None

        Parameters:
        -----
        typeName: MString
        	[in] -> the name of the new type of user defined shape node 

        typeId: MTypeId
        	[in] -> a unique id that identifies this node 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from MPxSurfaceNode) that implements the new shape node type 

        initFunction: MFnPlugin.MInitializeFunction
        	[in] -> a pointer to a function that will initialize all the attributes of the new shape node type 

        classification: MString
        	[in] -> a string that determines how the node will be categorized in various rendering-related UI, such as the Create Render Node and HyperShade windows. See the documentation for the 


        '''
        pass

    def registerTransform(self, typeName: MString,
                        typeId: MTypeId,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        initFunction: MFnPlugin.MInitializeFunction,
                        xformCreatorFunction: MFnPlugin.MCreateXformMatrixFunction,
                        xformId: MTypeId,
                        classification: MString): 
        '''
        registerTransform(self, typeName: MString,
                        typeId: MTypeId,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        initFunction: MFnPlugin.MInitializeFunction,
                        xformCreatorFunction: MFnPlugin.MCreateXformMatrixFunction,
                        xformId: MTypeId,
                        classification: MString)

        Synopsis
        -----
        Registers the given user defined transform node with Maya. Once
        registered, the transform can be used from MEL in a manner
        identical to built-in Maya nodes.To deregister the transform node
        use the MFnPlugin::deregisterNode() method.

        Returns:
        -----
        None

        Parameters:
        -----
        typeName: MString
        	[in] -> the name of the new type of user defined transform node 

        typeId: MTypeId
        	[in] -> a unique id that identifies this node 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from 

        initFunction: MFnPlugin.MInitializeFunction
        	[in] -> a pointer to a function that will initialize all the attributes of the new transform node type 

        xformCreatorFunction: MFnPlugin.MCreateXformMatrixFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from 

        xformId: MTypeId
        	[in] -> a unique id that identifies this transformation matrix. If 

        classification: MString
        	[in] -> a string that determines how the node will be categorized in various rendering-related UI, such as the Create Render Node and HyperShade windows. See the documentation for the 


        '''
        pass

    def registerData(self, typeName: MString,
                        typeId: MTypeId,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        type: MPxData.MPxData): 
        '''
        registerData(self, typeName: MString,
                        typeId: MTypeId,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        type: MPxData.MPxData)

        Synopsis
        -----
        Register a new data type with Maya. Once registered, the data
        type can be passed between dependency nodes in a manner identical
        to built-in Maya data types./return Status code

        Returns:
        -----
        None

        Parameters:
        -----
        typeName: MString
        	[in] -> the name of the data type to register 

        typeId: MTypeId
        	[in] -> the unique type id of the data type to register 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from 

        type: MPxData.MPxData
        	[in] -> the type of data being registered, see the Type enum in MPxData.h for all available types


        '''
        pass

    def deregisterData(self, typeId: MTypeId): 
        '''
        deregisterData(self, typeId: MTypeId)

        Synopsis
        -----
        Deregister the given user defined data type from Maya. It is
        important to note that this method will always fail if there are
        any instances of the user-defined data in the scene. If the plug-
        in were to be allowed to deregister its implementation of the
        data, it would become impossible to save the scene since the
        writeASCII and writeBinary methods would no longer be accessible.

        Returns:
        -----
        None

        Parameters:
        -----
        typeId: MTypeId
        	[in] -> the unique type id of the data type to deregister


        '''
        pass

    def registerDevice(self, deviceName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction): 
        '''
        registerDevice(self, deviceName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction)

        Synopsis
        -----
        Register a new input device with Maya. Once registered, the new
        input device can be connected to Maya actions using the
        assignInputDevice command in MEL in a manner identical to built-
        in Maya devices. In Maya 1.0, only Midi input devices are
        supported and the creatorFunction must return a pointer to a
        MPxMidiInputDevice instance. This interface will be generalized
        in a future release.

        Returns:
        -----
        None

        Parameters:
        -----
        deviceName: MString
        	[in] -> the name of the device to register 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from 


        '''
        pass

    def deregisterDevice(self, deviceName: MString): 
        '''
        deregisterDevice(self, deviceName: MString)

        Synopsis
        -----
        Deregister the given user defined input device from Maya.

        Returns:
        -----
        None

        Parameters:
        -----
        deviceName: MString
        	[in] -> the name of the input device to deregister


        '''
        pass

    def registerFileTranslator(self, translatorName: MString,
                        pixmapName: char,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        optionsScriptName: char,
                        defaultOptionsString: char,
                        requiresFullMel: bool,
                        dataStorageLocation: MString): 
        '''
        registerFileTranslator(self, translatorName: MString,
                        pixmapName: char,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        optionsScriptName: char,
                        defaultOptionsString: char,
                        requiresFullMel: bool,
                        dataStorageLocation: MString)

        Synopsis
        -----
        Register a new file translator with Maya. It requires a name
        string containing the "name" by which Maya will refer to this
        file type, and a pathname to an "icon" file which Maya will use
        in its file selection dialogs.

        Returns:
        -----
        None

        Parameters:
        -----
        translatorName: MString
        	[in] -> the string by which Maya will refer to this file type 

        pixmapName: char
        	[in] -> the pathname of the icon used in file selection dialogs 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from 

        optionsScriptName: char
        	[in] -> the name of a MEL script that will be used to display the contents of the options dialog during file open and save. 

        defaultOptionsString: char
        	[in] -> the default value of the options string that will be passed to the options script. 

        requiresFullMel: bool
        	[in] -> this should be set to true if the 

        dataStorageLocation: MString
        	[in] -> the default location where this translator will store its data relative to the current project. This defaults to 


        '''
        pass

    def deregisterFileTranslator(self, translatorName: MString): 
        '''
        deregisterFileTranslator(self, translatorName: MString)

        Synopsis
        -----
        Deregister the specified file translator with Maya.

        Returns:
        -----
        None

        Parameters:
        -----
        translatorName: MString
        	[in] -> the name of the translator to deregister


        '''
        pass

    def registerURIFileResolver(self, fileResolverName: MString,
                        uriScheme: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction): 
        '''
        registerURIFileResolver(self, fileResolverName: MString,
                        uriScheme: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction)

        Synopsis
        -----
        Register a Custom URI File Resolver with Maya.

        Returns:
        -----
        None

        Parameters:
        -----
        fileResolverName: MString
        	[in] -> Name of new file resolver to register. 

        uriScheme: MString
        	[in] -> URI scheme this resolver supports. 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> Pointer to a function that will return a pointer to a new instance of the class (derived from 


        '''
        pass

    def deregisterURIFileResolver(self, fileResolverName: MString): 
        '''
        deregisterURIFileResolver(self, fileResolverName: MString)

        Synopsis
        -----
        Deregister the specified URI file resolver with Maya.

        Returns:
        -----
        None

        Parameters:
        -----
        fileResolverName: MString
        	[in] -> the name of the file resolver to deregister


        '''
        pass

    def registerIkSolver(self, ikSolverName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction): 
        '''
        registerIkSolver(self, ikSolverName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction)

        Synopsis
        -----
        Register a new ik-solver with Maya. NOTE: this method is
        obsolete. Instead, register the IK solver as a node as described
        in the example plug-in simpleSolverNode.cpp.

        Returns:
        -----
        None

        Parameters:
        -----
        ikSolverName: MString
        	[in] -> name of the new IK solver 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> pointer to a function that will return a pointer to a new instance of the class (derived from 


        '''
        pass

    def deregisterIkSolver(self, ikSolverName: MString): 
        '''
        deregisterIkSolver(self, ikSolverName: MString)

        Synopsis
        -----
        Deregister the specified ik-solver with Maya. NOTE: this method
        is obsolete. Instead, register the IK solver as a node as
        described in the example plug-in simpleSolverNode.cpp.

        Returns:
        -----
        None

        Parameters:
        -----
        ikSolverName: MString
        	[in] -> the name of the ik solver to deregister


        '''
        pass

    def registerCacheFormat(self, cacheFormatName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction): 
        '''
        registerCacheFormat(self, cacheFormatName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction)

        Synopsis
        -----
        Register a new cache format with Maya.

        Returns:
        -----
        None

        Parameters:
        -----
        cacheFormatName: MString
        	[in] -> Name of the new cache format. 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> Pointer to a function that will return a pointer to a new instance of the class (derived from 


        '''
        pass

    def deregisterCacheFormat(self, cacheFormatName: MString): 
        '''
        deregisterCacheFormat(self, cacheFormatName: MString)

        Synopsis
        -----
        Deregister the specified cache format with Maya.

        Returns:
        -----
        None

        Parameters:
        -----
        cacheFormatName: MString
        	[in] -> the name of the cache format to deregister


        '''
        pass

    def registerUIStrings(self, registerMStringResources: MFnPlugin.MInitializeFunction,
                        pluginStringsProc: MString): 
        '''
        registerUIStrings(self, registerMStringResources: MFnPlugin.MInitializeFunction,
                        pluginStringsProc: MString)

        Synopsis
        -----
        Set the callback and procedure names of routines that register
        plugin string resources and optionally load localized values for
        them. These procedures are called immediately upon plugin load.
        They are responsible for registering all string resources that
        can be referred to during the plugin execution. If the string
        resources are localized, the localized values are also loaded at
        this time.Each string resource is given a default value when it
        is registered. If the plugin is localized, any localized values
        specified will override the registered default and will be used
        instead of the default value when the resource value is
        queried.The registerMStringResources callback is a function which
        makes a series of calls to MStringResource::registerString for
        each MStringResourceId to be registered. Its signature is
        described by the MInitializeFunction typedef.The
        pluginStringsProc is a mel procedure that will be evaluated to
        register any other strings resources for the plugin, i.e. those
        used in the plugin's scripts (see the registerPluginString
        command). It is also responsible for loading the localized
        resource overrides if they are available (see
        loadPluginLanguageResources).See also the following classes:
        MStringResourceId, MStringResource.

        Returns:
        -----
        None

        Parameters:
        -----
        registerMStringResources: MFnPlugin.MInitializeFunction
        	[in] -> This callback is used to register MStringResources that are used by the plugin code. The callback signature type is defined by MInitializeFunction. 

        pluginStringsProc: MString
        	[in] -> The name of the mel procedure to be run during plugin load to register script-based resources. This script will also make the necessary calls to load localized string values if they exist.


        '''
        pass

    def registerUI(self, creationProc: MFnPlugin.PyObject,
                        deletionProc: MFnPlugin.PyObject,
                        creationBatchProc: MFnPlugin.PyObject,
                        deletionBatchProc: MFnPlugin.PyObject): 
        '''
        registerUI(self, creationProc: MFnPlugin.PyObject,
                        deletionProc: MFnPlugin.PyObject,
                        creationBatchProc: MFnPlugin.PyObject,
                        deletionBatchProc: MFnPlugin.PyObject)

        Synopsis
        -----
        Sets the Python callable objects to be called to create and
        destroy any UI associated with the plugin.

        Returns:
        -----
        None

        Parameters:
        -----
        creationProc: MFnPlugin.PyObject
        	[in] -> The name of the Python callable object to be run when the plug in is loaded 

        deletionProc: MFnPlugin.PyObject
        	[in] -> The name of the Python callable object to be run when the plug in is unloaded 

        creationBatchProc: MFnPlugin.PyObject
        	[in] -> The name of the Python callable object to be run when the plug in is loaded in batch mode. The procedure should not contain UI related code. 

        deletionBatchProc: MFnPlugin.PyObject
        	[in] -> The name of the Python callable object to be run when the plug in is unloaded in batch mode. The procedure should not contain UI related code.


        '''
        pass

    def registerDragAndDropBehavior(self, behaviorName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction): 
        '''
        registerDragAndDropBehavior(self, behaviorName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction)

        Synopsis
        -----
        Register a new drag and drop behavior with Maya. Once registered,
        the new behavior can be used to finish connections between node
        drag and drops from the hyperGraph/hyperShade to other nodes or
        Maya UI.

        Returns:
        -----
        None

        Parameters:
        -----
        behaviorName: MString
        	[in] -> the name of the drag and drop behavior to register 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from 


        '''
        pass

    def deregisterDragAndDropBehavior(self, behaviorName: MString): 
        '''
        deregisterDragAndDropBehavior(self, behaviorName: MString)

        Synopsis
        -----
        Deregister the given drag and drop behavior from Maya.

        Returns:
        -----
        None

        Parameters:
        -----
        behaviorName: MString
        	[in] -> the name of the behavior to deregister


        '''
        pass

    def registerImageFile(self, imageFormatName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        imageFileExtensions: MStringArray,
                        priority: MFnPlugin.ImageFilePriority): 
        '''
        registerImageFile(self, imageFormatName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        imageFileExtensions: MStringArray,
                        priority: MFnPlugin.ImageFilePriority)

        Synopsis
        -----
        Changed in 2020.0 Register a new image file translator with Maya.

        Returns:
        -----
        None

        Parameters:
        -----
        imageFormatName: MString
        	[in] -> the name of the image format to register 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from MImageFile) that implements the new file type. 

        imageFileExtensions: MStringArray
        	[in] -> this list of file extensions this image file should be associated with. 

        priority: MFnPlugin.ImageFilePriority
        	[in] -> Priority number that allow user to specify the plugin priority. The higher the number is, the lower the priority is. High priority plugin will be use before Maya internal code and low priority plugin will be use after Maya internal code. 


        '''
        pass

    def deregisterImageFile(self, imageFormatName: MString): 
        '''
        deregisterImageFile(self, imageFormatName: MString)

        Synopsis
        -----
        Deregister the specified image file translator with Maya.

        Returns:
        -----
        None

        Parameters:
        -----
        imageFormatName: MString
        	[in] -> the name of the image format to deregister


        '''
        pass

    def registerRenderPassImpl(self, passImplId: MString,
                        passDef: MRenderPassDef,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        overload: bool): 
        '''
        registerRenderPassImpl(self, passImplId: MString,
                        passDef: MRenderPassDef,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        overload: bool)

        Synopsis
        -----
        Register a new render pass implementation with Maya and associate
        with the given render pass definition. If an implementation with
        id passImplId has already been registered and creatorFunction is
        the same as the already registered creator function then the
        existing implementation will also be used for the current pass
        (SAME instances). It is an error if the passImplId is already
        defined and a different creatorFunction is used. If you wish to
        associate DIFFERENT instances of the same pass implementation
        with different passes, then use unique passImplIds when
        registering each.

        Returns:
        -----
        None

        Parameters:
        -----
        passImplId: MString
        	[in] -> a unique name identifying the pass implementation 

        passDef: MRenderPassDef
        	[in] -> the render pass definition to associate this implementation with 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from 

        overload: bool
        	[in] -> Override any existing implementation in the registry


        '''
        pass

    def deregisterRenderPassImpl(self, passImplId: MString): 
        '''
        deregisterRenderPassImpl(self, passImplId: MString)

        Synopsis
        -----
        Deregister the specified render pass implementation with Maya.
        This will remove the implementation from all passes it is
        associated with.

        Returns:
        -----
        None

        Parameters:
        -----
        passImplId: MString
        	[in] -> the name identifying the pass implementation to remove


        '''
        pass

    def registerAttributePatternFactory(self, patternFactoryName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction): 
        '''
        registerAttributePatternFactory(self, patternFactoryName: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction)

        Synopsis
        -----
        Registers a new attribute pattern factory type with Maya.

        Returns:
        -----
        None

        Parameters:
        -----
        patternFactoryName: MString
        	[in] -> the new attribute pattern factory name. 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> pointer to function that returns a new instance of an attribute pattern factory.


        '''
        pass

    def deregisterAttributePatternFactory(self, attributePatternFactoryName: MString): 
        '''
        deregisterAttributePatternFactory(self, attributePatternFactoryName: MString)

        Synopsis
        -----
        Deregister the attribute pattern factory type with Maya.

        Returns:
        -----
        None

        Parameters:
        -----
        attributePatternFactoryName: MString
        	[in] -> the attribute pattern factory name.


        '''
        pass

    def registerAnimCurveInterpolator(self, typeName: MString,
                        typeId: int,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        flags: int): 
        '''
        registerAnimCurveInterpolator(self, typeName: MString,
                        typeId: int,
                        creatorFunction: MFnPlugin.MCreatorFunction,
                        flags: int)

        Synopsis
        -----
        Register a new animation curve interpolator with Maya. Once
        registered, the interpolator can be used in interpolating between
        keyframes.

        Returns:
        -----
        None

        Parameters:
        -----
        typeName: MString
        	[in] -> the name of the interpolator to register 

        typeId: int
        	[in] -> the unique type id of the interpolator to register. See 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from 

        flags: int
        	[in] -> an integer value containing a combination of enum values as specified in the InterpolatorFlags enumerated type (see 


        '''
        pass

    def deregisterAnimCurveInterpolator(self, typeName: MString): 
        '''
        deregisterAnimCurveInterpolator(self, typeName: MString)

        Synopsis
        -----
        Deregister the given user defined animation curve interpolator
        from Maya.

        Returns:
        -----
        None

        Parameters:
        -----
        typeName: MString
        	[in] -> the unique type id of the interpolator to deregister


        '''
        pass

    def registerDisplayFilter(self, name: MString,
                        label: MString,
                        classification: MString): 
        '''
        registerDisplayFilter(self, name: MString,
                        label: MString,
                        classification: MString)

        Synopsis
        -----
        Register a new display filter with Maya. A display filter with
        the same label and classification can be registered multiple
        times. There is a counter to maintain the registration. Each
        successful registration needs a call to deregisterDisplayFilter()
        to balance the counter.See M3dView::setPluginObjectDisplay() for
        more details on plug-in display filters.

        Returns:
        -----
        None

        Parameters:
        -----
        name: MString
        	[in] -> the new display filter name 

        label: MString
        	[in] -> the UI display name of the display filter 

        classification: MString
        	[in] -> the classification to filter objects in Viewport 2.0


        '''
        pass

    def deregisterDisplayFilter(self, name: MString): 
        '''
        deregisterDisplayFilter(self, name: MString)

        Synopsis
        -----
        Deregister a display filter with Maya.

        Returns:
        -----
        None

        Parameters:
        -----
        name: MString
        	[in] -> the display filter name


        '''
        pass

    def registerRenderer(self, name: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction): 
        '''
        registerRenderer(self, name: MString,
                        creatorFunction: MFnPlugin.MCreatorFunction)

        Synopsis
        -----
        Registers a new renderer identified by name.

        Returns:
        -----
        None

        Parameters:
        -----
        name: MString
        	[in] -> The name of the renderer 

        creatorFunction: MFnPlugin.MCreatorFunction
        	[in] -> a pointer to a function that will return a pointer to a new instance of the class (derived from 


        '''
        pass

    def deregisterRenderer(self, name: MString): 
        '''
        deregisterRenderer(self, name: MString)

        Synopsis
        -----
        Deregisters an renderer identified by name.

        Returns:
        -----
        None

        Parameters:
        -----
        name: MString
        	[in] -> The name of the renderer


        '''
        pass

    def findPlugin(self, pluginName: MString): 
        '''
        findPlugin(self, pluginName: MString) -> MObject

        Synopsis
        -----
        Returns an MObject corresponding to the named plugin. If the
        plugin isn't loaded, the MObject will be kNullObj. This MObject
        may be used in the same way as the MObject passed to the plugin's
        initializePlugin() function. Do not hold onto this MObject, if
        you need it again later, call findPlugin() again.

        Returns: 
        ----- 
        An MObject corresponding to the plugin if the plugin is loaded.
        MObject::kNullObj if the plugin isn't loaded.

        Parameters:
        -----
        pluginName: MString
        	[in] -> the name of the plugin you want a handle for.


        '''
        pass

    def isNodeRegistered(self, typeName: MString): 
        '''
        isNodeRegistered(self, typeName: MString) -> bool

        Synopsis
        -----
        Queries if the given typeName has been registered by maya or
        plugins.

        Returns: 
        ----- 
        true if registered, false otherwise.

        Parameters:
        -----
        typeName: MString
        	[in] -> the type name of a depend graph node to query.


        '''
        pass

    def matrixTypeIdFromXformId(self, xformTypeId: MTypeId,
                        ReturnStatus: MFnPlugin.MStatus): 
        '''
        matrixTypeIdFromXformId(self, xformTypeId: MTypeId,
                        ReturnStatus: MFnPlugin.MStatus) -> MTypeId

        Synopsis
        -----
        The function returns the MTypeId of the matrix when the MTypeId
        of the corresponding xform is given.

        Returns: 
        ----- 
        MTypeId TypeId of the corresponding transformation matrix, if
        found.

        Parameters:
        -----
        xformTypeId: MTypeId
        	[in] -> the typeId of the transform. 

        ReturnStatus: MFnPlugin.MStatus
        	[out] -> Return status.


        '''
        pass

    def addMenuItem(self, menuItemName: MString,
                        menuItemLabel: MString,
                        parentName: MString,
                        commandName: MString,
                        commandParams: MString,
                        needOptionBox: bool,
                        optBoxFunction: MString,
                        retStatus: MFnPlugin.MStatus,
                        extraMenuItemParams: MString): 
        '''
        addMenuItem(self, menuItemName: MString,
                        menuItemLabel: MString,
                        parentName: MString,
                        commandName: MString,
                        commandParams: MString,
                        needOptionBox: bool,
                        optBoxFunction: MString,
                        retStatus: MFnPlugin.MStatus,
                        extraMenuItemParams: MString) -> MStringArray

        Synopsis
        -----
        Introduced in 2022.0 The function adds the menuItem to the
        specified parent, and associates a command with it.Additionally,
        an option box can be created and a MEL function/command can be
        added to it. The function returns the names of the new menuItem
        and the optionBox created.

        Returns: 
        ----- 
        MStringArray returns the names of the new menuItems created. In
        case the method fails, and MStringArray has items in it,
        removeMenuItem() should be called on it to remove the unused UI
        references.

        Parameters:
        -----
        menuItemName: MString
        	[in] -> This will be used as the name for the menuItem. It must be 7bit ASCII. 

        menuItemLabel: MString
        	[in] -> This will be used as the label for the menuItem. 

        parentName: MString
        	[in] -> Name of the parent to which the new menuItem needs to be attached. 

        commandName: MString
        	[in] -> Command to be attached. 

        commandParams: MString
        	[in] -> Parameters for the command. 

        needOptionBox: bool
        	[in] -> Boolean indicating whether an option box is required. Default value is false. 

        optBoxFunction: MString
        	[in] -> MEL Function to be attached to the option box. If the needOptionBox is false, then this argument will have no effect. 

        retStatus: MFnPlugin.MStatus
        	[out] -> Return status. 

        extraMenuItemParams: MString
        	[in] -> Parameters for creating the menuItem.


        '''
        pass

    def removeMenuItem(self, menuItemNames: MStringArray): 
        '''
        removeMenuItem(self, menuItemNames: MStringArray)

        Synopsis
        -----
        The function removes the menuItem and the corresponding option
        box, if exists, from the UI.

        Returns:
        -----
        None

        Parameters:
        -----
        menuItemNames: MStringArray
        	[in] -> Names of the menuItem which needs to be removed.


        '''
        pass

    def registerMaterialInfo(self, materialInfoName: MString,
                        fnPtr: MMaterialInfoFactoryFnPtr): 
        '''
        registerMaterialInfo(self, materialInfoName: MString,
                        fnPtr: MMaterialInfoFactoryFnPtr)

        Synopsis
        -----
        Registers a new material information type with Maya.

        Returns:
        -----
        None

        Parameters:
        -----
        materialInfoName: MString
        	[in] -> the new material info generator name. 

        fnPtr: MMaterialInfoFactoryFnPtr
        	[in] -> pointer to function that return a new instance of material information node.


        '''
        pass

    def unregisterMaterialInfo(self, materialInfoName: MString): 
        '''
        unregisterMaterialInfo(self, materialInfoName: MString)

        Synopsis
        -----
        Deregister the specified material info type with Maya.

        Returns:
        -----
        None

        Parameters:
        -----
        materialInfoName: MString
        	[in] -> the material info generator name.


        '''
        pass

    def registerBakeEngine(self, bakeEngineGenName: MString,
                        fnPtr: MBakeEngineCreatorFnPtr): 
        '''
        registerBakeEngine(self, bakeEngineGenName: MString,
                        fnPtr: MBakeEngineCreatorFnPtr)

        Synopsis
        -----
        Registers a new bake engine type with Maya.

        Returns:
        -----
        None

        Parameters:
        -----
        bakeEngineGenName: MString
        	[in] -> the new bake engine generator name. 

        fnPtr: MBakeEngineCreatorFnPtr
        	[in] -> pointer to function that return a new instance of bake engine generator node.


        '''
        pass

    def unregisterBakeEngine(self, bakeEngineGenName: MString): 
        '''
        unregisterBakeEngine(self, bakeEngineGenName: MString)

        Synopsis
        -----
        Deregister the bake engine type with Maya.

        Returns:
        -----
        None

        Parameters:
        -----
        bakeEngineGenName: MString
        	[in] -> the bake engine generator name.


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MFnPluginData:
    '''User defined data function set for dependency node data.
All user defined data that is to be passed between nodes in the
dependency graph must be derived from
MPxData. The use of this class is closely linked to the use of
MPxData,
MFnPluginData,
MDataHandle, and
MTypeId.
In order to use user defined data, one must first create an
instance of the
MTypeId class that is initialized with a unique id tag. Then create a
new class derived from
MPxData to hold the user-defined data, As well as a helper class derived
from
MPxData that can create instances of the new derived type.
For data of this type that needs to be passed into a plug, one
would get an
MDataHandle for the attribute that uses the type. This would result in a
call to the
MPxData helper class that would create an instance of the type inside
the
MDataHandle. The
MDataHandle::data method can then be used to get an get an
MObject for the user defined data and this should be used to initialize
an instance of
MFnPluginData. Then the
MFnPluginData::data method can be used to get an
MPxData pointer, which can be safely cast to a pointer of the user
defined type. The data can be updated through this pointer, after
which the
MDataHandle::setClean method is used to complete the operation.
To receive data of this type from a plug, an
MDataHandle for the attribute that uses the new data type is created. The
MDataHandle::type method should be used to ascertain that it contains kPlugin
data. Then the
MDataHandle::data method is used to get an
MObject for the user defined data and this should be used to initialize
an instance of
MFnPluginData. The
MFnPluginData::typeId method can be used to ascertain that the data is in fact of the
user defined type. Then the
MFnPluginData::data method can be used to get an
MPxData pointer, which can be safely cast to a pointer to the user
defined type.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kPluginData.Reimplemented from MFnData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnPluginData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnPluginData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def typeId(self, ReturnStatus: MFnPluginData.MStatus): 
        '''
        typeId(self, ReturnStatus: MFnPluginData.MStatus) -> MTypeId

        Synopsis
        -----
        Return the unique MTypeId of the user defined data that is held
        by this instance.

        Returns: 
        ----- 
        The unique MTypeId of the data held in this instance

        Parameters:
        -----
        ReturnStatus: MFnPluginData.MStatus
        	[out] -> kSuccess if the instance is attached to an 


        '''
        pass

    def constData(self, ReturnStatus: MFnPluginData.MStatus): 
        '''
        constData(self, ReturnStatus: MFnPluginData.MStatus) -> const MPxData*

        Synopsis
        -----
        Return a constant pointer to the user defined data held in this
        instance.

        Returns: 
        ----- 
        A constant pointer to the MPxData base class for the user defined
        data

        Parameters:
        -----
        ReturnStatus: MFnPluginData.MStatus
        	[out] -> kSuccess if the instance is attached to an 


        '''
        pass

    def create(self, id: MTypeId,
                        ReturnStatus: MFnPluginData.MStatus): 
        '''
        create(self, id: MTypeId,
                        ReturnStatus: MFnPluginData.MStatus) -> MObject

        Synopsis
        -----
        Create an instance of MPluginData and initialize it to represent
        user defined data of the given type.

        Returns: 
        ----- 
        An MObject that represents an instance of the user defined data
        type. This will be set to MObject::kNullObj if the create failes.

        Parameters:
        -----
        id: MTypeId
        	[in] -> the unique 

        ReturnStatus: MFnPluginData.MStatus
        	[out] -> kSuccess if the create suceeds, and kFailure otherwise


        '''
        pass

class MFnPointArrayData:
    '''Point array function set for dependency node data.
MFnPointArrayData allows the creation and manipulation of
MPointArray data objects for use in the dependency graph.
If a user written dependency node either accepts or produces
MPointArrays, then this class is used to extract or create the
data that comes from or goes to other dependency graph nodes. The
MDataHandle::type method will return kPointArray when data of this type is
present. To access it, the
MDataHandle::data method is used to get an
MObject for the data and this should then be used to initialize an
instance of
MFnPointArrayData.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kPointArrayData.Reimplemented from MFnData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnPointArrayData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnPointArrayData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def length(self, ReturnStatus: MFnPointArrayData.MStatus): 
        '''
        length(self, ReturnStatus: MFnPointArrayData.MStatus) -> int

        Synopsis
        -----
        Return the number of points in the instance.

        Returns: 
        ----- 
        The number of points in the instance

        Parameters:
        -----
        ReturnStatus: MFnPointArrayData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    @overload
    def set(self, element: MPoint,
                        index: int): 
        '''
        set(self, element: MPoint,
                        index: int)

        Synopsis
        -----
        Set the point element at the specified index.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MPoint
        	[in] -> the element to be set 

        index: int
        	[in] -> the index of the 


        '''
        pass

    def copyTo(self, dest: MPointArray): 
        '''
        copyTo(self, dest: MPointArray)

        Synopsis
        -----
        Copy all the points in the instance into the given MPointArray.
        No checking is done by this class on sizes, so it is up to the
        user to ensure that the given MPointArray is large enough to hold
        the number of MPoints in the instance.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: MPointArray
        	[out] -> the 


        '''
        pass

    @overload
    def set(self, array: MPointArray): 
        '''
        set(self, array: MPointArray)

        Synopsis
        -----
        Set the instance to contain the points defined in the given
        MPointArray.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MPointArray
        	[in] -> the 


        '''
        pass

    def array(self, ReturnStatus: MFnPointArrayData.MStatus): 
        '''
        array(self, ReturnStatus: MFnPointArrayData.MStatus) -> MPointArray

        Synopsis
        -----
        Get an MPointArray containing the points stored in this instance.
        The MPointArray returned by this method is editable, so any
        changes to the return instance also affects the MObject operated
        upon by this function set.

        Returns: 
        ----- 
        A copy of the MPointArray held in this instance

        Parameters:
        -----
        ReturnStatus: MFnPointArrayData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    @overload
    def create(self, ReturnStatus: MFnPointArrayData.MStatus): 
        '''
        create(self, ReturnStatus: MFnPointArrayData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance, and initialize
        it to contain no points.

        Returns: 
        ----- 
        The newly created MObject

        Parameters:
        -----
        ReturnStatus: MFnPointArrayData.MStatus
        	[out] -> kSuccess


        '''
        pass

    @overload
    def create(self, arr: MPointArray,
                        ReturnStatus: MFnPointArrayData.MStatus): 
        '''
        create(self, arr: MPointArray,
                        ReturnStatus: MFnPointArrayData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance, and initialize
        it to contain the data from the given MPointArray.

        Returns: 
        ----- 
        The newly created MObject

        Parameters:
        -----
        arr: MPointArray
        	[in] -> the data to use when initializing this instance 

        ReturnStatus: MFnPointArrayData.MStatus
        	[out] -> kSuccess


        '''
        pass

class MFnPointLight:
    '''Manage Point Light dependency Nodes.
MFnPointLight facilitates creation and manipulation of dependency graph nodes
representing point lights.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kPointLight.Reimplemented from
        MFnNonExtendedLight.Reimplemented in MFnVolumeLight.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnPointLight.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnPointLight".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def create(self, UIvisible: bool,
                        ReturnStatus: MFnPointLight.MStatus): 
        '''
        create(self, UIvisible: bool,
                        ReturnStatus: MFnPointLight.MStatus) -> MObject

        Synopsis
        -----
        Creates a new point light dependency graph node and adds it to
        the dependency graph. If the UIvisible parameter is true, the new
        node will be connected to the light classification node (which
        allows the UI to recognize the node as a light) and added to the
        default light list. If UIvisible is false, the node will be
        created in isolation.The light node is added to the current
        model, under a new transformation.

        Returns: 
        ----- 
        MObject representing the new dependency node.

        Parameters:
        -----
        UIvisible: bool
        	[in] -> determines whether or not to connect the new node to the light classification node and add it to the default light list. 

        ReturnStatus: MFnPointLight.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def create(self, parent: MObject,
                        UIvisible: bool,
                        wantTransform: bool,
                        ReturnStatus: MFnPointLight.MStatus): 
        '''
        create(self, parent: MObject,
                        UIvisible: bool,
                        wantTransform: bool,
                        ReturnStatus: MFnPointLight.MStatus) -> MObject

        Synopsis
        -----
        Creates a new point light dependency graph node and adds it to
        the dependency graph. If the UIvisible parameter is true, the new
        node will be connected to the light classification node (which
        allows the UI to recognize the node as a light) and added to the
        default light list. If UIvisible is false, the node will be
        created in isolation.If wantTransform parameter is false ( which
        is by default ), the new shape node is created under the
        specified parent and no transform node is created. If the
        specified parent is null, then no shape node will be created.The
        light node is added to the current model, under the specified
        parent.

        Returns: 
        ----- 
        MObject representing the new dependency node.

        Parameters:
        -----
        parent: MObject
        	[in] -> the node under which the new light and its transform will be added. 

        UIvisible: bool
        	[in] -> determines whether or not to connect the new node to the light classification node and add it to the default light list. 

        wantTransform: bool
        	[in] -> Boolean to indicate whether the transform node is needed or not, which is 'false' by default. 

        ReturnStatus: MFnPointLight.MStatus
        	[out] -> return status


        '''
        pass

class MFnReference:
    '''Function set for querying information about file references.
Reference nodes are used to track data about file references.
Referenced files may be loaded and unloaded. They also store data
about changes made to objects in the referenced file. The class
MItEdits may be used to retrieve information about such changes.
The class
MFileIO may be used to perform actual operations on references such as
loading, unloading, adding and removing references.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kReference.Reimplemented from MFnDependencyNode.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> staticchar*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isValidReference(self, ReturnStatus: MFnReference.MStatus): 
        '''
        isValidReference(self, ReturnStatus: MFnReference.MStatus) -> bool

        Synopsis
        -----
        Introduced in 2023.0 Returns true if the reference is a valid
        file reference.

        Returns: 
        ----- 
        Whether or not the reference is a file reference

        Parameters:
        -----
        ReturnStatus: MFnReference.MStatus
        	[out] -> return status


        '''
        pass

    def fileName(self, resolvedName: bool,
                        includePath: bool,
                        includeCopyNumber: bool,
                        ReturnStatus: MFnReference.MStatus): 
        '''
        fileName(self, resolvedName: bool,
                        includePath: bool,
                        includeCopyNumber: bool,
                        ReturnStatus: MFnReference.MStatus) -> MString

        Synopsis
        -----
        Returns the name of file associated with this reference.

        Returns: 
        ----- 
        The name of the referenced file

        Parameters:
        -----
        resolvedName: bool
        	[in] -> If true, return the resolved name rather than the original file name. The unresolved name is the string originally specified when the file was loaded into Maya; this may contain environment variables, may be a relative path, and may otherwise not precisely indicate where the file can be located on disk. The resolved name is the actual path name that Maya is using to locate the file after relative paths and environment variables have been expanded, and any other necessary steps have been used to resolve its physical location. 

        includePath: bool
        	[in] -> If true, include the file path in the return string. 

        includeCopyNumber: bool
        	[in] -> If true, include the copy number (if there is one) in the return string. 

        ReturnStatus: MFnReference.MStatus
        	[out] -> return status


        '''
        pass

    def associatedNamespace(self, baseName: bool,
                        ReturnStatus: MFnReference.MStatus): 
        '''
        associatedNamespace(self, baseName: bool,
                        ReturnStatus: MFnReference.MStatus) -> MString

        Synopsis
        -----
        Returns the namespace associated with this reference.

        Returns: 
        ----- 
        The namespace of this reference

        Parameters:
        -----
        baseName: bool
        	[in] -> If true, return the base name of the reference 

        ReturnStatus: MFnReference.MStatus
        	[out] -> return status


        '''
        pass

    def parentFileName(self, resolveName: bool,
                        includePath: bool,
                        includeCopyNumber: bool,
                        ReturnStatus: MFnReference.MStatus): 
        '''
        parentFileName(self, resolveName: bool,
                        includePath: bool,
                        includeCopyNumber: bool,
                        ReturnStatus: MFnReference.MStatus) -> MString

        Synopsis
        -----
        Returns the name of parent file associated with this reference.

        Returns: 
        ----- 
        The name of the parent file to the reference. Returns an empty
        string if there is no parent file.

        Parameters:
        -----
        resolveName: bool
        	[in] -> If true, return the resolved name rather than the original file name. The unresolved name is the string originally specified when the file was loaded into Maya; this may contain environment variables, may be a relative path, and may otherwise not precisely indicate where the file can be located on disk. The resolved name is the actual path name that Maya is using to locate the file after relative paths and environment variables have been expanded, and any other necessary steps have been used to resolve its physical location. 

        includePath: bool
        	[in] -> If true, include the file path in the return string. 

        includeCopyNumber: bool
        	[in] -> If true, include the copy number (if there is one) in the return string. 

        ReturnStatus: MFnReference.MStatus
        	[out] -> return status


        '''
        pass

    def parentReference(self, ReturnStatus: MFnReference.MStatus): 
        '''
        parentReference(self, ReturnStatus: MFnReference.MStatus) -> MObject

        Synopsis
        -----
        Returns the reference node associated with the parent reference.

        Returns: 
        ----- 
        The parent reference of this reference or MObject::kNullObj if
        there is no associated reference.

        Parameters:
        -----
        ReturnStatus: MFnReference.MStatus
        	[out] -> return status


        '''
        pass

    def parentAssembly(self, ReturnStatus: MFnReference.MStatus): 
        '''
        parentAssembly(self, ReturnStatus: MFnReference.MStatus) -> MObject

        Synopsis
        -----
        Returns the parent assembly node that contains this reference.
        See MFnAssembly documentation for more details.

        Returns: 
        ----- 
        The parent assembly node that contains this reference or
        MObject::kNullObj if there is no parent assembly node.

        Parameters:
        -----
        ReturnStatus: MFnReference.MStatus
        	[out] -> return status


        '''
        pass

    def containsNode(self, node: MObject,
                        ReturnStatus: MFnReference.MStatus): 
        '''
        containsNode(self, node: MObject,
                        ReturnStatus: MFnReference.MStatus) -> bool

        Synopsis
        -----
        Returns true if the specified node is from this reference or one
        of its child references. The containsNodeExactly method can be
        used to test membership without including the child references.

        Returns: 
        ----- 
        Whether or not the node is from the reference or one of its child
        references.

        Parameters:
        -----
        node: MObject
        	[in] -> The node to be checked 

        ReturnStatus: MFnReference.MStatus
        	[out] -> return status


        '''
        pass

    def containsNodeExactly(self, node: MObject,
                        ReturnStatus: MFnReference.MStatus): 
        '''
        containsNodeExactly(self, node: MObject,
                        ReturnStatus: MFnReference.MStatus) -> bool

        Synopsis
        -----
        Returns true if the specified node is from this reference.
        Membership in child references is not checked. The containsNode
        method may be used to test membership in a reference and its
        child references.

        Returns: 
        ----- 
        Whether or not the node is from the reference.

        Parameters:
        -----
        node: MObject
        	[in] -> The node to be checked 

        ReturnStatus: MFnReference.MStatus
        	[out] -> return status


        '''
        pass

    def nodes(self, nodeList: MObjectArray,
                        ReturnStatus: MFnReference.MStatus): 
        '''
        nodes(self, nodeList: MObjectArray,
                        ReturnStatus: MFnReference.MStatus)

        Synopsis
        -----
        Returns an array of the nodes associated with this reference.

        Returns:
        -----
        None

        Parameters:
        -----
        nodeList: MObjectArray
        	[out] -> the nodes from this reference 

        ReturnStatus: MFnReference.MStatus
        	[out] -> return status


        '''
        pass

    def isLoaded(self, ReturnStatus: MFnReference.MStatus): 
        '''
        isLoaded(self, ReturnStatus: MFnReference.MStatus) -> bool

        Synopsis
        -----
        Returns true if the reference is loaded.

        Returns: 
        ----- 
        Whether or not the reference is loaded

        Parameters:
        -----
        ReturnStatus: MFnReference.MStatus
        	[out] -> return status


        '''
        pass

    def isLocked(self, ReturnStatus: MFnReference.MStatus): 
        '''
        isLocked(self, ReturnStatus: MFnReference.MStatus) -> bool

        Synopsis
        -----
        Returns true if the reference is locked or if the referenced file
        was saved as locked.

        Returns: 
        ----- 
        Returns true if the reference is locked or if the referenced file
        was saved as locked

        Parameters:
        -----
        ReturnStatus: MFnReference.MStatus
        	[out] -> return status


        '''
        pass

    def isExportEditsFile(self, ReturnStatus: MFnReference.MStatus): 
        '''
        isExportEditsFile(self, ReturnStatus: MFnReference.MStatus) -> bool

        Synopsis
        -----
        Returns true if the reference is an export edits file. An export
        edits file is a file of type ".editMA" or ".editMB" which was
        created using Maya's offline file functionality.

        Returns: 
        ----- 
        Whether or not the reference is an export edits file

        Parameters:
        -----
        ReturnStatus: MFnReference.MStatus
        	[out] -> return status


        '''
        pass

    def ignoreReferenceEdits(self): 
        '''
        ignoreReferenceEdits(self) -> bool

        Synopsis
        -----
        Indicates whether reference edits will be tracked and logged or
        not.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setIgnoreReferenceEdits(self, ignoreEdits: bool): 
        '''
        setIgnoreReferenceEdits(self, ignoreEdits: bool)

        Synopsis
        -----
        Specify whether reference edits should be tracked and logged or
        not. This should be treated as a temporary state and should be
        enabled around a batch of operations where reference edits should
        be ignored. Restore the previous value when the batch of
        operations is complete.

        Returns:
        -----
        None

        Parameters:
        -----
        ignoreEdits: bool
        	[in] -> If true reference edits will not be logged. 


        '''
        pass

class MFnReflectShader:
    '''Manage Reflective Surface Shaders.
MFnReflectShader allows manipulation of dependency graph nodes representing
reflective surface shaders. This includes Phong and Blinn
shaders.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kReflect.Reimplemented from MFnLambertShader.Reimplemented
        in MFnBlinnShader, and MFnPhongShader.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnReflectShader.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnReflectShader".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def reflectedRayDepthLimit(self, ReturnStatus: MFnReflectShader.MStatus): 
        '''
        reflectedRayDepthLimit(self, ReturnStatus: MFnReflectShader.MStatus) -> short

        Synopsis
        -----
        Retrieves the value of the "reflectedRayDepthLimit" attribute of
        a reflective shader node. This attribute represents the maximum
        reflected ray depth used in the shading calculation.

        Returns: 
        ----- 
        The value of the "reflectedRayDepthLimit" attribute of the node.

        Parameters:
        -----
        ReturnStatus: MFnReflectShader.MStatus
        	[out] -> return status


        '''
        pass

    def setReflectedRayDepthLimit(self, reflected_ray_depth_limit: short): 
        '''
        setReflectedRayDepthLimit(self, reflected_ray_depth_limit: short)

        Synopsis
        -----
        Sets the value of the "reflectedRayDepthLimit" attribute of a
        lambert shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        reflected_ray_depth_limit: short
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def specularColor(self, ReturnStatus: MFnReflectShader.MStatus): 
        '''
        specularColor(self, ReturnStatus: MFnReflectShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "specularColor" attribute of a
        reflective shader node. This attribute represents the color of
        specular highlights produced by the shader.

        Returns: 
        ----- 
        The value of the "specularColor" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnReflectShader.MStatus
        	[out] -> return status


        '''
        pass

    def setSpecularColor(self, specular_color: MColor): 
        '''
        setSpecularColor(self, specular_color: MColor)

        Synopsis
        -----
        Sets the value of the "specularColor" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        specular_color: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def reflectivity(self, ReturnStatus: MFnReflectShader.MStatus): 
        '''
        reflectivity(self, ReturnStatus: MFnReflectShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "reflectivity" attribute of a
        reflective shader node. This attribute represents the
        reflectivity of the shader.

        Returns: 
        ----- 
        The value of the "reflectivity" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnReflectShader.MStatus
        	[out] -> return status


        '''
        pass

    def setReflectivity(self, reflect: float): 
        '''
        setReflectivity(self, reflect: float)

        Synopsis
        -----
        Sets the value of the "reflectivity" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        reflect: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def reflectedColor(self, ReturnStatus: MFnReflectShader.MStatus): 
        '''
        reflectedColor(self, ReturnStatus: MFnReflectShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "reflectedColor" attribute of a
        reflective shader node. This attribute represents the color of
        reflection produced by the shader.

        Returns: 
        ----- 
        The value of the "reflectedColor" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnReflectShader.MStatus
        	[out] -> return status


        '''
        pass

    def setReflectedColor(self, reflected_color: MColor): 
        '''
        setReflectedColor(self, reflected_color: MColor)

        Synopsis
        -----
        Sets the value of the "reflectedColor" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        reflected_color: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

class MFnSet:
    '''Function Set for Sets of Objects.
MFnSet is the function set that is used for manipulating sets of
objects. Sets in Maya are dependency nodes, so it is possible for
one set to contain others.
A set is a list of dependency nodes and dag nodes. Sets are
useful for keeping track of lists of objects for many purposes
such as selection or applying common rendering parameters. Sets
in Maya are also dependency nodes, so it is possible for one set
to contain others.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kSet.Reimplemented from MFnDependencyNode.Reimplemented in
        MFnCharacter.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnSet.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name : "MFnSet".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, members: MSelectionList,
                        restriction: MFnSet.Restriction,
                        ReturnStatus: MFnSet.MStatus): 
        '''
        create(self, members: MSelectionList,
                        restriction: MFnSet.Restriction,
                        ReturnStatus: MFnSet.MStatus) -> MObject

        Synopsis
        -----
        Creates a new set dependency node and puts it in the dependency
        graph.

        Returns: 
        ----- 
        A handle for the new set object

        Parameters:
        -----
        members: MSelectionList
        	[in] -> list of members for new set 

        restriction: MFnSet.Restriction
        	[in] -> restriction applied to members 

        ReturnStatus: MFnSet.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def getUnion(self, withSet: MObject,
                        result: MSelectionList): 
        '''
        getUnion(self, withSet: MObject,
                        result: MSelectionList)

        Synopsis
        -----
        This method calculates the union of two sets. The result will be
        the union of this set and the set passed into the method.

        Returns:
        -----
        None

        Parameters:
        -----
        withSet: MObject
        	[in] -> set to find union of with this set 

        result: MSelectionList
        	[out] -> storage for the result of the union operation


        '''
        pass

    @overload
    def getUnion(self, setList: MObjectArray,
                        result: MSelectionList): 
        '''
        getUnion(self, setList: MObjectArray,
                        result: MSelectionList)

        Synopsis
        -----
        This method calculates the union of a list of sets. The result
        will be the union of this set and the sets passed into the
        method.

        Returns:
        -----
        None

        Parameters:
        -----
        setList: MObjectArray
        	[in] -> sets to find union of with this set 

        result: MSelectionList
        	[out] -> storage for the result of the union operation


        '''
        pass

    @overload
    def getIntersection(self, withSet: MObject,
                        result: MSelectionList): 
        '''
        getIntersection(self, withSet: MObject,
                        result: MSelectionList)

        Synopsis
        -----
        This method calculates the intersection of two sets. The result
        will be the intersection of this set and the set passed into the
        method.

        Returns:
        -----
        None

        Parameters:
        -----
        withSet: MObject
        	[in] -> set to find intersection of with this set 

        result: MSelectionList
        	[out] -> storage for the result of the intersection operation


        '''
        pass

    @overload
    def getIntersection(self, setList: MObjectArray,
                        result: MSelectionList): 
        '''
        getIntersection(self, setList: MObjectArray,
                        result: MSelectionList)

        Synopsis
        -----
        This method calculates the intersection of a list of sets. The
        result will be the intersection of this set and the sets passed
        into the method.

        Returns:
        -----
        None

        Parameters:
        -----
        setList: MObjectArray
        	[in] -> sets to find intersection of with this set 

        result: MSelectionList
        	[out] -> storage for the result of the intersection operation


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Removes all elements from this set.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getMembers(self, members: MSelectionList,
                        flatten: bool): 
        '''
        getMembers(self, members: MSelectionList,
                        flatten: bool)

        Synopsis
        -----
        Get the members of this set as a selection list. This information
        is provided as a selection list so that all of the path
        information is retained for DAG nodes.It is possible to ask for
        the returned list to be flattened. This means that all sets that
        exist inside this set will be expanded into a list of their
        contents.Typically set members are updated using callbacks. When
        members are added/removed, the set members are marked as dirty.
        The set members are only updated on request such as invoking
        getMembers(). This method can be useful in scenarios where
        callbacks are temporarily suspended (eg. during file IO
        operations).

        Returns:
        -----
        None

        Parameters:
        -----
        members: MSelectionList
        	[out] -> storage for the returned list of members 

        flatten: bool
        	[in] -> whether to flatten the returned list.


        '''
        pass

    @overload
    def addMember(self, obj: MObject): 
        '''
        addMember(self, obj: MObject)

        Synopsis
        -----
        Add a new object (dependency node) to the set.

        Returns:
        -----
        None

        Parameters:
        -----
        obj: MObject
        	[in] -> the object to add


        '''
        pass

    @overload
    def addMember(self, obj: MDagPath,
                        component: MObject): 
        '''
        addMember(self, obj: MDagPath,
                        component: MObject)

        Synopsis
        -----
        Add a new object (DAG node) to the set.

        Returns:
        -----
        None

        Parameters:
        -----
        obj: MDagPath
        	[in] -> the object to add 

        component: MObject
        	[in] -> the selection component


        '''
        pass

    @overload
    def addMember(self, plug: MPlug): 
        '''
        addMember(self, plug: MPlug)

        Synopsis
        -----
        Add a new plug to the set.

        Returns:
        -----
        None

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug to add


        '''
        pass

    def addMembers(self, list: MSelectionList): 
        '''
        addMembers(self, list: MSelectionList)

        Synopsis
        -----
        Add a list of new objects to the set.

        Returns:
        -----
        None

        Parameters:
        -----
        list: MSelectionList
        	[in] -> the list of objects as a selection list


        '''
        pass

    @overload
    def removeMember(self, obj: MObject): 
        '''
        removeMember(self, obj: MObject)

        Synopsis
        -----
        Remove an object (dependency node) from the set.

        Returns:
        -----
        None

        Parameters:
        -----
        obj: MObject
        	[in] -> the object to remove


        '''
        pass

    @overload
    def removeMember(self, obj: MDagPath,
                        component: MObject): 
        '''
        removeMember(self, obj: MDagPath,
                        component: MObject)

        Synopsis
        -----
        Remove an object (DAG node) from the set.

        Returns:
        -----
        None

        Parameters:
        -----
        obj: MDagPath
        	[in] -> the object to remove 

        component: MObject
        	[in] -> the selection component


        '''
        pass

    @overload
    def removeMember(self, plug: MPlug): 
        '''
        removeMember(self, plug: MPlug)

        Synopsis
        -----
        Remove an plug from the set.

        Returns:
        -----
        None

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug to remove


        '''
        pass

    def removeMembers(self, list: MSelectionList): 
        '''
        removeMembers(self, list: MSelectionList)

        Synopsis
        -----
        Remove items of the selection list from the set.

        Returns:
        -----
        None

        Parameters:
        -----
        list: MSelectionList
        	[in] -> the selection list of items to remove


        '''
        pass

    @overload
    def isMember(self, object: MObject,
                        ReturnStatus: MFnSet.MStatus): 
        '''
        isMember(self, object: MObject,
                        ReturnStatus: MFnSet.MStatus) -> bool

        Synopsis
        -----
        Returns true if the given object (dependency node) is a member of
        this set.

        Returns: 
        ----- 
        A boolean value indicating whether the object is a member

        Parameters:
        -----
        object: MObject
        	[in] -> object to test for membership 

        ReturnStatus: MFnSet.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def isMember(self, object: MDagPath,
                        component: MObject,
                        ReturnStatus: MFnSet.MStatus): 
        '''
        isMember(self, object: MDagPath,
                        component: MObject,
                        ReturnStatus: MFnSet.MStatus) -> bool

        Synopsis
        -----
        Returns true if the given object (DAG node) is a member of this
        set.

        Returns: 
        ----- 
        A boolean value indicating whether the object is a member

        Parameters:
        -----
        object: MDagPath
        	[in] -> object to test for membership 

        component: MObject
        	[in] -> selection component (optional) 

        ReturnStatus: MFnSet.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def isMember(self, plug: MPlug,
                        ReturnStatus: MFnSet.MStatus): 
        '''
        isMember(self, plug: MPlug,
                        ReturnStatus: MFnSet.MStatus) -> bool

        Synopsis
        -----
        Returns true if the given plug is a member of this set.

        Returns: 
        ----- 
        A boolean value indicating whether the plug is a member

        Parameters:
        -----
        plug: MPlug
        	[in] -> plug to test for membership 

        ReturnStatus: MFnSet.MStatus
        	[out] -> return status


        '''
        pass

    def intersectsWith(self, otherSet: MObject,
                        ReturnStatus: MFnSet.MStatus): 
        '''
        intersectsWith(self, otherSet: MObject,
                        ReturnStatus: MFnSet.MStatus) -> bool

        Synopsis
        -----
        Returns true if this set intersects with the given set. An
        intersection occurs if there are any common members between the
        two sets.

        Returns: 
        ----- 
        Boolean value indicating whether there was an intersection

        Parameters:
        -----
        otherSet: MObject
        	[in] -> set to test for intersection with 

        ReturnStatus: MFnSet.MStatus
        	[out] -> return status


        '''
        pass

    def hasRestrictions(self, ReturnStatus: MFnSet.MStatus): 
        '''
        hasRestrictions(self, ReturnStatus: MFnSet.MStatus) -> bool

        Synopsis
        -----
        Returns true if this function set has restrictions on the type of
        objects that it may contain.

        Returns: 
        ----- 
        A boolean value indicating whether this set has restriction

        Parameters:
        -----
        ReturnStatus: MFnSet.MStatus
        	[out] -> return status


        '''
        pass

    def restriction(self, ReturnStatus: MFnSet.MStatus): 
        '''
        restriction(self, ReturnStatus: MFnSet.MStatus) -> MFnSet.MFnSet

        Synopsis
        -----
        Returns the type of membership restriction that this set has.

        Returns: 
        ----- 
        The type of restriction

        Parameters:
        -----
        ReturnStatus: MFnSet.MStatus
        	[out] -> return status


        '''
        pass

    def annotation(self, ReturnStatus: MFnSet.MStatus): 
        '''
        annotation(self, ReturnStatus: MFnSet.MStatus) -> MString

        Synopsis
        -----
        Returns the annotation string for this set. This allows a
        description of the set to be stored with it.

        Returns: 
        ----- 
        The annotation string

        Parameters:
        -----
        ReturnStatus: MFnSet.MStatus
        	[out] -> return status


        '''
        pass

    def setAnnotation(self, annotation: MString): 
        '''
        setAnnotation(self, annotation: MString)

        Synopsis
        -----
        Sets the annotation string for this set. This allows a
        description of the set to be stored with it.

        Returns:
        -----
        None

        Parameters:
        -----
        annotation: MString
        	[in] -> new annotation string


        '''
        pass

    def getMemberPaths(self, members: MDagPathArray,
                        shading: bool): 
        '''
        getMemberPaths(self, members: MDagPathArray,
                        shading: bool)

        Synopsis
        -----
        Introduced in 2023.0 Get the members of this set as an array of
        dagPaths.This will usually return the same dagPaths as will be
        contained in the getMembers method. If the shading flag is set to
        true, the list will consist only of dagPaths that are affected by
        this set for the purposes of material assignments.

        Returns:
        -----
        None

        Parameters:
        -----
        members: MDagPathArray
        	[out] -> storage for the returned list of members 

        shading: bool
        	[in] -> whether the list should only contain members of this set used for shading purposes.


        '''
        pass

class Restriction:
    '''Set membership restrictions. 
    Non-functional class.  Values for this enum:
    kNone
    kVerticesOnly
    kEdgesOnly
    kFacetsOnly
    kEditPointsOnly
    kRenderableOnly
    '''

    def __init__(self):
        pass

    def kNone(self):
        '''This is an enum of Restriction.
        - Description:  
        - Value: 0
        '''
        pass

    def kVerticesOnly(self):
        '''This is an enum of Restriction.
        - Description:  
        - Value: 1
        '''
        pass

    def kEdgesOnly(self):
        '''This is an enum of Restriction.
        - Description:  
        - Value: 2
        '''
        pass

    def kFacetsOnly(self):
        '''This is an enum of Restriction.
        - Description:  
        - Value: 3
        '''
        pass

    def kEditPointsOnly(self):
        '''This is an enum of Restriction.
        - Description:  
        - Value: 4
        '''
        pass

    def kRenderableOnly(self):
        '''This is an enum of Restriction.
        - Description:  
        - Value: 5
        '''
        pass

class MFnSingleIndexedComponent:
    '''Single indexed component function set.
This function set allows you to create, edit, and query single
indexed components. Single indexed components store 1 dimensional
index values.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kSingleIndexedComponent.Reimplemented from MFnComponent.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnSingleIndexedComponent.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnSingleIndexedComponent".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, compType: MFn.MFn,
                        ReturnStatus: MFnSingleIndexedComponent.MStatus): 
        '''
        create(self, compType: MFn.MFn,
                        ReturnStatus: MFnSingleIndexedComponent.MStatus) -> MObject

        Synopsis
        -----
        Create a single indexed component of the given type. Allowable
        types areMFn::kCurveCVComponent MFn::kCurveEPComponent
        MFn::kCurveKnotComponent MFn::kMeshEdgeComponent
        MFn::kMeshPolygonComponent MFn::kMeshVertComponent
        MFn::kMeshMapComponent

        Returns: 
        ----- 
        The new component

        Parameters:
        -----
        compType: MFn.MFn
        	[in] -> the type of component to create 

        ReturnStatus: MFnSingleIndexedComponent.MStatus
        	[out] -> status code


        '''
        pass

    def addElement(self, element: int): 
        '''
        addElement(self, element: int)

        Synopsis
        -----
        Add the specified element to the component.

        Returns:
        -----
        None

        Parameters:
        -----
        element: int
        	[in] -> the element index to be added


        '''
        pass

    def addElements(self, elements: MIntArray): 
        '''
        addElements(self, elements: MIntArray)

        Synopsis
        -----
        Add the specified elements to the component.

        Returns:
        -----
        None

        Parameters:
        -----
        elements: MIntArray
        	[in] -> the array of element indices to be added


        '''
        pass

    def elementMax(self, ReturnStatus: MFnSingleIndexedComponent.MStatus): 
        '''
        elementMax(self, ReturnStatus: MFnSingleIndexedComponent.MStatus) -> int

        Synopsis
        -----
        Returns the biggest element, plus 1, from the component.

        Returns: 
        ----- 
        The biggest index plus 1 of the specified component

        Parameters:
        -----
        ReturnStatus: MFnSingleIndexedComponent.MStatus
        	[out] -> status code


        '''
        pass

    def element(self, index: int,
                        ReturnStatus: MFnSingleIndexedComponent.MStatus): 
        '''
        element(self, index: int,
                        ReturnStatus: MFnSingleIndexedComponent.MStatus) -> int

        Synopsis
        -----
        Returns the specified element from the component.

        Returns: 
        ----- 
        The index of the specified component

        Parameters:
        -----
        index: int
        	[in] -> the index of the element to retrieve 

        ReturnStatus: MFnSingleIndexedComponent.MStatus
        	[out] -> status code


        '''
        pass

    def getElements(self, elements: MIntArray): 
        '''
        getElements(self, elements: MIntArray)

        Synopsis
        -----
        Get all of the element indices from the component.

        Returns:
        -----
        None

        Parameters:
        -----
        elements: MIntArray
        	[out] -> storage for the array of indices


        '''
        pass

    def setCompleteData(self, numElements: int): 
        '''
        setCompleteData(self, numElements: int)

        Synopsis
        -----
        Marks the component as complete (meaning all items are selected)
        and uses the argument to identify the total number of elements
        selected. If the component should contain N element indices, then
        the range would be [0,N-1].Also sets the complete state of the
        component to 'true' (i.e. setComplete(true)).

        Returns:
        -----
        None

        Parameters:
        -----
        numElements: int
        	[in] -> the maximum number of elements in the component


        '''
        pass

    def getCompleteData(self, numElements: int): 
        '''
        getCompleteData(self, numElements: int)

        Synopsis
        -----
        Returns the number of elements for the complete component. A
        complete component means that all elements are selected.

        Returns:
        -----
        None

        Parameters:
        -----
        numElements: int
        	[out] -> storage for the maximum number of elements


        '''
        pass

class MFnSphereData:
    '''Sphere function set for dependency node data .
MFnSphereData allows the creation and manipulation of sphere (represented as
MObjects) data objects for use in the dependency graph.
If a user written dependency node either accepts or produces
MObjects containing spheres, then this class is used to extract
or create the data that comes from or goes to other dependency
graph nodes. The
MDataHandle::type method will return kSphere when data of this type is present. To
access it, the
MDataHandle::data method is used to get an
MObject for the data and this should then be used to initialize an
instance of
MFnNurbsSurface.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kSphereData.Reimplemented from MFnData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnSphereData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnSphereData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, rad: double,
                        ReturnStatus: MFnSphereData.MStatus): 
        '''
        create(self, rad: double,
                        ReturnStatus: MFnSphereData.MStatus) -> MObject

        Synopsis
        -----
        Create a new sphere of the given radius, and attach it to this
        instance as an MObject.

        Returns: 
        ----- 
        The new MObject

        Parameters:
        -----
        rad: double
        	[in] -> the radius of the new sphere 

        ReturnStatus: MFnSphereData.MStatus
        	[out] -> kSuccess


        '''
        pass

    def radius(self, ReturnStatus: MFnSphereData.MStatus): 
        '''
        radius(self, ReturnStatus: MFnSphereData.MStatus) -> double

        Synopsis
        -----
        Return the radius of the sphere attached to this instance.

        Returns: 
        ----- 
        The radius

        Parameters:
        -----
        ReturnStatus: MFnSphereData.MStatus
        	[out] -> kSuccess if the instance has a sphere attached to it, and kFailure otherwise.


        '''
        pass

    def setRadius(self, rad: double): 
        '''
        setRadius(self, rad: double)

        Synopsis
        -----
        Change the radius of the sphere attached to this instance
        instance as an MObject.

        Returns:
        -----
        None

        Parameters:
        -----
        rad: double
        	[in] -> the new radius


        '''
        pass

class MFnSpotLight:
    '''Manage Spot Light dependency Nodes.
MFnSpotLight facilitates creation and manipulation of dependency graph nodes
representing spotlights.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kSpotLight.Reimplemented from MFnNonExtendedLight.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnSpotLight.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnSpotLight".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def create(self, UIvisible: bool,
                        ReturnStatus: MFnSpotLight.MStatus): 
        '''
        create(self, UIvisible: bool,
                        ReturnStatus: MFnSpotLight.MStatus) -> MObject

        Synopsis
        -----
        Creates a new spotlight dependency graph node and adds it to the
        dependency graph. If the UIvisible parameter is true, the new
        node will be connected to the light classification node (which
        allows the UI to recognize the node as a light) and added to the
        default light list. If UIvisible is false, the node will be
        created in isolation.The light node is added to the current
        model, under a new transformation.

        Returns: 
        ----- 
        MObject representing the new dependency node.

        Parameters:
        -----
        UIvisible: bool
        	[in] -> determines whether or not to connect the new node to the light classification node and add it to the default light list. 

        ReturnStatus: MFnSpotLight.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def create(self, parent: MObject,
                        UIvisible: bool,
                        wantTransform: bool,
                        ReturnStatus: MFnSpotLight.MStatus): 
        '''
        create(self, parent: MObject,
                        UIvisible: bool,
                        wantTransform: bool,
                        ReturnStatus: MFnSpotLight.MStatus) -> MObject

        Synopsis
        -----
        Creates a new spotlight dependency graph node and adds it to the
        dependency graph. If the UIvisible parameter is true, the new
        node will be connected to the light classification node (which
        allows the UI to recognize the node as a light) and added to the
        default light list. If UIvisible is false, the node will be
        created in isolation.If wantTransform parameter is false ( which
        is by default ), the new shape node is created under the
        specified parent and no transform node is created. If the
        specified parent is null, then no shape node will be created.The
        light node is added to the current model, under the specified
        parent.

        Returns: 
        ----- 
        MObject representing the new dependency node.

        Parameters:
        -----
        parent: MObject
        	[in] -> the node under which the new light and its transform will be added. 

        UIvisible: bool
        	[in] -> determines whether or not to connect the new node to the light classification node and add it to the default light list. 

        wantTransform: bool
        	[in] -> Boolean to indicate whether the transform node is needed or not, which is 'false' by default. 

        ReturnStatus: MFnSpotLight.MStatus
        	[out] -> return status


        '''
        pass

    def coneAngle(self, ReturnStatus: MFnSpotLight.MStatus): 
        '''
        coneAngle(self, ReturnStatus: MFnSpotLight.MStatus) -> double

        Synopsis
        -----
        Retrieves the value of the "coneAngle" attribute of a light node.
        This attribute represents the angle that the spotlight cone makes
        with the spotlight direction vector.

        Returns: 
        ----- 
        The value of the "coneAngle" attribute of the light node.

        Parameters:
        -----
        ReturnStatus: MFnSpotLight.MStatus
        	[out] -> return status


        '''
        pass

    def setConeAngle(self, cone_angle: double): 
        '''
        setConeAngle(self, cone_angle: double)

        Synopsis
        -----
        Sets the value of the "coneAngle" attribute of a light node.

        Returns:
        -----
        None

        Parameters:
        -----
        cone_angle: double
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def penumbraAngle(self, ReturnStatus: MFnSpotLight.MStatus): 
        '''
        penumbraAngle(self, ReturnStatus: MFnSpotLight.MStatus) -> double

        Synopsis
        -----
        Retrieves the value of the "penumbraAngle" attribute of a light
        node. This attribute represents the extra angle beyond the cone
        angle used in soft shadow computations.

        Returns: 
        ----- 
        The value of the "penumbraAngle" attribute of the light node.

        Parameters:
        -----
        ReturnStatus: MFnSpotLight.MStatus
        	[out] -> return status


        '''
        pass

    def setPenumbraAngle(self, penumbra_angle: double): 
        '''
        setPenumbraAngle(self, penumbra_angle: double)

        Synopsis
        -----
        Sets the value of the "penumbraAngle" attribute of a light node.

        Returns:
        -----
        None

        Parameters:
        -----
        penumbra_angle: double
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def dropOff(self, ReturnStatus: MFnSpotLight.MStatus): 
        '''
        dropOff(self, ReturnStatus: MFnSpotLight.MStatus) -> double

        Synopsis
        -----
        Retrieves the value of the "dropOff" attribute of a light node.
        This attribute represents the degree to which intensity of the
        light decreases with increasing angular distance from the light
        direction vector. Higher values represent more rapid intensity
        dropoff.

        Returns: 
        ----- 
        The value of the "dropOff" attribute of the light node.

        Parameters:
        -----
        ReturnStatus: MFnSpotLight.MStatus
        	[out] -> return status


        '''
        pass

    def setDropOff(self, drop_off: double): 
        '''
        setDropOff(self, drop_off: double)

        Synopsis
        -----
        Sets the value of the "dropOff" attribute of a light node.

        Returns:
        -----
        None

        Parameters:
        -----
        drop_off: double
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def barnDoors(self, ReturnStatus: MFnSpotLight.MStatus): 
        '''
        barnDoors(self, ReturnStatus: MFnSpotLight.MStatus) -> bool

        Synopsis
        -----
        Retrieves the value of the "barnDoors" attribute of a light node.
        This attribute determines whether or not the light uses barn
        doors.

        Returns: 
        ----- 
        The value of the "barnDoors" attribute of the light node.

        Parameters:
        -----
        ReturnStatus: MFnSpotLight.MStatus
        	[out] -> return status


        '''
        pass

    def setBarnDoors(self, barn_doors: bool): 
        '''
        setBarnDoors(self, barn_doors: bool)

        Synopsis
        -----
        Sets the value of the "barnDoors" attribute of a light node.

        Returns:
        -----
        None

        Parameters:
        -----
        barn_doors: bool
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def barnDoorAngle(self, which_door: MFnSpotLight.MBarnDoor,
                        ReturnStatus: MFnSpotLight.MStatus): 
        '''
        barnDoorAngle(self, which_door: MFnSpotLight.MBarnDoor,
                        ReturnStatus: MFnSpotLight.MStatus) -> double

        Synopsis
        -----
        Retrieves the value of the barn door angle for the specified barn
        door. The barn door angles are represented by the "leftBarnDoor",
        "rightBarnDoor", "topBarnDoor", and "bottomBarnDoor" attributes.
        This function retrieves the value of the appropriate attribute.

        Returns: 
        ----- 
        The value of the appropriate barn door angle attribute of the
        light node.

        Parameters:
        -----
        which_door: MFnSpotLight.MBarnDoor
        	[in] -> which barn door to return. 

        ReturnStatus: MFnSpotLight.MStatus
        	[out] -> return status


        '''
        pass

    def setBarnDoorAngle(self, which_door: MFnSpotLight.MBarnDoor,
                        barn_door_angle: double): 
        '''
        setBarnDoorAngle(self, which_door: MFnSpotLight.MBarnDoor,
                        barn_door_angle: double)

        Synopsis
        -----
        Sets the value of the appropriate barn door angle attribute of a
        light node.

        Returns:
        -----
        None

        Parameters:
        -----
        which_door: MFnSpotLight.MBarnDoor
        	[in] -> Which barn door to return. 

        barn_door_angle: double
        	[in] -> New value for the barn door.


        '''
        pass

    def useDecayRegions(self, ReturnStatus: MFnSpotLight.MStatus): 
        '''
        useDecayRegions(self, ReturnStatus: MFnSpotLight.MStatus) -> bool

        Synopsis
        -----
        Retrieves the value of the "useDecayRegions" attribute of a light
        node. This attribute determines whether or not the light uses
        decay regions.

        Returns: 
        ----- 
        The value of the "useDecayRegions" attribute of the light node.

        Parameters:
        -----
        ReturnStatus: MFnSpotLight.MStatus
        	[out] -> return status


        '''
        pass

    def setUseDecayRegions(self, use_decay_regions: bool): 
        '''
        setUseDecayRegions(self, use_decay_regions: bool)

        Synopsis
        -----
        Sets the value of the "useDecayRegions" attribute of a light
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        use_decay_regions: bool
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def startDistance(self, which_region: MFnSpotLight.MDecayRegion,
                        ReturnStatus: MFnSpotLight.MStatus): 
        '''
        startDistance(self, which_region: MFnSpotLight.MDecayRegion,
                        ReturnStatus: MFnSpotLight.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the start distance for the specified decay
        regions. The start distances for the spotlight's 3 decay regions
        are represented by the "startDistance1", "startDistance2", and
        "startDistance3" attributes. This function retrieves the value of
        the appropriate attribute.

        Returns: 
        ----- 
        The value of the appropriate startDistance attribute of the light
        node.

        Parameters:
        -----
        which_region: MFnSpotLight.MDecayRegion
        	[in] -> the decay region whose startDistance attribute is to be retrieved. 

        ReturnStatus: MFnSpotLight.MStatus
        	[out] -> return status


        '''
        pass

    def setStartDistance(self, which_region: MFnSpotLight.MDecayRegion,
                        start_distance: float): 
        '''
        setStartDistance(self, which_region: MFnSpotLight.MDecayRegion,
                        start_distance: float)

        Synopsis
        -----
        Sets the value of the appropriate decay region start distance
        attribute of a light node.

        Returns:
        -----
        None

        Parameters:
        -----
        which_region: MFnSpotLight.MDecayRegion
        	[in] -> the decay region whose start distance is to be set. 

        start_distance: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def endDistance(self, which_region: MFnSpotLight.MDecayRegion,
                        ReturnStatus: MFnSpotLight.MStatus): 
        '''
        endDistance(self, which_region: MFnSpotLight.MDecayRegion,
                        ReturnStatus: MFnSpotLight.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the end distance for the specified decay
        regions. The end distances for the spotlight's 3 decay regions
        are represented by the "endDistance1", "endDistance2", and
        "endDistance3" attributes. This function retrieves the value of
        the appropriate attribute.

        Returns: 
        ----- 
        The value of the appropriate endDistance attribute of the light
        node.

        Parameters:
        -----
        which_region: MFnSpotLight.MDecayRegion
        	[in] -> the decay region whose endDistance attribute is to be retrieved. 

        ReturnStatus: MFnSpotLight.MStatus
        	[out] -> return status


        '''
        pass

    def setEndDistance(self, which_region: MFnSpotLight.MDecayRegion,
                        end_distance: float): 
        '''
        setEndDistance(self, which_region: MFnSpotLight.MDecayRegion,
                        end_distance: float)

        Synopsis
        -----
        Sets the value of the appropriate decay region end distance
        attribute of a light node.

        Returns:
        -----
        None

        Parameters:
        -----
        which_region: MFnSpotLight.MDecayRegion
        	[in] -> the decay region whose end distance is to be set. 

        end_distance: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

class MBarnDoor:
    '''Available doors for barnDoor-related methods. 
    Non-functional class.  Values for this enum:
    kLeft
    kRight
    kTop
    kBottom
    '''

    def __init__(self):
        pass

    def kLeft(self):
        '''This is an enum of MBarnDoor.
        - Description:  
        - Value: 0
        '''
        pass

    def kRight(self):
        '''This is an enum of MBarnDoor.
        - Description:  
        - Value: 1
        '''
        pass

    def kTop(self):
        '''This is an enum of MBarnDoor.
        - Description:  
        - Value: 2
        '''
        pass

    def kBottom(self):
        '''This is an enum of MBarnDoor.
        - Description:  
        - Value: 3
        '''
        pass

class MDecayRegion:
    '''Decay regions. 
    Non-functional class.  Values for this enum:
    kFirst
    kSecond
    kThird
    '''

    def __init__(self):
        pass

    def kFirst(self):
        '''This is an enum of MDecayRegion.
        - Description:  
        - Value: 0
        '''
        pass

    def kSecond(self):
        '''This is an enum of MDecayRegion.
        - Description:  
        - Value: 1
        '''
        pass

    def kThird(self):
        '''This is an enum of MDecayRegion.
        - Description:  
        - Value: 2
        '''
        pass

class MFnStandardSurfaceShader:
    '''Manage Standard Surface Shaders.
MFnStandardSurfaceShader facilitates the creation and manipulation of dependency graph
nodes representing standard surface shaders.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kStandardSurface.Reimplemented from MFnDependencyNode.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnStandardSurfaceShader.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnStandardSurfaceShader".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, UIvisible: bool,
                        ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        create(self, UIvisible: bool,
                        ReturnStatus: MFnStandardSurfaceShader.MStatus) -> MObject

        Synopsis
        -----
        Creates a new standard surface shader dependency graph node and
        adds it to the dependency graph. If the UIvisible parameter is
        true, the new node will be connected to the shader classification
        node (which allows the UI to recognize the node as a shader). If
        UIvisible is false, the node will be created in isolation.

        Returns: 
        ----- 
        MObject representing the new dependency node.

        Parameters:
        -----
        UIvisible: bool
        	[in] -> determines whether or not the new node will be connected to the shader classification node. 

        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def base(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        base(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "base" attribute of a standard surface
        shader node.

        Returns: 
        ----- 
        The value of the "base" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setBase(self, base: float): 
        '''
        setBase(self, base: float)

        Synopsis
        -----
        Sets the value of the "base" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        base: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def baseColor(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        baseColor(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "baseColor" attribute of a standard
        surface shader node.

        Returns: 
        ----- 
        The value of the "baseColor" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setBaseColor(self, base_color: MColor): 
        '''
        setBaseColor(self, base_color: MColor)

        Synopsis
        -----
        Sets the value of the "baseColor" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        base_color: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def diffuseRoughness(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        diffuseRoughness(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "diffuseRoughness" attribute of a
        standard surface shader node.

        Returns: 
        ----- 
        The value of the "diffuseRoughness" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setDiffuseRoughness(self, diffuse_roughness: float): 
        '''
        setDiffuseRoughness(self, diffuse_roughness: float)

        Synopsis
        -----
        Sets the value of the "diffuseRoughness" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        diffuse_roughness: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def metalness(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        metalness(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "metalness" attribute of a standard
        surface shader node.

        Returns: 
        ----- 
        The value of the "metalness" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setMetalness(self, metalness: float): 
        '''
        setMetalness(self, metalness: float)

        Synopsis
        -----
        Sets the value of the "metalness" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        metalness: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def specular(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        specular(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "specular" attribute of a standard
        surface shader node.

        Returns: 
        ----- 
        The value of the "specular" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setSpecular(self, specular: float): 
        '''
        setSpecular(self, specular: float)

        Synopsis
        -----
        Sets the value of the "specular" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        specular: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def specularColor(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        specularColor(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "specularColor" attribute of a
        standard surface shader node.

        Returns: 
        ----- 
        The value of the "specularColor" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setSpecularColor(self, specular_color: MColor): 
        '''
        setSpecularColor(self, specular_color: MColor)

        Synopsis
        -----
        Sets the value of the "specularColor" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        specular_color: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def specularRoughness(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        specularRoughness(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "specularRoughness" attribute of a
        standard surface shader node.

        Returns: 
        ----- 
        The value of the "specularRoughness" attribute of the shader
        node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setSpecularRoughness(self, specular_roughness: float): 
        '''
        setSpecularRoughness(self, specular_roughness: float)

        Synopsis
        -----
        Sets the value of the "specularRoughness" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        specular_roughness: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def specularIOR(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        specularIOR(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "specularIOR" attribute of a standard
        surface shader node.

        Returns: 
        ----- 
        The value of the "specularIOR" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setSpecularIOR(self, specular_i_o_r: float): 
        '''
        setSpecularIOR(self, specular_i_o_r: float)

        Synopsis
        -----
        Sets the value of the "specularIOR" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        specular_i_o_r: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def specularAnisotropy(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        specularAnisotropy(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "specularAnisotropy" attribute of a
        standard surface shader node.

        Returns: 
        ----- 
        The value of the "specularAnisotropy" attribute of the shader
        node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setSpecularAnisotropy(self, specular_anisotropy: float): 
        '''
        setSpecularAnisotropy(self, specular_anisotropy: float)

        Synopsis
        -----
        Sets the value of the "specularAnisotropy" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        specular_anisotropy: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def specularRotation(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        specularRotation(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "specularRotation" attribute of a
        standard surface shader node.

        Returns: 
        ----- 
        The value of the "specularRotation" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setSpecularRotation(self, specular_rotation: float): 
        '''
        setSpecularRotation(self, specular_rotation: float)

        Synopsis
        -----
        Sets the value of the "specularRotation" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        specular_rotation: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def transmission(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        transmission(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "transmission" attribute of a standard
        surface shader node.

        Returns: 
        ----- 
        The value of the "transmission" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setTransmission(self, transmission: float): 
        '''
        setTransmission(self, transmission: float)

        Synopsis
        -----
        Sets the value of the "transmission" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        transmission: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def transmissionColor(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        transmissionColor(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "transmissionColor" attribute of a
        standard surface shader node.

        Returns: 
        ----- 
        The value of the "transmissionColor" attribute of the shader
        node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setTransmissionColor(self, transmission_color: MColor): 
        '''
        setTransmissionColor(self, transmission_color: MColor)

        Synopsis
        -----
        Sets the value of the "transmissionColor" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        transmission_color: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def transmissionDepth(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        transmissionDepth(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "transmissionDepth" attribute of a
        standard surface shader node.

        Returns: 
        ----- 
        The value of the "transmissionDepth" attribute of the shader
        node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setTransmissionDepth(self, transmission_depth: float): 
        '''
        setTransmissionDepth(self, transmission_depth: float)

        Synopsis
        -----
        Sets the value of the "transmissionDepth" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        transmission_depth: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def transmissionScatter(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        transmissionScatter(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "transmissionScatter" attribute of a
        standard surface shader node.

        Returns: 
        ----- 
        The value of the "transmissionScatter" attribute of the shader
        node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setTransmissionScatter(self, transmission_scatter: MColor): 
        '''
        setTransmissionScatter(self, transmission_scatter: MColor)

        Synopsis
        -----
        Sets the value of the "transmissionScatter" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        transmission_scatter: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def transmissionScatterAnisotropy(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        transmissionScatterAnisotropy(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "transmissionScatterAnisotropy"
        attribute of a standard surface shader node.

        Returns: 
        ----- 
        The value of the "transmissionScatterAnisotropy" attribute of the
        shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setTransmissionScatterAnisotropy(self, transmission_scatter_anisotropy: float): 
        '''
        setTransmissionScatterAnisotropy(self, transmission_scatter_anisotropy: float)

        Synopsis
        -----
        Sets the value of the "transmissionScatterAnisotropy" attribute
        of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        transmission_scatter_anisotropy: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def transmissionDispersion(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        transmissionDispersion(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "transmissionDispersion" attribute of
        a standard surface shader node.

        Returns: 
        ----- 
        The value of the "transmissionDispersion" attribute of the shader
        node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setTransmissionDispersion(self, transmission_dispersion: float): 
        '''
        setTransmissionDispersion(self, transmission_dispersion: float)

        Synopsis
        -----
        Sets the value of the "transmissionDispersion" attribute of a
        shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        transmission_dispersion: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def transmissionExtraRoughness(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        transmissionExtraRoughness(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "transmissionExtraRoughness" attribute
        of a standard surface shader node.

        Returns: 
        ----- 
        The value of the "transmissionExtraRoughness" attribute of the
        shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setTransmissionExtraRoughness(self, transmission_extra_roughness: float): 
        '''
        setTransmissionExtraRoughness(self, transmission_extra_roughness: float)

        Synopsis
        -----
        Sets the value of the "transmissionExtraRoughness" attribute of a
        shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        transmission_extra_roughness: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def subsurface(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        subsurface(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "subsurface" attribute of a standard
        surface shader node.

        Returns: 
        ----- 
        The value of the "subsurface" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setSubsurface(self, subsurface: float): 
        '''
        setSubsurface(self, subsurface: float)

        Synopsis
        -----
        Sets the value of the "subsurface" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        subsurface: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def subsurfaceColor(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        subsurfaceColor(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "subsurfaceColor" attribute of a
        standard surface shader node.

        Returns: 
        ----- 
        The value of the "subsurfaceColor" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setSubsurfaceColor(self, subsurface_color: MColor): 
        '''
        setSubsurfaceColor(self, subsurface_color: MColor)

        Synopsis
        -----
        Sets the value of the "subsurfaceColor" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        subsurface_color: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def subsurfaceRadius(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        subsurfaceRadius(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "subsurfaceRadius" attribute of a
        standard surface shader node.

        Returns: 
        ----- 
        The value of the "subsurfaceRadius" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setSubsurfaceRadius(self, subsurface_radius: MColor): 
        '''
        setSubsurfaceRadius(self, subsurface_radius: MColor)

        Synopsis
        -----
        Sets the value of the "subsurfaceRadius" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        subsurface_radius: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def subsurfaceScale(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        subsurfaceScale(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "subsurfaceScale" attribute of a
        standard surface shader node.

        Returns: 
        ----- 
        The value of the "subsurfaceScale" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setSubsurfaceScale(self, subsurface_scale: float): 
        '''
        setSubsurfaceScale(self, subsurface_scale: float)

        Synopsis
        -----
        Sets the value of the "subsurfaceScale" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        subsurface_scale: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def subsurfaceAnisotropy(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        subsurfaceAnisotropy(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "subsurfaceAnisotropy" attribute of a
        standard surface shader node.

        Returns: 
        ----- 
        The value of the "subsurfaceAnisotropy" attribute of the shader
        node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setSubsurfaceAnisotropy(self, subsurface_anisotropy: float): 
        '''
        setSubsurfaceAnisotropy(self, subsurface_anisotropy: float)

        Synopsis
        -----
        Sets the value of the "subsurfaceAnisotropy" attribute of a
        shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        subsurface_anisotropy: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def coat(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        coat(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "coat" attribute of a standard surface
        shader node.

        Returns: 
        ----- 
        The value of the "coat" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setCoat(self, coat: float): 
        '''
        setCoat(self, coat: float)

        Synopsis
        -----
        Sets the value of the "coat" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        coat: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def coatColor(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        coatColor(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "coatColor" attribute of a standard
        surface shader node.

        Returns: 
        ----- 
        The value of the "coatColor" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setCoatColor(self, coat_color: MColor): 
        '''
        setCoatColor(self, coat_color: MColor)

        Synopsis
        -----
        Sets the value of the "coatColor" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        coat_color: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def coatRoughness(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        coatRoughness(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "coatRoughness" attribute of a
        standard surface shader node.

        Returns: 
        ----- 
        The value of the "coatRoughness" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setCoatRoughness(self, coat_roughness: float): 
        '''
        setCoatRoughness(self, coat_roughness: float)

        Synopsis
        -----
        Sets the value of the "coatRoughness" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        coat_roughness: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def coatIOR(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        coatIOR(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "coatIOR" attribute of a standard
        surface shader node.

        Returns: 
        ----- 
        The value of the "coatIOR" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setCoatIOR(self, coat_i_o_r: float): 
        '''
        setCoatIOR(self, coat_i_o_r: float)

        Synopsis
        -----
        Sets the value of the "coatIOR" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        coat_i_o_r: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def coatAnisotropy(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        coatAnisotropy(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "coatAnisotropy" attribute of a
        standard surface shader node.

        Returns: 
        ----- 
        The value of the "coatAnisotropy" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setCoatAnisotropy(self, coat_anisotropy: float): 
        '''
        setCoatAnisotropy(self, coat_anisotropy: float)

        Synopsis
        -----
        Sets the value of the "coatAnisotropy" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        coat_anisotropy: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def coatRotation(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        coatRotation(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "coatRotation" attribute of a standard
        surface shader node.

        Returns: 
        ----- 
        The value of the "coatRotation" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setCoatRotation(self, coat_rotation: float): 
        '''
        setCoatRotation(self, coat_rotation: float)

        Synopsis
        -----
        Sets the value of the "coatRotation" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        coat_rotation: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def coatAffectColor(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        coatAffectColor(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "coatAffectColor" attribute of a
        standard surface shader node.

        Returns: 
        ----- 
        The value of the "coatAffectColor" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setCoatAffectColor(self, coat_affect_color: float): 
        '''
        setCoatAffectColor(self, coat_affect_color: float)

        Synopsis
        -----
        Sets the value of the "coatAffectColor" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        coat_affect_color: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def coatAffectRoughness(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        coatAffectRoughness(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "coatAffectRoughness" attribute of a
        standard surface shader node.

        Returns: 
        ----- 
        The value of the "coatAffectRoughness" attribute of the shader
        node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setCoatAffectRoughness(self, coat_affect_roughness: float): 
        '''
        setCoatAffectRoughness(self, coat_affect_roughness: float)

        Synopsis
        -----
        Sets the value of the "coatAffectRoughness" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        coat_affect_roughness: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def sheen(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        sheen(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "sheen" attribute of a standard
        surface shader node.

        Returns: 
        ----- 
        The value of the "sheen" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setSheen(self, sheen: float): 
        '''
        setSheen(self, sheen: float)

        Synopsis
        -----
        Sets the value of the "sheen" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        sheen: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def sheenColor(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        sheenColor(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "sheenColor" attribute of a standard
        surface shader node.

        Returns: 
        ----- 
        The value of the "sheenColor" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setSheenColor(self, sheen_color: MColor): 
        '''
        setSheenColor(self, sheen_color: MColor)

        Synopsis
        -----
        Sets the value of the "sheenColor" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        sheen_color: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def sheenRoughness(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        sheenRoughness(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "sheenRoughness" attribute of a
        standard surface shader node.

        Returns: 
        ----- 
        The value of the "sheenRoughness" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setSheenRoughness(self, sheen_roughness: float): 
        '''
        setSheenRoughness(self, sheen_roughness: float)

        Synopsis
        -----
        Sets the value of the "sheenRoughness" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        sheen_roughness: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def emission(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        emission(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "emission" attribute of a standard
        surface shader node.

        Returns: 
        ----- 
        The value of the "emission" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setEmission(self, emission: float): 
        '''
        setEmission(self, emission: float)

        Synopsis
        -----
        Sets the value of the "emission" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        emission: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def emissionColor(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        emissionColor(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "emissionColor" attribute of a
        standard surface shader node.

        Returns: 
        ----- 
        The value of the "emissionColor" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setEmissionColor(self, emission_color: MColor): 
        '''
        setEmissionColor(self, emission_color: MColor)

        Synopsis
        -----
        Sets the value of the "emissionColor" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        emission_color: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def thinFilmThickness(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        thinFilmThickness(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "thinFilmThickness" attribute of a
        standard surface shader node.

        Returns: 
        ----- 
        The value of the "thinFilmThickness" attribute of the shader
        node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setThinFilmThickness(self, thin_film_thickness: float): 
        '''
        setThinFilmThickness(self, thin_film_thickness: float)

        Synopsis
        -----
        Sets the value of the "thinFilmThickness" attribute of a shader
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        thin_film_thickness: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def thinFilmIOR(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        thinFilmIOR(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "thinFilmIOR" attribute of a standard
        surface shader node.

        Returns: 
        ----- 
        The value of the "thinFilmIOR" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setThinFilmIOR(self, thin_film_i_o_r: float): 
        '''
        setThinFilmIOR(self, thin_film_i_o_r: float)

        Synopsis
        -----
        Sets the value of the "thinFilmIOR" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        thin_film_i_o_r: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def thinWalled(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        thinWalled(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> bool

        Synopsis
        -----
        Retrieves the value of the "thinWalled" attribute of a standard
        surface shader node.

        Returns: 
        ----- 
        The value of the "thinWalled" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setThinWalled(self, thin_walled: bool): 
        '''
        setThinWalled(self, thin_walled: bool)

        Synopsis
        -----
        Sets the value of the "thinWalled" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        thin_walled: bool
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def opacity(self, ReturnStatus: MFnStandardSurfaceShader.MStatus): 
        '''
        opacity(self, ReturnStatus: MFnStandardSurfaceShader.MStatus) -> MColor

        Synopsis
        -----
        Retrieves the value of the "opacity" attribute of a standard
        surface shader node.

        Returns: 
        ----- 
        The value of the "opacity" attribute of the shader node.

        Parameters:
        -----
        ReturnStatus: MFnStandardSurfaceShader.MStatus
        	[out] -> return status


        '''
        pass

    def setOpacity(self, opacity: MColor): 
        '''
        setOpacity(self, opacity: MColor)

        Synopsis
        -----
        Sets the value of the "opacity" attribute of a shader node.

        Returns:
        -----
        None

        Parameters:
        -----
        opacity: MColor
        	[in] -> value to which the attribute will be set.


        '''
        pass

class MFnStringArrayData:
    '''String array function set for dependency node data.
MFnStringArrayData allows the creation and manipulation of
MStringArray data objects for use in the dependency graph.
If a user written dependency node either accepts or produces
MStringArrays, then this class is used to extract or create the
data that comes from or goes to other dependency graph nodes. The
MDataHandle::type method will return kStringArray when data of this type is
present. To access it, the
MDataHandle::data method is used to get an
MObject for the data and this should then be used to initialize an
instance of
MFnStringArrayData.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kStringArrayData.Reimplemented from MFnData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnStringArrayData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnStringArrayData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def length(self, ReturnStatus: MFnStringArrayData.MStatus): 
        '''
        length(self, ReturnStatus: MFnStringArrayData.MStatus) -> int

        Synopsis
        -----
        Return the number of strings in the instance.

        Returns: 
        ----- 
        The number of strings in the instance

        Parameters:
        -----
        ReturnStatus: MFnStringArrayData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    @overload
    def set(self, element: MString,
                        index: int): 
        '''
        set(self, element: MString,
                        index: int)

        Synopsis
        -----
        Set the element at the specified index of the array. No checking
        is done by this class to ensure that the index is valid - use the
        length method to determine the size of the array.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MString
        	[in] -> the element 

        index: int
        	[in] -> the index of the 


        '''
        pass

    def copyTo(self, dest: MStringArray): 
        '''
        copyTo(self, dest: MStringArray)

        Synopsis
        -----
        Copy all the strings in the instance into the given MStringArray.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: MStringArray
        	[out] -> the 


        '''
        pass

    @overload
    def set(self, array: MStringArray): 
        '''
        set(self, array: MStringArray)

        Synopsis
        -----
        Set the instance to contain the strings defined in the given
        MStringArray.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MStringArray
        	[in] -> the 


        '''
        pass

    def array(self, ReturnStatus: MFnStringArrayData.MStatus): 
        '''
        array(self, ReturnStatus: MFnStringArrayData.MStatus) -> MStringArray

        Synopsis
        -----
        Return an MStringArray containing the string array currently
        operated upon by the function set. The MStringArray returned by
        this method is editable, so any changes to the return instance
        also affects the MObject operated upon by this function set.

        Returns: 
        ----- 
        A copy of the MStringArray held in this instance

        Parameters:
        -----
        ReturnStatus: MFnStringArrayData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    @overload
    def create(self, ReturnStatus: MFnStringArrayData.MStatus): 
        '''
        create(self, ReturnStatus: MFnStringArrayData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance, and initialize
        it to contain no strings.

        Returns: 
        ----- 
        The newly created MObject

        Parameters:
        -----
        ReturnStatus: MFnStringArrayData.MStatus
        	[out] -> kSuccess


        '''
        pass

    @overload
    def create(self, arr: MStringArray,
                        ReturnStatus: MFnStringArrayData.MStatus): 
        '''
        create(self, arr: MStringArray,
                        ReturnStatus: MFnStringArrayData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance, and initialize
        it to contain the data from the given MStringArray.

        Returns: 
        ----- 
        The newly created MObject

        Parameters:
        -----
        arr: MStringArray
        	[in] -> the data to use when initializing this instance 

        ReturnStatus: MFnStringArrayData.MStatus
        	[out] -> kSuccess


        '''
        pass

    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> const MString&

        Synopsis
        -----
        Extract the indicated MString from the const instance. No
        checking is done by this class to ensure that the index is valid
        - use the length method to determine the size of the array. If
        the instance is not attached to an MObject, this method will
        return an MString containing "".

        Returns: 
        ----- 
        The indicated MString

        Parameters:
        -----
        index: int
        	[in] -> the index of the 


        '''
        pass

class MFnStringData:
    '''String function set for dependency node data.
MFnStringData allows the creation and manipulation of
MString data objects for use in the dependency graph.
If a user written dependency node either accepts or produces
MString, then this class is used to extract or create the data that
comes from or goes to other dependency graph nodes. The
MDataHandle::type method will return kStringData when data of this type is
present. To access it, the
MDataHandle::data method is used to get an
MObject for the data and this should then be used to initialize an
instance of
MFnStringData.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kStringData.Reimplemented from MFnData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnStringData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnStringData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def string(self, ReturnStatus: MFnStringData.MStatus): 
        '''
        string(self, ReturnStatus: MFnStringData.MStatus) -> MString

        Synopsis
        -----
        Return a copy of the string held in this instance.

        Returns: 
        ----- 
        An MString containing the string

        Parameters:
        -----
        ReturnStatus: MFnStringData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    def set(self, string: MString): 
        '''
        set(self, string: MString)

        Synopsis
        -----
        Set this instance to hold a copy of the given string.

        Returns:
        -----
        None

        Parameters:
        -----
        string: MString
        	[in] -> the 


        '''
        pass

    @overload
    def create(self, str: MString,
                        ReturnStatus: MFnStringData.MStatus): 
        '''
        create(self, str: MString,
                        ReturnStatus: MFnStringData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance and initialize
        it to a copy of the given string.

        Returns: 
        ----- 
        The new MObject

        Parameters:
        -----
        str: MString
        	[in] -> the string to copy 

        ReturnStatus: MFnStringData.MStatus
        	[out] -> kSuccess


        '''
        pass

    @overload
    def create(self, ReturnStatus: MFnStringData.MStatus): 
        '''
        create(self, ReturnStatus: MFnStringData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance and initialize
        it to the null string.

        Returns: 
        ----- 
        The new MObject

        Parameters:
        -----
        ReturnStatus: MFnStringData.MStatus
        	[out] -> kSuccess


        '''
        pass

class MFnSubd:
    '''Subdivision surface function set.
This function set provides access to subdivision surfaces.
Objects of type
MFn::kSubdiv,
MFn::kSubdivData, and
MFn::kSubdivGeom are supported.
MFn::kSubdiv objects are shapes in the DAG,
MFn::kSubdivGeom objects are the raw geometry that the shapes use, and
MFn::kSubdivData objects are the data that is passed through dependency graph
connections.
Maya implements fully hierarchical Catmull-Clark quad based
subdivision surfaces. You can use them without any hierarchical
edits, but their full power is only realized when you do use the
hierarchy. Using the hierarchy lets you access additional
vertices on the existing faces. For example, a single 4 vertex
plane can give you access, through hierarchy, to over 16,000,000
points at the finest level of the hierarchy (please don't try
it). Additionally, the points at the finer levels are created
only as you need them and only in the areas where you need them,
giving you an implied level of detail workflow.
The "base" mesh is sometimes used to describe the coarsest level
of the hierarchy. Once we go one level finer (to level "1") all
faces are four sided (though not all vertices are of valence 4).
At that point, each face can be considered to have 4 "children"
faces. Starting with a 4 vertex single face plane, there will be
4 faces (and 9 vertices) at level 1, 16 faces (and 25 vertices)
at level 2, etc. You can go as deep as level 12.
Please consult Maya documentation on subdivision surfaces for
more details.
 Subdivision surfaces are created by specifying a base polygonal
mesh, hierarchical edits (optional) and creases (optional).
The base mesh contains a vertex list, a list of vertex counts
per-polygon, and a list of vertices that make up the polygons. If
you are familiar with the creation of polygonal meshes, this is
exactly equivalent to that setup. With a small set of
limitations, any polygonal object can be converted into a
subdivision surface. The current limitations are:
The easiest way to create a subdivision surface is probably to
use polyToSubdiv MEL command to create it from a polygon.
Alternativelly, the same functionality is available through the
API using
 method.
Alternatively, you can create a subdivision surface either by
converting an existing NURBS surface with
 or directly, by specifying vertex lists, vertex connections
lists, etc. The last method will look familiar to those that have
used
 method to create a polygon.
The following lists are used by the create method to construct a
subdivision surface:
 You can optionally specify texture (uv) coordinates. UV
coordinates are 2-d coordinates used for mapping textures to the
polygons of a surface. Each polygon contains as many UV's as it
has vertices. The UV values are not shared and you can think of
them as "owned" by a polygon, rather than each vertex in that
polygon.
In order to successfully use the subdivision surface API, you
need to familiarize yourself with the naming convention used for
its components within the API.
In the polygon case, we simply number the vertices 0, 1, ... N-1.
The faces and the edges and the faces are numbered similarly.
For the subdivision surfaces, this is not the case, mostly
because of the hierarchical approach we took. Since it would be
prohibitive to instantiate all the faces all the time (think of
those 16M that can from just one original face) the names have to
be order of creation independent.
The simplest way to think about each API name is "start with a
face and follow a path into the finer levels of the hierarchy
recording each turn along the way".
Here's some details. You should also consult
 class which contains a number of helpful methods for
interpreting, creating and modifying the component API names.
While this will take some getting used to, the good news is that
instantiating more vertices does not change the names of the
existing ones (unless you're adding more level 0 vertices) so any
vertex animation, etc. will not be affected by a need to model
more detail into another part of the surface.
For the subdivision surfaces, the most important names are those
of the faces. Given a face name, each vertex on that face is
named based on that face. That does mean that each vertex will
typically have more than one name. Maya will always give you a
unique name by choosing the one that is numerically the smallest
(in the 64 bit sense).
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kSubdiv.Reimplemented from MFnDagNode.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnSubd.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnSubd".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def createBaseMesh(self, reverseNormal: bool,
                        numVertices: int,
                        numPolygons: int,
                        vertexArray: MPointArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        createBaseMesh(self, reverseNormal: bool,
                        numVertices: int,
                        numPolygons: int,
                        vertexArray: MPointArray,
                        polygonCounts: MIntArray,
                        polygonConnects: MIntArray,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnSubd.MStatus) -> MObject

        Synopsis
        -----
        Creates a new subdivision surface given an array of vertices and
        connection information and sets this function set to operate on
        the new surface. This method is meant to be as efficient as
        possible and thus assumes that all the given data is
        topologically correct.The parentOrOwner argument is used to
        specify the owner of the new surface.If the parentOrOwner is
        kSubdivData then the created surface will be of type kSubdivGeom
        and will be returned. The parentOrOwner will become the owner of
        the new subdivision surface.If parentOrOwner is NULL then a new
        transform will be created and returned which will be the parent
        for the subdivision surface. The new transform will be added to
        the DAG.If parentOrOwner is a DAG node then the new subdivision
        surface will be returned and the parentOrOwner will become its
        parent.

        Returns: 
        ----- 
        If parentOrOwner is NULL then the transform for this surface is
        returned  If parentOrOwner is a DAG object then the new surface
        shape is returned  The surface geometry is returned if
        parentOrOwner is of type kSubdivData

        Parameters:
        -----
        reverseNormal: bool
        	[in] -> Not currently used 

        numVertices: int
        	[in] -> number of vertices 

        numPolygons: int
        	[in] -> number of polygons 

        vertexArray: MPointArray
        	[in] -> point (vertex) array 

        polygonCounts: MIntArray
        	[in] -> array of vertex counts for each polygon 

        polygonConnects: MIntArray
        	[in] -> array of vertex connections for each polygon 

        parentOrOwner: MObject
        	[in] -> parent of the polygon that will be created 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def copy(self, source: MObject,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        copy(self, source: MObject,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnSubd.MStatus) -> MObject

        Synopsis
        -----
        This method creates a copy of a given source subdivision surface.
        After the copy this function set will operate on the new
        subdivision surface.The parentOrOwner argument is used to specify
        the owner of the new surface.If the parentOrOwner is kSubdivData
        then the created surface will be of type kSubdivGeom and will be
        returned. The parentOrOwner will become the owner of the new
        subdivision surface.If parentOrOwner is NULL then a new transform
        will be created and returned which will be the parent for the
        subdivision surface. The new transform will be added to the
        DAG.If parentOrOwner is a DAG node then the new subdivision
        surface will be returned and the parentOrOwner will become its
        parent.

        Returns: 
        ----- 
        If parentOrOwner is NULL then the transform for this surface is
        returned  If parentOrOwner is a DAG object then the new surface
        shape is returned  The surface geometry is returned if
        parentOrOwner is of type kSubdivData

        Parameters:
        -----
        source: MObject
        	[in] -> the subdivision surface to be copied 

        parentOrOwner: MObject
        	[in] -> the DAG parent or kSubdivData the new subdivision surface will belong to 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def collapse(self, level: int,
                        makeNewNodeInvisible: bool,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        collapse(self, level: int,
                        makeNewNodeInvisible: bool,
                        ReturnStatus: MFnSubd.MStatus) -> MObject

        Synopsis
        -----
        This method creates a copy of a given source subdivision surface
        collapsed by the given number of levels. After the collapse this
        function set will operate on the new subdivision surface.As an
        example, a collapse of one level means the level one vertices of
        the current subdivision surface become the level zero vertices of
        the new subdivision surface.Be careful passing in a large value
        for the level, as each level of collapse increases the number of
        faces on the new subdivision surface significantly.Collapsing a
        surface by one level means that the resulting surface is all
        quads. This can be useful in certain situations.NOTE: the
        collapse() method will fail if the function set has not been
        initialized with a dag path.

        Returns: 
        ----- 
        The new collapsed subdivision object

        Parameters:
        -----
        level: int
        	[in] -> the number of levels of the hierarchy to collapse 

        makeNewNodeInvisible: bool
        	[in] -> sets the invisible attribute of the new node 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def vertexBaseMeshAdd(self, x: double,
                        y: double,
                        z: double,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        vertexBaseMeshAdd(self, x: double,
                        y: double,
                        z: double,
                        ReturnStatus: MFnSubd.MStatus) -> int

        Synopsis
        -----
        Add a vertex to the base mesh and return its "index" name. Note
        that it will not have a valid 64-bit name until you actually
        create a polygon that holds it.

        Returns: 
        ----- 
        The index of the newly created vertex. It will be -1 if the
        creation failed.

        Parameters:
        -----
        x: double
        	[in] -> X location of the vertex 

        y: double
        	[in] -> Y location of the vertex 

        z: double
        	[in] -> Z location of the vertex 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def polygonBaseMeshAdd(self, vertexCount: int,
                        vertexIndex: int,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        polygonBaseMeshAdd(self, vertexCount: int,
                        vertexIndex: int,
                        ReturnStatus: MFnSubd.MStatus) -> MUint64

        Synopsis
        -----
        Add a polygon at the base mesh level. You will need to use the
        index names of the vertices (remember, they get their 64-bit
        names only after they have been added to a polygon).

        Returns: 
        ----- 
        The name of the newly created polygon

        Parameters:
        -----
        vertexCount: int
        	[in] -> Number of vertices in the polygon 

        vertexIndex: int
        	[in] -> The vertex indices (0, 1, 2, ...) 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def polygonBaseMeshAddWithUVs(self, vertexCount: int,
                        vertexIds: int,
                        uValues: double,
                        vValues: double,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        polygonBaseMeshAddWithUVs(self, vertexCount: int,
                        vertexIds: int,
                        uValues: double,
                        vValues: double,
                        ReturnStatus: MFnSubd.MStatus) -> MUint64

        Synopsis
        -----
        Add a polygon at the base mesh level. You will need to use the
        index names of the vertices (remember, they get their 64-bit
        names only after they have been added to a polygon). Specify the
        UV values as well.

        Returns: 
        ----- 
        The name of the newly created polygon

        Parameters:
        -----
        vertexCount: int
        	[in] -> Number of vertices in the polygon 

        vertexIds: int
        	[in] -> The vertex indices (0, 1, 2, ...) 

        uValues: double
        	[in] -> U values for each vertex 

        vValues: double
        	[in] -> V values for each vertex 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def editsPending(self, ReturnStatus: MFnSubd.MStatus): 
        '''
        editsPending(self, ReturnStatus: MFnSubd.MStatus) -> int

        Synopsis
        -----
        As the new hierarchical vertex offsets are being introduced, you
        can choose to not apply them to the surface immediatelly. If you
        do that, the number of edits pending will increase. Any edits are
        not actually made until you call "updateEdits". This functions
        lets you know if you need to call it or not.

        Returns: 
        ----- 
        Edits pending (1) or not (0).

        Parameters:
        -----
        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def editsUpdateAll(self, ReturnStatus: MFnSubd.MStatus): 
        '''
        editsUpdateAll(self, ReturnStatus: MFnSubd.MStatus)

        Synopsis
        -----
        If there are pending edits, this function will update the surface
        so that there are no pending edits.

        Returns:
        -----
        None

        Parameters:
        -----
        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def levelMaxCurrent(self, ReturnStatus: MFnSubd.MStatus): 
        '''
        levelMaxCurrent(self, ReturnStatus: MFnSubd.MStatus) -> int

        Synopsis
        -----
        Returns the finest level that currently exist. As int as a single
        face exists at a level, that level is counted. Note that this not
        mean that all of the faces exist on all levels.

        Returns: 
        ----- 
        The finest level in the hierarchy

        Parameters:
        -----
        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def levelMaxAllowed(self, ReturnStatus: MFnSubd.MStatus): 
        '''
        levelMaxAllowed(self, ReturnStatus: MFnSubd.MStatus) -> int

        Synopsis
        -----
        Returns the maximum level that can be created. You should
        probably avoid fully subdividing the surface to that level as you
        will most likelly just run out of memory.

        Returns: 
        ----- 
        The maximum possibly value for the finest level in the hierarchy

        Parameters:
        -----
        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def levelFullySubdivideTo(self, level: int,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        levelFullySubdivideTo(self, level: int,
                        ReturnStatus: MFnSubd.MStatus)

        Synopsis
        -----
        Fully subdivide the whole surface to the specified level. This
        could be very expensive, so be careful, or you will run out of
        memory. As a rule, each level has 4 times more faces than the
        previous one.

        Returns:
        -----
        None

        Parameters:
        -----
        level: int
        	[in] -> The level to which to fully subdivide 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def vertexCount(self, level: int,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        vertexCount(self, level: int,
                        ReturnStatus: MFnSubd.MStatus) -> int

        Synopsis
        -----
        Returns the finest vertex count at a particular level. These are
        the vertices that are currently instantiated.

        Returns: 
        ----- 
        The number of vertices at the given level

        Parameters:
        -----
        level: int
        	[in] -> The level we are interested in 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def vertexIdFromBaseVertexIndex(self, baseVertexIndex: int,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        vertexIdFromBaseVertexIndex(self, baseVertexIndex: int,
                        ReturnStatus: MFnSubd.MStatus) -> MUint64

        Synopsis
        -----
        Vertices are named using 64-bit integers. The base mesh vertices
        will also have a simple 0, 1, 2, N-1 indices. Use this function
        to compute the proper 64-bit name using the 0, 1, 2, ... indices.

        Returns: 
        ----- 
        The 64-bit name of the vertex

        Parameters:
        -----
        baseVertexIndex: int
        	[in] -> The index in the base mesh vertex array of this vertex 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def vertexBaseIndexFromVertexId(self, vertexId: MUint64,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        vertexBaseIndexFromVertexId(self, vertexId: MUint64,
                        ReturnStatus: MFnSubd.MStatus) -> int

        Synopsis
        -----
        Given a 64-bit id of the vertex, return its index (0, 1, ...) if
        it happens to be a base mesh vertex. It is an error to call this
        function with a non base mesh vertex.

        Returns: 
        ----- 
        The index in the base mesh vertex array of this vertex

        Parameters:
        -----
        vertexId: MUint64
        	[in] -> The 64-bit name of the vertex 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def vertexEditsGetAllNonBase(self, vertexIds: MUint64Array,
                        edits: MVectorArray,
                        space: MSpace.MSpace): 
        '''
        vertexEditsGetAllNonBase(self, vertexIds: MUint64Array,
                        edits: MVectorArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Returns all the vertices below the base mesh that have been
        modified from their original position (the original position is
        specified by the position of the base mesh vertices). The two
        arrays will be of the same length upon return. Length 0 would
        suggest that there have been no edits from the original
        positions.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexIds: MUint64Array
        	[in] -> The names of the vertices 

        edits: MVectorArray
        	[in] -> The offsets from the original position 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def vertexEditsSetAllNonBase(self, vertexIds: MUint64Array,
                        edits: MVectorArray,
                        space: MSpace.MSpace): 
        '''
        vertexEditsSetAllNonBase(self, vertexIds: MUint64Array,
                        edits: MVectorArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Given an array of vertex names and the offsets from their
        original positions, set the new vertex positions.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexIds: MUint64Array
        	[in] -> The names of the vertices 

        edits: MVectorArray
        	[in] -> The offsets from the original positions 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def vertexEditsClearAllNonBase(self): 
        '''
        vertexEditsClearAllNonBase(self)

        Synopsis
        -----
        Find all vertices with edits and remove those edits, setting them
        back to their original position.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def vertexPositionGet(self, vertexId: MUint64,
                        position: MPoint,
                        space: MSpace.MSpace): 
        '''
        vertexPositionGet(self, vertexId: MUint64,
                        position: MPoint,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Get the position of the vertex with a given name.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexId: MUint64
        	[in] -> The name of the vertex 

        position: MPoint
        	[out] -> The vertex position in the appropriate space 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def vertexEditGet(self, vertexId: MUint64,
                        edit: MVector,
                        space: MSpace.MSpace): 
        '''
        vertexEditGet(self, vertexId: MUint64,
                        edit: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Get the offset of the specified vertex from its original
        position. This vector really is vertexPositionGet() -
        vertexPositionGetNoEdit().

        Returns:
        -----
        None

        Parameters:
        -----
        vertexId: MUint64
        	[in] -> The name of the vertex 

        edit: MVector
        	[out] -> The offset in object space 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def vertexPositionGetNoEdit(self, vertexId: MUint64,
                        position: MPoint,
                        space: MSpace.MSpace): 
        '''
        vertexPositionGetNoEdit(self, vertexId: MUint64,
                        position: MPoint,
                        space: MSpace.MSpace)

        Synopsis
        -----
        What would the position of this vertex be if there were no edits;
        i.e., what was its original position.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexId: MUint64
        	[in] -> The name of the vertex 

        position: MPoint
        	[out] -> The original position 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def vertexPositionSet(self, vertexId: MUint64,
                        position: MPoint,
                        updateEdits: bool,
                        space: MSpace.MSpace): 
        '''
        vertexPositionSet(self, vertexId: MUint64,
                        position: MPoint,
                        updateEdits: bool,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the position of the vertex with a given name.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexId: MUint64
        	[in] -> The vertex name 

        position: MPoint
        	[out] -> The new vertex position 

        updateEdits: bool
        	[in] -> If false, you will need to call 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def vertexEditSet(self, vertexId: MUint64,
                        edit: MVector,
                        updateEdits: bool,
                        space: MSpace.MSpace): 
        '''
        vertexEditSet(self, vertexId: MUint64,
                        edit: MVector,
                        updateEdits: bool,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the original position offset for the given vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexId: MUint64
        	[in] -> The name of the vertex 

        edit: MVector
        	[in] -> The offset to set 

        updateEdits: bool
        	[in] -> If false, you will need to call 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def vertexBaseMeshGet(self, positions: MPointArray,
                        space: MSpace.MSpace): 
        '''
        vertexBaseMeshGet(self, positions: MPointArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Return all base mesh vertices in the array using their indices
        (not the 64-bit names).

        Returns:
        -----
        None

        Parameters:
        -----
        positions: MPointArray
        	[out] -> The array of point positions 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def vertexBaseMeshSet(self, positions: MPointArray,
                        space: MSpace.MSpace): 
        '''
        vertexBaseMeshSet(self, positions: MPointArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the positions for the base mesh vertices using the 0, 1,...
        indexing instead of the 64-bit vertex names.

        Returns:
        -----
        None

        Parameters:
        -----
        positions: MPointArray
        	[out] -> The positions for the vertices 

        space: MSpace.MSpace
        	[in] -> Specifies the coordinate system for this operation


        '''
        pass

    def vertexBaseMeshGetWithId(self, positions: MPointArray,
                        vertexIds: MUint64Array,
                        space: MSpace.MSpace): 
        '''
        vertexBaseMeshGetWithId(self, positions: MPointArray,
                        vertexIds: MUint64Array,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Return all base mesh vertices in the array using their indices
        but also provide the 64-bit names.

        Returns:
        -----
        None

        Parameters:
        -----
        positions: MPointArray
        	[out] -> The array of point positions 

        vertexIds: MUint64Array
        	[out] -> The vertex 64-bit ids 

        space: MSpace.MSpace
        	[in] -> The space we are working in


        '''
        pass

    def vertexBaseMeshSetWithId(self, positions: MPointArray,
                        vertexIds: MUint64Array,
                        space: MSpace.MSpace): 
        '''
        vertexBaseMeshSetWithId(self, positions: MPointArray,
                        vertexIds: MUint64Array,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the positions for the base mesh vertices using the 64-bit
        names. The ordering of the elements in the array is irrelevant.
        The edits will be automatically updated (i.e., editsPending()
        will return 0 after the call to this function).

        Returns:
        -----
        None

        Parameters:
        -----
        positions: MPointArray
        	[out] -> The positions for the vertices 

        vertexIds: MUint64Array
        	[out] -> The vertex 64-bit ids 

        space: MSpace.MSpace
        	[in] -> The space we are working in


        '''
        pass

    def vertexValence(self, vertexId: MUint64,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        vertexValence(self, vertexId: MUint64,
                        ReturnStatus: MFnSubd.MStatus) -> int

        Synopsis
        -----
        Returns the valence (number of incident edges) of the given
        vertex.

        Returns: 
        ----- 
        The finest level in the hierarchy

        Parameters:
        -----
        vertexId: MUint64
        	[in] -> The vertex 64-bit id 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def vertexNormal(self, vertexId: MUint64,
                        normal: MVector): 
        '''
        vertexNormal(self, vertexId: MUint64,
                        normal: MVector)

        Synopsis
        -----
        Returns the normal at the vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexId: MUint64
        	[in] -> The vertex 64-bit ID. 

        normal: MVector
        	[out] -> The value of the normal


        '''
        pass

    def vertexAdjacentVertices(self, vertexId: MUint64,
                        vertList: MUint64Array): 
        '''
        vertexAdjacentVertices(self, vertexId: MUint64,
                        vertList: MUint64Array)

        Synopsis
        -----
        Return the list of adjacent vertices as their 64-bit ids.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexId: MUint64
        	[in] -> The vertex 64-bit name 

        vertList: MUint64Array
        	[out] -> The resulting list of adjacent vertices


        '''
        pass

    def vertexIncidentEdges(self, vertexId: MUint64,
                        edgeList: MUint64Array): 
        '''
        vertexIncidentEdges(self, vertexId: MUint64,
                        edgeList: MUint64Array)

        Synopsis
        -----
        Return the list of incident edges as their 64-bit ids.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexId: MUint64
        	[in] -> The vertex 64-bit name 

        edgeList: MUint64Array
        	[out] -> The resulting list of incident edges


        '''
        pass

    def vertexIncidentPolygons(self, vertexId: MUint64,
                        polyList: MUint64Array): 
        '''
        vertexIncidentPolygons(self, vertexId: MUint64,
                        polyList: MUint64Array)

        Synopsis
        -----
        Return the list of incident polygons as their 64-bit ids.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexId: MUint64
        	[in] -> The vertex 64-bit name 

        polyList: MUint64Array
        	[out] -> The resulting list of incident polygons


        '''
        pass

    def vertexIsBoundary(self, vertexId: MUint64,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        vertexIsBoundary(self, vertexId: MUint64,
                        ReturnStatus: MFnSubd.MStatus) -> bool

        Synopsis
        -----
        Return true if the vertex is a boundary vertex.

        Returns: 
        ----- 
        Whether the vertex is boundary or not

        Parameters:
        -----
        vertexId: MUint64
        	[in] -> The vertex 64-bit name 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def vertexIsValid(self, vertexId: MUint64,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        vertexIsValid(self, vertexId: MUint64,
                        ReturnStatus: MFnSubd.MStatus) -> bool

        Synopsis
        -----
        Return true if the vertex is a valid vertex.

        Returns: 
        ----- 
        Whether the vertex is valid or not. Valid means that the vertex
        has been instantiated on the surface. Not all vertices at all
        levels exist by default. A vertex only exists if it was created
        at the time the subdiv was first created or if the subdiv was
        refined.

        Parameters:
        -----
        vertexId: MUint64
        	[in] -> The vertex 64-bit name 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def vertexIsCreased(self, vertexId: MUint64,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        vertexIsCreased(self, vertexId: MUint64,
                        ReturnStatus: MFnSubd.MStatus) -> bool

        Synopsis
        -----
        Return true if the vertex is creased.

        Returns: 
        ----- 
        Whether the vertex is creased or not

        Parameters:
        -----
        vertexId: MUint64
        	[in] -> The vertex 64-bit name 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def vertexCreaseRelevant(self, vertexId: MUint64,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        vertexCreaseRelevant(self, vertexId: MUint64,
                        ReturnStatus: MFnSubd.MStatus) -> bool

        Synopsis
        -----
        Return true if the crease of the vertex is a relevant piece of
        information. The vertex inherits the crease state from its
        parent. So, its crease state is relevant only if different from
        its parent (or if there is no direct parent vertex).

        Returns: 
        ----- 
        Whether the vertex has relevant crease information

        Parameters:
        -----
        vertexId: MUint64
        	[in] -> The vertex 64-bit name 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def vertexSetCrease(self, vertexId: MUint64,
                        creased: bool): 
        '''
        vertexSetCrease(self, vertexId: MUint64,
                        creased: bool)

        Synopsis
        -----
        Set the particular vertex' crease state.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexId: MUint64
        	[in] -> The 64-bit name of the vertex 

        creased: bool
        	[in] -> Crease (true) or smooth (false)


        '''
        pass

    def vertexChildren(self, vertexId: MUint64,
                        children: MUint64Array): 
        '''
        vertexChildren(self, vertexId: MUint64,
                        children: MUint64Array)

        Synopsis
        -----
        Returns the "children" of the particular vertex if they exist.
        The children are defined as the finer-level version of the
        current vertex plus the neighbors of that vertex. For a valence n
        vertex this means 2n+1 vertices are returned if a finer level
        exists.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexId: MUint64
        	[in] -> 64-bit name of the vertex 

        children: MUint64Array
        	[out] -> 64-bit names of the children of this vertex


        '''
        pass

    def creasesGetAll(self, vertexIds: MUint64Array,
                        edgeIds: MUint64Array): 
        '''
        creasesGetAll(self, vertexIds: MUint64Array,
                        edgeIds: MUint64Array)

        Synopsis
        -----
        Returns all creases on the subdivision surface in two arrays of
        64-bit ids; one for the vertices, one for edges. Note that this
        information alone is not suitable for "copying" the surface;
        there may be some relevant crease information in the non-creased
        vertices or edges which will not be part of the arrays returned
        here. Consider a vertex at level N that is creased while the
        corresponding vertex at level N+1 is not creased. Calling
        creasesGetAll will return the level N vertex. Applying the
        creasing to this vertex in the copy will also set the vertex at
        level N+1 to be creased as well, since vertices inherit creasing
        from their parent unless they have a different creasing set
        explicitly. So to get correct behavior when copying surfaces it
        is necessary to set the creasing attribute explicitly to the
        appropriate value on all the vertices, not just the creased
        vertices. The same applies to edges.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexIds: MUint64Array
        	[out] -> The ids of the vertices that are creased 

        edgeIds: MUint64Array
        	[out] -> The ids of the edges that are creased


        '''
        pass

    def creasesSetAll(self, vertexIds: MUint64Array,
                        edgeIds: MUint64Array): 
        '''
        creasesSetAll(self, vertexIds: MUint64Array,
                        edgeIds: MUint64Array)

        Synopsis
        -----
        Set the creases on all vertices and edges with a given 64-bit
        name. Note that the combination of creasesGetAll() and
        creasesSetAll() will not exactly duplicate the crease information
        between two surfaces.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexIds: MUint64Array
        	[in] -> The ids of the vertices that are creased 

        edgeIds: MUint64Array
        	[in] -> The ids of the edges that are creased


        '''
        pass

    def creasesClearAll(self): 
        '''
        creasesClearAll(self)

        Synopsis
        -----
        Clear all crease information from this surface. No vertices or
        edges will be creased after this function completes.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def updateAllEditsAndCreases(self): 
        '''
        updateAllEditsAndCreases(self)

        Synopsis
        -----
        If you have been editing offsets without updating the surface,
        this function will save you. This will dirty up the complete
        surface and recompute the positions of all the cvs, updating the
        crease info along the way. Not cheap to call.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def edgeCount(self, level: int,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        edgeCount(self, level: int,
                        ReturnStatus: MFnSubd.MStatus) -> int

        Synopsis
        -----
        Returns the number of edges at a level.

        Returns: 
        ----- 
        Number of edges at the given level

        Parameters:
        -----
        level: int
        	[in] -> The level where we're counting the edges 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def edgeBetween(self, vertex1: MUint64,
                        vertex2: MUint64,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        edgeBetween(self, vertex1: MUint64,
                        vertex2: MUint64,
                        ReturnStatus: MFnSubd.MStatus) -> MUint64

        Synopsis
        -----
        Return the name of the edge that connects the two vertices. If
        the edge doesn't exist, it will be created.

        Returns: 
        ----- 
        The name of the edge between the two

        Parameters:
        -----
        vertex1: MUint64
        	[in] -> The name of the first vertex 

        vertex2: MUint64
        	[in] -> The name of the second vertex 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def edgeVertices(self, edgeId: MUint64,
                        v1: MUint64,
                        v2: MUint64): 
        '''
        edgeVertices(self, edgeId: MUint64,
                        v1: MUint64,
                        v2: MUint64)

        Synopsis
        -----
        Given an edge, return the two vertices at its ends.

        Returns:
        -----
        None

        Parameters:
        -----
        edgeId: MUint64
        	[in] -> The 64-bit edge name 

        v1: MUint64
        	[out] -> First vertex on the edge 

        v2: MUint64
        	[out] -> Second vertex on the edge


        '''
        pass

    def edgeAdjacentPolygon(self, edgeId: MUint64,
                        polys: MUint64Array): 
        '''
        edgeAdjacentPolygon(self, edgeId: MUint64,
                        polys: MUint64Array)

        Synopsis
        -----
        Return the polygons adjacent to this edge. There can be at most
        two, as non-manifold topology is not allowed.

        Returns:
        -----
        None

        Parameters:
        -----
        edgeId: MUint64
        	[in] -> The 64-bit edge name 

        polys: MUint64Array
        	[out] -> The 64-bit names of the polygons (1 or 2)


        '''
        pass

    def edgeIsBoundary(self, edgeId: MUint64,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        edgeIsBoundary(self, edgeId: MUint64,
                        ReturnStatus: MFnSubd.MStatus) -> bool

        Synopsis
        -----
        Test if the edge specified is a boundary edge or not.

        Returns: 
        ----- 
        True if the edge is a boundary edge, false otherwise.

        Parameters:
        -----
        edgeId: MUint64
        	[in] -> The 64-bit edge name 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def edgeIsValid(self, edgeId: MUint64,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        edgeIsValid(self, edgeId: MUint64,
                        ReturnStatus: MFnSubd.MStatus) -> bool

        Synopsis
        -----
        Returns true if the specified edge name is valid.

        Returns: 
        ----- 
        True if the edge name is valid, false otherwise.

        Parameters:
        -----
        edgeId: MUint64
        	[in] -> The 64-bit edge name 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def edgeIsCreased(self, edgeId: MUint64,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        edgeIsCreased(self, edgeId: MUint64,
                        ReturnStatus: MFnSubd.MStatus) -> bool

        Synopsis
        -----
        Return true if the edge is creased.

        Returns: 
        ----- 
        True if the edge is creased, false otherwise

        Parameters:
        -----
        edgeId: MUint64
        	[in] -> The 64-bit name of the edge 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def edgeCreaseRelevant(self, edgeId: MUint64,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        edgeCreaseRelevant(self, edgeId: MUint64,
                        ReturnStatus: MFnSubd.MStatus) -> bool

        Synopsis
        -----
        Return true if the crease of the edge is a relevant piece of
        information. The edge inherits the crease state from its parent.
        So, its crease state is relevant only if different from its
        parent (or if there is no direct parent edge).

        Returns: 
        ----- 
        Whether the edge has relevant crease information

        Parameters:
        -----
        edgeId: MUint64
        	[in] -> The edge 64-bit name 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def edgeSetCrease(self, edgeId: MUint64,
                        creased: bool): 
        '''
        edgeSetCrease(self, edgeId: MUint64,
                        creased: bool)

        Synopsis
        -----
        Set the particular edge's crease state.

        Returns:
        -----
        None

        Parameters:
        -----
        edgeId: MUint64
        	[in] -> The 64-bit name of the edge 

        creased: bool
        	[in] -> Crease (true) or smooth (false)


        '''
        pass

    def edgeChildren(self, edgeId: MUint64,
                        children: MUint64Array): 
        '''
        edgeChildren(self, edgeId: MUint64,
                        children: MUint64Array)

        Synopsis
        -----
        Returns the "children" of the particular edge. If the edge has
        children, there will always be two child edges.

        Returns:
        -----
        None

        Parameters:
        -----
        edgeId: MUint64
        	[in] -> 64-bit name of the edge 

        children: MUint64Array
        	[out] -> 64-bit names of the children of this edge


        '''
        pass

    def polygonCount(self, level: int,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        polygonCount(self, level: int,
                        ReturnStatus: MFnSubd.MStatus) -> int

        Synopsis
        -----
        Returns the number of polygons currently existing at the
        specified level of the hierarchy.

        Returns: 
        ----- 
        The number of polygons at the specified level

        Parameters:
        -----
        level: int
        	[in] -> Level at which we're counting 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def polygonCountMaxWithGivenBaseMesh(self, level: int,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        polygonCountMaxWithGivenBaseMesh(self, level: int,
                        ReturnStatus: MFnSubd.MStatus) -> int

        Synopsis
        -----
        If you were to fully subdivide at a given level, how many
        polygons would you have at that level? This function will tell
        you and possibly save you from running out of memory if you go
        too deep. Note that this is exactly the same as "polygonCount"
        for levels 0 and 1.

        Returns: 
        ----- 
        The number of polygons at the given level if you were to fully
        subdivide at that level.

        Parameters:
        -----
        level: int
        	[in] -> The level where you would be counting 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def polygonVertexCount(self, polyId: MUint64,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        polygonVertexCount(self, polyId: MUint64,
                        ReturnStatus: MFnSubd.MStatus) -> int

        Synopsis
        -----
        How many vertices on a given polygon? The vertices are at the
        same level as the polygon.

        Returns: 
        ----- 
        The number of vertices on this polygon

        Parameters:
        -----
        polyId: MUint64
        	[in] -> The 64-bit name of the polygon 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def polygonVertices(self, polyId: MUint64,
                        vertexIds: MUint64Array): 
        '''
        polygonVertices(self, polyId: MUint64,
                        vertexIds: MUint64Array)

        Synopsis
        -----
        Given the polygon, return its vertices. The vertices are at the
        same level as the polygon.

        Returns:
        -----
        None

        Parameters:
        -----
        polyId: MUint64
        	[in] -> The 64-bit name of the polygon 

        vertexIds: MUint64Array
        	[out] -> The 64-bit names of the vertices


        '''
        pass

    def polygonEdgeCount(self, polyId: MUint64,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        polygonEdgeCount(self, polyId: MUint64,
                        ReturnStatus: MFnSubd.MStatus) -> int

        Synopsis
        -----
        The number of edges on the given polygon.

        Returns: 
        ----- 
        The number of edges on this polygon

        Parameters:
        -----
        polyId: MUint64
        	[in] -> The 64-bit name of the polygon 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def polygonEdges(self, polyId: MUint64,
                        edgeIds: MUint64Array): 
        '''
        polygonEdges(self, polyId: MUint64,
                        edgeIds: MUint64Array)

        Synopsis
        -----
        Given the polygon, return its edges. The edges are at the same
        level as the polygon.

        Returns:
        -----
        None

        Parameters:
        -----
        polyId: MUint64
        	[in] -> The 64-bit name of the polygon 

        edgeIds: MUint64Array
        	[out] -> The 64-bit names of the edges


        '''
        pass

    def polygonIsValid(self, polygonId: MUint64,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        polygonIsValid(self, polygonId: MUint64,
                        ReturnStatus: MFnSubd.MStatus) -> bool

        Synopsis
        -----
        Return true if the polygon is a valid polygon.

        Returns: 
        ----- 
        Whether the polygon is valid or not. Valid means that the polygon
        has been instantiated on the surface. Not all polygons at all
        levels exist by default. A polygon only exists if it was created
        at the time the subdiv was first created or if the subdiv was
        refined.

        Parameters:
        -----
        polygonId: MUint64
        	[in] -> The polygon 64-bit name 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def polygonHasChildren(self, polyId: MUint64,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        polygonHasChildren(self, polyId: MUint64,
                        ReturnStatus: MFnSubd.MStatus) -> bool

        Synopsis
        -----
        Returns whether or not the given polygon has children.

        Returns: 
        ----- 
        Whether the polygon has children.

        Parameters:
        -----
        polyId: MUint64
        	[in] -> The polygon 64-bit name 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def polygonChildren(self, polyId: MUint64,
                        children: MUint64Array): 
        '''
        polygonChildren(self, polyId: MUint64,
                        children: MUint64Array)

        Synopsis
        -----
        Returns the list of children polygons on the given polygon. If
        the children array is not empty, we will just append to it.

        Returns:
        -----
        None

        Parameters:
        -----
        polyId: MUint64
        	[in] -> The 64-bit name of the original polygon 

        children: MUint64Array
        	[out] -> The 64-bit name of the child polygons


        '''
        pass

    def polygonSubdivide(self, polyId: MUint64): 
        '''
        polygonSubdivide(self, polyId: MUint64)

        Synopsis
        -----
        Subdivide the given polygon into 4 children (if this happens to
        be the level 0 polygon you will get as many children as that
        polygon has edges).

        Returns:
        -----
        None

        Parameters:
        -----
        polyId: MUint64
        	[in] -> The 64-bit name of the polygon


        '''
        pass

    def polygonSetUseUVs(self, polyId: MUint64,
                        useThem: bool): 
        '''
        polygonSetUseUVs(self, polyId: MUint64,
                        useThem: bool)

        Synopsis
        -----
        If this is set, the polygon will use the user specified UVs.

        Returns:
        -----
        None

        Parameters:
        -----
        polyId: MUint64
        	[in] -> The 64-bit polygon name 

        useThem: bool
        	[in] -> Use the user set UVs


        '''
        pass

    def polygonHasVertexUVs(self, polyId: MUint64,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        polygonHasVertexUVs(self, polyId: MUint64,
                        ReturnStatus: MFnSubd.MStatus) -> bool

        Synopsis
        -----
        Returns true if there are user specified UVs on this polygon.

        Returns: 
        ----- 
        True if there were explicitly specified UVs on this polygon.

        Parameters:
        -----
        polyId: MUint64
        	[in] -> The 64-bit polygon name 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def polygonGetVertexUVs(self, polyId: MUint64,
                        uValues: MDoubleArray,
                        vValues: MDoubleArray): 
        '''
        polygonGetVertexUVs(self, polyId: MUint64,
                        uValues: MDoubleArray,
                        vValues: MDoubleArray)

        Synopsis
        -----
        Get the vertex UVs from the polygon. The values come back in
        exactly the same order as the polygon vertices do.

        Returns:
        -----
        None

        Parameters:
        -----
        polyId: MUint64
        	[in] -> The 64-bit polygon name 

        uValues: MDoubleArray
        	[out] -> Array of U values 

        vValues: MDoubleArray
        	[out] -> Array of V values


        '''
        pass

    def polygonSetVertexUVs(self, polyId: MUint64,
                        uValues: MDoubleArray,
                        vValues: MDoubleArray): 
        '''
        polygonSetVertexUVs(self, polyId: MUint64,
                        uValues: MDoubleArray,
                        vValues: MDoubleArray)

        Synopsis
        -----
        Set the UV values on the polygon.

        Returns:
        -----
        None

        Parameters:
        -----
        polyId: MUint64
        	[in] -> The 64-bit polygon name 

        uValues: MDoubleArray
        	[in] -> Array of U values 

        vValues: MDoubleArray
        	[in] -> Array of V values


        '''
        pass

    def polygonGetCenterUV(self, polyId: MUint64,
                        u: double,
                        v: double): 
        '''
        polygonGetCenterUV(self, polyId: MUint64,
                        u: double,
                        v: double)

        Synopsis
        -----
        Return the UV values in the "center" of this polygon.

        Returns:
        -----
        None

        Parameters:
        -----
        polyId: MUint64
        	[in] -> The 64-bit polygon name 

        u: double
        	[out] -> The resulting U value 

        v: double
        	[out] -> The resulting V value


        '''
        pass

    def evaluatePosition(self, polyId: MUint64,
                        u: double,
                        v: double,
                        uvNormalized: bool,
                        pos: MPoint): 
        '''
        evaluatePosition(self, polyId: MUint64,
                        u: double,
                        v: double,
                        uvNormalized: bool,
                        pos: MPoint)

        Synopsis
        -----
        Evaluate the surface position at the given parameter point on the
        polygon. The limitation is that this cannot be a base mesh
        polygon; i.e., it has to be at least level 1.

        Returns:
        -----
        None

        Parameters:
        -----
        polyId: MUint64
        	[in] -> The 64-bit polygon name 

        u: double
        	[in] -> U value on the face 

        v: double
        	[in] -> V value on the face 

        uvNormalized: bool
        	[in] -> If true, its as if U, V are in [0,1] 

        pos: MPoint
        	[out] -> The resulting 3d position


        '''
        pass

    def evaluateNormal(self, polyId: MUint64,
                        u: double,
                        v: double,
                        uvNormalized: bool,
                        nrml: MVector): 
        '''
        evaluateNormal(self, polyId: MUint64,
                        u: double,
                        v: double,
                        uvNormalized: bool,
                        nrml: MVector)

        Synopsis
        -----
        Evaluate the surface normal at the given parameter point on the
        polygon. The limitation is that this cannot be a base mesh
        polygon; i.e., it has to be at least level 1.

        Returns:
        -----
        None

        Parameters:
        -----
        polyId: MUint64
        	[in] -> The 64-bit polygon name 

        u: double
        	[in] -> U value on the face 

        v: double
        	[in] -> V value on the face 

        uvNormalized: bool
        	[in] -> If true, its as if U, V are in [0,1] 

        nrml: MVector
        	[out] -> The resulting surface normal


        '''
        pass

    def evaluatePositionAndNormal(self, polyId: MUint64,
                        u: double,
                        v: double,
                        uvNormalized: bool,
                        pos: MPoint,
                        nrml: MVector): 
        '''
        evaluatePositionAndNormal(self, polyId: MUint64,
                        u: double,
                        v: double,
                        uvNormalized: bool,
                        pos: MPoint,
                        nrml: MVector)

        Synopsis
        -----
        Evaluate the surface position and normal at the given parameter
        point on the polygon. The limitation is that this cannot be a
        base mesh polygon; i.e., it has to be at least level 1.

        Returns:
        -----
        None

        Parameters:
        -----
        polyId: MUint64
        	[in] -> The 64-bit polygon name 

        u: double
        	[in] -> U value on the face 

        v: double
        	[in] -> V value on the face 

        uvNormalized: bool
        	[in] -> If true, its as if U, V are in [0,1] 

        pos: MPoint
        	[out] -> The resulting 3d position 

        nrml: MVector
        	[out] -> The resulting surface normal


        '''
        pass

    def getCubicSpline(self, polyId: MUint64,
                        vertices: MPointArray,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        getCubicSpline(self, polyId: MUint64,
                        vertices: MPointArray,
                        ReturnStatus: MFnSubd.MStatus) -> bool

        Synopsis
        -----
        Some of the faces (usually at level 2 or below) happen to be
        exactly the same as uniform bi-cubic B-splines. This routine will
        return the 16 points that define such spline.

        Returns: 
        ----- 
        True if we can make the conversion, false otherwise

        Parameters:
        -----
        polyId: MUint64
        	[in] -> The 64-bit polygon name 

        vertices: MPointArray
        	[out] -> point array 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status code


        '''
        pass

    def getConnectedShaders(self, instanceNumber: int,
                        shaders: MObjectArray,
                        faces: MUint64Array,
                        indices: MIntArray): 
        '''
        getConnectedShaders(self, instanceNumber: int,
                        shaders: MObjectArray,
                        faces: MUint64Array,
                        indices: MIntArray)

        Synopsis
        -----
        Returns all the shaders (sets) connected to the specified
        instance of this subdivision surface and two arrays indicating
        face/shader assignments. For each face in the face array, there
        is a corresponding entry in the indices array to indicate the
        assigned shader in the shader array.For instance, faces[0] is the
        64-bit index of the face on the subdivision surface. Then
        indices[0] is an index into the shaders array, eg. "3". Then
        shaders[3] is the shader assigned to the subdivision surface
        face.If a face does not have a shader assigned to it, the value
        of the index will be -1. The shader objects can be derived from
        the sets returned.See also getConnectedSetsAndMembers.

        Returns:
        -----
        None

        Parameters:
        -----
        instanceNumber: int
        	[in] -> The instance number of the subdivision surface to query 

        shaders: MObjectArray
        	[out] -> Storage for set objects (shader objects) 

        faces: MUint64Array
        	[out] -> Storage for indices matching faces to indices 

        indices: MIntArray
        	[out] -> Storage for indices matching indices to shaders


        '''
        pass

    def tesselate(self, uniform: bool,
                        depth: int,
                        sample: int,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        tesselate(self, uniform: bool,
                        depth: int,
                        sample: int,
                        parentOrOwner: MObject,
                        ReturnStatus: MFnSubd.MStatus) -> MObject

        Synopsis
        -----
        Performs tesselation on this surface and create a new mesh in the
        DAG. The parentOrOwner argument is used to specify the owner of
        the new surface.If the parentOrOwner is kMeshData then the
        created surface will be of type kMeshGeom and will be returned.
        The parentOrOwner will become the owner of the new mesh.If
        parentOrOwner is NULL then a new transform will be created and
        returned which will be the parent for the mesh. The new transform
        will be added to the DAG.If parentOrOwner is a DAG node then the
        new mesh will be returned and the parentOrOwner will become its
        parent.Note: Each level 1 face will tesselate into
        approximatelly: 2 * 4^(depth-1) * sample^2 triangles in the
        uniform case, so be careful as to how you choose these
        parameters.

        Returns: 
        ----- 
        If parentOrOwner is NULL then the transform for this surface is
        returned  If parentOrOwner is a DAG object then the new surface
        shape is returned  The surface geometry is returned if
        parentOrOwner is of type kMeshData

        Parameters:
        -----
        uniform: bool
        	[in] -> Use uniform tesselation if this is set. 

        depth: int
        	[in] -> Used in the uniform tesselation: how deep do we go 

        sample: int
        	[in] -> In both tesselation cases, once we decide which level to tesselate at, how many times do we sample. 

        parentOrOwner: MObject
        	[in] -> the DAG parent or kMeshData the new Mesh will belong to 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status Code


        '''
        pass

    def tessellateViaNurbs(self, parentOrOwner: MObject,
                        ReturnStatus: MFnSubd.MStatus): 
        '''
        tessellateViaNurbs(self, parentOrOwner: MObject,
                        ReturnStatus: MFnSubd.MStatus) -> MObject

        Synopsis
        -----
        Performs tesselation on this surface and create a new mesh in the
        DAG. The parentOrOwner argument is used to specify the owner of
        the new surface.If the parentOrOwner is kMeshData then the
        created surface will be of type kMeshGeom and will be returned.
        The parentOrOwner will become the owner of the new mesh.If
        parentOrOwner is NULL then a new transform will be created and
        returned which will be the parent for the mesh. The new transform
        will be added to the DAG.If parentOrOwner is a DAG node then the
        new mesh will be returned and the parentOrOwner will become its
        parent.Note: Each level 1 face will tesselate into
        approximatelly: 2 * 4^(depth-1) * sample^2 triangles in the
        uniform case, so be careful as to how you choose these
        parameters.

        Returns: 
        ----- 
        If parentOrOwner is NULL then the transform for this surface is
        returned  If parentOrOwner is a DAG object then the new surface
        shape is returned  The surface geometry is returned if
        parentOrOwner is of type kMeshData

        Parameters:
        -----
        parentOrOwner: MObject
        	[in] -> the DAG parent or kMeshData the new Mesh will belong to 

        ReturnStatus: MFnSubd.MStatus
        	[out] -> Status Code


        '''
        pass

    def convertToNurbs(self, newNurbsSurfaces: MObjectArray): 
        '''
        convertToNurbs(self, newNurbsSurfaces: MObjectArray)

        Synopsis
        -----
        Converts this surface to a set of nurbs surfaces.

        Returns:
        -----
        None

        Parameters:
        -----
        newNurbsSurfaces: MObjectArray
        	[out] -> Storage for the arary of NURBS


        '''
        pass

    def updateSubdSurface(self): 
        '''
        updateSubdSurface(self)

        Synopsis
        -----
        Signal that this subdivision surface has changed and needs to
        redraw itself.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def vertexBaseMeshAddWithIndex(self, x: double,
                        y: double,
                        z: double,
                        index: int): 
        '''
        vertexBaseMeshAddWithIndex(self, x: double,
                        y: double,
                        z: double,
                        index: int)

        Synopsis
        -----
        Very similar to vertexBaseMeshAdd, this gives you an advanced
        option of specifying the index for the new vertex to be created.
        You have to be extremelly careful to end up with the indices 0,
        1, ... N-1 for N total vertices.

        Returns:
        -----
        None

        Parameters:
        -----
        x: double
        	[in] -> X location of the vertex 

        y: double
        	[in] -> Y location of the vertex 

        z: double
        	[in] -> Z location of the vertex 

        index: int
        	[in] -> The index the vertex is to take


        '''
        pass

class MFnSubdData:
    '''Subdiv Surface function set for dependency node data.
MFnSubdData allows the creation and manipulation of Subdivision Surface data
objects for use in the dependency graph.
If a user written dependency node either accepts or produces
Subdivision Surfaces, then this class is used to extract or
create the data that comes from or goes to other dependency graph
nodes. The
MDataHandle::type method will return kSubdiv when data of this type is present.
If a node is receiving a Subdivision Surface via an input
attribute, the asSubdSurface method of
MDataHandle can be used to access that input Subdivision Surface.
If a node is to create a Subdivision Surface and send it via an
output attribute, a new
MFnSubdData must be instantiated and then the create method called to build
the actual data block as an
MObject. This
MObject should be passed to the
MFnSubd::create method as the parentOrOwner parameter so that the Subdivision
Surface will be constructed inside the data block. The
MDataHandle::set routine is then used to pass the data block down the connection.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kSubdivData.Reimplemented from MFnGeometryData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnSubdData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnSubdData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, ReturnStatus: MFnSubdData.MStatus): 
        '''
        create(self, ReturnStatus: MFnSubdData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance and initialize
        it with a data block capable of holding a Subdivision Surface.

        Returns: 
        ----- 
        The new MObject

        Parameters:
        -----
        ReturnStatus: MFnSubdData.MStatus
        	[out] -> kSuccess


        '''
        pass

class MFnSubdNames:
    '''Manipulate Subdivision Surface vertex, edge and face ids.
This function set provides some simple utilities for the
interpretation and manipulation of the subdivision surface
vertex, edge and face ids.
'''
    def __init__(self):
        pass


    def base(self, id: MUint64): 
        '''
        base(self, id: MUint64) -> int

        Synopsis
        -----
        Given a 64-bit name, return the base mesh face.

        Returns:
        -----
        None

        Parameters:
        -----
        id: MUint64
        	[in] -> The 64-bit name of the component 


        '''
        pass

    def first(self, id: MUint64): 
        '''
        first(self, id: MUint64) -> int

        Synopsis
        -----
        Given a 64-bit name, return the index of the first child of the
        base face.

        Returns:
        -----
        None

        Parameters:
        -----
        id: MUint64
        	[in] -> The 64-bit name of the component 


        '''
        pass

    def level(self, id: MUint64): 
        '''
        level(self, id: MUint64) -> int

        Synopsis
        -----
        Given a 64-bit name, return the level of the component.

        Returns:
        -----
        None

        Parameters:
        -----
        id: MUint64
        	[in] -> The 64-bit name of the component 


        '''
        pass

    def path(self, id: MUint64): 
        '''
        path(self, id: MUint64) -> int

        Synopsis
        -----
        Given a 64-bit name, return from level 1 face down to the face in
        question. Two bits per level for the four possible choices.

        Returns:
        -----
        None

        Parameters:
        -----
        id: MUint64
        	[in] -> The 64-bit name of the component 


        '''
        pass

    def corner(self, id: MUint64): 
        '''
        corner(self, id: MUint64) -> int

        Synopsis
        -----
        One of the 4 possible choices of the vertex or an edge once we're
        at the particular face.

        Returns:
        -----
        None

        Parameters:
        -----
        id: MUint64
        	[in] -> The 64-bit name of the component 


        '''
        pass

    def fromMUint64(self, id: MUint64,
                        base: int,
                        first: int,
                        level: int,
                        path: int,
                        corner: int): 
        '''
        fromMUint64(self, id: MUint64,
                        base: int,
                        first: int,
                        level: int,
                        path: int,
                        corner: int)

        Synopsis
        -----
        Given a 64-bit name, compute the base face, first level face
        index, level, path to the face and the corner choice at the
        finest face.

        Returns:
        -----
        None

        Parameters:
        -----
        id: MUint64
        	[in] -> The 64-bit name of the component 

        base: int
        	[out] -> Base face index 

        first: int
        	[out] -> First level face choice 

        level: int
        	[out] -> Level 

        path: int
        	[out] -> Path to the finest level 

        corner: int
        	[out] -> Corner choice at the finest level 


        '''
        pass

    def toMUint64(self, id: MUint64,
                        base: int,
                        first: int,
                        level: int,
                        path: int,
                        corner: int): 
        '''
        toMUint64(self, id: MUint64,
                        base: int,
                        first: int,
                        level: int,
                        path: int,
                        corner: int)

        Synopsis
        -----
        Compute the 64-bit name given the base face index, first level
        face index, level, path to the finest face and the corner choice.
        The corner is zero (ignore) if the component is to be the face.

        Returns:
        -----
        None

        Parameters:
        -----
        id: MUint64
        	[in] -> The 64-bit name of the component 

        base: int
        	[in] -> Base face index 

        first: int
        	[in] -> First level face choice 

        level: int
        	[in] -> Level 

        path: int
        	[in] -> Path to the finest level 

        corner: int
        	[in] -> Corner choice at the finest level 


        '''
        pass

    def baseFaceId(self, id: MUint64): 
        '''
        baseFaceId(self, id: MUint64) -> MUint64

        Synopsis
        -----
        Given a 64-bit name, return the 64-bit name of the base face that
        is the parent of the given component.

        Returns:
        -----
        None

        Parameters:
        -----
        id: MUint64
        	[in] -> The 64-bit name of the component 


        '''
        pass

    def baseFaceIndexFromId(self, id: MUint64): 
        '''
        baseFaceIndexFromId(self, id: MUint64) -> int

        Synopsis
        -----
        Same as base().

        Returns:
        -----
        None

        Parameters:
        -----
        id: MUint64
        	[in] -> The 64-bit name of the component 


        '''
        pass

    def levelOneFaceId(self, id: MUint64): 
        '''
        levelOneFaceId(self, id: MUint64) -> MUint64

        Synopsis
        -----
        Given a 64-bit name, return the level one face that is the parent
        for the given component.

        Returns:
        -----
        None

        Parameters:
        -----
        id: MUint64
        	[in] -> The 64-bit name of the component 


        '''
        pass

    def levelOneFaceIndexFromId(self, id: MUint64): 
        '''
        levelOneFaceIndexFromId(self, id: MUint64) -> int

        Synopsis
        -----
        Given a 64-bit name, return the level one mesh face as an
        integer, instead of 64-bit name.

        Returns:
        -----
        None

        Parameters:
        -----
        id: MUint64
        	[in] -> The 64-bit name of the component 


        '''
        pass

    def levelOneFaceIdFromIndex(self, index: int): 
        '''
        levelOneFaceIdFromIndex(self, index: int) -> MUint64

        Synopsis
        -----
        Given a level 1 face name as integer, return it as a 64-bit name.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The 64-bit name of the component 


        '''
        pass

    def baseFaceIdFromIndex(self, index: int): 
        '''
        baseFaceIdFromIndex(self, index: int) -> MUint64

        Synopsis
        -----
        Given the index of the base face (0, 1, ... N-1), return its
        64-bit name.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The base face name as integer 0, ... N-1 


        '''
        pass

    def parentFaceId(self, id: MUint64): 
        '''
        parentFaceId(self, id: MUint64) -> MUint64

        Synopsis
        -----
        Given a 64-bit name of the face, return its parent face id. Note
        that if the given face id is from a base face (ie. it is a face
        at level 0), the returned face will be exactly the same.

        Returns:
        -----
        None

        Parameters:
        -----
        id: MUint64
        	[in] -> The 64-bit name of the component 


        '''
        pass

    def nonBaseFaceVertices(self, id: MUint64,
                        vertex1: MUint64,
                        vertex2: MUint64,
                        vertex3: MUint64,
                        vertex4: MUint64): 
        '''
        nonBaseFaceVertices(self, id: MUint64,
                        vertex1: MUint64,
                        vertex2: MUint64,
                        vertex3: MUint64,
                        vertex4: MUint64)

        Synopsis
        -----
        Return the four vertices on the given face. Note that the face
        should not be a base mesh face (the level > 0).

        Returns:
        -----
        None

        Parameters:
        -----
        id: MUint64
        	[in] -> The id of the face 

        vertex1: MUint64
        	[in] -> The first vertex 

        vertex2: MUint64
        	[in] -> The second vertex 

        vertex3: MUint64
        	[in] -> The third vertex 

        vertex4: MUint64
        	[in] -> The fourth vertex


        '''
        pass

    def nonBaseFaceEdges(self, id: MUint64,
                        edge1: MUint64,
                        edge2: MUint64,
                        edge3: MUint64,
                        edge4: MUint64): 
        '''
        nonBaseFaceEdges(self, id: MUint64,
                        edge1: MUint64,
                        edge2: MUint64,
                        edge3: MUint64,
                        edge4: MUint64)

        Synopsis
        -----
        Return the four edges on the given face. Note that the face
        should not be a base mesh face (the level > 0).

        Returns:
        -----
        None

        Parameters:
        -----
        id: MUint64
        	[in] -> The id of the face 

        edge1: MUint64
        	[in] -> The first edge 

        edge2: MUint64
        	[in] -> The second edge 

        edge3: MUint64
        	[in] -> The third edge 

        edge4: MUint64
        	[in] -> The fourth edge


        '''
        pass

    def fromSelectionIndices(self, id: MUint64,
                        firstIndex: int,
                        secondIndex: int): 
        '''
        fromSelectionIndices(self, id: MUint64,
                        firstIndex: int,
                        secondIndex: int)

        Synopsis
        -----
        Given the two integers that would show as selection indices for
        the subd component, return the 64-bit name for that component.

        Returns:
        -----
        None

        Parameters:
        -----
        id: MUint64
        	[in] -> The 64-bit name of the component 

        firstIndex: int
        	[in] -> The first selection index 

        secondIndex: int
        	[in] -> The second selection index 


        '''
        pass

    def toSelectionIndices(self, id: MUint64,
                        firstIndex: int,
                        secondIndex: int): 
        '''
        toSelectionIndices(self, id: MUint64,
                        firstIndex: int,
                        secondIndex: int)

        Synopsis
        -----
        Given a 64-bit name, return the two integers that will show up as
        selection indices for that subd component.

        Returns:
        -----
        None

        Parameters:
        -----
        id: MUint64
        	[in] -> The 64-bit name of the component 

        firstIndex: int
        	[out] -> The first selection index 

        secondIndex: int
        	[out] -> The second selection index 


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MFnToolContext:
    '''Tool context function set.
MFnToolContext is the function set that is used for querying tool contexts.
Typically this could be used in conjunction with
MGlobal::currentToolContext().
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kToolContext.Reimplemented from MFnBase.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnToolContext.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnToolContext".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def name(self, ReturnStatus: MFnToolContext.MStatus): 
        '''
        name(self, ReturnStatus: MFnToolContext.MStatus) -> MString

        Synopsis
        -----
        Returns the tool context's name.

        Returns: 
        ----- 
        Name string

        Parameters:
        -----
        ReturnStatus: MFnToolContext.MStatus
        	[out] -> return status


        '''
        pass

    def title(self, ReturnStatus: MFnToolContext.MStatus): 
        '''
        title(self, ReturnStatus: MFnToolContext.MStatus) -> MString

        Synopsis
        -----
        Returns the tool context's title.

        Returns: 
        ----- 
        Title string

        Parameters:
        -----
        ReturnStatus: MFnToolContext.MStatus
        	[out] -> return status


        '''
        pass

class MFnTransform:
    '''Create and access transform nodes.
The
MFnTransform function set provides access to transformation DAG nodes called
transforms.
DAG nodes are separated into two types, transforms and geometry
nodes. All DAG nodes that are not transform nodes must exist as a
child of a transform node. Only transforms provide transformation
information. Transforms are also commonly used as parent nodes
for the purpose of hierarchical grouping.
The transformation in the node is represented as a 4x4
transformation matrix. This function set allows access to the
whole matrix, or the individual components (eg scale, rotation,
shear, etc) of the transformation. The transform node is made up
of many components that make up the final transformation matrix.
This breakdown provides animators fine control over the animation
of these parameters. Therefore, it is necessary to describe the
order in which these attributes are applied to build the final
matrix attribute.
A transformation matrix is composed of the following components.
All components with units will be in Maya's internal units
(radians for rotations and centimeters for translations):
The matrices are post-multiplied in Maya. For example, to
transform a point P from object-space to world-space (P') you
would need to post-multiply by the worldMatrix. (P' = P x WM)
The transformation matrix is then constructed as follows:
where 'x' denotes matrix multiplication and '-1' denotes matrix
inversion
Note that internally the Maya transform does not store the
individual component values in matrices. It stores them in the
data structure which makes the most sense for that component. For
example, translation is stored as a vector. The accessor methods
on
MFnTransform provide the data in their native structure rather than as a
matrix.
Additionally, each transform can save a temporary "rest position"
matrix using the setRestPosition method. The rest position is not
used internally by Maya. It is exclusively for use from the API
as a temporary cache, which can be set and restored within a
single Maya session. Note that the rest position is not saved
with the scene.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kTransform.Reimplemented from MFnDagNode.Reimplemented in
        MFnIkJoint, MFnRotateManip, MFnScaleManip,
        MFnFreePointTriadManip, MFnToggleManip, MFnHikEffector,
        MFnDirectionManip, MFnDistanceManip, MFnIkEffector, MFnManip3D,
        MFnStateManip, MFnCircleSweepManip, MFnCurveSegmentManip,
        MFnPointOnCurveManip, MFnPointOnSurfaceManip, MFnDiscManip, and
        MFnIkHandle.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnTransform.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnTransform".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, parent: MObject,
                        ReturnStatus: MFnTransform.MStatus): 
        '''
        create(self, parent: MObject,
                        ReturnStatus: MFnTransform.MStatus) -> MObject

        Synopsis
        -----
        Creates a new transformation node. The new node is placed in the
        DAG.

        Returns: 
        ----- 
        The newly created transform node object

        Parameters:
        -----
        parent: MObject
        	[in] -> the parent of the transform to be created 

        ReturnStatus: MFnTransform.MStatus
        	[out] -> status code


        '''
        pass

    def transformation(self, ReturnStatus: MFnTransform.MStatus): 
        '''
        transformation(self, ReturnStatus: MFnTransform.MStatus) -> MTransformationMatrix

        Synopsis
        -----
        Retrieve the transformation matrix represented by this transform.

        Returns: 
        ----- 
        The transformation matrix represented by this transform.

        Parameters:
        -----
        ReturnStatus: MFnTransform.MStatus
        	[out] -> status code


        '''
        pass

    def set(self, transform: MTransformationMatrix): 
        '''
        set(self, transform: MTransformationMatrix)

        Synopsis
        -----
        Change this transform to equal the given matrix.

        Returns:
        -----
        None

        Parameters:
        -----
        transform: MTransformationMatrix
        	[in] -> the matrix to copy


        '''
        pass

    def resetTransformation(self, m: MMatrix): 
        '''
        resetTransformation(self, m: MMatrix)

        Synopsis
        -----
        Reset this transform to equal the given matrix in world space.

        Returns:
        -----
        None

        Parameters:
        -----
        m: MMatrix
        	[in] -> 


        '''
        pass

    def getTranslation(self, space: MSpace.MSpace,
                        ReturnStatus: MFnTransform.MStatus): 
        '''
        getTranslation(self, space: MSpace.MSpace,
                        ReturnStatus: MFnTransform.MStatus) -> MVector

        Synopsis
        -----
        Retrieve the translation component of this transformation in
        centimeters.

        Returns: 
        ----- 
        Translation vector in centimeters

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> transform space in which to get the translation 

        ReturnStatus: MFnTransform.MStatus
        	[out] -> return status


        '''
        pass

    def setTranslation(self, vector: MVector,
                        space: MSpace.MSpace): 
        '''
        setTranslation(self, vector: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Change the translation component of this transformation.

        Returns:
        -----
        None

        Parameters:
        -----
        vector: MVector
        	[in] -> the new translation vector in centimeters 

        space: MSpace.MSpace
        	[in] -> transform space in which to perform the translation


        '''
        pass

    def translateBy(self, vector: MVector,
                        space: MSpace.MSpace): 
        '''
        translateBy(self, vector: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Relatively change the translation component of this
        transformation.

        Returns:
        -----
        None

        Parameters:
        -----
        vector: MVector
        	[in] -> the relative translation vector 

        space: MSpace.MSpace
        	[in] -> transform space in which to perform the translation


        '''
        pass

    def getScale(self, scale: double3): 
        '''
        getScale(self, scale: double3)

        Synopsis
        -----
        Retrieve the scaling component of this transformation.

        Returns:
        -----
        None

        Parameters:
        -----
        scale: double3
        	[out] -> Storage for the scale of the transform


        '''
        pass

    def setScale(self, scale: double3): 
        '''
        setScale(self, scale: double3)

        Synopsis
        -----
        Set the scaling component of this transformation.

        Returns:
        -----
        None

        Parameters:
        -----
        scale: double3
        	[in] -> The scale of the transform


        '''
        pass

    def scaleBy(self, scale: double3): 
        '''
        scaleBy(self, scale: double3)

        Synopsis
        -----
        Relatively scale this transformation.

        Returns:
        -----
        None

        Parameters:
        -----
        scale: double3
        	[in] -> The ratio by which to scale the transform


        '''
        pass

    def scalePivot(self, space: MSpace.MSpace,
                        ReturnStatus: MFnTransform.MStatus): 
        '''
        scalePivot(self, space: MSpace.MSpace,
                        ReturnStatus: MFnTransform.MStatus) -> MPoint

        Synopsis
        -----
        Returns the pivot around which the scale is applied. The pivot
        will be in centimeters.

        Returns: 
        ----- 
        Scale pivot point in centimeters

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> space in which to get the pivot 

        ReturnStatus: MFnTransform.MStatus
        	[out] -> return status


        '''
        pass

    def setScalePivot(self, point: MPoint,
                        space: MSpace.MSpace,
                        balance: bool): 
        '''
        setScalePivot(self, point: MPoint,
                        space: MSpace.MSpace,
                        balance: bool)

        Synopsis
        -----
        Set the pivot around which the scale is applied in centimeters.
        If balance if true, then the overall transformation matrix will
        not change and a compensating transformation will be added to the
        scale pivot translation to to compensate for the new scale pivot.

        Returns:
        -----
        None

        Parameters:
        -----
        point: MPoint
        	[in] -> new scale pivot in centimeters 

        space: MSpace.MSpace
        	[in] -> transform space in which to set the scale pivot 

        balance: bool
        	[in] -> whether to balance the matrix


        '''
        pass

    def scalePivotTranslation(self, space: MSpace.MSpace,
                        ReturnStatus: MFnTransform.MStatus): 
        '''
        scalePivotTranslation(self, space: MSpace.MSpace,
                        ReturnStatus: MFnTransform.MStatus) -> MVector

        Synopsis
        -----
        Returns the scale pivot translation in centimeters. This
        component is used as a compensation by maya when the user moves
        the scale pivot, or when the balance flag is set to true in the
        MfnTransform::setScalePivot method. The scale pivot translation
        serves as a compensation that allows existing transformations to
        be preserved when the scale pivot is modified. For the precise
        mathematics, refer to the transformation matrix details in the
        description section of MFnTransform.

        Returns: 
        ----- 
        Scale pivot translation in centimeters

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> space in which to get the scale pivot translation 

        ReturnStatus: MFnTransform.MStatus
        	[out] -> return status


        '''
        pass

    def setScalePivotTranslation(self, vector: MVector,
                        space: MSpace.MSpace): 
        '''
        setScalePivotTranslation(self, vector: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the scale pivot translation in centimeters. This component is
        used internally by maya when the user moves the scale pivot, or
        when the balance flag is set to true in the
        MfnTransform::setScalePivot method. It serves as a compensation
        that allows existing transformations to be preserved when the
        scale pivot is modified. For the precise mathematics, refer to
        the transformation matrix details in the description section of
        MFnTransform.

        Returns:
        -----
        None

        Parameters:
        -----
        vector: MVector
        	[in] -> new scale pivot translation in centimeters 

        space: MSpace.MSpace
        	[in] -> transform space in which to set the scale translation


        '''
        pass

    def getShear(self, shear: double3): 
        '''
        getShear(self, shear: double3)

        Synopsis
        -----
        Retrieve the shearing component of this transformation.

        Returns:
        -----
        None

        Parameters:
        -----
        shear: double3
        	[out] -> Storage for the shear of the transform


        '''
        pass

    def setShear(self, shear: double3): 
        '''
        setShear(self, shear: double3)

        Synopsis
        -----
        Set the shearing component of this transformation.

        Returns:
        -----
        None

        Parameters:
        -----
        shear: double3
        	[in] -> The shear of the transform


        '''
        pass

    def shearBy(self, shear: double3): 
        '''
        shearBy(self, shear: double3)

        Synopsis
        -----
        Relatively shear this transformation.

        Returns:
        -----
        None

        Parameters:
        -----
        shear: double3
        	[in] -> The ratio by which to shear the transform


        '''
        pass

    @overload
    def getRotation(self, quaternion: MQuaternion,
                        space: MSpace.MSpace): 
        '''
        getRotation(self, quaternion: MQuaternion,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Retrieve the rotation component of this transformation as a
        quaternion. The only valid transformation spaces for this method
        are MSpace::kTransform and MSpace::kWorld. All other spaces are
        treated as being equivalent to MSpace::kTransform.

        Returns:
        -----
        None

        Parameters:
        -----
        quaternion: MQuaternion
        	[out] -> the quaternion 

        space: MSpace.MSpace
        	[in] -> transform space in which to get the rotation


        '''
        pass

    @overload
    def setRotation(self, quaternion: MQuaternion,
                        space: MSpace.MSpace): 
        '''
        setRotation(self, quaternion: MQuaternion,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Change the rotation component of this transformation using a
        quaternion. The only valid transformation spaces for this method
        are MSpace::kTransform and MSpace::kWorld. All other spaces are
        treated as being equivalent to MSpace::kTransform.

        Returns:
        -----
        None

        Parameters:
        -----
        quaternion: MQuaternion
        	[in] -> the quaternion 

        space: MSpace.MSpace
        	[in] -> transform space in which to perform the rotation


        '''
        pass

    @overload
    def rotateBy(self, quaternion: MQuaternion,
                        space: MSpace.MSpace): 
        '''
        rotateBy(self, quaternion: MQuaternion,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Relatively change the rotation of this transformation using a
        quaternion.

        Returns:
        -----
        None

        Parameters:
        -----
        quaternion: MQuaternion
        	[in] -> the quaternion 

        space: MSpace.MSpace
        	[in] -> transform space in which to perform the rotation


        '''
        pass

    @overload
    def getRotation(self, rotation: MEulerRotation): 
        '''
        getRotation(self, rotation: MEulerRotation)

        Synopsis
        -----
        Retrieve the rotation component of this transformation. The
        rotation is retrieved in MSpace::kTransform space.

        Returns:
        -----
        None

        Parameters:
        -----
        rotation: MEulerRotation
        	[out] -> the euler rotation in radians


        '''
        pass

    @overload
    def setRotation(self, rotation: MEulerRotation): 
        '''
        setRotation(self, rotation: MEulerRotation)

        Synopsis
        -----
        Change the rotation component of this transformation. The
        rotation is set in MSpace::kTransform space.

        Returns:
        -----
        None

        Parameters:
        -----
        rotation: MEulerRotation
        	[in] -> the euler rotation


        '''
        pass

    @overload
    def rotateBy(self, rotation: MEulerRotation,
                        space: MSpace.MSpace): 
        '''
        rotateBy(self, rotation: MEulerRotation,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Relatively change the rotation component of this transformation.

        Returns:
        -----
        None

        Parameters:
        -----
        rotation: MEulerRotation
        	[in] -> the euler rotation 

        space: MSpace.MSpace
        	[in] -> transform space in which to perform the rotation


        '''
        pass

    def rotatePivot(self, space: MSpace.MSpace,
                        ReturnStatus: MFnTransform.MStatus): 
        '''
        rotatePivot(self, space: MSpace.MSpace,
                        ReturnStatus: MFnTransform.MStatus) -> MPoint

        Synopsis
        -----
        Returns the pivot about which the rotation is applied.

        Returns: 
        ----- 
        Rotation pivot point in centimeters

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> space in which to get the pivot 

        ReturnStatus: MFnTransform.MStatus
        	[out] -> return status


        '''
        pass

    def setRotatePivot(self, point: MPoint,
                        space: MSpace.MSpace,
                        balance: bool): 
        '''
        setRotatePivot(self, point: MPoint,
                        space: MSpace.MSpace,
                        balance: bool)

        Synopsis
        -----
        Set the rotate pivot in centimeters about which rotation is
        applied. If balance if true, then the overall transformation
        matrix will not change and a compensating transformation will be
        added to the rotate translate pivot to compensate for the pivot
        modification.

        Returns:
        -----
        None

        Parameters:
        -----
        point: MPoint
        	[in] -> new rotation pivot in centimeters 

        space: MSpace.MSpace
        	[in] -> transform space in which to set the pivot 

        balance: bool
        	[in] -> whether to balance the matrix


        '''
        pass

    def rotatePivotTranslation(self, space: MSpace.MSpace,
                        ReturnStatus: MFnTransform.MStatus): 
        '''
        rotatePivotTranslation(self, space: MSpace.MSpace,
                        ReturnStatus: MFnTransform.MStatus) -> MVector

        Synopsis
        -----
        Return the rotate pivot translation in centimeters. This
        component is used internally by maya when the user moves the
        rotate pivot, or when the balance flag is set to true in the
        MfnTransform::setRotatePivot method. It serves as a compensation
        that allows existing transformations to be preserved. For the
        precise mathematics, refer to the transformation matrix details
        in the description section of MFnTransform.

        Returns: 
        ----- 
        Scale pivot translation in centimeters

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> space in which to get the pivot translation 

        ReturnStatus: MFnTransform.MStatus
        	[out] -> return status


        '''
        pass

    def setRotatePivotTranslation(self, vector: MVector,
                        space: MSpace.MSpace): 
        '''
        setRotatePivotTranslation(self, vector: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the rotate pivot translation in centimeters. This component
        is used internally by maya when the user moves the rotate pivot,
        or when the balance flag is true in the
        MFnTransform::setRotatePivot method. It serves as a compensation
        that allows existing transformations to be preserved when the
        rotate pivot is modified. For the precise mathematics, refer to
        the transformation matrix details in the description section of
        MFnTransform.

        Returns:
        -----
        None

        Parameters:
        -----
        vector: MVector
        	[in] -> new rotation pivot translation in centimeters 

        space: MSpace.MSpace
        	[in] -> transform space in which to set the rotation pivot translation


        '''
        pass

    def getRotationQuaternion(self, x: double,
                        y: double,
                        z: double,
                        w: double,
                        space: MSpace.MSpace): 
        '''
        getRotationQuaternion(self, x: double,
                        y: double,
                        z: double,
                        w: double,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Retrieve the rotation component of this transformation as a
        quaternion. The only valid transformation spaces for this method
        are MSpace::kTransform and MSpace::kWorld. All other spaces are
        treated as being equivalent to MSpace::kTransform.

        Returns:
        -----
        None

        Parameters:
        -----
        x: double
        	[out] -> storage for the x component of the quaternion 

        y: double
        	[out] -> storage for the y component of the quaternion 

        z: double
        	[out] -> storage for the z component of the quaternion 

        w: double
        	[out] -> storage for the w component of the quaternion 

        space: MSpace.MSpace
        	[in] -> transform space in which to get the rotation


        '''
        pass

    def setRotationQuaternion(self, x: double,
                        y: double,
                        z: double,
                        w: double,
                        space: MSpace.MSpace): 
        '''
        setRotationQuaternion(self, x: double,
                        y: double,
                        z: double,
                        w: double,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Change the rotation component of this transformation using a
        quaternion. The only valid transformation spaces for this method
        are MSpace::kTransform and MSpace::kWorld. All other spaces are
        treated as being equivalent to MSpace::kTransform.

        Returns:
        -----
        None

        Parameters:
        -----
        x: double
        	[in] -> x component of the quaternion 

        y: double
        	[in] -> y component of the quaternion 

        z: double
        	[in] -> z component of the quaternion 

        w: double
        	[in] -> w component of the quaternion 

        space: MSpace.MSpace
        	[in] -> transform space in which to perform the rotation


        '''
        pass

    def rotateByQuaternion(self, x: double,
                        y: double,
                        z: double,
                        w: double,
                        space: MSpace.MSpace): 
        '''
        rotateByQuaternion(self, x: double,
                        y: double,
                        z: double,
                        w: double,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Relatively change the rotation of this transformation using a
        quaternion.

        Returns:
        -----
        None

        Parameters:
        -----
        x: double
        	[in] -> x component of the quaternion 

        y: double
        	[in] -> y component of the quaternion 

        z: double
        	[in] -> z component of the quaternion 

        w: double
        	[in] -> w component of the quaternion 

        space: MSpace.MSpace
        	[in] -> transform space in which to perform the rotation


        '''
        pass

    @overload
    def getRotation(self, rotation: double3,
                        order: MTransformationMatrix.MTransformationMatrix): 
        '''
        getRotation(self, rotation: double3,
                        order: MTransformationMatrix.MTransformationMatrix)

        Synopsis
        -----
        Retrieve the rotation component of this transformation. The
        rotation is retrieved in MSpace::kTransform space.

        Returns:
        -----
        None

        Parameters:
        -----
        rotation: double3
        	[out] -> storage for the rotation components 

        order: MTransformationMatrix.MTransformationMatrix
        	[out] -> storage for the order of rotation


        '''
        pass

    @overload
    def setRotation(self, rotation: double3,
                        order: MTransformationMatrix.MTransformationMatrix): 
        '''
        setRotation(self, rotation: double3,
                        order: MTransformationMatrix.MTransformationMatrix)

        Synopsis
        -----
        Change the rotation component of this transformation. The
        rotation is set in MSpace::kTransform space.

        Returns:
        -----
        None

        Parameters:
        -----
        rotation: double3
        	[in] -> the new rotation components 

        order: MTransformationMatrix.MTransformationMatrix
        	[in] -> the order in which to apply the rotations


        '''
        pass

    @overload
    def rotateBy(self, rotation: double3,
                        order: MTransformationMatrix.MTransformationMatrix,
                        space: MSpace.MSpace): 
        '''
        rotateBy(self, rotation: double3,
                        order: MTransformationMatrix.MTransformationMatrix,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Relatively change the rotation component of this transformation.

        Returns:
        -----
        None

        Parameters:
        -----
        rotation: double3
        	[in] -> the relative rotation components 

        order: MTransformationMatrix.MTransformationMatrix
        	[in] -> the order in which to apply the rotations 

        space: MSpace.MSpace
        	[in] -> transform space in which to perform the rotation


        '''
        pass

    def rotateOrientation(self, space: MSpace.MSpace,
                        ReturnStatus: MFnTransform.MStatus): 
        '''
        rotateOrientation(self, space: MSpace.MSpace,
                        ReturnStatus: MFnTransform.MStatus) -> MQuaternion

        Synopsis
        -----
        Returns the rotation used to orient the local rotation space. For
        the precise mathematics, refer to the transformation matrix
        details in the description section of MFnTransform.

        Returns: 
        ----- 
        Rotateorientation

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> space in which to get the rotation orientation. This argument is currently ignored. The rotateOrientation is always returned in local space: 

        ReturnStatus: MFnTransform.MStatus
        	[out] -> return status


        '''
        pass

    def setRotateOrientation(self, quat: MQuaternion,
                        space: MSpace.MSpace,
                        balance: bool): 
        '''
        setRotateOrientation(self, quat: MQuaternion,
                        space: MSpace.MSpace,
                        balance: bool)

        Synopsis
        -----
        Set the rotation used to orient the local rotation space. For the
        precise mathematics, refer to the transformation matrix details
        in the description section of MFnTransform.If balance if true,
        then the overall transformation matrix will not change and the
        rotation will be modified to achieve this.

        Returns:
        -----
        None

        Parameters:
        -----
        quat: MQuaternion
        	[in] -> new orientation as a quaternion 

        space: MSpace.MSpace
        	[in] -> transform space in which to set the rotateOrientation. This argument is currently ignored. The rotateOrientation always set in local space: 

        balance: bool
        	[in] -> whether to balance the overall transformation matrix


        '''
        pass

    def rotationOrder(self, ReturnStatus: MFnTransform.MStatus): 
        '''
        rotationOrder(self, ReturnStatus: MFnTransform.MStatus) -> MTransformationMatrix.MTransformationMatrix

        Synopsis
        -----
        Returns the rotation order for the transform matrix - the order
        in which the Euler angles are applied to create the end rotation.

        Returns: 
        ----- 
        rotation order

        Parameters:
        -----
        ReturnStatus: MFnTransform.MStatus
        	[out] -> return status


        '''
        pass

    def setRotationOrder(self, order: MTransformationMatrix.MTransformationMatrix,
                        reorder: bool): 
        '''
        setRotationOrder(self, order: MTransformationMatrix.MTransformationMatrix,
                        reorder: bool)

        Synopsis
        -----
        Change the rotation order for the transform - the order in which
        the Euler angles are applied to create the end rotation.

        Returns:
        -----
        None

        Parameters:
        -----
        order: MTransformationMatrix.MTransformationMatrix
        	[in] -> the order in which to apply rotations 

        reorder: bool
        	[in] -> flag indicating whether or not rotations should be reordered.


        '''
        pass

    def restPosition(self, ReturnStatus: MFnTransform.MStatus): 
        '''
        restPosition(self, ReturnStatus: MFnTransform.MStatus) -> MTransformationMatrix

        Synopsis
        -----
        Retrieve the saved rest position of this transform.

        Returns: 
        ----- 
        The transformation matrix equivalent to the transform's rest
        position. This rest position will be identity unless the
        "setRestPosition" method has been called.

        Parameters:
        -----
        ReturnStatus: MFnTransform.MStatus
        	[out] -> status code


        '''
        pass

    def setRestPosition(self, matrix: MTransformationMatrix): 
        '''
        setRestPosition(self, matrix: MTransformationMatrix)

        Synopsis
        -----
        Change the saved rest position of this transform. The rest
        position is not used internally by Maya. It is exclusively for
        use from the API as a temporary cache, which can be set and
        restored within a single Maya session. Note that the rest
        position is not saved with the scene.

        Returns:
        -----
        None

        Parameters:
        -----
        matrix: MTransformationMatrix
        	[in] -> the new rest position for this transform


        '''
        pass

    def resetFromRestPosition(self): 
        '''
        resetFromRestPosition(self)

        Synopsis
        -----
        Reset the transform to its rest position.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def clearRestPosition(self): 
        '''
        clearRestPosition(self)

        Synopsis
        -----
        Clear the saved rest position of this transform.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isLimited(self, type: MFnTransform.MFnTransform,
                        ReturnStatus: MFnTransform.MStatus): 
        '''
        isLimited(self, type: MFnTransform.MFnTransform,
                        ReturnStatus: MFnTransform.MStatus) -> bool

        Synopsis
        -----
        Determine if the specified limit attribute is enabled or
        disabled.

        Returns: 
        ----- 
        True or false, true means the limit is enabled.

        Parameters:
        -----
        type: MFnTransform.MFnTransform
        	[in] -> type to query limit 

        ReturnStatus: MFnTransform.MStatus
        	[out] -> status code


        '''
        pass

    def limitValue(self, type: MFnTransform.MFnTransform,
                        ReturnStatus: MFnTransform.MStatus): 
        '''
        limitValue(self, type: MFnTransform.MFnTransform,
                        ReturnStatus: MFnTransform.MStatus) -> double

        Synopsis
        -----
        Determine the current value of the specified limit.

        Returns: 
        ----- 
        Current value of the specified limit as internal unit.

        Parameters:
        -----
        type: MFnTransform.MFnTransform
        	[in] -> type to query limit 

        ReturnStatus: MFnTransform.MStatus
        	[out] -> status code


        '''
        pass

    def setLimit(self, type: MFnTransform.MFnTransform,
                        value: double): 
        '''
        setLimit(self, type: MFnTransform.MFnTransform,
                        value: double)

        Synopsis
        -----
        Change the limit value for the specified limit type, and
        automatically enable the limit to be true.

        Returns:
        -----
        None

        Parameters:
        -----
        type: MFnTransform.MFnTransform
        	[in] -> type to apply a limit 

        value: double
        	[in] -> new limit value as internal unit


        '''
        pass

    def enableLimit(self, type: MFnTransform.MFnTransform,
                        flag: bool): 
        '''
        enableLimit(self, type: MFnTransform.MFnTransform,
                        flag: bool)

        Synopsis
        -----
        Enable or disable the limit value for the specified limit type.

        Returns:
        -----
        None

        Parameters:
        -----
        type: MFnTransform.MFnTransform
        	[in] -> type to apply a limit 

        flag: bool
        	[in] -> true or false to enable


        '''
        pass

    def balanceTransformation(self, localTranslate: MVector,
                        localRotate: MEulerRotation,
                        localScale: MVector,
                        mtx: MTransformationMatrix,
                        rotateAxis: MQuaternion,
                        jointOrient: MQuaternion,
                        segmentScaleCompensate: bool,
                        inverseScale: MVector,
                        rotateOrder: MEulerRotation.MEulerRotation): 
        '''
        balanceTransformation(self, localTranslate: MVector,
                        localRotate: MEulerRotation,
                        localScale: MVector,
                        mtx: MTransformationMatrix,
                        rotateAxis: MQuaternion,
                        jointOrient: MQuaternion,
                        segmentScaleCompensate: bool,
                        inverseScale: MVector,
                        rotateOrder: MEulerRotation.MEulerRotation)

        Synopsis
        -----
        Balance a transformation when applying a world matrix to a joint.
        This accesses the same underlying functionality as the xform
        command.

        Returns:
        -----
        None

        Parameters:
        -----
        localTranslate: MVector
        	[out] -> The resulting translation, as an 

        localRotate: MEulerRotation
        	[out] -> The resulting rotation for the joint, as an 

        localScale: MVector
        	[out] -> The resulting scale for the joint, as an 

        mtx: MTransformationMatrix
        	[in] -> The world matrix to be applied to the joint node, as an 

        rotateAxis: MQuaternion
        	[in] -> The joint's rotateAxis attribute, as an 

        jointOrient: MQuaternion
        	[in] -> The joint's jointOrient attribute, as an 

        segmentScaleCompensate: bool
        	[in] -> The joint's segmentScaleCompensate attribute, as a bool 

        inverseScale: MVector
        	[in] -> The joint's inverseScale attribute, as an 

        rotateOrder: MEulerRotation.MEulerRotation
        	[in] -> The joint's rotateOrder attribute, as an 


        '''
        pass

class LimitType:
    '''Limit types. 
    Non-functional class.  Values for this enum:
    kScaleMinX
    kScaleMaxX
    kScaleMinY
    kScaleMaxY
    kScaleMinZ
    kScaleMaxZ
    kShearMinXY
    kShearMaxXY
    kShearMinXZ
    kShearMaxXZ
    kShearMinYZ
    kShearMaxYZ
    kRotateMinX
    kRotateMaxX
    kRotateMinY
    kRotateMaxY
    kRotateMinZ
    kRotateMaxZ
    kTranslateMinX
    kTranslateMaxX
    kTranslateMinY
    kTranslateMaxY
    kTranslateMinZ
    kTranslateMaxZ
    '''

    def __init__(self):
        pass

    def kScaleMinX(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 0
        '''
        pass

    def kScaleMaxX(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 1
        '''
        pass

    def kScaleMinY(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 2
        '''
        pass

    def kScaleMaxY(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 3
        '''
        pass

    def kScaleMinZ(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 4
        '''
        pass

    def kScaleMaxZ(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 5
        '''
        pass

    def kShearMinXY(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 6
        '''
        pass

    def kShearMaxXY(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 7
        '''
        pass

    def kShearMinXZ(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 8
        '''
        pass

    def kShearMaxXZ(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 9
        '''
        pass

    def kShearMinYZ(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 10
        '''
        pass

    def kShearMaxYZ(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 11
        '''
        pass

    def kRotateMinX(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 12
        '''
        pass

    def kRotateMaxX(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 13
        '''
        pass

    def kRotateMinY(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 14
        '''
        pass

    def kRotateMaxY(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 15
        '''
        pass

    def kRotateMinZ(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 16
        '''
        pass

    def kRotateMaxZ(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 17
        '''
        pass

    def kTranslateMinX(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 18
        '''
        pass

    def kTranslateMaxX(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 19
        '''
        pass

    def kTranslateMinY(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 20
        '''
        pass

    def kTranslateMaxY(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 21
        '''
        pass

    def kTranslateMinZ(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 22
        '''
        pass

    def kTranslateMaxZ(self):
        '''This is an enum of LimitType.
        - Description:  
        - Value: 23
        '''
        pass

class MFnTripleIndexedComponent:
    '''Triple indexed component function set.
This function set allows you to create, edit, and query triple
indexed components. Triple indexed components store 3 dimensional
index values.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kTripleIndexedComponent.Reimplemented from MFnComponent.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnTripleIndexedComponent.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnTripleIndexedComponent".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, compType: MFn.MFn,
                        ReturnStatus: MFnTripleIndexedComponent.MStatus): 
        '''
        create(self, compType: MFn.MFn,
                        ReturnStatus: MFnTripleIndexedComponent.MStatus) -> MObject

        Synopsis
        -----
        Create a triple indexed component of the given type. Allowable
        types areMFn::kLatticeComponent

        Returns: 
        ----- 
        The new component

        Parameters:
        -----
        compType: MFn.MFn
        	[in] -> the type of component to create 

        ReturnStatus: MFnTripleIndexedComponent.MStatus
        	[out] -> status code


        '''
        pass

    def addElement(self, sIndex: int,
                        tIndex: int,
                        uIndex: int): 
        '''
        addElement(self, sIndex: int,
                        tIndex: int,
                        uIndex: int)

        Synopsis
        -----
        Add the specified element to the component.

        Returns:
        -----
        None

        Parameters:
        -----
        sIndex: int
        	[in] -> the s index to add 

        tIndex: int
        	[in] -> the t index to add 

        uIndex: int
        	[in] -> the u index to add


        '''
        pass

    def addElements(self, sIndices: MIntArray,
                        tIndices: MIntArray,
                        uIndices: MIntArray): 
        '''
        addElements(self, sIndices: MIntArray,
                        tIndices: MIntArray,
                        uIndices: MIntArray)

        Synopsis
        -----
        Add the specified elements to the component.

        Returns:
        -----
        None

        Parameters:
        -----
        sIndices: MIntArray
        	[in] -> the array of s indices to be added 

        tIndices: MIntArray
        	[in] -> the array of t indices to be added 

        uIndices: MIntArray
        	[in] -> the array of u indices to be added


        '''
        pass

    def getElement(self, index: int,
                        sIndex: int,
                        tIndex: int,
                        uIndex: int): 
        '''
        getElement(self, index: int,
                        sIndex: int,
                        tIndex: int,
                        uIndex: int)

        Synopsis
        -----
        Get the specified element from the component.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the index of the element to retrieve 

        sIndex: int
        	[out] -> the s index of the component 

        tIndex: int
        	[out] -> the t index of the component 

        uIndex: int
        	[out] -> the u index of the component


        '''
        pass

    def getElements(self, sIndices: MIntArray,
                        tIndices: MIntArray,
                        uIndices: MIntArray): 
        '''
        getElements(self, sIndices: MIntArray,
                        tIndices: MIntArray,
                        uIndices: MIntArray)

        Synopsis
        -----
        Get all of the element indices from the component.

        Returns:
        -----
        None

        Parameters:
        -----
        sIndices: MIntArray
        	[out] -> storage for the array of s indices 

        tIndices: MIntArray
        	[out] -> storage for the array of t indices 

        uIndices: MIntArray
        	[out] -> storage for the array of u indices


        '''
        pass

    def setCompleteData(self, maxS: int,
                        maxT: int,
                        maxU: int): 
        '''
        setCompleteData(self, maxS: int,
                        maxT: int,
                        maxU: int)

        Synopsis
        -----
        Marks the component as complete (meaning all items are selected)
        and uses the argument to identify the total number of elements
        selected. If the component should contain N element indices, then
        the range would be [0,N-1].Also sets the complete state of the
        component to 'true' (i.e. setComplete(true)).

        Returns:
        -----
        None

        Parameters:
        -----
        maxS: int
        	[in] -> the maximum number of S elements 

        maxT: int
        	[in] -> the maximum number of T elements 

        maxU: int
        	[in] -> the maximum number of U elements


        '''
        pass

    def getCompleteData(self, maxS: int,
                        maxT: int,
                        maxU: int): 
        '''
        getCompleteData(self, maxS: int,
                        maxT: int,
                        maxU: int)

        Synopsis
        -----
        Returns the number of elements for the complete component. A
        complete component means that all elements are selected.

        Returns:
        -----
        None

        Parameters:
        -----
        maxS: int
        	[out] -> storage for the maximum number of S elements 

        maxT: int
        	[out] -> storage for the maximum number of T elements 

        maxU: int
        	[out] -> storage for the maximum number of U elements


        '''
        pass

class MFnTypedAttribute:
    '''Typed attribute function set.
MFnTypedAttribute is the function set for typed dependency node attributes. A
typed attribute accepts exactly one type of data. The type that
it accepts is set when the attribute is created.
Once a typed attribute had been created, the data for it can be
accessed using an
MDataHandle while in your node's compute method.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kTypedAttribute.Reimplemented from MFnAttribute.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnTypedAttribute.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnTypedAttribute".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def create(self, fullName: MString,
                        briefName: MString,
                        id: MTypeId,
                        defaultData: MObject,
                        ReturnStatus: MFnTypedAttribute.MStatus): 
        '''
        create(self, fullName: MString,
                        briefName: MString,
                        id: MTypeId,
                        defaultData: MObject,
                        ReturnStatus: MFnTypedAttribute.MStatus) -> MObject

        Synopsis
        -----
        Create a new typed attribute with the given type.

        Returns: 
        ----- 
        Pointer to the new attribute object.

        Parameters:
        -----
        fullName: MString
        	[in] -> Full name for the new attribute. 

        briefName: MString
        	[in] -> Short name for the attribute. 

        id: MTypeId
        	[in] -> Type id of the attribute's data. 

        defaultData: MObject
        	[in] -> Default data for the attribute. 

        ReturnStatus: MFnTypedAttribute.MStatus
        	[out] -> Return status.


        '''
        pass

    @overload
    def create(self, fullName: MString,
                        briefName: MString,
                        type: MFnData.MFnData,
                        defaultData: MObject,
                        ReturnStatus: MFnTypedAttribute.MStatus): 
        '''
        create(self, fullName: MString,
                        briefName: MString,
                        type: MFnData.MFnData,
                        defaultData: MObject,
                        ReturnStatus: MFnTypedAttribute.MStatus) -> MObject

        Synopsis
        -----
        Create a new typed attribute with the given type. The create
        method needs to be called on a per node basis. That means if you
        want to create and add the same attribute to multiple nodes, you
        need to call the create method for each node to get a unique
        MObject back. If you call create just once and add the attribute
        to multiple nodes, Maya will encounter a fatal error.

        Returns: 
        ----- 
        Pointer to the new attribute object.

        Parameters:
        -----
        fullName: MString
        	[in] -> Full name for the new attribute. 

        briefName: MString
        	[in] -> Short name for the attribute. 

        type: MFnData.MFnData
        	[in] -> Type of the attribute's data. 

        defaultData: MObject
        	[in] -> Default data for the attribute. 

        ReturnStatus: MFnTypedAttribute.MStatus
        	[out] -> Return status.


        '''
        pass

    def attrType(self, ReturnStatus: MFnTypedAttribute.MStatus): 
        '''
        attrType(self, ReturnStatus: MFnTypedAttribute.MStatus) -> MFnData.MFnData

        Synopsis
        -----
        Return the type of this attribute.

        Returns: 
        ----- 
        An element of the MFnData::Type enum.

        Parameters:
        -----
        ReturnStatus: MFnTypedAttribute.MStatus
        	[out] -> 


        '''
        pass

    def getDefault(self, defaultData: MObject): 
        '''
        getDefault(self, defaultData: MObject)

        Synopsis
        -----
        Get the default data for this attribute. The data can then be
        operated on using the appropriate MFn*Data functionset.

        Returns:
        -----
        None

        Parameters:
        -----
        defaultData: MObject
        	[out] -> receives a copy of the attribute's default data.


        '''
        pass

    def setDefault(self, defaultData: MObject): 
        '''
        setDefault(self, defaultData: MObject)

        Synopsis
        -----
        Set the default data for this attribute. The data can be created
        using the appropriate MFn*Data function set.

        Returns:
        -----
        None

        Parameters:
        -----
        defaultData: MObject
        	[in] -> default data for the attribute


        '''
        pass

class MFnUint64SingleIndexedComponent:
    '''Single MUint64 indexed component function set.
This function set allows you to create, edit, and query single
MUint64 indexed components. Single indexed components store 1
dimensional index values, where each value is an MUint64.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kUint64SingleIndexedComponent.Reimplemented from
        MFnComponent.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnUint64SingleIndexedComponent.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnUint64SingleIndexedComponent".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def create(self, compType: MFn.MFn,
                        ReturnStatus: MFnUint64SingleIndexedComponent.MStatus): 
        '''
        create(self, compType: MFn.MFn,
                        ReturnStatus: MFnUint64SingleIndexedComponent.MStatus) -> MObject

        Synopsis
        -----
        Create a single indexed component of the given type. Allowable
        types areMFn::kSubdivCVComponent MFn::kSubdivEdgeComponent
        MFn::kSubdivFaceComponent

        Returns: 
        ----- 
        The new component

        Parameters:
        -----
        compType: MFn.MFn
        	[in] -> the type of component to create 

        ReturnStatus: MFnUint64SingleIndexedComponent.MStatus
        	[out] -> status code


        '''
        pass

    def addElement(self, element: MUint64): 
        '''
        addElement(self, element: MUint64)

        Synopsis
        -----
        Add the specified element to the component.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MUint64
        	[in] -> the element index to be added


        '''
        pass

    def addElements(self, elements: MUint64Array): 
        '''
        addElements(self, elements: MUint64Array)

        Synopsis
        -----
        Add the specified elements to the component.

        Returns:
        -----
        None

        Parameters:
        -----
        elements: MUint64Array
        	[in] -> the array of element indices to be added


        '''
        pass

    def element(self, index: int,
                        ReturnStatus: MFnUint64SingleIndexedComponent.MStatus): 
        '''
        element(self, index: int,
                        ReturnStatus: MFnUint64SingleIndexedComponent.MStatus) -> MUint64

        Synopsis
        -----
        Returns the specified element from the component.

        Returns: 
        ----- 
        The index of the specified component

        Parameters:
        -----
        index: int
        	[in] -> the index of the element to retrieve 

        ReturnStatus: MFnUint64SingleIndexedComponent.MStatus
        	[out] -> status code


        '''
        pass

    def getElements(self, elements: MUint64Array): 
        '''
        getElements(self, elements: MUint64Array)

        Synopsis
        -----
        Get all of the element indices from the component.

        Returns:
        -----
        None

        Parameters:
        -----
        elements: MUint64Array
        	[out] -> storage for the array of indices


        '''
        pass

    def setCompleteData(self, numElements: MUint64): 
        '''
        setCompleteData(self, numElements: MUint64)

        Synopsis
        -----
        Marks the component as complete (meaning all items are selected)
        and uses the argument to identify the total number of elements
        selected. If the component should contain N element indices, then
        the range would be [0,N-1].Also sets the complete state of the
        component to 'true' (i.e. setComplete(true)).

        Returns:
        -----
        None

        Parameters:
        -----
        numElements: MUint64
        	[in] -> the maximum number of elements in the component


        '''
        pass

    def getCompleteData(self, numElements: MUint64): 
        '''
        getCompleteData(self, numElements: MUint64)

        Synopsis
        -----
        Returns the number of elements for the complete component. A
        complete component means that all elements are selected.

        Returns:
        -----
        None

        Parameters:
        -----
        numElements: MUint64
        	[out] -> storage for the maximum number of elements


        '''
        pass

class MFnUnitAttribute:
    '''Unit attribute Function set.
MFnUnitAttribute is the function set for dependency nodes attributes that store
one of the fundamental types of Maya data. The currently
supported types are
MAngle,
MDistance, and
MTime.
It is possible to set the defaults using a double. This is valid
for angles and distances. In the case of angles, the value is
assumed to be in radians, and in the case of distances, it is
assumed to be in centimeters. Time values should not be set using
a double.
It is possible to use unit attributes in place of double
attributes when creating numeric compounds (see
MFnNumericAttrbute). To create a numeric compound of three
distance values, create the three child attributes using
MFnUnitAttribute and then pass the children into the create method of
MFnNumericAttribute.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kUnitAttribute.Reimplemented from MFnAttribute.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnUnitAttribute.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnUnitAttribute".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def create(self, fullName: MString,
                        briefName: MString,
                        unitType: MFnUnitAttribute.MFnUnitAttribute,
                        defaultValue: double,
                        ReturnStatus: MFnUnitAttribute.MStatus): 
        '''
        create(self, fullName: MString,
                        briefName: MString,
                        unitType: MFnUnitAttribute.MFnUnitAttribute,
                        defaultValue: double,
                        ReturnStatus: MFnUnitAttribute.MStatus) -> MObject

        Synopsis
        -----
        Create a new unit attribute and return it as an MObject. For both
        angle and distance attributes, the attribute is type independent.
        For example, you define an angular attribute as containing an
        angle in radians. The defaultValue passed to the create method
        must be in these units, and the value in those units will be
        returned by the get and set methods. If this method is used to
        instantiate a time attribute, the units stored in the attribute
        will be those of the current default time unit (see MTime).A unit
        attribute supports both a hard maximum/minimum and a soft
        maximum/minimum. The soft maximum/minimum are used by the user
        interface for limits on sliders, but values within the hard range
        are still valid.The create method needs to be called on a per
        node basis. That means if you want to create and add the same
        attribute to multiple nodes, you need to call the create method
        for each node to get a unique MObject back. If you call create
        just once and add the attribute to multiple nodes, Maya will
        encounter a fatal error.

        Returns: 
        ----- 
        An MObject representing the new attribute

        Parameters:
        -----
        fullName: MString
        	[in] -> the full (or int) name of the attribute 

        briefName: MString
        	[in] -> the brief (or short) name of the attribute 

        unitType: MFnUnitAttribute.MFnUnitAttribute
        	[in] -> an element of the 

        defaultValue: double
        	[in] -> the default value for the new attribute 

        ReturnStatus: MFnUnitAttribute.MStatus
        	[out] -> 



        '''
        pass

    @overload
    def create(self, fullName: MString,
                        briefName: MString,
                        defaultValue: MTime,
                        ReturnStatus: MFnUnitAttribute.MStatus): 
        '''
        create(self, fullName: MString,
                        briefName: MString,
                        defaultValue: MTime,
                        ReturnStatus: MFnUnitAttribute.MStatus) -> MObject

        Synopsis
        -----
        Create a new unit attribute of type time and return it as an
        MObject. The units of the time value stored in the attribute will
        be those of the current default time units in effect (see MTime).

        Returns: 
        ----- 
        An MObject representing the new attribute

        Parameters:
        -----
        fullName: MString
        	[in] -> the full (or int) name of the attribute 

        briefName: MString
        	[in] -> the brief (or short) name of the attribute 

        defaultValue: MTime
        	[in] -> the default value for the new attribute 

        ReturnStatus: MFnUnitAttribute.MStatus
        	[out] -> 



        '''
        pass

    @overload
    def create(self, fullName: MString,
                        briefName: MString,
                        defaultValue: MAngle,
                        ReturnStatus: MFnUnitAttribute.MStatus): 
        '''
        create(self, fullName: MString,
                        briefName: MString,
                        defaultValue: MAngle,
                        ReturnStatus: MFnUnitAttribute.MStatus) -> MObject

        Synopsis
        -----
        Create a new unit attribute of type angle and return it as an
        MObject.

        Returns: 
        ----- 
        An MObject representing the new attribute

        Parameters:
        -----
        fullName: MString
        	[in] -> the full (or int) name of the attribute 

        briefName: MString
        	[in] -> the brief (or short) name of the attribute 

        defaultValue: MAngle
        	[in] -> the default value for the new attribute 

        ReturnStatus: MFnUnitAttribute.MStatus
        	[out] -> 



        '''
        pass

    @overload
    def create(self, fullName: MString,
                        briefName: MString,
                        defaultValue: MDistance,
                        ReturnStatus: MFnUnitAttribute.MStatus): 
        '''
        create(self, fullName: MString,
                        briefName: MString,
                        defaultValue: MDistance,
                        ReturnStatus: MFnUnitAttribute.MStatus) -> MObject

        Synopsis
        -----
        Create a new unit attribute of type distance and return it as an
        MObject.

        Returns: 
        ----- 
        An MObject representing the new attribute

        Parameters:
        -----
        fullName: MString
        	[in] -> the full (or int) name of the attribute 

        briefName: MString
        	[in] -> the brief (or short) name of the attribute 

        defaultValue: MDistance
        	[in] -> the default value for the new attribute 

        ReturnStatus: MFnUnitAttribute.MStatus
        	[out] -> 



        '''
        pass

    def unitType(self, ReturnStatus: MFnUnitAttribute.MStatus): 
        '''
        unitType(self, ReturnStatus: MFnUnitAttribute.MStatus) -> MFnUnitAttribute.MFnUnitAttribute

        Synopsis
        -----
        Return the unit type of this attribute.

        Returns: 
        ----- 
        An element of the MFnUnitAttribute::Type enum

        Parameters:
        -----
        ReturnStatus: MFnUnitAttribute.MStatus
        	[out] -> 



        '''
        pass

    def hasMin(self, ReturnStatus: MFnUnitAttribute.MStatus): 
        '''
        hasMin(self, ReturnStatus: MFnUnitAttribute.MStatus) -> bool

        Synopsis
        -----
        Determine whether or not this attribute has a minimum value set.

        Returns: 
        ----- 
        true if the attribute has a minimum value, and false otherwise

        Parameters:
        -----
        ReturnStatus: MFnUnitAttribute.MStatus
        	[out] -> 



        '''
        pass

    def hasMax(self, ReturnStatus: MFnUnitAttribute.MStatus): 
        '''
        hasMax(self, ReturnStatus: MFnUnitAttribute.MStatus) -> bool

        Synopsis
        -----
        Determine whether or not this attribute has a maximum value set.

        Returns: 
        ----- 
        true if the attribute has a maximum value, and false otherwise

        Parameters:
        -----
        ReturnStatus: MFnUnitAttribute.MStatus
        	[out] -> 



        '''
        pass

    def hasSoftMin(self, ReturnStatus: MFnUnitAttribute.MStatus): 
        '''
        hasSoftMin(self, ReturnStatus: MFnUnitAttribute.MStatus) -> bool

        Synopsis
        -----
        Determine whether or not this attribute has a soft minimum value
        set.

        Returns: 
        ----- 
        true if the attribute has a minimum value, and false otherwise

        Parameters:
        -----
        ReturnStatus: MFnUnitAttribute.MStatus
        	[out] -> 



        '''
        pass

    def hasSoftMax(self, ReturnStatus: MFnUnitAttribute.MStatus): 
        '''
        hasSoftMax(self, ReturnStatus: MFnUnitAttribute.MStatus) -> bool

        Synopsis
        -----
        Determine whether or not this attribute has a soft maximum value
        set.

        Returns: 
        ----- 
        true if the attribute has a maximum value, and false otherwise

        Parameters:
        -----
        ReturnStatus: MFnUnitAttribute.MStatus
        	[out] -> 



        '''
        pass

    @overload
    def getMin(self, minValue: double): 
        '''
        getMin(self, minValue: double)

        Synopsis
        -----
        Return the minimum value for this attribute. This routine simply
        returns the numerical value of the attribute. It is up to the
        programmer to know the units used by this attribute (eg. radians
        for angular data, centimeters for distance data, etc.) and
        interpret the response appropriately.

        Returns:
        -----
        None

        Parameters:
        -----
        minValue: double
        	[out] -> the minimum value for this attribute


        '''
        pass

    @overload
    def getMin(self, minValue: MTime): 
        '''
        getMin(self, minValue: MTime)

        Synopsis
        -----
        Return the minimum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        minValue: MTime
        	[out] -> the minimum value for this attribute


        '''
        pass

    @overload
    def getMin(self, minValue: MAngle): 
        '''
        getMin(self, minValue: MAngle)

        Synopsis
        -----
        Return the minimum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        minValue: MAngle
        	[out] -> the minimum value for this attribute. The returned angle is always in radians


        '''
        pass

    @overload
    def getMin(self, minValue: MDistance): 
        '''
        getMin(self, minValue: MDistance)

        Synopsis
        -----
        Return the minimum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        minValue: MDistance
        	[out] -> the minimum value for this attribute. The returned distance is always in centimeters


        '''
        pass

    @overload
    def getMax(self, maxValue: double): 
        '''
        getMax(self, maxValue: double)

        Synopsis
        -----
        Return the maximum value for this attribute. This routine simply
        returns the numerical value of the attribute. It is up to the
        programmer to know the units used by this attribute (eg. radians
        for angular data, centimeters for distance data, etc.) and
        interpret the response appropriately.

        Returns:
        -----
        None

        Parameters:
        -----
        maxValue: double
        	[out] -> the maximum value for this attribute


        '''
        pass

    @overload
    def getMax(self, maxValue: MTime): 
        '''
        getMax(self, maxValue: MTime)

        Synopsis
        -----
        Return the maximum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        maxValue: MTime
        	[out] -> the maximum value for this attribute


        '''
        pass

    @overload
    def getMax(self, maxValue: MAngle): 
        '''
        getMax(self, maxValue: MAngle)

        Synopsis
        -----
        Return the maximum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        maxValue: MAngle
        	[out] -> the maximum value for this attribute. The returned angle is always in radians


        '''
        pass

    @overload
    def getMax(self, maxValue: MDistance): 
        '''
        getMax(self, maxValue: MDistance)

        Synopsis
        -----
        Return the maximum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        maxValue: MDistance
        	[out] -> the maximum value for this attribute. The returned distance is always in centimeters


        '''
        pass

    @overload
    def getSoftMin(self, minValue: double): 
        '''
        getSoftMin(self, minValue: double)

        Synopsis
        -----
        Return the soft minimum value for this attribute. This routine
        simply returns the numerical value of the attribute. It is up to
        the programmer to know the units used by this attribute (eg.
        radians for angular data, centimeters for distance data, etc.)
        and interpret the response appropriately.

        Returns:
        -----
        None

        Parameters:
        -----
        minValue: double
        	[out] -> the soft minimum value for this attribute


        '''
        pass

    @overload
    def getSoftMin(self, minValue: MTime): 
        '''
        getSoftMin(self, minValue: MTime)

        Synopsis
        -----
        Return the soft minimum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        minValue: MTime
        	[out] -> the soft minimum value for this attribute


        '''
        pass

    @overload
    def getSoftMin(self, minValue: MAngle): 
        '''
        getSoftMin(self, minValue: MAngle)

        Synopsis
        -----
        Return the soft minimum value for this attribute. The returned
        angle is always in radians

        Returns:
        -----
        None

        Parameters:
        -----
        minValue: MAngle
        	[out] -> the soft minimum value for this attribute


        '''
        pass

    @overload
    def getSoftMin(self, minValue: MDistance): 
        '''
        getSoftMin(self, minValue: MDistance)

        Synopsis
        -----
        Return the soft minimum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        minValue: MDistance
        	[out] -> the soft minimum value for this attribute. The returned distance is always in centimeters


        '''
        pass

    @overload
    def getSoftMax(self, maxValue: double): 
        '''
        getSoftMax(self, maxValue: double)

        Synopsis
        -----
        Return the soft maximum value for this attribute. This routine
        simply returns the numerical value of the attribute. It is up to
        the programmer to know the units used by this attribute (eg.
        radians for angular data, centimeters for distance data, etc.)
        and interpret the response appropriately.

        Returns:
        -----
        None

        Parameters:
        -----
        maxValue: double
        	[out] -> the soft maximum value for this attribute


        '''
        pass

    @overload
    def getSoftMax(self, maxValue: MTime): 
        '''
        getSoftMax(self, maxValue: MTime)

        Synopsis
        -----
        Return the soft maximum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        maxValue: MTime
        	[out] -> the soft maximum value for this attribute


        '''
        pass

    @overload
    def getSoftMax(self, maxValue: MAngle): 
        '''
        getSoftMax(self, maxValue: MAngle)

        Synopsis
        -----
        Return the soft maximum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        maxValue: MAngle
        	[out] -> the soft maximum value for this attribute. The returned angle is always in radians


        '''
        pass

    @overload
    def getSoftMax(self, maxValue: MDistance): 
        '''
        getSoftMax(self, maxValue: MDistance)

        Synopsis
        -----
        Return the soft maximum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        maxValue: MDistance
        	[out] -> the soft maximum value for this attribute. The returned distance is always in centimeters


        '''
        pass

    @overload
    def setMin(self, minValue: double): 
        '''
        setMin(self, minValue: double)

        Synopsis
        -----
        Set the minimum value for this attribute. This routine simply
        stores the given double as the numerical value of the attribute.
        It is up to the programmer to know the units used by this
        attribute (eg. radians for angular data, centimeters for distance
        data, etc.) and provide the appropriate value.

        Returns:
        -----
        None

        Parameters:
        -----
        minValue: double
        	[in] -> the new minimum value for this attribute


        '''
        pass

    @overload
    def setMin(self, minValue: MTime): 
        '''
        setMin(self, minValue: MTime)

        Synopsis
        -----
        Set the minimum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        minValue: MTime
        	[in] -> the new minimum value for this attribute


        '''
        pass

    @overload
    def setMin(self, minValue: MAngle): 
        '''
        setMin(self, minValue: MAngle)

        Synopsis
        -----
        Set the minimum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        minValue: MAngle
        	[in] -> the new minimum value for this attribute


        '''
        pass

    @overload
    def setMin(self, minValue: MDistance): 
        '''
        setMin(self, minValue: MDistance)

        Synopsis
        -----
        Set the minimum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        minValue: MDistance
        	[in] -> the new minimum value for this attribute


        '''
        pass

    @overload
    def setMax(self, maxValue: double): 
        '''
        setMax(self, maxValue: double)

        Synopsis
        -----
        Set the maximum value for this attribute. This routine simply
        stores the given double as the numerical value of the attribute.
        It is up to the programmer to know the units used by this
        attribute (eg. radians for angular data, centimeters for distance
        data, etc.) and provide the appropriate value.

        Returns:
        -----
        None

        Parameters:
        -----
        maxValue: double
        	[in] -> the new maximum value for this attribute


        '''
        pass

    @overload
    def setMax(self, maxValue: MTime): 
        '''
        setMax(self, maxValue: MTime)

        Synopsis
        -----
        Set the maximum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        maxValue: MTime
        	[in] -> the new maximum value for this attribute


        '''
        pass

    @overload
    def setMax(self, maxValue: MAngle): 
        '''
        setMax(self, maxValue: MAngle)

        Synopsis
        -----
        Set the maximum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        maxValue: MAngle
        	[in] -> the new maximum value for this attribute


        '''
        pass

    @overload
    def setMax(self, maxValue: MDistance): 
        '''
        setMax(self, maxValue: MDistance)

        Synopsis
        -----
        Set the maximum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        maxValue: MDistance
        	[in] -> the new maximum value for this attribute


        '''
        pass

    @overload
    def setSoftMin(self, minValue: double): 
        '''
        setSoftMin(self, minValue: double)

        Synopsis
        -----
        Set the soft minimum value for this attribute. This routine
        simply stores the given double as the numerical value of the
        attribute. It is up to the programmer to know the units used by
        this attribute (eg. radians for angular data, centimeters for
        distance data, etc.) and provide the appropriate value.

        Returns:
        -----
        None

        Parameters:
        -----
        minValue: double
        	[in] -> the new soft minimum value for this attribute


        '''
        pass

    @overload
    def setSoftMin(self, minValue: MTime): 
        '''
        setSoftMin(self, minValue: MTime)

        Synopsis
        -----
        Set the soft minimum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        minValue: MTime
        	[in] -> the new soft minimum value for this attribute


        '''
        pass

    @overload
    def setSoftMin(self, minValue: MAngle): 
        '''
        setSoftMin(self, minValue: MAngle)

        Synopsis
        -----
        Set the soft minimum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        minValue: MAngle
        	[in] -> the new soft minimum value for this attribute


        '''
        pass

    @overload
    def setSoftMin(self, minValue: MDistance): 
        '''
        setSoftMin(self, minValue: MDistance)

        Synopsis
        -----
        Set the soft minimum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        minValue: MDistance
        	[in] -> the new soft minimum value for this attribute


        '''
        pass

    @overload
    def setSoftMax(self, maxValue: double): 
        '''
        setSoftMax(self, maxValue: double)

        Synopsis
        -----
        Set the soft maximum value for this attribute. This routine
        simply stores the given double as the numerical value of the
        attribute. It is up to the programmer to know the units used by
        this attribute (eg. radians for angular data, centimeters for
        distance data, etc.) and provide the appropriate value.

        Returns:
        -----
        None

        Parameters:
        -----
        maxValue: double
        	[in] -> the new soft maximum value for this attribute


        '''
        pass

    @overload
    def setSoftMax(self, maxValue: MTime): 
        '''
        setSoftMax(self, maxValue: MTime)

        Synopsis
        -----
        Set the soft maximum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        maxValue: MTime
        	[in] -> the new soft maximum value for this attribute


        '''
        pass

    @overload
    def setSoftMax(self, maxValue: MAngle): 
        '''
        setSoftMax(self, maxValue: MAngle)

        Synopsis
        -----
        Set the soft maximum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        maxValue: MAngle
        	[in] -> the new soft maximum value for this attribute


        '''
        pass

    @overload
    def setSoftMax(self, maxValue: MDistance): 
        '''
        setSoftMax(self, maxValue: MDistance)

        Synopsis
        -----
        Set the soft maximum value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        maxValue: MDistance
        	[in] -> the new soft maximum value for this attribute


        '''
        pass

    @overload
    def getDefault(self, defaultValue: double): 
        '''
        getDefault(self, defaultValue: double)

        Synopsis
        -----
        Gets the default value for this attribute. This routine simply
        returns the given double which represents the default value for
        the attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        defaultValue: double
        	[out] -> returns the default value for this attribute. This method simply returns the given default value of the attribute as a double. It is up to the programmer to know the units used by this attribute (eg. radians for angular data, centimeters for distance data, etc.).


        '''
        pass

    @overload
    def getDefault(self, defaultValue: MTime): 
        '''
        getDefault(self, defaultValue: MTime)

        Synopsis
        -----
        Gets the default value for a time attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        defaultValue: MTime
        	[out] -> returns the default value for this attribute


        '''
        pass

    @overload
    def getDefault(self, defaultValue: MAngle): 
        '''
        getDefault(self, defaultValue: MAngle)

        Synopsis
        -----
        Gets the default value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        defaultValue: MAngle
        	[out] -> returns the default value for this attribute in radians


        '''
        pass

    @overload
    def getDefault(self, defaultValue: MDistance): 
        '''
        getDefault(self, defaultValue: MDistance)

        Synopsis
        -----
        Gets the default value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        defaultValue: MDistance
        	[out] -> returns the default value for this attribute in centimeters


        '''
        pass

    @overload
    def setDefault(self, defaultValue: double): 
        '''
        setDefault(self, defaultValue: double)

        Synopsis
        -----
        Set a new default value for this attribute. This routine simply
        stores the given double as the new default value of the
        attribute. It is up to the programmer to know the units used by
        this attribute (eg. radians for angular data, centimeters for
        distance data, etc.) and provide the appropriate value.

        Returns:
        -----
        None

        Parameters:
        -----
        defaultValue: double
        	[in] -> the new default value for this attribute


        '''
        pass

    @overload
    def setDefault(self, defaultValue: MTime): 
        '''
        setDefault(self, defaultValue: MTime)

        Synopsis
        -----
        Set a new default value for a time attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        defaultValue: MTime
        	[in] -> the new default value for this attribute


        '''
        pass

    @overload
    def setDefault(self, defaultValue: MAngle): 
        '''
        setDefault(self, defaultValue: MAngle)

        Synopsis
        -----
        Set a new default value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        defaultValue: MAngle
        	[in] -> the new default value for this attribute


        '''
        pass

    @overload
    def setDefault(self, defaultValue: MDistance): 
        '''
        setDefault(self, defaultValue: MDistance)

        Synopsis
        -----
        Set a new default value for this attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        defaultValue: MDistance
        	[in] -> the new default value for this attribute


        '''
        pass

class Type:
    '''Type of unit represented by attribute values. 
    Non-functional class.  Values for this enum:
    kInvalid
    kAngle
    kDistance
    kTime
    kLast
    '''

    def __init__(self):
        pass

    def kInvalid(self):
        '''This is an enum of Type.
        - Description: Invalid unit type. 
        - Value: 0
        '''
        pass

    def kAngle(self):
        '''This is an enum of Type.
        - Description: Angular attribute. 
        - Value: 1
        '''
        pass

    def kDistance(self):
        '''This is an enum of Type.
        - Description: Distance (linear) attribute. 
        - Value: 2
        '''
        pass

    def kTime(self):
        '''This is an enum of Type.
        - Description: Time attribute. 
        - Value: 3
        '''
        pass

    def kLast(self):
        '''This is an enum of Type.
        - Description: Last value, for counting. 
        - Value: 4
        '''
        pass

class MFnUInt64ArrayData:
    '''MUint64 array function set for dependency node data.
MFnUInt64ArrayData allows the creation and manipulation of
MUint64Array data objects for use in the dependency graph.
If a user written dependency node either accepts or produces
MUint64Arrays, then this class is used to extract or create the
data that comes from or goes to other dependency graph nodes. The
MDataHandle::type method will return kUInt64Array when data of this type is
present. To access it, the
MDataHandle::data method is used to get an
MObject for the data and this should then be used to initialize an
instance of
MFnUInt64ArrayData.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kUInt64ArrayData.Reimplemented from MFnData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnUInt64ArrayData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnUInt64ArrayData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def length(self, ReturnStatus: MFnUInt64ArrayData.MStatus): 
        '''
        length(self, ReturnStatus: MFnUInt64ArrayData.MStatus) -> int

        Synopsis
        -----
        Return the number of MUint64s in the instance.

        Returns: 
        ----- 
        The number of MUint64s in the instance

        Parameters:
        -----
        ReturnStatus: MFnUInt64ArrayData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    @overload
    def set(self, element: MUint64,
                        index: int): 
        '''
        set(self, element: MUint64,
                        index: int)

        Synopsis
        -----
        Set the element at the specified index of the array. No checking
        is done by this class to ensure that the index is valid - use the
        length method to determine the size of the array.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MUint64
        	[in] -> the element 

        index: int
        	[in] -> the index of the MUint64 to set


        '''
        pass

    def copyTo(self, dest: MUint64Array): 
        '''
        copyTo(self, dest: MUint64Array)

        Synopsis
        -----
        Copy all the MUint64s in the instance into the given
        MUint64Array.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: MUint64Array
        	[out] -> the 


        '''
        pass

    @overload
    def set(self, array: MUint64Array): 
        '''
        set(self, array: MUint64Array)

        Synopsis
        -----
        Set the instance to contain the MUint64s defined in the given
        MUint64Array.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MUint64Array
        	[in] -> the 


        '''
        pass

    def array(self, ReturnStatus: MFnUInt64ArrayData.MStatus): 
        '''
        array(self, ReturnStatus: MFnUInt64ArrayData.MStatus) -> MUint64Array

        Synopsis
        -----
        Return an MUint64Array containing the MUint64 array currently
        operated upon by the function set. The MUint64Array returned by
        this method is editable, so any changes to the return instance
        also affects the MObject operated upon by this function set.

        Returns: 
        ----- 
        A copy of the MUint64Array held in this instance

        Parameters:
        -----
        ReturnStatus: MFnUInt64ArrayData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    @overload
    def create(self, ReturnStatus: MFnUInt64ArrayData.MStatus): 
        '''
        create(self, ReturnStatus: MFnUInt64ArrayData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance, and initialize
        it to be empty.

        Returns: 
        ----- 
        The newly created MObject

        Parameters:
        -----
        ReturnStatus: MFnUInt64ArrayData.MStatus
        	[out] -> kSuccess


        '''
        pass

    @overload
    def create(self, arr: MUint64Array,
                        ReturnStatus: MFnUInt64ArrayData.MStatus): 
        '''
        create(self, arr: MUint64Array,
                        ReturnStatus: MFnUInt64ArrayData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance, and initialize
        it to contain the data from the given MUint64Array.

        Returns: 
        ----- 
        The newly created MObject

        Parameters:
        -----
        arr: MUint64Array
        	[in] -> the data to use when initializing this instance 

        ReturnStatus: MFnUInt64ArrayData.MStatus
        	[out] -> kSuccess


        '''
        pass

    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> MUint64

        Synopsis
        -----
        Extract the indicated MUint64 from the instance. by the function
        set. The MUint64 returned by this method is editable, so any
        changes to the return instance also affects the MObject operated
        upon by this function set.No checking is done by this class to
        ensure that the index is valid - use the length method to
        determine the size of the array. If the instance is not attached
        to an MObject, this method will return an MUint64 containing
        zero.

        Returns: 
        ----- 
        The indicated MUint64

        Parameters:
        -----
        index: int
        	[in] -> the index of the MUint64 to extract


        '''
        pass

class MFnVectorArrayData:
    '''int array function set for dependency node data.
MFnVectorArrayData allows the creation and manipulation of
MVectorArray data objects for use in the dependency graph.
If a user written dependency node either accepts or produces
MVectorArrays, then this class is used to extract or create the
data that comes from or goes to other dependency graph nodes. The
MDataHandle::type method will return kVectorArray when data of this type is
present. To access it, the
MDataHandle::data method is used to get an
MObject for the data and this should then be used to initialize an
instance of
MFnVectorArrayData.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kVectorArrayData.Reimplemented from MFnData.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnVectorArrayData.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnVectorArrayData".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def length(self, ReturnStatus: MFnVectorArrayData.MStatus): 
        '''
        length(self, ReturnStatus: MFnVectorArrayData.MStatus) -> int

        Synopsis
        -----
        Return the number of vectors in the instance.

        Returns: 
        ----- 
        The number of vectors in the instance

        Parameters:
        -----
        ReturnStatus: MFnVectorArrayData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    @overload
    def set(self, element: MVector,
                        index: int): 
        '''
        set(self, element: MVector,
                        index: int)

        Synopsis
        -----
        Set the element at the specified index. No checking is done by
        this class to ensure that the index is valid - use the length
        method to determine the size of the array.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MVector
        	[in] -> the element 

        index: int
        	[in] -> the index of the vector to set


        '''
        pass

    def copyTo(self, dest: MVectorArray): 
        '''
        copyTo(self, dest: MVectorArray)

        Synopsis
        -----
        Copy all the vectors in the instance into the given MVectorArray.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: MVectorArray
        	[out] -> the 


        '''
        pass

    @overload
    def set(self, array: MVectorArray): 
        '''
        set(self, array: MVectorArray)

        Synopsis
        -----
        Set the instance to contain the vectors defined in the given
        MVectorArray.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MVectorArray
        	[in] -> the 


        '''
        pass

    def array(self, ReturnStatus: MFnVectorArrayData.MStatus): 
        '''
        array(self, ReturnStatus: MFnVectorArrayData.MStatus) -> MVectorArray

        Synopsis
        -----
        Return an MVectorArray containing the vector array currently
        operated upon by the function set. The MVectorArray returned by
        this method is editable, so any changes to the return instance
        also affects the MObject operated upon by this function set.

        Returns: 
        ----- 
        A copy of the MVectorArray held in this instance

        Parameters:
        -----
        ReturnStatus: MFnVectorArrayData.MStatus
        	[out] -> kFailure if the instance is not attached to an 


        '''
        pass

    @overload
    def create(self, ReturnStatus: MFnVectorArrayData.MStatus): 
        '''
        create(self, ReturnStatus: MFnVectorArrayData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance, and initialize
        it to be empty.

        Returns: 
        ----- 
        The newly created MObject

        Parameters:
        -----
        ReturnStatus: MFnVectorArrayData.MStatus
        	[out] -> kSuccess


        '''
        pass

    @overload
    def create(self, arr: MVectorArray,
                        ReturnStatus: MFnVectorArrayData.MStatus): 
        '''
        create(self, arr: MVectorArray,
                        ReturnStatus: MFnVectorArrayData.MStatus) -> MObject

        Synopsis
        -----
        Create a new MObject, attach it to this instance, and initialize
        it to contain the data from the given MVectorArray.

        Returns: 
        ----- 
        The newly created MObject

        Parameters:
        -----
        arr: MVectorArray
        	[in] -> the data to use when initializing this instance 

        ReturnStatus: MFnVectorArrayData.MStatus
        	[out] -> kSuccess


        '''
        pass

class MFnVolumeLight:
    '''Manage volume Light dependency Nodes.
MFnVolumeLight facilitates creation and manipulation of dependency graph nodes
representing voume lights.
'''
    def __init__(self):
        pass


    def type(self): 
        '''
        type(self) -> MFn.MFn

        Synopsis
        -----
        Function set type. Return the class type :
        MFn::kVolumeLight.Reimplemented from MFnPointLight.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> MFnVolumeLight.OPENMAYA_MAJOR_NAMESPACE_OPENchar*

        Synopsis
        -----
        Returns the name of this class. Return the class name :
        "MFnVolumeLight".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def create(self, UIvisible: bool,
                        ReturnStatus: MFnVolumeLight.MStatus): 
        '''
        create(self, UIvisible: bool,
                        ReturnStatus: MFnVolumeLight.MStatus) -> MObject

        Synopsis
        -----
        Creates a new volume light dependency graph node and adds it to
        the dependency graph. If the UIvisible parameter is true, the new
        node will be connected to the light classification node (which
        allows the UI to recognize the node as a light) and added to the
        default light list. If UIvisible is false, the node will be
        created in isolation.The light node is added to the current
        model, under a new transformation.

        Returns: 
        ----- 
        MObject representing the new dependency node.

        Parameters:
        -----
        UIvisible: bool
        	[in] -> determines whether or not to connect the new node to the light classification node and add it to the default light list. 

        ReturnStatus: MFnVolumeLight.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def create(self, parent: MObject,
                        UIvisible: bool,
                        wantTransform: bool,
                        ReturnStatus: MFnVolumeLight.MStatus): 
        '''
        create(self, parent: MObject,
                        UIvisible: bool,
                        wantTransform: bool,
                        ReturnStatus: MFnVolumeLight.MStatus) -> MObject

        Synopsis
        -----
        Creates a new volume light dependency graph node and adds it to
        the dependency graph. If the UIvisible parameter is true, the new
        node will be connected to the light classification node (which
        allows the UI to recognize the node as a light) and added to the
        default light list. If UIvisible is false, the node will be
        created in isolation.If wantTransform parameter is false ( which
        is by default ), the new shape node is created under the
        specified parent and no transform node is created. If the
        specified parent is null, then no shape node will be created.The
        light node is added to the current model, under the specified
        parent.

        Returns: 
        ----- 
        MObject representing the new dependency node.

        Parameters:
        -----
        parent: MObject
        	[in] -> the node under which the new light and its transform will be added. 

        UIvisible: bool
        	[in] -> determines whether or not to connect the new node to the light classification node and add it to the default light list. 

        wantTransform: bool
        	[in] -> Boolean to indicate whether the transform node is needed or not, which is 'false' by default. 

        ReturnStatus: MFnVolumeLight.MStatus
        	[out] -> return status


        '''
        pass

    def lightShape(self, ReturnStatus: MFnVolumeLight.MStatus): 
        '''
        lightShape(self, ReturnStatus: MFnVolumeLight.MStatus) -> MFnVolumeLight.MFnVolumeLight

        Synopsis
        -----
        Retrieves the "lightShape" attribute of the light. The shape can
        be one of the following.

        Returns: 
        ----- 
        The value of the "lightShape" attribute of the volume light node.

        Parameters:
        -----
        ReturnStatus: MFnVolumeLight.MStatus
        	[out] -> return status


        '''
        pass

    def setLightShape(self, light_shape: MFnVolumeLight.MFnVolumeLight): 
        '''
        setLightShape(self, light_shape: MFnVolumeLight.MFnVolumeLight)

        Synopsis
        -----
        Sets the value of the "lightShape" attribute of a volume light
        node. The shape can be one of the following:

        Returns:
        -----
        None

        Parameters:
        -----
        light_shape: MFnVolumeLight.MFnVolumeLight
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def volumeLightDirection(self, ReturnStatus: MFnVolumeLight.MStatus): 
        '''
        volumeLightDirection(self, ReturnStatus: MFnVolumeLight.MStatus) -> MFnVolumeLight.MFnVolumeLight

        Synopsis
        -----
        Retrieves the value of the "volumeLightDirection" attribute. The
        volumeLightDirection attribute determines the direction of the
        light within the volume. Outward has light moving away from the
        center of a Box or Sphere and away from the central axis of a
        Cylinder or Cone. Inward is the reverse of the direction. One can
        light from the outside of a sphere going in. Up Axis is like a
        directional light pointing in the positive y direction. Down axis
        points in the negative y direction. Note that Inward will not
        always shadow in a desirable fashion. The volumeLightDirection
        attribute can be one of the following:

        Returns: 
        ----- 
        The value of the "lightDirection" attribute of the volume light
        node.

        Parameters:
        -----
        ReturnStatus: MFnVolumeLight.MStatus
        	[out] -> return status


        '''
        pass

    def setVolumeLightDirection(self, volume_light_direction: MFnVolumeLight.MFnVolumeLight): 
        '''
        setVolumeLightDirection(self, volume_light_direction: MFnVolumeLight.MFnVolumeLight)

        Synopsis
        -----
        Sets the value of the "volumeLightDirection" attribute of a
        volume light node. The shape can be one of the following.

        Returns:
        -----
        None

        Parameters:
        -----
        volume_light_direction: MFnVolumeLight.MFnVolumeLight
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def arc(self, ReturnStatus: MFnVolumeLight.MStatus): 
        '''
        arc(self, ReturnStatus: MFnVolumeLight.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "arc" attribute. The arc is an angular
        slice of the light about the y axis. The value can range from 0
        to 360 degrees.

        Returns: 
        ----- 
        The value of the "arc" attribute of the volume light node.

        Parameters:
        -----
        ReturnStatus: MFnVolumeLight.MStatus
        	[out] -> return status


        '''
        pass

    def setArc(self, arc: float): 
        '''
        setArc(self, arc: float)

        Synopsis
        -----
        Sets the value of the "arc" attribute of a volume light node.

        Returns:
        -----
        None

        Parameters:
        -----
        arc: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def coneEndRadius(self, ReturnStatus: MFnVolumeLight.MStatus): 
        '''
        coneEndRadius(self, ReturnStatus: MFnVolumeLight.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "coneEndRadius" attribute. The
        coneEndRadius attribute determines the relative size of the one
        end of the cone. At a value of 1.0 it is a cylinder, while at 0
        it is a cone.

        Returns: 
        ----- 
        The value of the "coneEndRadius" attribute of the volume light
        node.

        Parameters:
        -----
        ReturnStatus: MFnVolumeLight.MStatus
        	[out] -> return status


        '''
        pass

    def setConeEndRadius(self, cone_end_radius: float): 
        '''
        setConeEndRadius(self, cone_end_radius: float)

        Synopsis
        -----
        Sets the value of the "coneEndRadius" attribute of a volume light
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        cone_end_radius: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def emitAmbient(self, ReturnStatus: MFnVolumeLight.MStatus): 
        '''
        emitAmbient(self, ReturnStatus: MFnVolumeLight.MStatus) -> bool

        Synopsis
        -----
        Retrieves the value of the "emitAmbient" attribute. If true, then
        light affects surfaces in a non directional fashion. When
        combined with Emit Diffuse the lighting at a surface will be half
        applied using the surface/light angle, and half in a
        nondirectional fashion. If Emit Diffuse is off then the light
        will be totally omnidirectional.

        Returns: 
        ----- 
        The value of the "emitAmbient" attribute of the volume light
        node.

        Parameters:
        -----
        ReturnStatus: MFnVolumeLight.MStatus
        	[out] -> return status


        '''
        pass

    def setEmitAmbient(self, emit_ambient: bool): 
        '''
        setEmitAmbient(self, emit_ambient: bool)

        Synopsis
        -----
        Sets the value of the "emitAmbient" attribute of a volume light
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        emit_ambient: bool
        	[in] -> value to which the attribute will be set.


        '''
        pass

    def colorRamp(self, ReturnStatus: MFnVolumeLight.MStatus): 
        '''
        colorRamp(self, ReturnStatus: MFnVolumeLight.MStatus) -> MRampAttribute

        Synopsis
        -----
        Retrieves the "colorRamp" attribute.

        Returns: 
        ----- 
        The color ramp attribute

        Parameters:
        -----
        ReturnStatus: MFnVolumeLight.MStatus
        	[out] -> return status


        '''
        pass

    def penumbraRamp(self, ReturnStatus: MFnVolumeLight.MStatus): 
        '''
        penumbraRamp(self, ReturnStatus: MFnVolumeLight.MStatus) -> MRampAttribute

        Synopsis
        -----
        Retrieves the "penumbraRamp" attribute.

        Returns: 
        ----- 
        The penumbra ramp attribute

        Parameters:
        -----
        ReturnStatus: MFnVolumeLight.MStatus
        	[out] -> return status


        '''
        pass

    def shadowAngle(self, ReturnStatus: MFnVolumeLight.MStatus): 
        '''
        shadowAngle(self, ReturnStatus: MFnVolumeLight.MStatus) -> float

        Synopsis
        -----
        Retrieves the value of the "shadowAngle" attribute of a volume
        light node. This attribute represents an angular divergence from
        the direction vector of the light used to calculate soft shadows.
        It's enabled only if the volume light direction is kDownAxis.

        Returns: 
        ----- 
        The value of the "shadowAngle" attribute of the light node.

        Parameters:
        -----
        ReturnStatus: MFnVolumeLight.MStatus
        	[out] -> return status


        '''
        pass

    def setShadowAngle(self, shadow_angle: float): 
        '''
        setShadowAngle(self, shadow_angle: float)

        Synopsis
        -----
        Sets the value of the "shadowAngle" attribute of a volume light
        node. It's enabled only if the volume light direction is
        kDownAxis.

        Returns:
        -----
        None

        Parameters:
        -----
        shadow_angle: float
        	[in] -> value to which the attribute will be set.


        '''
        pass

class MLightShape:
    '''Available shapes for a volume light. 
    Non-functional class.  Values for this enum:
    kBoxVolume
    kSphereVolume
    kCylinderVolume
    kConeVolume
    '''

    def __init__(self):
        pass

    def kBoxVolume(self):
        '''This is an enum of MLightShape.
        - Description:  
        - Value: 0
        '''
        pass

    def kSphereVolume(self):
        '''This is an enum of MLightShape.
        - Description:  
        - Value: 1
        '''
        pass

    def kCylinderVolume(self):
        '''This is an enum of MLightShape.
        - Description:  
        - Value: 2
        '''
        pass

    def kConeVolume(self):
        '''This is an enum of MLightShape.
        - Description:  
        - Value: 3
        '''
        pass

class MLightDirection:
    '''Direction that light travels. 
    Non-functional class.  Values for this enum:
    kOutward
    kInward
    kDownAxis
    '''

    def __init__(self):
        pass

    def kOutward(self):
        '''This is an enum of MLightDirection.
        - Description: Light travels outwared from the center of a box- or sphere-shaped volume, and outward from the axis of a cylinder- or cone-shaped volume. 
        - Value: 0
        '''
        pass

    def kInward(self):
        '''This is an enum of MLightDirection.
        - Description: Light travels inward toward the center of a box- or sphere-shaped volume, and inward toward the axis of a cylinder- or cone-shaped volume. 
        - Value: 1
        '''
        pass

    def kDownAxis(self):
        '''This is an enum of MLightDirection.
        - Description: Light travels down the axis, like a directional light pointing in the negative Y direction. 
        - Value: 2
        '''
        pass

class MGlobal:
    '''Static class providing common API global functions.
Provide methods for selection, 3D-views, time, model manipulation
and MEL commands.
MGlobal is a static class which provides access to Maya's model (3d
graphical database).
MGlobal provides methods for selection, 3d-views, setting the global
time, adding to the DAG, and executing MEL commands from within
the API. There are multiple methods provided in this class for
executing MEL within the API. Plug-ins requiring the execution of
MEL from the non-main Maya thread must use the
executeCommandOnIdle() method to avoid program errors.
MGlobal also provides methods for controlling error logging in the API.
'''
    def __init__(self):
        pass


    def mayaName(self): 
        '''
        mayaName(self) -> MGlobal.OPENMAYA_MAJOR_NAMESPACE_OPEN MString

        Synopsis
        -----
        Introduced in 2023.0 Returns a string describing which kind of
        Maya is running.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def mayaVersion(self): 
        '''
        mayaVersion(self) -> MString

        Synopsis
        -----
        Returns a string describing this version of Maya.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def apiVersion(self): 
        '''
        apiVersion(self) -> int

        Synopsis
        -----
        Returns a number describing the version of the Maya API at
        runtime.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isCustomVersion(self): 
        '''
        isCustomVersion(self) -> bool

        Synopsis
        -----
        Introduced in 2020.0 Returns true if this is a custom version of
        Maya.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def mayaFeatureSet(self): 
        '''
        mayaFeatureSet(self) -> MGlobal.MGlobal

        Synopsis
        -----
        Introduced in 2023.0 Returns true if this version of Maya is
        fully featured.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def customVersionString(self): 
        '''
        customVersionString(self) -> MString

        Synopsis
        -----
        Introduced in 2020.0 Returns a string describing the custom
        version of Maya at runtime.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def customVersionMajor(self): 
        '''
        customVersionMajor(self) -> int

        Synopsis
        -----
        Introduced in 2020.0 Returns a number describing the major custom
        version of Maya at runtime.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def customVersionMinor(self): 
        '''
        customVersionMinor(self) -> int

        Synopsis
        -----
        Introduced in 2020.0 Returns a number describing the minor custom
        version of Maya at runtime.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def customVersionClient(self): 
        '''
        customVersionClient(self) -> MString

        Synopsis
        -----
        Introduced in 2020.0 Returns a string describing the custom
        version client of Maya at runtime.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def customVersion(self): 
        '''
        customVersion(self) -> int

        Synopsis
        -----
        Returns an encoded number describing the custom version of Maya
        at runtime. This number can be used to compare custom versions of
        Maya and is encoded as (10000 * maya_major_version + 100 *
        custom_major_version + custom_minor_version). Note: If this is
        not a custom version then (10000 * maya_major_version) will be
        returned.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getAbsolutePathToResources(self): 
        '''
        getAbsolutePathToResources(self) -> MString

        Synopsis
        -----
        Return the absolute path of Maya's "Resources" fold on the
        system, including the "Resources" folder itself.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isDefaultLanguage(self): 
        '''
        isDefaultLanguage(self) -> bool

        Synopsis
        -----
        Introduced in 2020.0 Returns True when no specific localization
        has been requested, or the localization requested was not
        supported or installed.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getUILanguage(self): 
        '''
        getUILanguage(self) -> MString

        Synopsis
        -----
        Introduced in 2020.0 Return standardized string identifier
        representing the UI language to use.This will either be a
        localized language, or the default language.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def mayaState(self, ReturnStatus: MGlobal.MStatus): 
        '''
        mayaState(self, ReturnStatus: MGlobal.MStatus) -> MGlobal.MGlobal

        Synopsis
        -----
        Returns an enumerated type specifying the way in which Maya was
        invoked.

        Returns: 
        ----- 
        MGlobal::kInteractive Running with a UI  MGlobal::kBatch Running
        without a UI  MGlobal::kLibraryApp Running as a standalone
        (MLibrary) application.  MGlobal::kBaseUIMode Running with UI
        enabled but Maya's std UI scripts not run.

        Parameters:
        -----
        ReturnStatus: MGlobal.MStatus
        	[out] -> Status code.


        '''
        pass

    def isInCrashHandler(self): 
        '''
        isInCrashHandler(self) -> bool

        Synopsis
        -----
        Introduced in 2023.0 Checks if Maya is currently handling a
        crash.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getFunctionSetList(self, forObject: MObject,
                        array: MStringArray): 
        '''
        getFunctionSetList(self, forObject: MObject,
                        array: MStringArray)

        Synopsis
        -----
        Gets a list of strings that represent the type of each function
        set that will accept this object. The strings match the values in
        MFn.h.

        Returns:
        -----
        None

        Parameters:
        -----
        forObject: MObject
        	[in] -> object to get list of function sets for 

        array: MStringArray
        	[out] -> storage for the array of strings


        '''
        pass

    def getAssociatedSets(self, list: MSelectionList,
                        setArray: MObjectArray): 
        '''
        getAssociatedSets(self, list: MSelectionList,
                        setArray: MObjectArray)

        Synopsis
        -----
        This utility method finds all the sets that the items in the
        given selection list are members of.

        Returns:
        -----
        None

        Parameters:
        -----
        list: MSelectionList
        	[in] -> items to finds sets for 

        setArray: MObjectArray
        	[out] -> storage for the array of sets


        '''
        pass

    def getSelectionListByName(self, name: MString,
                        list: MSelectionList): 
        '''
        getSelectionListByName(self, name: MString,
                        list: MSelectionList)

        Synopsis
        -----
        This method fills a selection list with all of the objects that
        match a specified name. The name may use the same type of regular
        expressions the can be used in MEL commands. For example, the
        pattern "pCube*" will match all occurances of objects that begin
        their names with "pCube".Taking this a step further, the
        following example looks for all objects that both start their
        names with "pCube" but also have a child that starts its name
        with "pCubeShape". Since the pattern is matching a DAG path, the
        items that match the pattern should be DAG nodes.For the case
        where a polyCube (pCube1) is the parent of another polyCube
        (pCube2), the output of the above example would be as
        follows:|pCube1|pCubeShape1 |pCube1|pCube2|pCubeShape2

        Returns:
        -----
        None

        Parameters:
        -----
        name: MString
        	[in] -> Regular expression to match object name. 

        list: MSelectionList
        	[out] -> Selection list into which the objects matching the name will be placed.


        '''
        pass

    def getActiveSelectionList(self, dest: MSelectionList,
                        orderedSelectionIfAvailable: bool): 
        '''
        getActiveSelectionList(self, dest: MSelectionList,
                        orderedSelectionIfAvailable: bool)

        Synopsis
        -----
        Returns a copy of the active selection list, or optionally a copy
        of the ordered active selection list. This is the active
        selection list but with components as well as objects appearing
        in the order that they were selected.In order to get the ordered
        selection list, tracking component selection order must be
        enabled through either the 'selectPref' Maya command or through
        the MGlobal function 'setTrackSelectionOrderEnabled'.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: MSelectionList
        	[out] -> Storage for the selection list 

        orderedSelectionIfAvailable: bool
        	[in] -> If true, and tracking is enabled, will return the selected items in the order that they were selected.


        '''
        pass

    def getRichSelection(self, richSelection: MRichSelection,
                        defaultToActiveSelection: bool): 
        '''
        getRichSelection(self, richSelection: MRichSelection,
                        defaultToActiveSelection: bool)

        Synopsis
        -----
        Returns the current rich selection (usually the active selection
        with any soft selection and symmetry applied). Optionally if no
        rich selection exists, the current active selection can be
        returned instead (reducing the need for duplicated code).

        Returns:
        -----
        None

        Parameters:
        -----
        richSelection: MRichSelection
        	[out] -> Storage for the rich selection 

        defaultToActiveSelection: bool
        	[in] -> If true, Maya will return the active selection when no rich selection exists.


        '''
        pass

    def getLiveList(self, dest: MSelectionList): 
        '''
        getLiveList(self, dest: MSelectionList)

        Synopsis
        -----
        Returns a copy of the live list. When a user performs a
        "Modify->Make Live" in the user interface the currently selected
        objects are added to the live list.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: MSelectionList
        	[out] -> Storage for the selection list


        '''
        pass

    def getHiliteList(self, dest: MSelectionList): 
        '''
        getHiliteList(self, dest: MSelectionList)

        Synopsis
        -----
        Returns a copy of the hilite list. The hilite list contains all
        DAG objects that are hilited for component selection mode. (e.g.
        when the user right clicks over a Mesh object and chooses the
        "vertex" option the Mesh line drawing changes color and the mesh
        is added to the hiliteList.)

        Returns:
        -----
        None

        Parameters:
        -----
        dest: MSelectionList
        	[out] -> Storage for the hilite list


        '''
        pass

    def setHiliteList(self, list: MSelectionList): 
        '''
        setHiliteList(self, list: MSelectionList)

        Synopsis
        -----
        Sets the current hilite list. The current selection list is
        unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        list: MSelectionList
        	[in] -> The new hilite list.


        '''
        pass

    def setActiveSelectionList(self, src: MSelectionList,
                        listAdjustment: MGlobal.MGlobal): 
        '''
        setActiveSelectionList(self, src: MSelectionList,
                        listAdjustment: MGlobal.MGlobal)

        Synopsis
        -----
        Set the active selection list. The selection items on the given
        list will update the contents of the active selection list as
        indicated by the listAdjustment parameter.

        Returns:
        -----
        None

        Parameters:
        -----
        src: MSelectionList
        	[in] -> The source list 

        listAdjustment: MGlobal.MGlobal
        	[in] -> Determines how the active selection list is modified. 


        '''
        pass

    def setRichSelection(self, src: MRichSelection): 
        '''
        setRichSelection(self, src: MRichSelection)

        Synopsis
        -----
        Set the current rich selection.

        Returns:
        -----
        None

        Parameters:
        -----
        src: MRichSelection
        	[in] -> The source list


        '''
        pass

    def setDisplayCVs(self, src: MSelectionList,
                        state: bool): 
        '''
        setDisplayCVs(self, src: MSelectionList,
                        state: bool)

        Synopsis
        -----
        Controls drawing of control points in the specified selection
        list. The selection items on the given list will be marked for
        drawing. This overrides Maya's current draw list and allow, for
        example, the drawing of control points without being in vertex
        selection mode.

        Returns:
        -----
        None

        Parameters:
        -----
        src: MSelectionList
        	[in] -> The source list 

        state: bool
        	[in] -> Whether items should be marked on/off for drawing


        '''
        pass

    def selectCommand(self, src: MSelectionList,
                        listAdjustment: MGlobal.MGlobal): 
        '''
        selectCommand(self, src: MSelectionList,
                        listAdjustment: MGlobal.MGlobal)

        Synopsis
        -----
        Set the active selection list, by calling the built in Maya
        select command. This differs from setActiveSelectionList in that
        in this version Maya takes over the selection list you give it
        and will be responsible for maintaing the necessary information
        required for undo, redo, and journalling.

        Returns:
        -----
        None

        Parameters:
        -----
        src: MSelectionList
        	[in] -> The source list 

        listAdjustment: MGlobal.MGlobal
        	[in] -> Determines how the active selection list is modified. 


        '''
        pass

    def selectByName(self, name: MString,
                        listAdjustment: MGlobal.MGlobal): 
        '''
        selectByName(self, name: MString,
                        listAdjustment: MGlobal.MGlobal)

        Synopsis
        -----
        Puts objects that match the give name on the active selection
        list.

        Returns:
        -----
        None

        Parameters:
        -----
        name: MString
        	[in] -> Regular expression to match object name. 

        listAdjustment: MGlobal.MGlobal
        	[in] -> Determines how the active selection list is modified. 


        '''
        pass

    def unselectByName(self, name: MString): 
        '''
        unselectByName(self, name: MString)

        Synopsis
        -----
        Removes objects matching the pattern from the active selection
        list.

        Returns:
        -----
        None

        Parameters:
        -----
        name: MString
        	[in] -> Regular expression to match object name.


        '''
        pass

    @overload
    def select(self, object: MObject,
                        listAdjustment: MGlobal.MGlobal): 
        '''
        select(self, object: MObject,
                        listAdjustment: MGlobal.MGlobal)

        Synopsis
        -----
        Put the given object on the active selection list.

        Returns:
        -----
        None

        Parameters:
        -----
        object: MObject
        	[in] -> Object to make selected. 

        listAdjustment: MGlobal.MGlobal
        	[in] -> Determines how the active selection list is modified. 


        '''
        pass

    @overload
    def select(self, object: MDagPath,
                        component: MObject,
                        listAdjustment: MGlobal.MGlobal): 
        '''
        select(self, object: MDagPath,
                        component: MObject,
                        listAdjustment: MGlobal.MGlobal)

        Synopsis
        -----
        Put the given object or components on the active selection list.
        If the component is null then the object in the dag path will be
        selected, otherwise the given component will be selected.

        Returns:
        -----
        None

        Parameters:
        -----
        object: MDagPath
        	[in] -> Object to make selected. 

        component: MObject
        	[in] -> Components to select. 

        listAdjustment: MGlobal.MGlobal
        	[in] -> Determines how the active selection list is modified. 


        '''
        pass

    @overload
    def unselect(self, object: MObject): 
        '''
        unselect(self, object: MObject)

        Synopsis
        -----
        Remove the given object from the active selection list.

        Returns:
        -----
        None

        Parameters:
        -----
        object: MObject
        	[in] -> Object to unselect.


        '''
        pass

    @overload
    def unselect(self, object: MDagPath,
                        component: MObject): 
        '''
        unselect(self, object: MDagPath,
                        component: MObject)

        Synopsis
        -----
        Remove the given object/components from the active selection
        list. If components is null then the object will be unselected,
        otherwise the components will be unselected.

        Returns:
        -----
        None

        Parameters:
        -----
        object: MDagPath
        	[in] -> Object to unselect. 

        component: MObject
        	[in] -> Components to be unselected.


        '''
        pass

    @overload
    def selectFromScreen(self, x_pos: short,
                        y_pos: short,
                        listAdjustment: MGlobal.MGlobal,
                        selectMethod: MGlobal.MGlobal): 
        '''
        selectFromScreen(self, x_pos: short,
                        y_pos: short,
                        listAdjustment: MGlobal.MGlobal,
                        selectMethod: MGlobal.MGlobal)

        Synopsis
        -----
        Perform click-pick type selection on the dag. If an object
        intersects the click point then it is selected according to
        listAdjustment.

        Returns:
        -----
        None

        Parameters:
        -----
        x_pos: short
        	[in] -> X position on screen to select at. 

        y_pos: short
        	[in] -> Y position on screen to select at. 

        listAdjustment: MGlobal.MGlobal
        	[in] -> Determines how the active selection list is modified. 

        selectMethod: MGlobal.MGlobal
        	[in] -> Determines how the selection is done. 


        '''
        pass

    @overload
    def selectFromScreen(self, start_x: short,
                        start_y: short,
                        end_x: short,
                        end_y: short,
                        listAdjustment: MGlobal.MGlobal,
                        selectMethod: MGlobal.MGlobal): 
        '''
        selectFromScreen(self, start_x: short,
                        start_y: short,
                        end_x: short,
                        end_y: short,
                        listAdjustment: MGlobal.MGlobal,
                        selectMethod: MGlobal.MGlobal)

        Synopsis
        -----
        Perform marquee type selection on the dag. If an object
        intersects the selection rectangle, it is selected according to
        listAdjustment.

        Returns:
        -----
        None

        Parameters:
        -----
        start_x: short
        	[in] -> Start x position of selection rectangle 

        start_y: short
        	[in] -> Start y position of selection rectangle 

        end_x: short
        	[in] -> End x position of selection rectangle 

        end_y: short
        	[in] -> End y position of selection rectangle 

        listAdjustment: MGlobal.MGlobal
        	[in] -> Determines how the active selection list is modified. 

        selectMethod: MGlobal.MGlobal
        	[in] -> Determines how the selection is done. 


        '''
        pass

    def selectionMethod(self, ReturnStatus: MGlobal.MStatus): 
        '''
        selectionMethod(self, ReturnStatus: MGlobal.MStatus) -> MGlobal.MGlobal

        Synopsis
        -----
        Determines the selection method that should be used in the
        currently active viewport. This is useful as input to the
        "selectFromScreen" functions.

        Returns: 
        ----- 
        The selection method.

        Parameters:
        -----
        ReturnStatus: MGlobal.MStatus
        	[out] -> 


        '''
        pass

    def selectionMode(self, ReturnStatus: MGlobal.MStatus): 
        '''
        selectionMode(self, ReturnStatus: MGlobal.MStatus) -> MGlobal.MGlobal

        Synopsis
        -----
        Determines Maya's selection mode. kSelectObjectMode  Objects are
        selected as a whole. Components are not directly
        accessible.kSelectComponentMode  Components such as vertices are
        selectable in this mode.kSelectRootMode  Selecting the child in
        a hierarchy will also select its root DAG node.kSelectLeafMode 
        Selecting the child in a hierarchy will result only in that child
        being selected.kSelectTemplateMode  Templated objects are
        selectable in this mode.

        Returns: 
        ----- 
        The selection mode.

        Parameters:
        -----
        ReturnStatus: MGlobal.MStatus
        	[out] -> 


        '''
        pass

    def setSelectionMode(self, mode: MGlobal.MGlobal): 
        '''
        setSelectionMode(self, mode: MGlobal.MGlobal)

        Synopsis
        -----
        Sets the selection mode. kSelectObjectMode  Objects are selected
        as a whole. Components are not directly
        accessible.kSelectComponentMode  Components such as vertices are
        selectable in this mode.kSelectRootMode  Selecting the child in
        a hierarchy will also select its root DAG node.kSelectLeafMode 
        Selecting the child in a hierarchy will result only in that child
        being selected.kSelectTemplateMode  Templated objects are
        selectable in this mode.

        Returns:
        -----
        None

        Parameters:
        -----
        mode: MGlobal.MGlobal
        	[in] -> The mode to be set


        '''
        pass

    def objectSelectionMask(self, ReturnStatus: MGlobal.MStatus): 
        '''
        objectSelectionMask(self, ReturnStatus: MGlobal.MStatus) -> MSelectionMask

        Synopsis
        -----
        Returns the object selection mask.

        Returns: 
        ----- 
        The selection mask

        Parameters:
        -----
        ReturnStatus: MGlobal.MStatus
        	[out] -> 


        '''
        pass

    def setObjectSelectionMask(self, mask: MSelectionMask): 
        '''
        setObjectSelectionMask(self, mask: MSelectionMask)

        Synopsis
        -----
        Set the object selection mask to the supplied value.

        Returns:
        -----
        None

        Parameters:
        -----
        mask: MSelectionMask
        	[in] -> The mask to set to


        '''
        pass

    def componentSelectionMask(self, ReturnStatus: MGlobal.MStatus): 
        '''
        componentSelectionMask(self, ReturnStatus: MGlobal.MStatus) -> MSelectionMask

        Synopsis
        -----
        Returns the component selection mask.

        Returns: 
        ----- 
        The component selection mask

        Parameters:
        -----
        ReturnStatus: MGlobal.MStatus
        	[out] -> 


        '''
        pass

    def setComponentSelectionMask(self, mask: MSelectionMask): 
        '''
        setComponentSelectionMask(self, mask: MSelectionMask)

        Synopsis
        -----
        Set the component selection mask to the supplied value.

        Returns:
        -----
        None

        Parameters:
        -----
        mask: MSelectionMask
        	[in] -> The mask to be set


        '''
        pass

    def animSelectionMask(self, ReturnStatus: MGlobal.MStatus): 
        '''
        animSelectionMask(self, ReturnStatus: MGlobal.MStatus) -> MSelectionMask

        Synopsis
        -----
        Returns the animation selection mask.

        Returns: 
        ----- 
        The selection mask

        Parameters:
        -----
        ReturnStatus: MGlobal.MStatus
        	[out] -> 


        '''
        pass

    def setAnimSelectionMask(self, mask: MSelectionMask): 
        '''
        setAnimSelectionMask(self, mask: MSelectionMask)

        Synopsis
        -----
        Set the animation selection mask to the supplied value.

        Returns:
        -----
        None

        Parameters:
        -----
        mask: MSelectionMask
        	[in] -> The mask to be set


        '''
        pass

    def miscSelectionMask(self, ReturnStatus: MGlobal.MStatus): 
        '''
        miscSelectionMask(self, ReturnStatus: MGlobal.MStatus) -> MSelectionMask

        Synopsis
        -----
        Returns the miscellaneous selection mask.

        Returns: 
        ----- 
        The selection mask

        Parameters:
        -----
        ReturnStatus: MGlobal.MStatus
        	[out] -> 


        '''
        pass

    def setMiscSelectionMask(self, mask: MSelectionMask): 
        '''
        setMiscSelectionMask(self, mask: MSelectionMask)

        Synopsis
        -----
        Set the miscellaneous selection mask to the supplied value.

        Returns:
        -----
        None

        Parameters:
        -----
        mask: MSelectionMask
        	[in] -> The mask to be set


        '''
        pass

    def clearSelectionList(self): 
        '''
        clearSelectionList(self)

        Synopsis
        -----
        Removes all items from the active selection list.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isSelected(self, object: MObject,
                        ReturnStatus: MGlobal.MStatus): 
        '''
        isSelected(self, object: MObject,
                        ReturnStatus: MGlobal.MStatus) -> bool

        Synopsis
        -----
        Determines whether the given object is on the active selection
        list. Note: The given object must be a dependency node.

        Returns: 
        ----- 
        Boolean value: true if the object is selected, false otherwise.

        Parameters:
        -----
        object: MObject
        	[in] -> Dependency node object to test. 

        ReturnStatus: MGlobal.MStatus
        	[out] -> 


        '''
        pass

    def trackSelectionOrderEnabled(self, ReturnStatus: MGlobal.MStatus): 
        '''
        trackSelectionOrderEnabled(self, ReturnStatus: MGlobal.MStatus) -> bool

        Synopsis
        -----
        Returns whether the selection order is currerntly being tracked.

        Returns: 
        ----- 
        Boolean value: true if the selection order is being tracked,
        false otherwise.

        Parameters:
        -----
        ReturnStatus: MGlobal.MStatus
        	[out] -> 


        '''
        pass

    def setTrackSelectionOrderEnabled(self, enable: bool): 
        '''
        setTrackSelectionOrderEnabled(self, enable: bool)

        Synopsis
        -----
        Set whether Maya should maintain an active selection list which
        maintains object and component selection order.

        Returns:
        -----
        None

        Parameters:
        -----
        enable: bool
        	[in] -> Flag to enable or disable the tracking of selection order.


        '''
        pass

    def getPreselectionHiliteList(self, list: MSelectionList): 
        '''
        getPreselectionHiliteList(self, list: MSelectionList)

        Synopsis
        -----
        Gets the objects for which Maya is displaying a preselection
        highlight in the viewports.

        Returns:
        -----
        None

        Parameters:
        -----
        list: MSelectionList
        	[out] -> Storage for the preselection highlight list.


        '''
        pass

    def setPreselectionHiliteList(self, list: MSelectionList): 
        '''
        setPreselectionHiliteList(self, list: MSelectionList)

        Synopsis
        -----
        Sets the objects for which Maya will display a preselection
        highlight in the viewports. The objects/components in the list
        will be drawn in Maya's preselection highlight style on the next
        viewport refresh (if preselection highlighting is enabled in the
        preferences).If preselection highlighting is not enabled, Maya
        will still store the list.

        Returns:
        -----
        None

        Parameters:
        -----
        list: MSelectionList
        	[in] -> List of objects/components to highlight.


        '''
        pass

    def currentToolContext(self): 
        '''
        currentToolContext(self) -> MObject

        Synopsis
        -----
        Returns the current tool context as an MObject.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def viewFrame(self, time: MTime): 
        '''
        viewFrame(self, time: MTime)

        Synopsis
        -----
        Sets the global time to the specified time. This function is
        optimized for sequential time values that are monotonically
        increasing. While one can set the time randomly with this
        function, a significant performance hit will be incurred.

        Returns:
        -----
        None

        Parameters:
        -----
        time: MTime
        	[in] -> Time to set.


        '''
        pass

    @overload
    def viewFrame(self, time: double): 
        '''
        viewFrame(self, time: double)

        Synopsis
        -----
        Sets the global time to the specified time. This function is
        optimized for sequential time values that are monotonically
        increasing. While one can set the time randomly with this
        function, a significant performance hit will be incurred.

        Returns:
        -----
        None

        Parameters:
        -----
        time: double
        	[in] -> Time to set, in the units currently in effect for the user interface.


        '''
        pass

    def sourceFile(self, fileName: MString): 
        '''
        sourceFile(self, fileName: MString)

        Synopsis
        -----
        Causes the MEL command engine to open the named file and execute
        the contents of the file as a MEL script. If the provided
        fileName is a Unix absolute pathname, then that file is opened.
        If a relative pathname is provided, the directories indicated by
        the environment variable, MAYA_SCRIPT_PATH, will be searched for
        a matching filename.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> The name of a file containing MEL commands


        '''
        pass

    def executeCommandOnIdle(self, command: MString,
                        displayEnabled: bool): 
        '''
        executeCommandOnIdle(self, command: MString,
                        displayEnabled: bool)

        Synopsis
        -----
        Sets a MEL command to execute on the next idle event. Since the
        command will likely not be executed until some time after control
        is returned to caller, there is no access to the command
        results.This method is thread safe and can be called from a
        thread other than Maya's main thread. However, that thread must
        still be part of the Maya process. Calling this method from a
        completely separate process will not work and may lead to
        unpredictable behaviour.

        Returns:
        -----
        None

        Parameters:
        -----
        command: MString
        	[in] -> The MEL command string to add to idle queue. 

        displayEnabled: bool
        	[in] -> Flag to enable display of command in Script Editor - defaults to false


        '''
        pass

    @overload
    def executeCommand(self, command: MString,
                        displayEnabled: bool,
                        undoEnabled: bool): 
        '''
        executeCommand(self, command: MString,
                        displayEnabled: bool,
                        undoEnabled: bool)

        Synopsis
        -----
        Executes a MEL command with no access to result. Optionally
        allows display of the command in the Command Window to be enabled
        or disabled. Defaults to disabled. Optionally allows undo for the
        command to be enabled or disabled. Defaults to disabled.Note:
        This is not thread safe; you may use executeCommandOnIdle
        instead.

        Returns:
        -----
        None

        Parameters:
        -----
        command: MString
        	[in] -> The MEL command string to execute. 

        displayEnabled: bool
        	[in] -> Flag to enable display of command in journal window - defaults to false 

        undoEnabled: bool
        	[in] -> Flag to enable addition of command to undo queue - defaults to false


        '''
        pass

    @overload
    def executeCommand(self, command: MString,
                        result: MCommandResult,
                        displayEnabled: bool,
                        undoEnabled: bool): 
        '''
        executeCommand(self, command: MString,
                        result: MCommandResult,
                        displayEnabled: bool,
                        undoEnabled: bool)

        Synopsis
        -----
        Executes a MEL command that returns an MCommandResult from the
        command engine. Optionally allows display of the command in the
        Command Window to be enabled or disabled. Defaults to disabled.
        Optionally allows undo for the command to be enabled or disabled.
        Defaults to disabled.Note: This is not thread safe; you may use
        executeCommandOnIdle instead.

        Returns:
        -----
        None

        Parameters:
        -----
        command: MString
        	[in] -> The MEL command string to execute 

        result: MCommandResult
        	[out] -> The command result 

        displayEnabled: bool
        	[in] -> Flag to enable display of command in journal window - defaults to false 

        undoEnabled: bool
        	[in] -> Flag to enable addition of command to undo queue - defaults to false


        '''
        pass

    @overload
    def executeCommand(self, command: MString,
                        result: int,
                        displayEnabled: bool,
                        undoEnabled: bool): 
        '''
        executeCommand(self, command: MString,
                        result: int,
                        displayEnabled: bool,
                        undoEnabled: bool)

        Synopsis
        -----
        Executes a MEL command that returns an integer result from the
        command engine. Optionally allows display of the command in the
        Command Window to be enabled or disabled. Defaults to disabled.
        Optionally allows undo for the command to be enabled or disabled.
        Defaults to disabled.Note: This is not thread safe; you may use
        executeCommandOnIdle instead.

        Returns:
        -----
        None

        Parameters:
        -----
        command: MString
        	[in] -> The MEL command string to execute 

        result: int
        	[out] -> The integer result 

        displayEnabled: bool
        	[in] -> Flag to enable display of command in journal window - defaults to false 

        undoEnabled: bool
        	[in] -> Flag to enable addition of command to undo queue - defaults to false


        '''
        pass

    @overload
    def executeCommand(self, command: MString,
                        result: MIntArray,
                        displayEnabled: bool,
                        undoEnabled: bool): 
        '''
        executeCommand(self, command: MString,
                        result: MIntArray,
                        displayEnabled: bool,
                        undoEnabled: bool)

        Synopsis
        -----
        Executes a MEL command that returns an integer array result from
        the command engine. Optionally allows display of the command in
        the Command Window to be enabled or disabled. Defaults to
        disabled. Optionally allows undo for the command to be enabled or
        disabled. Defaults to disabled.Note: This is not thread safe; you
        may use executeCommandOnIdle instead.

        Returns:
        -----
        None

        Parameters:
        -----
        command: MString
        	[in] -> The MEL command string to execute 

        result: MIntArray
        	[out] -> The 

        displayEnabled: bool
        	[in] -> Flag to enable display of command in journal window - defaults to false 

        undoEnabled: bool
        	[in] -> Flag to enable addition of command to undo queue - defaults to false


        '''
        pass

    @overload
    def executeCommand(self, command: MString,
                        result: double,
                        displayEnabled: bool,
                        undoEnabled: bool): 
        '''
        executeCommand(self, command: MString,
                        result: double,
                        displayEnabled: bool,
                        undoEnabled: bool)

        Synopsis
        -----
        Executes a MEL command that returns a double result from the
        command engine. Optionally allows display of the command in the
        Command Window to be enabled or disabled. Defaults to disabled.
        Optionally allows undo for the command to be enabled or disabled.
        Defaults to disabled.Note: This is not thread safe; you may use
        executeCommandOnIdle instead.

        Returns:
        -----
        None

        Parameters:
        -----
        command: MString
        	[in] -> The MEL command string to execute 

        result: double
        	[out] -> The double result 

        displayEnabled: bool
        	[in] -> Flag to enable display of command in journal window - defaults to false 

        undoEnabled: bool
        	[in] -> Flag to enable addition of command to undo queue - defaults to false


        '''
        pass

    @overload
    def executeCommand(self, command: MString,
                        result: MDoubleArray,
                        displayEnabled: bool,
                        undoEnabled: bool): 
        '''
        executeCommand(self, command: MString,
                        result: MDoubleArray,
                        displayEnabled: bool,
                        undoEnabled: bool)

        Synopsis
        -----
        Executes a MEL command that returns a double array result from
        the command engine. Optionally allows display of the command in
        the Command Window to be enabled or disabled. Defaults to
        disabled. Optionally allows undo for the command to be enabled or
        disabled. Defaults to disabled.Note: This is not thread safe; you
        may use executeCommandOnIdle instead.

        Returns:
        -----
        None

        Parameters:
        -----
        command: MString
        	[in] -> The MEL command string to execute 

        result: MDoubleArray
        	[out] -> The 

        displayEnabled: bool
        	[in] -> Flag to enable display of command in journal window - defaults to false 

        undoEnabled: bool
        	[in] -> Flag to enable addition of command to undo queue - defaults to false


        '''
        pass

    @overload
    def executeCommand(self, command: MString,
                        result: MStringArray,
                        displayEnabled: bool,
                        undoEnabled: bool): 
        '''
        executeCommand(self, command: MString,
                        result: MStringArray,
                        displayEnabled: bool,
                        undoEnabled: bool)

        Synopsis
        -----
        Executes a MEL command that returns a string array result from
        the command engine. Optionally allows display of the command in
        the Command Window to be enabled or disabled. Defaults to
        disabled. Optionally allows undo for the command to be enabled or
        disabled. Defaults to disabled.Note: This is not thread safe; you
        may use executeCommandOnIdle instead.

        Returns:
        -----
        None

        Parameters:
        -----
        command: MString
        	[in] -> The MEL command string to execute 

        result: MStringArray
        	[out] -> The 

        displayEnabled: bool
        	[in] -> Flag to enable display of command in journal window - defaults to false 

        undoEnabled: bool
        	[in] -> Flag to enable addition of command to undo queue - defaults to false


        '''
        pass

    def executeCommandStringResult(self, command: MString,
                        displayEnabled: bool,
                        undoEnabled: bool,
                        ReturnStatus: MGlobal.MStatus): 
        '''
        executeCommandStringResult(self, command: MString,
                        displayEnabled: bool,
                        undoEnabled: bool,
                        ReturnStatus: MGlobal.MStatus) -> MString

        Synopsis
        -----
        Executes a MEL command that returns a string result from the
        command engine. Optionally allows display of the command in the
        Command Window to be enabled or disabled. Defaults to disabled.
        Optionally allows undo for the command to be enabled or disabled.
        Defaults to disabled.Note: This is not thread safe; you may use
        executeCommandOnIdle instead.

        Returns: 
        ----- 
        String value returned by command

        Parameters:
        -----
        command: MString
        	[in] -> The MEL command string to execute 

        displayEnabled: bool
        	[in] -> Flag to enable display of command in journal window - defaults to false 

        undoEnabled: bool
        	[in] -> Flag to enable addition of command to undo queue - defaults to false 

        ReturnStatus: MGlobal.MStatus
        	[out] -> Optional return status. See below.


        '''
        pass

    @overload
    def executePythonCommand(self, command: MString,
                        displayEnabled: bool,
                        undoEnabled: bool): 
        '''
        executePythonCommand(self, command: MString,
                        displayEnabled: bool,
                        undoEnabled: bool)

        Synopsis
        -----
        Executes a Python command with no access to result. Optionally
        allows display of the command in the Command Window to be enabled
        or disabled. Defaults to disabled. Optionally allows undo for the
        command to be enabled or disabled. Defaults to disabled.Note:
        This is not thread safe; you may use executePythonCommandOnIdle
        instead.

        Returns:
        -----
        None

        Parameters:
        -----
        command: MString
        	[in] -> The Python command string to execute. 

        displayEnabled: bool
        	[in] -> Flag to enable display of command in journal window - defaults to false 

        undoEnabled: bool
        	[in] -> Flag to enable addition of command to undo queue - defaults to false


        '''
        pass

    @overload
    def executePythonCommand(self, command: MString,
                        result: int,
                        displayEnabled: bool,
                        undoEnabled: bool): 
        '''
        executePythonCommand(self, command: MString,
                        result: int,
                        displayEnabled: bool,
                        undoEnabled: bool)

        Synopsis
        -----
        Executes a Python command that returns an integer result from the
        command engine. Optionally allows display of the command in the
        Command Window to be enabled or disabled. Defaults to disabled.
        Optionally allows undo for the command to be enabled or disabled.
        Defaults to disabled.Note: This is not thread safe; you may use
        executePythonCommandOnIdle instead.

        Returns:
        -----
        None

        Parameters:
        -----
        command: MString
        	[in] -> The Python command string to execute 

        result: int
        	[out] -> The integer result 

        displayEnabled: bool
        	[in] -> Flag to enable display of command in journal window - defaults to false 

        undoEnabled: bool
        	[in] -> Flag to enable addition of command to undo queue - defaults to false


        '''
        pass

    @overload
    def executePythonCommand(self, command: MString,
                        result: MIntArray,
                        displayEnabled: bool,
                        undoEnabled: bool): 
        '''
        executePythonCommand(self, command: MString,
                        result: MIntArray,
                        displayEnabled: bool,
                        undoEnabled: bool)

        Synopsis
        -----
        Executes a Python command that returns an integer array result
        from the command engine. Optionally allows display of the command
        in the Command Window to be enabled or disabled. Defaults to
        disabled. Optionally allows undo for the command to be enabled or
        disabled. Defaults to disabled.Note: This is not thread safe; you
        may use executePythonCommandOnIdle instead.

        Returns:
        -----
        None

        Parameters:
        -----
        command: MString
        	[in] -> The Python command string to execute 

        result: MIntArray
        	[out] -> The integer array result 

        displayEnabled: bool
        	[in] -> Flag to enable display of command in journal window - defaults to false 

        undoEnabled: bool
        	[in] -> Flag to enable addition of command to undo queue - defaults to false


        '''
        pass

    @overload
    def executePythonCommand(self, command: MString,
                        result: double,
                        displayEnabled: bool,
                        undoEnabled: bool): 
        '''
        executePythonCommand(self, command: MString,
                        result: double,
                        displayEnabled: bool,
                        undoEnabled: bool)

        Synopsis
        -----
        Executes a Python command that returns a double result from the
        command engine. Optionally allows display of the command in the
        Command Window to be enabled or disabled. Defaults to disabled.
        Optionally allows undo for the command to be enabled or disabled.
        Defaults to disabled.Note: This is not thread safe; you may use
        executePythonCommandOnIdle instead.

        Returns:
        -----
        None

        Parameters:
        -----
        command: MString
        	[in] -> The Python command string to execute 

        result: double
        	[out] -> The double result 

        displayEnabled: bool
        	[in] -> Flag to enable display of command in journal window - defaults to false 

        undoEnabled: bool
        	[in] -> Flag to enable addition of command to undo queue - defaults to false


        '''
        pass

    @overload
    def executePythonCommand(self, command: MString,
                        result: MDoubleArray,
                        displayEnabled: bool,
                        undoEnabled: bool): 
        '''
        executePythonCommand(self, command: MString,
                        result: MDoubleArray,
                        displayEnabled: bool,
                        undoEnabled: bool)

        Synopsis
        -----
        Executes a Python command that returns a double array result from
        the command engine. Optionally allows display of the command in
        the Command Window to be enabled or disabled. Defaults to
        disabled. Optionally allows undo for the command to be enabled or
        disabled. Defaults to disabled.Note: This is not thread safe; you
        may use executePythonCommandOnIdle instead.

        Returns:
        -----
        None

        Parameters:
        -----
        command: MString
        	[in] -> The Python command string to execute 

        result: MDoubleArray
        	[out] -> The double array result 

        displayEnabled: bool
        	[in] -> Flag to enable display of command in journal window - defaults to false 

        undoEnabled: bool
        	[in] -> Flag to enable addition of command to undo queue - defaults to false


        '''
        pass

    def executePythonCommandStringResult(self, command: MString,
                        displayEnabled: bool,
                        undoEnabled: bool,
                        ReturnStatus: MGlobal.MStatus): 
        '''
        executePythonCommandStringResult(self, command: MString,
                        displayEnabled: bool,
                        undoEnabled: bool,
                        ReturnStatus: MGlobal.MStatus) -> MString

        Synopsis
        -----
        Executes a Python command that returns a string result from the
        command engine. Optionally allows display of the command in the
        Command Window to be enabled or disabled. Defaults to disabled.
        Optionally allows undo for the command to be enabled or disabled.
        Defaults to disabled.Note: This is not thread safe; you may use
        executePythonCommandOnIdle instead.

        Returns: 
        ----- 
        String returned from command

        Parameters:
        -----
        command: MString
        	[in] -> The Python command string to execute 

        displayEnabled: bool
        	[in] -> Flag to enable display of command in journal window - defaults to false 

        undoEnabled: bool
        	[in] -> Flag to enable addition of command to undo queue - defaults to false 

        ReturnStatus: MGlobal.MStatus
        	[out] -> Optional return status. See below.


        '''
        pass

    @overload
    def executePythonCommand(self, command: MString,
                        result: MString,
                        displayEnabled: bool,
                        undoEnabled: bool): 
        '''
        executePythonCommand(self, command: MString,
                        result: MString,
                        displayEnabled: bool,
                        undoEnabled: bool)

        Synopsis
        -----
        Executes a Python command that returns a string result from the
        command engine. Optionally allows display of the command in the
        Command Window to be enabled or disabled. Defaults to disabled.
        Optionally allows undo for the command to be enabled or disabled.
        Defaults to disabled.Note: This is not thread safe; you may use
        executePythonCommandOnIdle instead.Python NotesThis method is not
        supported in Python. Please see the
        executePythonCommandStringResult() function.

        Returns:
        -----
        None

        Parameters:
        -----
        command: MString
        	[in] -> The Python command string to execute 

        result: MString
        	[out] -> The string result 

        displayEnabled: bool
        	[in] -> Flag to enable display of command in journal window - defaults to false 

        undoEnabled: bool
        	[in] -> Flag to enable addition of command to undo queue - defaults to false


        '''
        pass

    @overload
    def executePythonCommand(self, command: MString,
                        result: MStringArray,
                        displayEnabled: bool,
                        undoEnabled: bool): 
        '''
        executePythonCommand(self, command: MString,
                        result: MStringArray,
                        displayEnabled: bool,
                        undoEnabled: bool)

        Synopsis
        -----
        Executes a Python command that returns a string array result from
        the command engine. Optionally allows display of the command in
        the Command Window to be enabled or disabled. Defaults to
        disabled. Optionally allows undo for the command to be enabled or
        disabled. Defaults to disabled.Note: This is not thread safe; you
        may use executePythonCommandOnIdle instead.

        Returns:
        -----
        None

        Parameters:
        -----
        command: MString
        	[in] -> The Python command string to execute 

        result: MStringArray
        	[out] -> The string array result 

        displayEnabled: bool
        	[in] -> Flag to enable display of command in journal window - defaults to false 

        undoEnabled: bool
        	[in] -> Flag to enable addition of command to undo queue - defaults to false


        '''
        pass

    def executePythonCommandOnIdle(self, command: MString,
                        displayEnabled: bool): 
        '''
        executePythonCommandOnIdle(self, command: MString,
                        displayEnabled: bool)

        Synopsis
        -----
        Sets a Python command to execute on the next idle event. This is
        a thread safe way to execute commands, however, there is no
        access to the command results. Optionally allows display of the
        command in the Command Window to be enabled or disabled. Defaults
        to disabled.

        Returns:
        -----
        None

        Parameters:
        -----
        command: MString
        	[in] -> The Python command string to add to idle queue. 

        displayEnabled: bool
        	[in] -> Flag to enable display of command in journal window - defaults to false


        '''
        pass

    def addToModel(self, object: MObject,
                        parent: MObject): 
        '''
        addToModel(self, object: MObject,
                        parent: MObject)

        Synopsis
        -----
        This method is used to add new dag objects to the model. If no
        parent node is specified, then the node is added under the world.
        When a node is added under the world, then a transform node is
        automatically created as a parent. This assumes that the node
        being added is not already a transform node. This method is only
        valid for dag nodes. If the specified object is not of type
        MFn::kDagNode then MS::kInvalidParameter will be returned.

        Returns:
        -----
        None

        Parameters:
        -----
        object: MObject
        	[in] -> object to be added 

        parent: MObject
        	[in] -> parent dag node (optional)


        '''
        pass

    def addToModelAt(self, object: MObject,
                        point: MVector,
                        scale: double3,
                        rotation: double3,
                        rotOrder: MTransformationMatrix.MTransformationMatrix): 
        '''
        addToModelAt(self, object: MObject,
                        point: MVector,
                        scale: double3,
                        rotation: double3,
                        rotOrder: MTransformationMatrix.MTransformationMatrix)

        Synopsis
        -----
        Adds the specified dag object to the DAG and transform the object
        by the specified arguments. This method is only valid for dag
        nodes. If the specified object is not of type MFn::kDagNode then
        MS::kInvalidParameter will be returned.

        Returns:
        -----
        None

        Parameters:
        -----
        object: MObject
        	[in] -> the object to be added to the DAG 

        point: MVector
        	[in] -> translation vector 

        scale: double3
        	[in] -> scale amount 

        rotation: double3
        	[in] -> rotation amount 

        rotOrder: MTransformationMatrix.MTransformationMatrix
        	[in] -> the order of the rotation


        '''
        pass

    def removeFromModel(self, object: MObject): 
        '''
        removeFromModel(self, object: MObject)

        Synopsis
        -----
        Removes the specified dag node from the scene. This method is
        only valid for dag nodes. If the specified object is not of type
        MFn::kDagNode then MS::kInvalidParameter will be returned.Note
        that this method doesn't delete the dag node which means the node
        must be added back to scene by calling either
        MGlobal::addToModel() or MGlobal::addToModelAt() in later calls,
        otherwise the dag node is leaked. To delete the dag node, call
        MGlobal::deleteNode() instead.

        Returns:
        -----
        None

        Parameters:
        -----
        object: MObject
        	[in] -> dag node to be removed from the scene


        '''
        pass

    def deleteNode(self, object: MObject): 
        '''
        deleteNode(self, object: MObject)

        Synopsis
        -----
        Delete the given dag node or dependency graph node.

        Returns:
        -----
        None

        Parameters:
        -----
        object: MObject
        	[in] -> node to be deleted


        '''
        pass

    def setYAxisUp(self, rotateView: bool): 
        '''
        setYAxisUp(self, rotateView: bool)

        Synopsis
        -----
        This method sets the flag to identify which axis is Up, and
        rotates the ground plane around around the X-axis 90 degrees to
        get the Y-Up from Z-Up.

        Returns:
        -----
        None

        Parameters:
        -----
        rotateView: bool
        	[in] -> If true then the viewing camera will be rotated


        '''
        pass

    def setZAxisUp(self, rotateView: bool): 
        '''
        setZAxisUp(self, rotateView: bool)

        Synopsis
        -----
        This method sets the flag to identify which axis is Up, and
        rotates the ground plane around around the X-axis -90 degrees to
        get the Z-Up from Y-Up.

        Returns:
        -----
        None

        Parameters:
        -----
        rotateView: bool
        	[in] -> If true then the viewing camera will be rotated


        '''
        pass

    def isYAxisUp(self, ReturnStatus: MGlobal.MStatus): 
        '''
        isYAxisUp(self, ReturnStatus: MGlobal.MStatus) -> bool

        Synopsis
        -----
        This method returns true if, currently, the Y-axis is UP.

        Returns: 
        ----- 
        Boolean value: true the Y-axis is Up, false otherwise.

        Parameters:
        -----
        ReturnStatus: MGlobal.MStatus
        	[in] -> 


        '''
        pass

    def isZAxisUp(self, ReturnStatus: MGlobal.MStatus): 
        '''
        isZAxisUp(self, ReturnStatus: MGlobal.MStatus) -> bool

        Synopsis
        -----
        This method returns true if, currently, the Z-axis is UP.

        Returns: 
        ----- 
        Boolean value: true the Z-axis is Up, false otherwise.

        Parameters:
        -----
        ReturnStatus: MGlobal.MStatus
        	[in] -> 


        '''
        pass

    def upAxis(self, ReturnStatus: MGlobal.MStatus): 
        '''
        upAxis(self, ReturnStatus: MGlobal.MStatus) -> MVector

        Synopsis
        -----
        This method returns the model's current up axis.

        Returns: 
        ----- 
        The models up axis

        Parameters:
        -----
        ReturnStatus: MGlobal.MStatus
        	[in] -> 


        '''
        pass

    def displayInfo(self, theMessage: MString): 
        '''
        displayInfo(self, theMessage: MString)

        Synopsis
        -----
        This method is used to display an informational message in the
        script editor. This method is threadsafe, however for calls made
        outside of Maya's main thread the display of text will be
        deferred to the next idle cycle.

        Returns:
        -----
        None

        Parameters:
        -----
        theMessage: MString
        	[in] -> The message string to be displayed 


        '''
        pass

    def displayWarning(self, theWarning: MString): 
        '''
        displayWarning(self, theWarning: MString)

        Synopsis
        -----
        This method is used to display a warning in the script editor.
        This method is threadsafe, however for calls made outside of
        Maya's main thread the display of text will be deferred to the
        next idle cycle.

        Returns:
        -----
        None

        Parameters:
        -----
        theWarning: MString
        	[in] -> The warning string to be displayed 


        '''
        pass

    def displayError(self, theError: MString): 
        '''
        displayError(self, theError: MString)

        Synopsis
        -----
        This method is used to display an error in the script editor.
        This method is threadsafe, however for calls made outside of
        Maya's main thread the display of text will be deferred to the
        next idle cycle.

        Returns:
        -----
        None

        Parameters:
        -----
        theError: MString
        	[in] -> The error string to be displayed 


        '''
        pass

    def setDisableStow(self, state: bool): 
        '''
        setDisableStow(self, state: bool)

        Synopsis
        -----
        This method is used to make the visiblity of all Maya windows
        unchangable. If set to true, it disables any attempts to change
        the visiblity of any window. In addition, all popup windows will
        be supressed.

        Returns:
        -----
        None

        Parameters:
        -----
        state: bool
        	[in] -> true or false 


        '''
        pass

    def disableStow(self): 
        '''
        disableStow(self) -> bool

        Synopsis
        -----
        This method is used to query if the disabling of Stowing (hiding)
        and Unstowing (showing) windows is active.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def optionVarIntValue(self, name: MString,
                        exists: bool): 
        '''
        optionVarIntValue(self, name: MString,
                        exists: bool) -> int

        Synopsis
        -----
        This method is used to get the option variable value of int type.

        Returns: 
        ----- 
        Value of the variable as an integer.

        Parameters:
        -----
        name: MString
        	[in] -> option variable name 

        exists: bool
        	[out] -> true if variable exists, false otherwise


        '''
        pass

    def optionVarDoubleValue(self, name: MString,
                        exists: bool): 
        '''
        optionVarDoubleValue(self, name: MString,
                        exists: bool) -> double

        Synopsis
        -----
        This method is used to get the option variable value of type
        double.

        Returns: 
        ----- 
        Value of the variable as a double.

        Parameters:
        -----
        name: MString
        	[in] -> option variable name 

        exists: bool
        	[out] -> true if variable exists, false otherwise


        '''
        pass

    def optionVarStringValue(self, name: MString,
                        exists: bool): 
        '''
        optionVarStringValue(self, name: MString,
                        exists: bool) -> MString

        Synopsis
        -----
        This method is used to get the option variable value of type
        string.

        Returns: 
        ----- 
        Value of the variable as a string.

        Parameters:
        -----
        name: MString
        	[in] -> option variable name 

        exists: bool
        	[out] -> true if variable exists, false otherwise


        '''
        pass

    @overload
    def setOptionVarValue(self, name: MString,
                        value: int): 
        '''
        setOptionVarValue(self, name: MString,
                        value: int) -> bool

        Synopsis
        -----
        This method is used to set the option variable value of int type.

        Returns: 
        ----- 
        true

        Parameters:
        -----
        name: MString
        	[in] -> option variable name 

        value: int
        	[in] -> option variable value to set


        '''
        pass

    @overload
    def setOptionVarValue(self, optionVarName: MString,
                        value: double): 
        '''
        setOptionVarValue(self, optionVarName: MString,
                        value: double) -> bool

        Synopsis
        -----
        This method is used to set the option variable value of type
        double.

        Returns: 
        ----- 
        true

        Parameters:
        -----
        optionVarName: MString
        	[in] -> option variable name 

        value: double
        	[in] -> option variable value to set


        '''
        pass

    @overload
    def setOptionVarValue(self, name: MString,
                        value: MString): 
        '''
        setOptionVarValue(self, name: MString,
                        value: MString) -> bool

        Synopsis
        -----
        This method is used to set the option variable value of type
        string.

        Returns: 
        ----- 
        true

        Parameters:
        -----
        name: MString
        	[in] -> option variable name 

        value: MString
        	[in] -> option variable value to set


        '''
        pass

    @overload
    def initOptionVar(self, name: MString,
                        value: int,
                        category: MString): 
        '''
        initOptionVar(self, name: MString,
                        value: int,
                        category: MString) -> bool

        Synopsis
        -----
        Introduced in 2023.0 This method is used to initialize an option
        variable value of type int.This method will create the option var
        if it doesn't exist and set the default value and category.

        Returns: 
        ----- 
        true

        Parameters:
        -----
        name: MString
        	[in] -> option variable name 

        value: int
        	[in] -> option variable default value 

        category: MString
        	[in] -> option variable category


        '''
        pass

    @overload
    def initOptionVar(self, name: MString,
                        value: double,
                        category: MString): 
        '''
        initOptionVar(self, name: MString,
                        value: double,
                        category: MString) -> bool

        Synopsis
        -----
        Introduced in 2023.0 This method is used to initialize an option
        variable value of type double.This method will create the option
        var if it doesn't exist and set the default value and category.

        Returns: 
        ----- 
        true

        Parameters:
        -----
        name: MString
        	[in] -> option variable name 

        value: double
        	[in] -> option variable default value 

        category: MString
        	[in] -> option variable category


        '''
        pass

    @overload
    def initOptionVar(self, name: MString,
                        value: MString,
                        category: MString): 
        '''
        initOptionVar(self, name: MString,
                        value: MString,
                        category: MString) -> bool

        Synopsis
        -----
        Introduced in 2023.0 This method is used to initialize an option
        variable value of type string.This method will create the option
        var if it doesn't exist and set the default value and category.

        Returns: 
        ----- 
        true

        Parameters:
        -----
        name: MString
        	[in] -> option variable name 

        value: MString
        	[in] -> option variable default value 

        category: MString
        	[in] -> option variable category


        '''
        pass

    def removeOptionVar(self, name: MString): 
        '''
        removeOptionVar(self, name: MString)

        Synopsis
        -----
        This method is used to remove the option variable.

        Returns:
        -----
        None

        Parameters:
        -----
        name: MString
        	[in] -> option variable name 


        '''
        pass

    def optionVarExists(self, name: MString): 
        '''
        optionVarExists(self, name: MString) -> bool

        Synopsis
        -----
        This method is used to check if the option variable exists.

        Returns: 
        ----- 
        true if option variable exists

        Parameters:
        -----
        name: MString
        	[in] -> option variable name


        '''
        pass

    def defaultErrorLogPathName(self, ReturnStatus: MGlobal.MStatus): 
        '''
        defaultErrorLogPathName(self, ReturnStatus: MGlobal.MStatus) -> MString

        Synopsis
        -----
        Determines the default path name of the error log file. Returns
        an empty string on failure.

        Returns: 
        ----- 
        Default path name

        Parameters:
        -----
        ReturnStatus: MGlobal.MStatus
        	[out] -> Status code


        '''
        pass

    def resetToDefaultErrorLogPathName(self): 
        '''
        resetToDefaultErrorLogPathName(self)

        Synopsis
        -----
        Closes the current log file if it is open, and then resets the
        log path to the default path. Logging is disabled and the log
        file speicified by the default path is not opened. If logging is
        disabled, it remains disabled. Use startErrorLogging() to enable
        logging to the default log file. If the current path is the
        default path, no action is taken, but an invalid parameter error
        is returned.Note that if the default log is reopened after it is
        closed, all information previously logged to it is lost.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setErrorLogPathName(self, logPathName: MString): 
        '''
        setErrorLogPathName(self, logPathName: MString)

        Synopsis
        -----
        Closes the current log file if it is open, and then sets the log
        path to the given path. If logging is enabled, it remains
        enabled, but on the log file speicified by the new path. If
        logging is disabled, it remains disabled. Use startErrorLogging()
        to enable logging to the new file. If the given path name is the
        same as the current path name, no action is taken, but an invalid
        parameter error is returned.

        Returns:
        -----
        None

        Parameters:
        -----
        logPathName: MString
        	[in] -> Path of the new error log file


        '''
        pass

    def errorLogPathName(self, ReturnStatus: MGlobal.MStatus): 
        '''
        errorLogPathName(self, ReturnStatus: MGlobal.MStatus) -> MString

        Synopsis
        -----
        Determines the path name of the current error log file. Returns
        the null string on failure.

        Returns: 
        ----- 
        Error log path name

        Parameters:
        -----
        ReturnStatus: MGlobal.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    @overload
    def startErrorLogging(self): 
        '''
        startErrorLogging(self)

        Synopsis
        -----
        This method enables output to the API error log. If no log is
        currently open, a log file is opened at the current path. The
        error log is time and date stamped when it is opened. If output
        is already enabled, then no action is taken.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def startErrorLogging(self, logPathName: MString): 
        '''
        startErrorLogging(self, logPathName: MString)

        Synopsis
        -----
        This method enables output to the API error log file specified by
        the path. If another error log file is already open this method
        time and date stamps the log, and closes it. The new error log is
        time and date stamped when it is opened.If the new path name is
        the same as the current path name, this method ensures that
        logging is enabled, but no other action is taken.

        Returns:
        -----
        None

        Parameters:
        -----
        logPathName: MString
        	[in] -> Path of the error log file


        '''
        pass

    def errorLoggingIsOn(self, ReturnStatus: MGlobal.MStatus): 
        '''
        errorLoggingIsOn(self, ReturnStatus: MGlobal.MStatus) -> bool

        Synopsis
        -----
        This method determines whether or not API errors are being
        logged.

        Returns: 
        ----- 
        Boolean value: true Errors are being logged false otherwise.

        Parameters:
        -----
        ReturnStatus: MGlobal.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def stopErrorLogging(self): 
        '''
        stopErrorLogging(self)

        Synopsis
        -----
        This method disables output to the API error log but does not
        close the log file.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def closeErrorLog(self): 
        '''
        closeErrorLog(self)

        Synopsis
        -----
        This method closes the API error log file. If error logging is
        currently enabled this method disables it. The error log is time
        and date stamped before it is closed. After the log is closed the
        error log path name is reset to the default path name. If the
        error log file is already closed, then no action is taken.Note
        that if a log is reopened after it is closed, all information
        previously logged to it is lost.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def doErrorLogEntry(self, errorLogEntry: MString): 
        '''
        doErrorLogEntry(self, errorLogEntry: MString)

        Synopsis
        -----
        Logs an entry in the currently open log file. It is not necessary
        for error logging to be enabled, but a log file must be open. A
        newline is appended to each log entry.

        Returns:
        -----
        None

        Parameters:
        -----
        errorLogEntry: MString
        	[in] -> Information to log to file


        '''
        pass

    def isUndoing(self): 
        '''
        isUndoing(self) -> bool

        Synopsis
        -----
        Returns true if Maya is currently in the middle of an undo.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isRedoing(self): 
        '''
        isRedoing(self) -> bool

        Synopsis
        -----
        Returns true if Maya is currently in the middle of an redo.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MMayaFeatureSet:
    '''Introduced in 2023.0 
    Non-functional class.  Values for this enum:
    kComplete
    kRestricted
    '''

    def __init__(self):
        pass

    def kComplete(self):
        '''This is an enum of MMayaFeatureSet.
        - Description: Full set of all features available for given version of Maya is available. 
        - Value: 0
        '''
        pass

    def kRestricted(self):
        '''This is an enum of MMayaFeatureSet.
        - Description: Some features are restricted and/or not available at all. 
        - Value: 1
        '''
        pass

class MMayaState:
    '''State in which Maya has been started. 
    Non-functional class.  Values for this enum:
    kInteractive
    kBatch
    kLibraryApp
    kBaseUIMode
    '''

    def __init__(self):
        pass

    def kInteractive(self):
        '''This is an enum of MMayaState.
        - Description: Running with a UI. 
        - Value: 0
        '''
        pass

    def kBatch(self):
        '''This is an enum of MMayaState.
        - Description: Running without a UI. 
        - Value: 1
        '''
        pass

    def kLibraryApp(self):
        '''This is an enum of MMayaState.
        - Description: Running as a standalone (MLibrary) application. 
        - Value: 2
        '''
        pass

    def kBaseUIMode(self):
        '''This is an enum of MMayaState.
        - Description: Running with UI enabled but Maya's std UI scripts not run. 
        - Value: 3
        '''
        pass

class ListAdjustment:
    '''Operations on selection lists. 
    Non-functional class.  Values for this enum:
    kReplaceList
    kXORWithList
    kAddToList
    kRemoveFromList
    kAddToHeadOfList
    '''

    def __init__(self):
        pass

    def kReplaceList(self):
        '''This is an enum of ListAdjustment.
        - Description: Totally replace the list with the given items. 
        - Value: 0
        '''
        pass

    def kXORWithList(self):
        '''This is an enum of ListAdjustment.
        - Description: Any of the items which are already on the list will be removed. Any which are not already on the list will be added to the end of the list. 
        - Value: 1
        '''
        pass

    def kAddToList(self):
        '''This is an enum of ListAdjustment.
        - Description: Add the items to the end of the list. 
        - Value: 2
        '''
        pass

    def kRemoveFromList(self):
        '''This is an enum of ListAdjustment.
        - Description: Remove the items from the list. 
        - Value: 3
        '''
        pass

    def kAddToHeadOfList(self):
        '''This is an enum of ListAdjustment.
        - Description: Add the items to the beginning of the list. 
        - Value: 4
        '''
        pass

class SelectionMethod:
    '''Choices for types of selection methods used in the selectFromScreen functions. 
    Non-functional class.  Values for this enum:
    kSurfaceSelectMethod
    kWireframeSelectMethod
    '''

    def __init__(self):
        pass

    def kSurfaceSelectMethod(self):
        '''This is an enum of SelectionMethod.
        - Description: Select based on the surface of the objects. 
        - Value: 0
        '''
        pass

    def kWireframeSelectMethod(self):
        '''This is an enum of SelectionMethod.
        - Description: Select based on the wireframe of the objects. 
        - Value: 1
        '''
        pass

class MSelectionMode:
    '''Global selection modes. 
    Non-functional class.  Values for this enum:
    kSelectObjectMode
    kSelectComponentMode
    kSelectRootMode
    kSelectLeafMode
    kSelectTemplateMode
    '''

    def __init__(self):
        pass

    def kSelectObjectMode(self):
        '''This is an enum of MSelectionMode.
        - Description: Select objects. 
        - Value: 0
        '''
        pass

    def kSelectComponentMode(self):
        '''This is an enum of MSelectionMode.
        - Description: Select components. 
        - Value: 1
        '''
        pass

    def kSelectRootMode(self):
        '''This is an enum of MSelectionMode.
        - Description: Select DAG roots. 
        - Value: 2
        '''
        pass

    def kSelectLeafMode(self):
        '''This is an enum of MSelectionMode.
        - Description: Select DAG leaves. 
        - Value: 3
        '''
        pass

    def kSelectTemplateMode(self):
        '''This is an enum of MSelectionMode.
        - Description: Select templated objects. 
        - Value: 4
        '''
        pass

class MIdleTaskPriority:
    '''Introduced in 2019.0 
    Non-functional class.  Values for this enum:
    kHighIdlePriority
    kLowIdlePriority
    kVeryLowIdlePriority
    '''

    def __init__(self):
        pass

    def kHighIdlePriority(self):
        '''This is an enum of MIdleTaskPriority.
        - Description: High priority. 
        - Value: None
        '''
        pass

    def kLowIdlePriority(self):
        '''This is an enum of MIdleTaskPriority.
        - Description: Low priority. 
        - Value: None
        '''
        pass

    def kVeryLowIdlePriority(self):
        '''This is an enum of MIdleTaskPriority.
        - Description: Very low priority. 
        - Value: None
        '''
        pass

class MIffFile:
    '''Read file images stored on disk.
This class provides a simple C++ interface to the IFF i/o library
(flib). A class called
MIffTag is used to create the 4 byte tags that are used to distinguish
the different block types within an IFF file.
'''
    def __init__(self):
        pass


    def open(self, fileName: MString): 
        '''
        open(self, fileName: MString)

        Synopsis
        -----
        Opens the file for reading.

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> The file name (full path).


        '''
        pass

    def close(self): 
        '''
        close(self)

        Synopsis
        -----
        Close the currently open file.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isActive(self): 
        '''
        isActive(self) -> bool

        Synopsis
        -----
        Is the file currently active?

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def beginReadGroup(self, id: MIffTag,
                        type: MIffTag): 
        '''
        beginReadGroup(self, id: MIffTag,
                        type: MIffTag)

        Synopsis
        -----
        Opens a group for reading. A group is composed of several chunks
        (sub-groups). Provides the id and type of the current group. Can
        be followed by several calls to chunk reading functions or to
        nested beginReadGroup(...) calls if needed (depending on the file
        structure). The function endReadGroup(...) is used to closed a
        group skipping remaining data (including nested groups).

        Returns:
        -----
        None

        Parameters:
        -----
        id: MIffTag
        	[out] -> id of the group being read 

        type: MIffTag
        	[out] -> type of the group being read


        '''
        pass

    def endReadGroup(self): 
        '''
        endReadGroup(self)

        Synopsis
        -----
        Closes group currently being read, skipping remaining data
        (including nested groups).

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getChunk(self, chunkTag: MIffTag,
                        byteCount: *): 
        '''
        getChunk(self, chunkTag: MIffTag,
                        byteCount: *) -> void*

        Synopsis
        -----
        Opens a chunk for reading. A chunk is a block of unstructured
        data with an associated tag.

        Returns: 
        ----- 
        Returns a pointer to the data, the content of which should not be
        modified.  NULL if the read was not successful.

        Parameters:
        -----
        chunkTag: MIffTag
        	[out] -> chunk's associated tag 

        byteCount: *
        	[out] -> number of bytes in the chunk


        '''
        pass

    def beginGet(self, chunkTag: MIffTag,
                        byteCount: *): 
        '''
        beginGet(self, chunkTag: MIffTag,
                        byteCount: *)

        Synopsis
        -----
        Begin grabbing the data.

        Returns:
        -----
        None

        Parameters:
        -----
        chunkTag: MIffTag
        	[out] -> tag of current chunk 

        byteCount: *
        	[out] -> number of bytes in the chunk


        '''
        pass

    def endGet(self): 
        '''
        endGet(self)

        Synopsis
        -----
        Finish grabbing the data.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def get(self, buf: void,
                        byteCount: unsigned,
                        ReturnStatus: MIffFile.MStatus): 
        '''
        get(self, buf: void,
                        byteCount: unsigned,
                        ReturnStatus: MIffFile.MStatus) -> int

        Synopsis
        -----
        Attempt to read 'byteCount' bytes from the file into the buffer
        pointed to by buf.

        Returns: 
        ----- 
        Number of bytes read if successful.

        Parameters:
        -----
        buf: void
        	[out] -> pointer to buffer in which to store the data read from the file. 

        byteCount: unsigned
        	[in] -> maximum number of bytes that 

        ReturnStatus: MIffFile.MStatus
        	[out] -> status code


        '''
        pass

    def iffGetShort(self, result: short): 
        '''
        iffGetShort(self, result: short)

        Synopsis
        -----
        Grabs a short from the active file.

        Returns:
        -----
        None

        Parameters:
        -----
        result: short
        	[out] -> the short value read from the file


        '''
        pass

    def iffGetInt(self, result: int): 
        '''
        iffGetInt(self, result: int)

        Synopsis
        -----
        Grabs an integer from the active file.

        Returns:
        -----
        None

        Parameters:
        -----
        result: int
        	[out] -> the int value read from the file


        '''
        pass

    def iffGetFloat(self, result: float): 
        '''
        iffGetFloat(self, result: float)

        Synopsis
        -----
        Grabs a float from the active file.

        Returns:
        -----
        None

        Parameters:
        -----
        result: float
        	[out] -> the float value read from the file


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MIffTag:
    '''Encapsulates IFF's 4 character block structure.
Class
MIffTag is used to create the 4 byte tags that are used to distinguish
the different block types within an IFF file.
'''
    def __init__(self):
        pass


    def __eq__(self, tag: MIffTag): 
        '''
        __eq__(self, tag: MIffTag) -> bool

        Synopsis
        -----
        Equals operator.

        Returns:
        -----
        None

        Parameters:
        -----
        tag: MIffTag
        	[in] -> tag value to compare against 


        '''
        pass

class MImage:
    '''Image manipulation.
This class provides methods for reading file images stored on
disk.
MImage is a class which provides access to some of Maya's image
manipulation functionality. It has methods for loading and
resizing image files in any Maya-supported raster format,
including IFF, SGI, Softimage (pic), TIFF (tif), Alias PIX (als),
GIF, RLA, JPEG (jpg). The image is stored as an uncompressed
array of pixels, that can be read and manipulated directly. For
simplicity, the pixels are stored in a RGBA format (4 bytes per
pixel).
'''
    def __init__(self):
        pass


    def create(self, width: int,
                        height: int,
                        channels: int,
                        type: MImage.MPixelType): 
        '''
        create(self, width: int,
                        height: int,
                        channels: int,
                        type: MImage.MPixelType)

        Synopsis
        -----
        Create a new MImage object. Allocates memory for an RGBA array of
        pixels of the given size. If an object was already in memory, it
        is released first.

        Returns:
        -----
        None

        Parameters:
        -----
        width: int
        	[in] -> the desired image's width in pixels. 

        height: int
        	[in] -> the desired image's height in pixels. 

        channels: int
        	[in] -> the desired number of channels per pixel. For byte typed images, 4 channels is the only value currently supported. 

        type: MImage.MPixelType
        	[in] -> the desired pixel format.


        '''
        pass

    def readFromFile(self, pathname: MString,
                        type: MImage.MPixelType): 
        '''
        readFromFile(self, pathname: MString,
                        type: MImage.MPixelType)

        Synopsis
        -----
        Attempt to identify and open the specified image file. Please
        note that IFF and SGI are the fastest image file formats for
        reading.

        Returns:
        -----
        None

        Parameters:
        -----
        pathname: MString
        	[in] -> the full path of the image file that should be opened. 

        type: MImage.MPixelType
        	[in] -> the desired pixel format. kUnknown attempts to load the native pixel type.


        '''
        pass

    def readFromTextureNode(self, fileTextureObject: MObject,
                        type: MImage.MPixelType): 
        '''
        readFromTextureNode(self, fileTextureObject: MObject,
                        type: MImage.MPixelType)

        Synopsis
        -----
        Attempt to read the content of the given file texture node.
        Please note that IFF and SGI are the fastest image file formats
        for reading.

        Returns:
        -----
        None

        Parameters:
        -----
        fileTextureObject: MObject
        	[in] -> an object that refers to the file texture node that should be read. 

        type: MImage.MPixelType
        	[in] -> the desired pixel format. kUnknown attempts to load the native image pixel type.


        '''
        pass

    def getSize(self, width: int,
                        height: int): 
        '''
        getSize(self, width: int,
                        height: int)

        Synopsis
        -----
        Get the width and height of the currently opened image.

        Returns:
        -----
        None

        Parameters:
        -----
        width: int
        	[out] -> the variable that will be set to the image's width in pixels. 

        height: int
        	[out] -> the variable that will be set to the image's height in pixels.


        '''
        pass

    def pixelType(self): 
        '''
        pixelType(self) -> MImage.MImage

        Synopsis
        -----
        Get the current pixel format of the image.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def pixels(self): 
        '''
        pixels(self) -> char*

        Synopsis
        -----
        Returns a pointer to the first pixel of the uncompressed pixels
        array. This array is tightly packed, of size (width * height *
        depth) bytes. For the moment, pixels are always stored in a RGBA
        (depth=4 bytes) pixel format.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def floatPixels(self): 
        '''
        floatPixels(self) -> float*

        Synopsis
        -----
        Returns a pointer to the first pixel of the uncompressed pixels
        array. This array is tightly packed, of size (width * height *
        depth * sizeof( float)) bytes.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setPixels(self, inPixelPtr: char,
                        width: int,
                        height: int): 
        '''
        setPixels(self, inPixelPtr: char,
                        width: int,
                        height: int)

        Synopsis
        -----
        Set the pointer to the first pixel of the uncompressed pixels
        array. This array is tightly packed, of size (width * height *
        depth) bytes. For the moment, pixels are always stored in a RGBA
        (depth=4 bytes) pixel format.

        Returns:
        -----
        None

        Parameters:
        -----
        inPixelPtr: char
        	[in] -> the variable containing a block of pixels. 

        width: int
        	[in] -> the variable that will be set to the image's width in pixels. 

        height: int
        	[in] -> the variable that will be set to the image's height in pixels. 


        '''
        pass

    def setFloatPixels(self, inPixelPtr: float,
                        width: int,
                        height: int,
                        channels: int): 
        '''
        setFloatPixels(self, inPixelPtr: float,
                        width: int,
                        height: int,
                        channels: int)

        Synopsis
        -----
        Set the pointer to the first pixel of the uncompressed pixels
        array. This array is tightly packed, of size (width * height *
        depth) bytes. For the moment, pixels are always stored in a RGBA
        (depth=4 bytes) pixel format.

        Returns:
        -----
        None

        Parameters:
        -----
        inPixelPtr: float
        	[in] -> the variable containing a block of pixels. 

        width: int
        	[in] -> the variable that will be set to the image's width in pixels. 

        height: int
        	[in] -> the variable that will be set to the image's height in pixels. 

        channels: int
        	[in] -> the number of channels per pixel. 


        '''
        pass

    def depth(self): 
        '''
        depth(self) -> int

        Synopsis
        -----
        Get the color depth (in bytes) of the currently opened image.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getDepthMapSize(self, width: int,
                        height: int): 
        '''
        getDepthMapSize(self, width: int,
                        height: int)

        Synopsis
        -----
        Returns the size of the depth map buffer. Note, depth maps can
        differ in resolution from the color map. This is mainly for
        oversampling support in image planes. In all other cases, you
        should insure that depth size matches the color buffer size. You
        cannot write out an image where the depth map and image map has
        different resolutions.Note, depth maps are not support with HDR,
        or floating point, images.

        Returns:
        -----
        None

        Parameters:
        -----
        width: int
        	[out] -> - width of the depth map 

        height: int
        	[out] -> - height of the depth map


        '''
        pass

    def getDepthMapRange(self, minValue: float,
                        maxValue: float): 
        '''
        getDepthMapRange(self, minValue: float,
                        maxValue: float)

        Synopsis
        -----
        Compute the minimum and maximum depth values (range) for any
        stored depth buffer. The depth values returned are positive
        distances from the camera, with higher values indicating points
        further from the camera.

        Returns:
        -----
        None

        Parameters:
        -----
        minValue: float
        	[out] -> Minimum value 

        maxValue: float
        	[out] -> Maximum value


        '''
        pass

    @overload
    def setDepthMap(self, depth: float,
                        width: unsigned,
                        height: unsigned): 
        '''
        setDepthMap(self, depth: float,
                        width: unsigned,
                        height: unsigned)

        Synopsis
        -----
        Specifies the depth map resolution and data. Note, it is possible
        for the depth map to be a different resolution from the color
        map. This is to support oversampling with image planes. You
        cannot save image data to a file if the color map and image maps
        are different resolutions.

        Returns:
        -----
        None

        Parameters:
        -----
        depth: float
        	[in] -> - float buffer that contains depth values. The depth values should be stored as -1.0/eyeDistance, where eyeDistance == 0.0 implies no depth is at that location. 

        width: unsigned
        	[in] -> - the width of the depth buffer 

        height: unsigned
        	[in] -> - the height of the depth buffer.


        '''
        pass

    @overload
    def setDepthMap(self, depth: MFloatArray,
                        width: unsigned,
                        height: unsigned): 
        '''
        setDepthMap(self, depth: MFloatArray,
                        width: unsigned,
                        height: unsigned)

        Synopsis
        -----
        Specifies the depth map resolution and data. Note, it is possible
        for the depth map to be a different resolution from the color
        map. This is to support oversampling with image planes. You
        cannot save image data to a file if the color map and image maps
        are different resolutions.

        Returns:
        -----
        None

        Parameters:
        -----
        depth: MFloatArray
        	[in] -> - float array that contains depth values. The depth values should be stored as -1.0/eyeDistance, where eyeDistance == 0.0 implies no depth is at that location. 

        width: unsigned
        	[in] -> - the width of the depth buffer 

        height: unsigned
        	[in] -> - the height of the depth buffer.


        '''
        pass

    def depthMap(self, ReturnStatus: MImage.MStatus): 
        '''
        depthMap(self, ReturnStatus: MImage.MStatus) -> float*

        Synopsis
        -----
        Returns a pointer to the depth data.

        Returns: 
        ----- 
        MS::kFailure - invalid object, or no depth data exists for this
        image instance.  MS::kSuccess - depth buffer successfully
        returned.

        Parameters:
        -----
        ReturnStatus: MImage.MStatus
        	[in] -> - return code.


        '''
        pass

    def readDepthMap(self, pathname: MString): 
        '''
        readDepthMap(self, pathname: MString)

        Synopsis
        -----
        Reads the depth map from the specified file and place the result
        into the depth map array of this MImage instance.

        Returns:
        -----
        None

        Parameters:
        -----
        pathname: MString
        	[in] -> - the path to the depth file.


        '''
        pass

    def resize(self, width: int,
                        height: int,
                        preserveAspectRatio: bool): 
        '''
        resize(self, width: int,
                        height: int,
                        preserveAspectRatio: bool)

        Synopsis
        -----
        Resize the currently opened image to the specified dimension, or
        to the closest width/height that is preserves the original aspect
        ratio. Resizing the image doesn't affect the file it was loaded
        from; it only affects the pixels in memory. The pixels are
        automatically filtered and antialiased to avoid a pixelated look.

        Returns:
        -----
        None

        Parameters:
        -----
        width: int
        	[in] -> the desired width in pixels. 

        height: int
        	[in] -> the desired height in pixels. 

        preserveAspectRatio: bool
        	[in] -> a boolean specifying whether the aspect ratio should be preserved or not. If this flag is set, the given width and height are interpreted as the maximum dimensions allowable.


        '''
        pass

    def filterExists(self, sourceFormat: MImage.MImageFilterFormat,
                        targetFormat: MImage.MImageFilterFormat): 
        '''
        filterExists(self, sourceFormat: MImage.MImageFilterFormat,
                        targetFormat: MImage.MImageFilterFormat) -> bool

        Synopsis
        -----
        Return whether or not a given source format can be directly
        converted to a given target format. See MImage::filter() for more
        information.

        Returns: 
        ----- 
        true if the filter exists.  false otherwise.

        Parameters:
        -----
        sourceFormat: MImage.MImageFilterFormat
        	[in] -> the format of the source image.

        targetFormat: MImage.MImageFilterFormat
        	[out] -> the format of the resulting image. 


        '''
        pass

    def filter(self, sourceFormat: MImage.MImageFilterFormat,
                        targetFormat: MImage.MImageFilterFormat,
                        scale: double,
                        offset: double): 
        '''
        filter(self, sourceFormat: MImage.MImageFilterFormat,
                        targetFormat: MImage.MImageFilterFormat,
                        scale: double,
                        offset: double)

        Synopsis
        -----
        Modify the content of the image by applying a filter. The
        dimension of the image remains the same; only the RGBA components
        get affected.Currently, only one filter is supported:sourceFormat
        = kHeightFieldBumpFormat, targetFormat = kNormalMapBumpFormat:
        this filter performs a conversion from the height-field bump
        format (generally used by Maya) to a normal map bump format
        suitable for interactive display. This filter is typically most
        useful to support bump mapping in a MPxHwShaderNode-derived
        hardware shader plug-in, since most high-end graphics adapter
        support it. For more information regarding this filter, see "A
        Practical and Robust Bump-mapping Technique for Today's GPUs", by
        Mark J. Kilgard, NVIDIA Corporation.The scale argument for this
        filter can vary from -256.0 to 256.0, although typical values
        range from 1.0 to 10.0. The offset argument is currently ignored
        and should be left to the default value of 0.0.

        Returns:
        -----
        None

        Parameters:
        -----
        sourceFormat: MImage.MImageFilterFormat
        	[in] -> the source format. 

        targetFormat: MImage.MImageFilterFormat
        	[in] -> desired target format. 

        scale: double
        	[in] -> vary depending on the source/target format. 

        offset: double
        	[in] -> vary depending on the source/target format.


        '''
        pass

    def writeToFile(self, pathname: MString,
                        outputFormat: MString): 
        '''
        writeToFile(self, pathname: MString,
                        outputFormat: MString)

        Synopsis
        -----
        Save the content of this image in a file. By default, the file is
        saved in IFF format. Optionally, the file can also be converted
        in a variety of image formats.

        Returns:
        -----
        None

        Parameters:
        -----
        pathname: MString
        	[in] -> a path to the desired file. This path can be absolute (eg: "C:/temp/bump.iff") or relative (eg: "temp/bump.iff").

        outputFormat: MString
        	[in] -> the desired image format to save into. This follows the same convention found in the Render Globals window. Examples of valid formats include: als, bmp, cin, gif, jpg, rla, sgi, tga, tif. "iff" is the default, and is the fastest format to save into since it doesn't need any internal conversion.


        '''
        pass

    def writeToFileWithDepth(self, pathname: MString,
                        outputFormat: MString,
                        writeDepth: bool): 
        '''
        writeToFileWithDepth(self, pathname: MString,
                        outputFormat: MString,
                        writeDepth: bool)

        Synopsis
        -----
        Save the content of this image in a file. By default, the file is
        saved in IFF format. Optionally, the file can also be converted
        in a variety of image formats. If the writeDepth parameter is
        true then any depth information stored in MImage will be written
        to file.IMPORTANT: Depth map is only supported if the
        outputFormat is 'iff'. If the depth map and color map size differ
        in resolution then the file cannot be written.

        Returns:
        -----
        None

        Parameters:
        -----
        pathname: MString
        	[in] -> a path to the desired file. This path can be absolute (eg: "C:/temp/bump.iff") or relative (eg: "temp/bump.iff").

        outputFormat: MString
        	[in] -> the desired image format to save into. This follows the same convention found in the Render Globals window. Examples of valid formats include: als, bmp, cin, gif, jpg, rla, sgi, tga, tif. "iff" is the default, and is the fastest format to save into since it doesn't need any internal conversion.

        writeDepth: bool
        	[in] -> writes the depth channel information if it stored in the class data.


        '''
        pass

    def release(self): 
        '''
        release(self)

        Synopsis
        -----
        Release the current image. If there is no current image, the call
        is ignored. An image is always released automatically during
        destruction, so generally there is no need to call this function
        manually.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setRGBA(self, rgbaFormat: bool): 
        '''
        setRGBA(self, rgbaFormat: bool)

        Synopsis
        -----
        Sets a flag to indicate that pixel information is in RGBA
        sequence or BGRA sequence. Pixel data must have been allocated
        before this call is made.

        Returns:
        -----
        None

        Parameters:
        -----
        rgbaFormat: bool
        	[in] -> true value indicates RGBA format 


        '''
        pass

    def isRGBA(self): 
        '''
        isRGBA(self) -> bool

        Synopsis
        -----
        Query flag which indicates whether the pixel information is in
        RGBA sequence or BGRA sequence. If no pixel data exists, then
        false will be returned.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def haveDepth(self): 
        '''
        haveDepth(self) -> bool

        Synopsis
        -----
        Returns true if this instance of MImage contains a depth map.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def convertPixelFormat(self, format: MImage.MPixelType,
                        scale: double,
                        offset: double): 
        '''
        convertPixelFormat(self, format: MImage.MPixelType,
                        scale: double,
                        offset: double)

        Synopsis
        -----
        Convert the pixel format used by this image using the specified
        parameters.

        Returns:
        -----
        None

        Parameters:
        -----
        format: MImage.MPixelType
        	[in] -> the desired pixel format. If this matches the current format, this method will do nothing. 

        scale: double
        	[in] -> if conversion is required, this specifies the scaling applied to every channel of every pixel. A scale of 0 will automatically rescale based on the minimum and maximum values in the image. 

        offset: double
        	[in] -> if conversion is required, this specifies the offset applied to every channel of every pixel.


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MImageFilterFormat:
    '''Filter formats. 
    Non-functional class.  Values for this enum:
    kNoFormat
    kHeightFieldBumpFormat
    kNormalMapBumpFormat
    kUnknownFormat
    '''

    def __init__(self):
        pass

    def kNoFormat(self):
        '''This is an enum of MImageFilterFormat.
        - Description:  
        - Value: 0
        '''
        pass

    def kHeightFieldBumpFormat(self):
        '''This is an enum of MImageFilterFormat.
        - Description:  
        - Value: 1
        '''
        pass

    def kNormalMapBumpFormat(self):
        '''This is an enum of MImageFilterFormat.
        - Description:  
        - Value: 2
        '''
        pass

    def kUnknownFormat(self):
        '''This is an enum of MImageFilterFormat.
        - Description:  
        - Value: 3
        '''
        pass

class MPixelType:
    '''Pixel formats. 
    Non-functional class.  Values for this enum:
    kUnknown
    kByte
    kFloat
    '''

    def __init__(self):
        pass

    def kUnknown(self):
        '''This is an enum of MPixelType.
        - Description: Format not known or invalid. 
        - Value: 0
        '''
        pass

    def kByte(self):
        '''This is an enum of MPixelType.
        - Description: One byte per channel, ranging from 0 to 255. 
        - Value: 1
        '''
        pass

    def kFloat(self):
        '''This is an enum of MPixelType.
        - Description: One float per channel, ranging from 0.0 to 1.0. 
        - Value: 2
        '''
        pass

class MImageFileInfo:
    '''Image manipulation.
This class provides methods for reading file images stored on
disk.
MImageFileInfo is a utility class used to describe the characteristics of an
image file, such as dimensions, channel count, and pixel format.
This class is used in
MPxImageFile.
'''
    def __init__(self):
        pass


    @overload
    def width(self, value: int): 
        '''
        width(self, value: int)

        Synopsis
        -----
        Set the width in pixels of this image file.

        Returns:
        -----
        None

        Parameters:
        -----
        value: int
        	[in] -> the width in pixels 


        '''
        pass

    @overload
    def height(self, value: int): 
        '''
        height(self, value: int)

        Synopsis
        -----
        Set the height in pixels of this image file.

        Returns:
        -----
        None

        Parameters:
        -----
        value: int
        	[in] -> the height in pixels 


        '''
        pass

    @overload
    def channels(self, value: int): 
        '''
        channels(self, value: int)

        Synopsis
        -----
        Set the number of channels per pixels in this image file.

        Returns:
        -----
        None

        Parameters:
        -----
        value: int
        	[in] -> the number of channels per pixel 


        '''
        pass

    @overload
    def numberOfImages(self, value: int): 
        '''
        numberOfImages(self, value: int)

        Synopsis
        -----
        Set the total number of images in this image file.

        Returns:
        -----
        None

        Parameters:
        -----
        value: int
        	[in] -> the number of images 


        '''
        pass

    @overload
    def pixelType(self, value: MImage.MImage): 
        '''
        pixelType(self, value: MImage.MImage)

        Synopsis
        -----
        Set the native pixel format of this image file.

        Returns:
        -----
        None

        Parameters:
        -----
        value: MImage.MImage
        	[in] -> the native pixel format of this image file 


        '''
        pass

    @overload
    def imageType(self, value: MImageFileInfo.MImageType): 
        '''
        imageType(self, value: MImageFileInfo.MImageType)

        Synopsis
        -----
        Set the type of information stored in this image file (e.g. the
        image contains a color map, a bump map, etc). This is an optional
        call as most image file formats do not describe the semantic use
        of the pixels they contains. In such cases it is safe to leave
        this as the default value of kImageTypeUnknown.

        Returns:
        -----
        None

        Parameters:
        -----
        value: MImageFileInfo.MImageType
        	[in] -> the type of information in this image file 


        '''
        pass

    @overload
    def hardwareType(self, value: MImageFileInfo.MHwTextureType): 
        '''
        hardwareType(self, value: MImageFileInfo.MHwTextureType)

        Synopsis
        -----
        Set the hardware texture type of this image file, configuring
        whether this image contains a 2D texture, a cubemap, etc.

        Returns:
        -----
        None

        Parameters:
        -----
        value: MImageFileInfo.MHwTextureType
        	[in] -> the hardware texture type of this image file 


        '''
        pass

    @overload
    def hasAlpha(self, value: bool): 
        '''
        hasAlpha(self, value: bool)

        Synopsis
        -----
        Set whether or not this image file contains alpha.

        Returns:
        -----
        None

        Parameters:
        -----
        value: bool
        	[in] -> true if the image contains alpha, false otherwise. 


        '''
        pass

    @overload
    def hasMipMaps(self, value: bool): 
        '''
        hasMipMaps(self, value: bool)

        Synopsis
        -----
        Set whether or not this image file contains or can generate
        mipmaps.

        Returns:
        -----
        None

        Parameters:
        -----
        value: bool
        	[in] -> true if the image contains or can generate mipmaps, false otherwise. 


        '''
        pass

    @overload
    def width(self): 
        '''
        width(self) -> int

        Synopsis
        -----
        Get the width in pixels of this image file.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def height(self): 
        '''
        height(self) -> int

        Synopsis
        -----
        Get the height in pixels of this image file.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def channels(self): 
        '''
        channels(self) -> int

        Synopsis
        -----
        Get the number of channels in this image file.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def numberOfImages(self): 
        '''
        numberOfImages(self) -> int

        Synopsis
        -----
        Get the number of images in this image file.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def pixelType(self): 
        '''
        pixelType(self) -> MImage.MImage

        Synopsis
        -----
        Get the native pixel format of this image file.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def imageType(self): 
        '''
        imageType(self) -> MImageFileInfo.MImageFileInfo

        Synopsis
        -----
        Query the type of information in this image file (e.g. is it a
        color map, a normal map, etc). Most image file formats do not
        contain this information, meaning this will be left as
        kImageTypeUnknown.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def hardwareType(self): 
        '''
        hardwareType(self) -> MImageFileInfo.MImageFileInfo

        Synopsis
        -----
        Get the hardware texture type of this image file, describing
        whether this image contains a 2D texture, a cubemap, etc.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def hasAlpha(self): 
        '''
        hasAlpha(self) -> bool

        Synopsis
        -----
        Query whether this image contains alpha information.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def hasMipMaps(self): 
        '''
        hasMipMaps(self) -> bool

        Synopsis
        -----
        Query whether this image contains or can generate mipmap
        information.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MHwTextureType:
    '''Hardware texture types. 
    Non-functional class.  Values for this enum:
    kHwTextureUnknown
    kHwTexture1D
    kHwTexture2D
    kHwTexture3D
    kHwTextureRectangle
    kHwTextureCubeMap
    '''

    def __init__(self):
        pass

    def kHwTextureUnknown(self):
        '''This is an enum of MHwTextureType.
        - Description:  
        - Value: 0
        '''
        pass

    def kHwTexture1D(self):
        '''This is an enum of MHwTextureType.
        - Description:  
        - Value: 1
        '''
        pass

    def kHwTexture2D(self):
        '''This is an enum of MHwTextureType.
        - Description:  
        - Value: 2
        '''
        pass

    def kHwTexture3D(self):
        '''This is an enum of MHwTextureType.
        - Description:  
        - Value: 3
        '''
        pass

    def kHwTextureRectangle(self):
        '''This is an enum of MHwTextureType.
        - Description:  
        - Value: 4
        '''
        pass

    def kHwTextureCubeMap(self):
        '''This is an enum of MHwTextureType.
        - Description:  
        - Value: 5
        '''
        pass

class MImageType:
    '''Image types. 
    Non-functional class.  Values for this enum:
    kImageTypeUnknown
    kImageTypeColor
    kImageTypeNormal
    kImageTypeBump
    '''

    def __init__(self):
        pass

    def kImageTypeUnknown(self):
        '''This is an enum of MImageType.
        - Description:  
        - Value: 0
        '''
        pass

    def kImageTypeColor(self):
        '''This is an enum of MImageType.
        - Description:  
        - Value: 1
        '''
        pass

    def kImageTypeNormal(self):
        '''This is an enum of MImageType.
        - Description:  
        - Value: 2
        '''
        pass

    def kImageTypeBump(self):
        '''This is an enum of MImageType.
        - Description:  
        - Value: 3
        '''
        pass

class MInt64Array:
    '''Array of 64-bit integers data type.
This class implements an array of 64-bit integers. Common
convenience functions are available, and the implementation is
compatible with the internal Maya implementation so that it can
be passed efficiently between plugins and internal maya data
structures.
'''
    def __init__(self):
        pass


    def set(self, element: MInt64Array.MInt64,
                        index: int): 
        '''
        set(self, element: MInt64Array.MInt64,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated value.
        NOTE: This method does not grow the array if the index is out of
        bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MInt64Array.MInt64
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    def setLength(self, length: int): 
        '''
        setLength(self, length: int)

        Synopsis
        -----
        Set the length of the array. This will grow and shrink the array
        as desired. Elements that are grown have uninitialized values,
        while those which are shrunk will lose the data contained in the
        deleted elements (ie. it will release the memory).

        Returns:
        -----
        None

        Parameters:
        -----
        length: int
        	[in] -> the new size of the array 


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Returns the number of elements in the instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Remove the array element at the given index. All array elements
        following the removed element are shifted toward the first
        element.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> index of the element to be removed


        '''
        pass

    def insert(self, element: MInt64Array.MInt64,
                        index: int): 
        '''
        insert(self, element: MInt64Array.MInt64,
                        index: int)

        Synopsis
        -----
        Inserts a new value into the array at the given index. The
        initial element at that index, and all following elements, are
        shifted towards the last. If the array cannot be expanded in size
        by 1 element, then the insert will fail and the existing array
        will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MInt64Array.MInt64
        	[in] -> the new value to insert into the array 

        index: int
        	[in] -> the index of the element to set to the the new value


        '''
        pass

    def append(self, element: MInt64Array.MInt64): 
        '''
        append(self, element: MInt64Array.MInt64)

        Synopsis
        -----
        Adds a new element to the end of the array. If the array cannot
        be expanded in size by 1 element, then the append will fail and
        the existing array will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MInt64Array.MInt64
        	[in] -> the value for the new last element


        '''
        pass

    def copy(self, source: MInt64Array): 
        '''
        copy(self, source: MInt64Array)

        Synopsis
        -----
        Copy the contents of the source array to this array.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MInt64Array
        	[in] -> array to copy from


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clear the contents of the array. After this operation the length
        method will return 0. This does not change the amount of memory
        allocated to the array, only the number of valid elements in it.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def get(self, array: MInt64Array.MInt64): 
        '''
        get(self, array: MInt64Array.MInt64)

        Synopsis
        -----
        Copy the elements of the array into the given C++ array of ints.
        No checking is done to ensure that the destination C++ array of
        64-bit ints is large enough to hold all the elements of the
        instance.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MInt64Array.MInt64
        	[out] -> the array to populate


        '''
        pass

    def setSizeIncrement(self, newIncrement: int): 
        '''
        setSizeIncrement(self, newIncrement: int)

        Synopsis
        -----
        Set the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        newIncrement: int
        	[in] -> the new increment 


        '''
        pass

    def sizeIncrement(self): 
        '''
        sizeIncrement(self) -> int

        Synopsis
        -----
        Return the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MInt64Array.MInt64Array

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MInt64Array.MInt64Array

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MInt64Array.MInt64Array

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MInt64Array.MInt64Array

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MInt64Array.MInt64Array

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MInt64Array.MInt64Array

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MIntArray:
    '''Array of integers data type.
This class implements an array of integers. Common convenience
functions are available, and the implementation is compatible
with the internal Maya implementation so that it can be passed
efficiently between plugins and internal maya data structures.
'''
    def __init__(self):
        pass


    def set(self, element: int,
                        index: int): 
        '''
        set(self, element: int,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated value.
        NOTE: This method does not grow the array if the index is out of
        bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        element: int
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    def setLength(self, length: int): 
        '''
        setLength(self, length: int)

        Synopsis
        -----
        Set the length of the array. This will grow and shrink the array
        as desired. Elements that are grown have uninitialized values,
        while those which are shrunk will lose the data contained in the
        deleted elements (ie. it will release the memory).

        Returns:
        -----
        None

        Parameters:
        -----
        length: int
        	[in] -> the new size of the array 


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Returns the number of elements in the instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Remove the array element at the given index. All array elements
        following the removed element are shifted toward the first
        element.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> index of the element to be removed


        '''
        pass

    def insert(self, element: int,
                        index: int): 
        '''
        insert(self, element: int,
                        index: int)

        Synopsis
        -----
        Inserts a new value into the array at the given index. The
        initial element at that index, and all following elements, are
        shifted towards the last. If the array cannot be expanded in size
        by 1 element, then the insert will fail and the existing array
        will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: int
        	[in] -> the new value to insert into the array 

        index: int
        	[in] -> the index of the element to set to the the new value


        '''
        pass

    def append(self, element: int): 
        '''
        append(self, element: int)

        Synopsis
        -----
        Adds a new element to the end of the array. If the array cannot
        be expanded in size by 1 element, then the append will fail and
        the existing array will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: int
        	[in] -> the value for the new last element


        '''
        pass

    def copy(self, source: MIntArray): 
        '''
        copy(self, source: MIntArray)

        Synopsis
        -----
        Copy the contents of the source array to this array.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MIntArray
        	[in] -> array to copy from


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clear the contents of the array. After this operation the length
        method will return 0. This does not change the amount of memory
        allocated to the array, only the number of valid elements in it.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def get(self, array: int): 
        '''
        get(self, array: int)

        Synopsis
        -----
        Copy the elements of the array into the given C++ array of ints.
        No checking is done to ensure that the destination C++ array of
        ints is large enough to hold all the elements of the instance.

        Returns:
        -----
        None

        Parameters:
        -----
        array: int
        	[out] -> the array to populate


        '''
        pass

    def setSizeIncrement(self, newIncrement: int): 
        '''
        setSizeIncrement(self, newIncrement: int)

        Synopsis
        -----
        Set the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        newIncrement: int
        	[in] -> the new increment 


        '''
        pass

    def sizeIncrement(self): 
        '''
        sizeIncrement(self) -> int

        Synopsis
        -----
        Return the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MIntArray.MIntArray

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MIntArray.MIntArray

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MIntArray.MIntArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MIntArray.MIntArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MIntArray.MIntArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MIntArray.MIntArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MIteratorType:
    '''MIteratorType class.
The
MIteratorType class is used on iterators where more than one type of filters
can be specified. It also provides functionalities to set and get
the filter list or individual types of filter. This class should
be used in conjunction with DAG/DG/DependencyNodes iterators for
using filter list (list of
MFn::Type objects) on them, thus enabling faster traversal thro'
iterators.
Also, the class has functionalities for specifying the type of
object the iterator will be reset to. This could be an
MObject, an
MPlug or an
MDagPath.
'''
    def __init__(self):
        pass


    def setFilterType(self, type: MFn.MFn,
                        ReturnStatus: MIteratorType.MStatus): 
        '''
        setFilterType(self, type: MFn.MFn,
                        ReturnStatus: MIteratorType.MStatus)

        Synopsis
        -----
        Sets the filter type to be used in the iterator. See MFn::Type
        for the list of filter types that can be set.

        Returns:
        -----
        None

        Parameters:
        -----
        type: MFn.MFn
        	[in] -> An object of type 

        ReturnStatus: MIteratorType.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def setFilterList(self, listOfFilters: MIntArray,
                        ReturnStatus: MIteratorType.MStatus): 
        '''
        setFilterList(self, listOfFilters: MIntArray,
                        ReturnStatus: MIteratorType.MStatus)

        Synopsis
        -----
        Sets the filter list. The types of filters to be traversed in the
        iterator is added to an array and then passed in to this
        function. This also enables filter list usage on iterators, as
        opposed to single filter.

        Returns:
        -----
        None

        Parameters:
        -----
        listOfFilters: MIntArray
        	[in] -> List of 

        ReturnStatus: MIteratorType.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def setObjectType(self, objFilterType: objFilterType,
                        ReturnStatus: MIteratorType.MStatus): 
        '''
        setObjectType(self, objFilterType: objFilterType,
                        ReturnStatus: MIteratorType.MStatus)

        Synopsis
        -----
        Sets the object type. This function should be used only when we
        want to reset the iterator root. Iterator root can be reset to
        either an MObject, an MDagPath or to an MPlug. For each of this,
        there is a corresponding enum value, which has to be used as an
        argument to this function.During creation of the iterator, this
        function has no effect.

        Returns:
        -----
        None

        Parameters:
        -----
        objFilterType: objFilterType
        	[in] -> Type specifying the type of object. 

        ReturnStatus: MIteratorType.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def getFilterType(self, ReturnStatus: MIteratorType.MStatus): 
        '''
        getFilterType(self, ReturnStatus: MIteratorType.MStatus) -> MFn.MFn

        Synopsis
        -----
        Returns the type of filter.

        Returns: 
        ----- 
        The filter type.

        Parameters:
        -----
        ReturnStatus: MIteratorType.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def getFilterList(self, listOfFilters: MIntArray): 
        '''
        getFilterList(self, listOfFilters: MIntArray)

        Synopsis
        -----
        Gets the list of filters.

        Returns:
        -----
        None

        Parameters:
        -----
        listOfFilters: MIntArray
        	[out] -> Array of filters.


        '''
        pass

    def getObjectType(self, ReturnStatus: MIteratorType.MStatus): 
        '''
        getObjectType(self, ReturnStatus: MIteratorType.MStatus) -> MIteratorType.MIteratorType

        Synopsis
        -----
        Returns the object type.

        Returns: 
        ----- 
        The object type.

        Parameters:
        -----
        ReturnStatus: MIteratorType.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def filterListEnabled(self): 
        '''
        filterListEnabled(self) -> bool

        Synopsis
        -----
        Returns whether the we are using a single filter on the iterator
        or a filter list.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class objFilterType:
    '''Type of object the iterator deals with. 
    Non-functional class.  Values for this enum:
    kMObject
    kMDagPathObject
    kMPlugObject
    '''

    def __init__(self):
        pass

    def kMObject(self):
        '''This is an enum of objFilterType.
        - Description: This is to indicate that the root of the iterator has to be reset to an MObject. 
        - Value: 0
        '''
        pass

    def kMDagPathObject(self):
        '''This is an enum of objFilterType.
        - Description: This is to indicate that the root of the iterator has to be reset to an MDagPath object. 
        - Value: 1
        '''
        pass

    def kMPlugObject(self):
        '''This is an enum of objFilterType.
        - Description: This is to indicate that the root of the iterator has to be reset to an MPlug object. 
        - Value: 2
        '''
        pass

class MItCurveCV:
    '''Iterator for NURBS curve CVs.
This class is the iterator class for NURBS curve control vertices
(CVs). The iteration can be for a given curve or for a group of
CVs.
 Translates the CVs for a curve in the X direction (world space).
'''
    def __init__(self):
        pass


    def isDone(self, ReturnStatus: MItCurveCV.MStatus): 
        '''
        isDone(self, ReturnStatus: MItCurveCV.MStatus) -> bool

        Synopsis
        -----
        Returns true if the iteration is finished, i.e. there are no more
        CVs to iterate on.

        Returns: 
        ----- 
        Boolean value: true if there are no more CVs to iterate on, false
        otherwise.

        Parameters:
        -----
        ReturnStatus: MItCurveCV.MStatus
        	[out] -> Status code


        '''
        pass

    def next(self): 
        '''
        next(self)

        Synopsis
        -----
        Advance to the next CV in the iteration. If the iterator is
        already at the last CV then this method has no effect. Use isDone
        to determine if the iterator is at the last CV.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def reset(self): 
        '''
        reset(self)

        Synopsis
        -----
        Reset the iterator to the first CV.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def reset(self, curve: MObject): 
        '''
        reset(self, curve: MObject)

        Synopsis
        -----
        Reset the iterator to the specified curve.

        Returns:
        -----
        None

        Parameters:
        -----
        curve: MObject
        	[in] -> The curve for the iteration


        '''
        pass

    @overload
    def reset(self, curve: MDagPath,
                        component: MObject): 
        '''
        reset(self, curve: MDagPath,
                        component: MObject)

        Synopsis
        -----
        Reset the iterator to the specified curve and component. The
        component is a group of CVs belonging to the specified curve. The
        component defaults to MObject::kNullObj. If a component is not
        given then the iterator will be reset for the whole curve.

        Returns:
        -----
        None

        Parameters:
        -----
        curve: MDagPath
        	[in] -> Dag path to the curve for the iteration 

        component: MObject
        	[in] -> A group of CVs to be iterated on


        '''
        pass

    def position(self, space: MSpace.MSpace,
                        ReturnStatus: MItCurveCV.MStatus): 
        '''
        position(self, space: MSpace.MSpace,
                        ReturnStatus: MItCurveCV.MStatus) -> MPoint

        Synopsis
        -----
        Return the position of the current CV.

        Returns: 
        ----- 
        Status code

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> the co-oordinate system for the returned point 

        ReturnStatus: MItCurveCV.MStatus
        	[out] -> Status code


        '''
        pass

    def setPosition(self, pt: MPoint,
                        space: MSpace.MSpace): 
        '''
        setPosition(self, pt: MPoint,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the position of the current CV to the specified point.

        Returns:
        -----
        None

        Parameters:
        -----
        pt: MPoint
        	[in] -> new position of CV 

        space: MSpace.MSpace
        	[in] -> the co-ordinate system for this transformation.


        '''
        pass

    def translateBy(self, vec: MVector,
                        space: MSpace.MSpace): 
        '''
        translateBy(self, vec: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Translates the current CV by the amount specified in vec.

        Returns:
        -----
        None

        Parameters:
        -----
        vec: MVector
        	[in] -> translation to be applied to the CV 

        space: MSpace.MSpace
        	[in] -> the co-oordinate system for this transformation.


        '''
        pass

    def index(self, ReturnStatus: MItCurveCV.MStatus): 
        '''
        index(self, ReturnStatus: MItCurveCV.MStatus) -> int

        Synopsis
        -----
        This method returns the index of the current CV in the CV array
        for this curve.

        Returns: 
        ----- 
        The index of the current CV

        Parameters:
        -----
        ReturnStatus: MItCurveCV.MStatus
        	[out] -> Status code


        '''
        pass

    def currentItem(self, ReturnStatus: MItCurveCV.MStatus): 
        '''
        currentItem(self, ReturnStatus: MItCurveCV.MStatus) -> MObject

        Synopsis
        -----
        This method returns the current CV as an MObject.

        Returns: 
        ----- 
        A handle to the CV requested

        Parameters:
        -----
        ReturnStatus: MItCurveCV.MStatus
        	[out] -> Status code


        '''
        pass

    def hasHistoryOnCreate(self, ReturnStatus: MItCurveCV.MStatus): 
        '''
        hasHistoryOnCreate(self, ReturnStatus: MItCurveCV.MStatus) -> bool

        Synopsis
        -----
        This method determines if the shape was created with history. If
        the object that this iterator is attached to is not a shape then
        this method will fail.

        Returns: 
        ----- 
        Boolean value: true if shape has history, false otherwise.

        Parameters:
        -----
        ReturnStatus: MItCurveCV.MStatus
        	[out] -> 


        '''
        pass

    def updateCurve(self): 
        '''
        updateCurve(self)

        Synopsis
        -----
        This method is used to signal the curve that it has been changed
        and needs to redraw itself. When modifying a large number of CVs,
        it is most efficient to call this method after all of the CVs
        have been modified.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MItDag:
    '''DAG Iterator.
Use the DAG iterator to traverse the DAG either depth first or
breadth first, visiting each node and, if desired, retrieving the
node (as an
MObject). The DAG iterator provides a basic filtering capability, so
that DAG node retrieval can be limited to a specific type (
MFn::Type) of node. With filtering enabled the iterator checks to see if
the node is compatible with the type of Function Set specified by
the filter. See
MFn::Type for a list of all valid Function set types.
Since each object, if retrieved, is returned as an
MObject, the
MObject::hasFn() method can be used to further check for compatible function set
types since an MObjects may be compatible with more than one
function set).
Any compatible Function Set can be attached to the retrieved
object to query or or edit it. Often you will want to use the DAG
node Function Set (
MFnDagNode), which is compatible with all DAG objects, to perform basic
queries on each node as the iterator traverses the DAG.
The iterator also provides the capability to reset the root of
the iteration, the type of traversal, and the filter.
Additionally, the iterator can be queried for the root, mode and
type of traversal, and to determine if the the traversal has been
completed.
'''
    def __init__(self):
        pass


    @overload
    def reset(self): 
        '''
        reset(self)

        Synopsis
        -----
        Resets the iterator. The iterator is reset to the previous
        traversal setting.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def reset(self, object: MObject,
                        type: MItDag.MItDag,
                        filter: MFn.MFn): 
        '''
        reset(self, object: MObject,
                        type: MItDag.MItDag,
                        filter: MFn.MFn)

        Synopsis
        -----
        Resets root, type and filter of the iterator.

        Returns:
        -----
        None

        Parameters:
        -----
        object: MObject
        	[in] -> Root node to begin traversal 

        type: MItDag.MItDag
        	[in] -> Enumerated type that determines the direction of the traversal

        filter: MFn.MFn
        	[in] -> Function set type (


        '''
        pass

    @overload
    def reset(self, path: MDagPath,
                        type: MItDag.MItDag,
                        filter: MFn.MFn): 
        '''
        reset(self, path: MDagPath,
                        type: MItDag.MItDag,
                        filter: MFn.MFn)

        Synopsis
        -----
        Resets root, type and filter of the iterator. This method is
        usefull when a node is instanced and a DAG path is necessary to
        specify which instance should be the root of the traversal.

        Returns:
        -----
        None

        Parameters:
        -----
        path: MDagPath
        	[in] -> Path to begin traversal 

        type: MItDag.MItDag
        	[in] -> Enumerated type that determines the direction of the traversal

        filter: MFn.MFn
        	[in] -> Function set type (


        '''
        pass

    @overload
    def reset(self, dagInfoObject: MIteratorType,
                        object: MObject,
                        path: MDagPath,
                        type: MItDag.MItDag): 
        '''
        reset(self, dagInfoObject: MIteratorType,
                        object: MObject,
                        path: MDagPath,
                        type: MItDag.MItDag)

        Synopsis
        -----
        Resets root, type and filter list of the iterator. This method is
        usefull when a node is instanced and a DAG path is necessary to
        specify which instance should be the root of the traversal.

        Returns:
        -----
        None

        Parameters:
        -----
        dagInfoObject: MIteratorType
        	[in] -> Iterator object having info on filter or filterlist. 

        object: MObject
        	[in] -> MObject

        path: MDagPath
        	[in] -> MDagPath

        type: MItDag.MItDag
        	[in] -> Enumerated type that determines the direction of the traversal


        '''
        pass

    def currentItem(self, ReturnStatus: MItDag.MStatus): 
        '''
        currentItem(self, ReturnStatus: MItDag.MStatus) -> MObject

        Synopsis
        -----
        Retrieves DAG node to which the iterator points.

        Returns: 
        ----- 
        Pointer to the DAG node. Null pointer indicates failure.

        Parameters:
        -----
        ReturnStatus: MItDag.MStatus
        	[out] -> Status Code (see below).


        '''
        pass

    def next(self): 
        '''
        next(self)

        Synopsis
        -----
        Moves to the next node matching the filter in the graph.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def prune(self): 
        '''
        prune(self)

        Synopsis
        -----
        Prunes iteration tree at current node.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isDone(self, ReturnStatus: MItDag.MStatus): 
        '''
        isDone(self, ReturnStatus: MItDag.MStatus) -> bool

        Synopsis
        -----
        Indicates end of iteration path.

        Returns: 
        ----- 
        Boolean value: true when done, false otherwise.

        Parameters:
        -----
        ReturnStatus: MItDag.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def root(self, ReturnStatus: MItDag.MStatus): 
        '''
        root(self, ReturnStatus: MItDag.MStatus) -> MObject

        Synopsis
        -----
        Returns the root (start node) of the current traversal. The
        constructor sets the root of traversal to the world node. The
        root can be changed by the reset() method.

        Returns: 
        ----- 
        Root of the traversal

        Parameters:
        -----
        ReturnStatus: MItDag.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def depth(self, ReturnStatus: MItDag.MStatus): 
        '''
        depth(self, ReturnStatus: MItDag.MStatus) -> int

        Synopsis
        -----
        Returns the height or depth of the current node in the DAG
        relative to the root node. The root node has a depth of zero.

        Returns: 
        ----- 
        Depth of the current node

        Parameters:
        -----
        ReturnStatus: MItDag.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def getType(self, ReturnStatus: MItDag.MStatus): 
        '''
        getType(self, ReturnStatus: MItDag.MStatus) -> MItDag.MItDag

        Synopsis
        -----
        Returns the direction of the traversal.

        Returns: 
        ----- 
        kDepthFirst Recursively visits grandchildren of each child node
        kBreadthFirst Recursively visits each child/parent node before
        any grandchild/grandparent nodes

        Parameters:
        -----
        ReturnStatus: MItDag.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def getPath(self, path: MDagPath): 
        '''
        getPath(self, path: MDagPath)

        Synopsis
        -----
        Determines a DAG Path to the current item in the iteration.

        Returns:
        -----
        None

        Parameters:
        -----
        path: MDagPath
        	[out] -> The DAG Path that is found (implicit return)


        '''
        pass

    def getAllPaths(self, paths: MDagPathArray): 
        '''
        getAllPaths(self, paths: MDagPathArray)

        Synopsis
        -----
        Determines all DAG Paths to current item in the iteration.

        Returns:
        -----
        None

        Parameters:
        -----
        paths: MDagPathArray
        	[out] -> Array of all DAG Paths that are found (implicit return)


        '''
        pass

    def fullPathName(self, ReturnStatus: MItDag.MStatus): 
        '''
        fullPathName(self, ReturnStatus: MItDag.MStatus) -> MString

        Synopsis
        -----
        Return a string representing the full path from the root of the
        dag to this object.

        Returns: 
        ----- 
        The full path name

        Parameters:
        -----
        ReturnStatus: MItDag.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def partialPathName(self, ReturnStatus: MItDag.MStatus): 
        '''
        partialPathName(self, ReturnStatus: MItDag.MStatus) -> MString

        Synopsis
        -----
        Return a string representing the partial path from the root of
        the dag to this object. The partial path is the minimum path that
        is still unique. This string may contain wildcards.

        Returns: 
        ----- 
        The partial path name

        Parameters:
        -----
        ReturnStatus: MItDag.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def isInstanced(self, indirect: bool,
                        ReturnStatus: MItDag.MStatus): 
        '''
        isInstanced(self, indirect: bool,
                        ReturnStatus: MItDag.MStatus) -> bool

        Synopsis
        -----
        Determines whether the current item (DAG node) in the iteration
        is directly or indirectly instanced. If indirect instance flag is
        false, the result is true if and only if the Node itself is
        multiply instanced (node->parentCount > 1).If the indirect flag
        is true, the result is true if and only if the Node itself is
        multiply instanced (node->parentCount > 1) or if the Node is not
        multipuly instanced, but it has a directly instanced parent
        (node->parentCount()=1 and parent->parentCount >1).

        Returns: 
        ----- 
        true = Node is instanced (directly or indirectly according to
        indirect instance flag)  false = Node is not instanced (directly
        or indirectly according to indirect instance flag)

        Parameters:
        -----
        indirect: bool
        	[in] -> Indirect instance flag 

        ReturnStatus: MItDag.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def instanceCount(self, total: bool,
                        ReturnStatus: MItDag.MStatus): 
        '''
        instanceCount(self, total: bool,
                        ReturnStatus: MItDag.MStatus) -> int

        Synopsis
        -----
        Determines the number of times the current item (DAG node) in the
        iteration is instanced. If total is false the number of direct
        instances is returned, which is the same as the node's parent
        count.If total is true the total number of instances is returned,
        including indirect instances resulting from instancing higher up
        the DAG hierarchy (i.e. one or more of the node's ancestors also
        has multiple instances).

        Returns: 
        ----- 
        Number of instances.

        Parameters:
        -----
        total: bool
        	[in] -> Controls whether to include indirect instances in the count. 

        ReturnStatus: MItDag.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def traverseUnderWorld(self, flag: bool): 
        '''
        traverseUnderWorld(self, flag: bool)

        Synopsis
        -----
        Specifies whether underworld traversal is turned on. The default
        is off.The underworld for a shape is a sub dag that hangs off of
        the shape. For example, if you have a curve on surface for a
        shape then there will be an underworld or sub-dag for the curve
        on surface.

        Returns:
        -----
        None

        Parameters:
        -----
        flag: bool
        	[in] -> turns on/off underworld traversal


        '''
        pass

    def willTraverseUnderWorld(self, ReturnStatus: MItDag.MStatus): 
        '''
        willTraverseUnderWorld(self, ReturnStatus: MItDag.MStatus) -> bool

        Synopsis
        -----
        Returns true if this iterator will traverse into underworld
        items. The underworld for a shape is a sub dag that hangs off of
        the shape. For example, if you have a curve on surface for a
        shape then there will be an underworld or sub-dag for the curve
        on surface.

        Returns: 
        ----- 
        Boolean: true if underworld traversal is on, false otherwise.

        Parameters:
        -----
        ReturnStatus: MItDag.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class TraversalType:
    '''Order in which nodes should be traversed. 
    Non-functional class.  Values for this enum:
    kInvalidType
    kDepthFirst
    kBreadthFirst
    '''

    def __init__(self):
        pass

    def kInvalidType(self):
        '''This is an enum of TraversalType.
        - Description:  
        - Value: 0
        '''
        pass

    def kDepthFirst(self):
        '''This is an enum of TraversalType.
        - Description: Visit a node's children before moving on to its siblings. 
        - Value: 1
        '''
        pass

    def kBreadthFirst(self):
        '''This is an enum of TraversalType.
        - Description: Visit a node's siblings before moving on to its children. Note: using kBreadthFirst instead of kDepthFirst can be significantly slower, especially when traversing whole hierarchies. 
        - Value: 2
        '''
        pass

class MItDependencyGraph:
    '''Dependency Graph Iterator.
Iterate over Dependency Graph (DG) Nodes or Plugs starting at a
specified root Node or Plug.
Set and query the root of the iteration.
Set and query the direction (downstream or upstream), traversal
priority (depth first or breadth first) and level of detail (Node
level or Plug level) and relationship (DG connection, dependency,
evaluation graph) of the iteration.
Set and disable a filter to iterate over only specific types (
MFn::Type) of Nodes.
Reset the root, filter, direction, traversal priority,
relationship and level of detail of the iteration.
Prune branches of the graph from iteration.
In Maya, all geometry, animation and rendering information is
implemented in nodes in the Dependency Graph (DG). The DG
includes the Directed Acyclic Graph (DAG). Therefore, all DAG
nodes are also DG nodes. The data on nodes is associated with
Attributes. Attributes on nodes are connected to Attributes on
other nodes via plugs on the Attributes. Plugs are, in effect the
external intefaces of Attributes.
The DG Iterator Class (
MItDependencyGraph) provides methods for iterating over either nodes or plugs, as
well as methods for setting and querying the characteristics and
behaviour of the iterator.
This iterator will traverse all connected attributes upstream or
downstream from the root node of the traversal. For non root
nodes, only attributes that are affected by the incoming
attribute to that node will be traversed. Hence, only nodes to
which data from the root node is flowing will be traversed.
By default, the iterator does not traverse world-space attribute
dependencies (an example of a world-space dependency is that
translateX affects worldMatrix). The
setTraversalOverWorldSpaceDependents method can be used to enable
such traversal. Note that even when world-space traversal is
enabled, the iterator will only iterate to connected nodes. It
does not iterate up and down through the dag hierarchy.
You can set the relationships that the traversal will follow. The
default is kDependOn which traverses plug dependencies. The other
options are kConnectedTo which traverses node connections and
kEvaluationGraph which traverses evaluation graph dependencies.
The DG Iterator is used in conjunction with the Maya Object (
MObject), plug (
MPlug), Maya Object Array (
MObjectArray) and plug Array (
MPlugArray) classes.
It is also useful to use Function Sets specific to the nodes
returned by the iterator to query and modify the nodes in the DG.
The DG itself can be modified using a DG Modifer (
MDGModifier).
Additionally, nodes can be added to and retrieved from selection
lists using the Selection List (
MSelectionList) class and Selection List Iterator (
MItSelectionList). This can be useful for obtaining the root node for an
iteration.
Attributes on the nodes can be manipulated using the Attribute
Function Set (
MFnAttribute) and its derivations.
'''
    def __init__(self):
        pass


    def reset(self): 
        '''
        reset(self)

        Synopsis
        -----
        Clears iterator data and resets the iterator to the root node or
        plug. If a valid filter is enabled, the iterator automatically
        advances to the next node after the root node that matches the
        filter. If no matching node is found the status is failure
        (MFn::kFailure).

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def resetTo(self, rootNode: MObject,
                        filter: MFn.MFn,
                        direction: MItDependencyGraph.Direction,
                        traversal: MItDependencyGraph.Traversal,
                        level: MItDependencyGraph.Level,
                        relationship: MItDependencyGraph.Relationship): 
        '''
        resetTo(self, rootNode: MObject,
                        filter: MFn.MFn,
                        direction: MItDependencyGraph.Direction,
                        traversal: MItDependencyGraph.Traversal,
                        level: MItDependencyGraph.Level,
                        relationship: MItDependencyGraph.Relationship)

        Synopsis
        -----
        Changed in 2022.0 Clears iterator data and re-initializes the
        iterator.If a valid filter is provided, the iterator
        automatically advances to the next node after the root node that
        matches the filter. If no matching node is found the status is
        failure (MFn::kFailure).

        Returns:
        -----
        None

        Parameters:
        -----
        rootNode: MObject
        	[in] -> Root node of the iteration 

        filter: MFn.MFn
        	[in] -> Object type filter (see 

        direction: MItDependencyGraph.Direction
        	[in] -> Primary direction of iteration

        traversal: MItDependencyGraph.Traversal
        	[in] -> Order of traversal 

        level: MItDependencyGraph.Level
        	[in] -> Level of detail of the iteration

        relationship: MItDependencyGraph.Relationship
        	[in] -> What kind of relationship to follow


        '''
        pass

    @overload
    def resetTo(self, rootPlug: MPlug,
                        filter: MFn.MFn,
                        direction: MItDependencyGraph.Direction,
                        traversal: MItDependencyGraph.Traversal,
                        level: MItDependencyGraph.Level,
                        relationship: MItDependencyGraph.Relationship): 
        '''
        resetTo(self, rootPlug: MPlug,
                        filter: MFn.MFn,
                        direction: MItDependencyGraph.Direction,
                        traversal: MItDependencyGraph.Traversal,
                        level: MItDependencyGraph.Level,
                        relationship: MItDependencyGraph.Relationship)

        Synopsis
        -----
        Changed in 2022.0 Clears iterator data and re-initializes the
        iterator.If a valid filter is enabled, the iterator automatically
        advances to the next node after the root node that matches the
        filter. If no matching node is found the status is failure
        (MFn::kFailure).

        Returns:
        -----
        None

        Parameters:
        -----
        rootPlug: MPlug
        	[in] -> Root plug of the iteration 

        filter: MFn.MFn
        	[in] -> Object type filter (see 

        direction: MItDependencyGraph.Direction
        	[in] -> Primary direction of iteration

        traversal: MItDependencyGraph.Traversal
        	[in] -> Order of traversal

        level: MItDependencyGraph.Level
        	[in] -> Level of detail of the iteration

        relationship: MItDependencyGraph.Relationship
        	[in] -> What kind of relationship to follow


        '''
        pass

    @overload
    def resetTo(self, rootNode: MObject,
                        rootPlug: MPlug,
                        infoObject: MIteratorType,
                        direction: MItDependencyGraph.Direction,
                        traversal: MItDependencyGraph.Traversal,
                        level: MItDependencyGraph.Level,
                        relationship: MItDependencyGraph.Relationship): 
        '''
        resetTo(self, rootNode: MObject,
                        rootPlug: MPlug,
                        infoObject: MIteratorType,
                        direction: MItDependencyGraph.Direction,
                        traversal: MItDependencyGraph.Traversal,
                        level: MItDependencyGraph.Level,
                        relationship: MItDependencyGraph.Relationship)

        Synopsis
        -----
        Changed in 2022.0 Clears iterator data and re-initializes the
        iterator.The filter list is reset to the new list specified thro'
        MIteratorType object. If a valid filter is enabled, the iterator
        automatically advances to the next node after the root node/plug
        that matches the filter. If no matching node is found the status
        is failure (MFn::kFailure).

        Returns:
        -----
        None

        Parameters:
        -----
        rootNode: MObject
        	[in] -> Root Node of the iteration. This can be null if the root has to be reset to plug. 

        rootPlug: MPlug
        	[in] -> Root plug of the iteration. This can be null if the root has to be reset to node. 

        infoObject: MIteratorType
        	[in] -> MIteratorType

        direction: MItDependencyGraph.Direction
        	[in] -> Primary direction of iteration

        traversal: MItDependencyGraph.Traversal
        	[in] -> Order of traversal

        level: MItDependencyGraph.Level
        	[in] -> Level of detail of the iteration

        relationship: MItDependencyGraph.Relationship
        	[in] -> What kind of relationship to follow


        '''
        pass

    def rootNode(self, ReturnStatus: MItDependencyGraph.MStatus): 
        '''
        rootNode(self, ReturnStatus: MItDependencyGraph.MStatus) -> MObject

        Synopsis
        -----
        Retrieves the root node of the iteration.

        Returns: 
        ----- 
        The root node

        Parameters:
        -----
        ReturnStatus: MItDependencyGraph.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def rootPlug(self, ReturnStatus: MItDependencyGraph.MStatus): 
        '''
        rootPlug(self, ReturnStatus: MItDependencyGraph.MStatus) -> MPlug

        Synopsis
        -----
        Retrieves the root plug of the iteration.

        Returns: 
        ----- 
        The root plug

        Parameters:
        -----
        ReturnStatus: MItDependencyGraph.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def currentFilter(self, ReturnStatus: MItDependencyGraph.MStatus): 
        '''
        currentFilter(self, ReturnStatus: MItDependencyGraph.MStatus) -> MFn.MFn

        Synopsis
        -----
        Retrieves the current node type filter.

        Returns: 
        ----- 
        The current node type filter

        Parameters:
        -----
        ReturnStatus: MItDependencyGraph.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def setCurrentFilter(self, filter: MFn.MFn): 
        '''
        setCurrentFilter(self, filter: MFn.MFn)

        Synopsis
        -----
        Sets the node or plug filter. Plug filtering is based on the type
        of the corresponding Attribute. Defaults to disabled
        (MFn::kInvalid). If a valid filter is specified, the iterator
        automatically advances to the next node that matches the filter.
        If no matching node status is failure (MFn::kFailure).Disables
        pruning on the new filter (default). Use enablePruningOnFilter()
        method to enable pruning. No other iterator data is changed. If
        new filter is the same as current filter, no action is taken.

        Returns:
        -----
        None

        Parameters:
        -----
        filter: MFn.MFn
        	[in] -> node or Attribute type filter (see 


        '''
        pass

    def resetFilter(self): 
        '''
        resetFilter(self)

        Synopsis
        -----
        Resets the node or plug filter to default, MFn::kInvalid (filter
        disabled). Disables pruning on the filter (default). Resets the
        iterator.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isPruningOnFilter(self, ReturnStatus: MItDependencyGraph.MStatus): 
        '''
        isPruningOnFilter(self, ReturnStatus: MItDependencyGraph.MStatus) -> bool

        Synopsis
        -----
        Tests whether or not the iteration path is pruned automatically
        at nodes or plugs which do not match the filter.

        Returns: 
        ----- 
        Bool: true if pruning is enabled, false otherwise.

        Parameters:
        -----
        ReturnStatus: MItDependencyGraph.MStatus
        	[in] -> Status Code (see below)


        '''
        pass

    def enablePruningOnFilter(self): 
        '''
        enablePruningOnFilter(self)

        Synopsis
        -----
        Enables automatic pruning of iteration path at nodes or plugs
        which do not match the filter.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def disablePruningOnFilter(self): 
        '''
        disablePruningOnFilter(self)

        Synopsis
        -----
        Disables automatic pruning of iteration path at nodes or plugs
        which do not match the filter.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isDirectionDownStream(self, ReturnStatus: MItDependencyGraph.MStatus): 
        '''
        isDirectionDownStream(self, ReturnStatus: MItDependencyGraph.MStatus) -> bool

        Synopsis
        -----
        Tests whether or not the iteration is moving downstream (in the
        direction of data flow) in the DG.

        Returns: 
        ----- 
        true Direction is downstream (MItDependencyGraph::kDownstream)
        false Direction is upstream (MItDependencyGraph::kUpstream)

        Parameters:
        -----
        ReturnStatus: MItDependencyGraph.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def currentDirection(self, ReturnStatus: MItDependencyGraph.MStatus): 
        '''
        currentDirection(self, ReturnStatus: MItDependencyGraph.MStatus) -> MItDependencyGraph.MItDependencyGraph

        Synopsis
        -----
        Reports the direction of the iteration through the graph.

        Returns: 
        ----- 
        MItDependencyGraph::kDownstream Direction is downstream
        MItDependencyGraph::kDownstream Direction is upstream

        Parameters:
        -----
        ReturnStatus: MItDependencyGraph.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def toggleDirection(self): 
        '''
        toggleDirection(self)

        Synopsis
        -----
        Toggles the direction of the iteration. Resets the root of the
        iteration to the current node or plug depending on the level of
        iteration. Clears iterator path data. If a valid filter is
        enabled, the iterator automatically advances to the next node
        that matches the filter. If no matching node is found the status
        is failure (MFn::kFailure). No other iterator parameters are
        affected.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isTraversalDepthFirst(self, ReturnStatus: MItDependencyGraph.MStatus): 
        '''
        isTraversalDepthFirst(self, ReturnStatus: MItDependencyGraph.MStatus) -> bool

        Synopsis
        -----
        Tests whether or not the iteration is proceeding depth first
        (away from the root of the iteration) in the DG.

        Returns: 
        ----- 
        true Traversal is depth first (MItDependencyGraph::kDepthFirst)
        false Traversal is breadth first
        (MItDependencyGraph::kBreadthFirst)

        Parameters:
        -----
        ReturnStatus: MItDependencyGraph.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def currentTraversal(self, ReturnStatus: MItDependencyGraph.MStatus): 
        '''
        currentTraversal(self, ReturnStatus: MItDependencyGraph.MStatus) -> MItDependencyGraph.MItDependencyGraph

        Synopsis
        -----
        Reports the traversal mode of the iteration through the graph.

        Returns: 
        ----- 
        MItDependencyGraph::kDepthFirst Traversal is depth first
        MItDependencyGraph::kBreadthFirst Traversal is breadth first

        Parameters:
        -----
        ReturnStatus: MItDependencyGraph.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def toggleTraversal(self): 
        '''
        toggleTraversal(self)

        Synopsis
        -----
        Toggles the traversal of the iteration. Resets the root of the
        iteration to the current node or plug depending on the level of
        iteration. Clears iterator path data. If a valid filter is
        enabled, the iterator automatically advances to the next node
        that matches the filter. If no matching node is found the status
        is failure (MFn::kFailure). No other iterator parameters are
        affected.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def atNodeLevel(self, ReturnStatus: MItDependencyGraph.MStatus): 
        '''
        atNodeLevel(self, ReturnStatus: MItDependencyGraph.MStatus) -> bool

        Synopsis
        -----
        Tests whether or not the iteration is at the node level of detail
        (every node is visited only once) in the DG.

        Returns: 
        ----- 
        true node level (MItDependencyGraph::kNodeLevel)  false plug
        level (MItDependencyGraph::kPlugLevel)

        Parameters:
        -----
        ReturnStatus: MItDependencyGraph.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def currentLevel(self, ReturnStatus: MItDependencyGraph.MStatus): 
        '''
        currentLevel(self, ReturnStatus: MItDependencyGraph.MStatus) -> MItDependencyGraph.MItDependencyGraph

        Synopsis
        -----
        Reports the level of the iteration through the graph.

        Returns: 
        ----- 
        MItDependencyGraph::kNodeLevel Level is node level
        MItDependencyGraph::kPlugLevel Level is plug level

        Parameters:
        -----
        ReturnStatus: MItDependencyGraph.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def currentRelationship(self, ReturnStatus: MItDependencyGraph.MStatus): 
        '''
        currentRelationship(self, ReturnStatus: MItDependencyGraph.MStatus) -> MItDependencyGraph.MItDependencyGraph

        Synopsis
        -----
        Introduced in 2022.0 Reports the relationship mode of the
        iteration through the graph.

        Returns: 
        ----- 
        MItDependencyGraph::kDependsOn Follow dependency
        MItDependencyGraph::kConnectedTo Follow DG connection
        MItDependencyGraph::kEvaluationGraph Follow evaluation graph

        Parameters:
        -----
        ReturnStatus: MItDependencyGraph.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def setCurrentRelationship(self, relationship: MItDependencyGraph.Relationship): 
        '''
        setCurrentRelationship(self, relationship: MItDependencyGraph.Relationship)

        Synopsis
        -----
        Introduced in 2022.0 Sets the relationship mode of the
        iteration.Resets the root of the iteration to the current node or
        plug depending on the level of iteration. Clears iterator path
        data. If a valid filter is enabled, the iterator automatically
        advances to the next node that matches the filter. If no matching
        node is found the status is failure (MFn::kFailure). No other
        iterator parameters are affected.

        Returns:
        -----
        None

        Parameters:
        -----
        relationship: MItDependencyGraph.Relationship
        	[in] -> 


        '''
        pass

    def setTraversalOverWorldSpaceDependents(self, val: bool): 
        '''
        setTraversalOverWorldSpaceDependents(self, val: bool)

        Synopsis
        -----
        This method controls whether the iterator will include world-
        space attribute dependencies in its traversal. For example, say
        there is an animation curve attached to the translateX attribute
        on a transform, and an upstream iterator starts at the
        worldMatrix attribute. If world-space traversal is enabled, the
        iterator will get to the animation curve. Note however that even
        when world-space traversal is enabled, the iterator will only
        iterate to connected nodes. It does not iterate up and down
        through the dag hierarchy.By default, traversal of world-space
        dependencies is disabled.

        Returns:
        -----
        None

        Parameters:
        -----
        val: bool
        	[in] -> True to enable traversal of world-space dependencies, false to disable.


        '''
        pass

    def isTraversingOverWorldSpaceDependents(self, ReturnStatus: MItDependencyGraph.MStatus): 
        '''
        isTraversingOverWorldSpaceDependents(self, ReturnStatus: MItDependencyGraph.MStatus) -> bool

        Synopsis
        -----
        Tests whether the iterator is set to traverse world-space
        attribute dependencies.

        Returns: 
        ----- 
        true Traversing of world-space attributes is enabled.  false
        Traversing of world-space attributes is disabled.

        Parameters:
        -----
        ReturnStatus: MItDependencyGraph.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def toggleLevel(self): 
        '''
        toggleLevel(self)

        Synopsis
        -----
        Toggles the level of the iteration. Resets the root of the
        iteration to the current node or plug depending on the level of
        iteration. Clears iterator path data. If a valid filter is
        enabled, the iterator automatically advances to the next node
        that matches the filter. If no matching node is found the status
        is failure (MFn::kFailure). No other iterator parameters are
        affected.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def next(self): 
        '''
        next(self)

        Synopsis
        -----
        Iterates to the next node or plug in accordance with the
        direction, traversal, level and filter. If a valid filter is set,
        the iterator only visits those nodes that match the filter. When
        filtering is enabled nodes that have unknown type are treated as
        non-matching nodes. With filtering disabled, iteration to a node
        with an unknown type is treated as a failure. An attempt to
        iterate when there is nothing left to iterate over has no effect.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isDone(self, ReturnStatus: MItDependencyGraph.MStatus): 
        '''
        isDone(self, ReturnStatus: MItDependencyGraph.MStatus) -> bool

        Synopsis
        -----
        Indicates whether or not all nodes or plugs have been iterated
        over in accordance with the direction, traversal, level and
        filter. If a valid filter is set, the iterator only visits those
        nodes that match the filter.

        Returns: 
        ----- 
        true Iteration is done  false Iteration is not done

        Parameters:
        -----
        ReturnStatus: MItDependencyGraph.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def prune(self): 
        '''
        prune(self)

        Synopsis
        -----
        Prunes the search path at the current plug. Iterator will not
        visit any of the plugs connected to the pruned plug.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def currentItem(self, ReturnStatus: MItDependencyGraph.MStatus): 
        '''
        currentItem(self, ReturnStatus: MItDependencyGraph.MStatus) -> MObject

        Synopsis
        -----
        Retrieves the current node of the iteration. Results in a null
        object on failure or if the node is of a unrecognized type.

        Returns: 
        ----- 
        Current node

        Parameters:
        -----
        ReturnStatus: MItDependencyGraph.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def thisNodeHasUnknownType(self, ReturnStatus: MItDependencyGraph.MStatus): 
        '''
        thisNodeHasUnknownType(self, ReturnStatus: MItDependencyGraph.MStatus) -> bool

        Synopsis
        -----
        Indicates whether or not the current node has an unrecognised
        type. This is useful if an unexpected failure is encountered in
        the next() or currentItem() methods.Returns true only if node
        exists but is not a recognizable type.Returns false if node
        exists and is recognizable. Also returns false on failure or if
        the iteration is done.

        Returns: 
        ----- 
        true Unknown type  false Type is known or iterator is done or
        failure encountered

        Parameters:
        -----
        ReturnStatus: MItDependencyGraph.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def thisPlug(self, ReturnStatus: MItDependencyGraph.MStatus): 
        '''
        thisPlug(self, ReturnStatus: MItDependencyGraph.MStatus) -> MPlug

        Synopsis
        -----
        Retrieves the current plug of the iteration. Results in a null
        plug on failure.

        Returns: 
        ----- 
        Current plug

        Parameters:
        -----
        ReturnStatus: MItDependencyGraph.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def previousPlug(self, ReturnStatus: MItDependencyGraph.MStatus): 
        '''
        previousPlug(self, ReturnStatus: MItDependencyGraph.MStatus) -> MPlug

        Synopsis
        -----
        Retrieves the previous plug of the iteration. Results in a null
        plug on failure. Null plug may also indicate that the current
        plug is the root plug.

        Returns: 
        ----- 
        Current plug

        Parameters:
        -----
        ReturnStatus: MItDependencyGraph.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def getNodesVisited(self, nodes: MObjectArray): 
        '''
        getNodesVisited(self, nodes: MObjectArray)

        Synopsis
        -----
        Retrieves all nodes visited during the iteration. State of the
        provided array is undefined if this method fails.

        Returns:
        -----
        None

        Parameters:
        -----
        nodes: MObjectArray
        	[out] -> Target array for retrieved nodes. On success contains all nodes visited


        '''
        pass

    def getPlugsVisited(self, plugs: MPlugArray): 
        '''
        getPlugsVisited(self, plugs: MPlugArray)

        Synopsis
        -----
        Retrieves all plugs visited during the iteration. State of the
        provided array is undefined if this method fails.

        Returns:
        -----
        None

        Parameters:
        -----
        plugs: MPlugArray
        	[out] -> Target array for retrieved plugs. On success contains all plugs visited


        '''
        pass

    def getNodePath(self, path: MObjectArray): 
        '''
        getNodePath(self, path: MObjectArray)

        Synopsis
        -----
        Retrieves the direct path from the current node to the root node.
        Path does not include the current node. State of the provided
        array is undefined if this method fails.

        Returns:
        -----
        None

        Parameters:
        -----
        path: MObjectArray
        	[out] -> Target array for retrieved path. On success contains direct path from the current node to the root node


        '''
        pass

    def getPlugPath(self, path: MPlugArray): 
        '''
        getPlugPath(self, path: MPlugArray)

        Synopsis
        -----
        Retrieves the direct path from the current plug to the root plug,
        with the current plug in element 0 of the array and the root plug
        in the final element of the array. Once the iterator is done
        (i.e. isDone() returns true) there is no longer a current plug
        and this method will return an empty array.If this method fails
        the state of the returned array is undefined.

        Returns:
        -----
        None

        Parameters:
        -----
        path: MPlugArray
        	[out] -> Target array for retrieved path. On success contains direct path from the current plug to the root plug


        '''
        pass

    def nodeDepth(self, ReturnStatus: MItDependencyGraph.MStatus): 
        '''
        nodeDepth(self, ReturnStatus: MItDependencyGraph.MStatus) -> int

        Synopsis
        -----
        Introduced in 2023.0 Reports the depth of the iteration through
        the graph.

        Returns: 
        ----- 
        int Depth in number of nodes

        Parameters:
        -----
        ReturnStatus: MItDependencyGraph.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class Direction:
    '''Direction within the DG relative to root Node or Plug. 
    Non-functional class.  Values for this enum:
    kDownstream
    kUpstream
    '''

    def __init__(self):
        pass

    def kDownstream(self):
        '''This is an enum of Direction.
        - Description: From source to destination. 
        - Value: 0
        '''
        pass

    def kUpstream(self):
        '''This is an enum of Direction.
        - Description: From destination to source. 
        - Value: 1
        '''
        pass

class Traversal:
    '''Perform a depth first or breadth first traversal. 
    Non-functional class.  Values for this enum:
    kDepthFirst
    kBreadthFirst
    '''

    def __init__(self):
        pass

    def kDepthFirst(self):
        '''This is an enum of Traversal.
        - Description: Away from root first. 
        - Value: 0
        '''
        pass

    def kBreadthFirst(self):
        '''This is an enum of Traversal.
        - Description: Equidistant from root first. 
        - Value: 1
        '''
        pass

class Level:
    '''Level of detail of the iteration. 
    Non-functional class.  Values for this enum:
    kNodeLevel
    kPlugLevel
    '''

    def __init__(self):
        pass

    def kNodeLevel(self):
        '''This is an enum of Level.
        - Description: Visit each Node at most once. 
        - Value: 0
        '''
        pass

    def kPlugLevel(self):
        '''This is an enum of Level.
        - Description: Visit each Plug at most once. 
        - Value: 1
        '''
        pass

class Relationship:
    '''Introduced in 2022.0 
    Non-functional class.  Values for this enum:
    kDependsOn
    kConnectedTo
    kEvaluationGraph
    '''

    def __init__(self):
        pass

    def kDependsOn(self):
        '''This is an enum of Relationship.
        - Description: Traverse dependency (this is the default behavior) 
        - Value: 0
        '''
        pass

    def kConnectedTo(self):
        '''This is an enum of Relationship.
        - Description: Traverse DG connection. 
        - Value: 1
        '''
        pass

    def kEvaluationGraph(self):
        '''This is an enum of Relationship.
        - Description: Traverse evaluation graph. 
        - Value: 2
        '''
        pass

class MItDependencyNodes:
    '''Dependency Node iterator.
Use the dependency node iterator to traverse all the nodes in
Maya's Dependency Graph.
With filtering enabled, the iterator checks to see if the node is
compatible with the type specified by the filter. See
MFn::Type for a list of all valid types.
Since MObjects may be compatible with more than one type (nodes
are organised in a hierarchy) the
MObject::hasFn() method can be used to further check for compatible types.
Any compatible Function Set can be attached to the retrieved
object to query or or edit it. Often you will want to use the
dependency node function set (
MFnDependencyNode), which is compatible with all dependency nodes, to perform
queries on each node as the iterator Traverses the Dependency
Graph.
'''
    def __init__(self):
        pass


    @overload
    def reset(self, filter: MFn.MFn): 
        '''
        reset(self, filter: MFn.MFn)

        Synopsis
        -----
        Resets the iterator and reinitializes the filter.

        Returns:
        -----
        None

        Parameters:
        -----
        filter: MFn.MFn
        	[in] -> Function set type (


        '''
        pass

    @overload
    def reset(self, infoObject: MIteratorType): 
        '''
        reset(self, infoObject: MIteratorType)

        Synopsis
        -----
        Resets the iterator and reinitializes the filter list. The filter
        list is specified through MIteratorType object.

        Returns:
        -----
        None

        Parameters:
        -----
        infoObject: MIteratorType
        	[in] -> MIterator object, which has filter list information.


        '''
        pass

    def thisNode(self, ReturnStatus: MItDependencyNodes.MStatus): 
        '''
        thisNode(self, ReturnStatus: MItDependencyNodes.MStatus) -> MObject

        Synopsis
        -----
        Retrieves the dependency node to which the iterator points.

        Returns: 
        ----- 
        The dependency node. A null MObject indicates failure.

        Parameters:
        -----
        ReturnStatus: MItDependencyNodes.MStatus
        	[out] -> Status Code (see below).


        '''
        pass

    def next(self): 
        '''
        next(self)

        Synopsis
        -----
        Moves to the next node matching the filter. If the filter is set
        to kInvalid, this method advances to the next DG node without
        doing any filtering.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isDone(self, ReturnStatus: MItDependencyNodes.MStatus): 
        '''
        isDone(self, ReturnStatus: MItDependencyNodes.MStatus) -> bool

        Synopsis
        -----
        Indicates end of the iteration.

        Returns: 
        ----- 
        Bool: true if the iteration is done, false otherwise

        Parameters:
        -----
        ReturnStatus: MItDependencyNodes.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MItEdits:
    '''Edits iterator.
Use the edits iterator to traverse all the edits on a reference
or assembly. An edit is any operation that modifies the
dependency graph such as modifications to values, connections,
parenting and so on.
In the case of references, edits are the changes that occur to
referenced nodes. In the case of assemblies, edits are the
changes that occur to assembly members.
Edits are returned as either strings representing an equivalent
MEL call, or as a class derived from
MEdit.
The edits iterator works regardless of whether the related
reference or assembly is loaded or unloaded. However, please note
that loading or unloading the related reference or assembly will
cause any in-progress iteration to be reset.
If new edits were created while iterating, the iterator will not
necessarily traverse them.
To control which edits you will traverse over, use the
combination of the 'editsOwner' and 'targetNode'/'targetNodeName'
parameters.
The editsOwner is the reference or assembly node that "owns"
edits. This is the top-level assembly/reference at the time the
edit was made. If you were to save a file, this is the node that
the edits would be stored on.
The targetNode is the innermost reference or assembly node
containing the edited nodes. Edits will be physically stored on
the edits owner, so use targetNode to get just edits that affect
nodes in a specific assembly/reference. If the nested assembly or
reference is not loaded, you can still query edits that affect
that node by specifying a string targetNodeName, instead of a
targetNode
MObject.
Hierarchical Example:
The following example explains the above terminology in the
hierarchical case. Suppose you have a reference or assembly
hierarchy that looks like this.
Edits can be made at three different levels:
Edits made from C to nodes in C. These edits were made from the C
file/assembly. These edits are stored on C
Edits made from B to nodes in B or C. These edits were made from
the B file/assembly. These edits are stored on B
To query all the edits stored on A, use: editsOwner = A
targetNode =
MObject::kNullObjTo query edits stored on A that affect nodes in A, use:
editsOwner = A targetNode = A
To query edits stored on A that affect nodes in B, use:
editsOwner = A targetNode = B
To query all the edits stored on B, use: editsOwner = B
targetNode =
MObject::kNullObjTo only query edits stored on B that affect nodes in C, use:
editsOwner = B targetNode = C
'''
    def __init__(self):
        pass


    def reset(self): 
        '''
        reset(self)

        Synopsis
        -----
        Resets the iterator.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def next(self): 
        '''
        next(self)

        Synopsis
        -----
        Moves to the next edit.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isDone(self, ReturnStatus: MItEdits.MStatus): 
        '''
        isDone(self, ReturnStatus: MItEdits.MStatus) -> bool

        Synopsis
        -----
        Indicates end of the iteration.

        Returns: 
        ----- 
        Bool: true if the iteration is done, false otherwise

        Parameters:
        -----
        ReturnStatus: MItEdits.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def isReverse(self, ReturnStatus: MItEdits.MStatus): 
        '''
        isReverse(self, ReturnStatus: MItEdits.MStatus) -> bool

        Synopsis
        -----
        Indicates whether the edit lists are iterated in reverse order.

        Returns: 
        ----- 
        Bool: true if the iteration is reversed, false otherwise

        Parameters:
        -----
        ReturnStatus: MItEdits.MStatus
        	[out] -> Status Code (see below)


        '''
        pass

    def currentEditString(self, ReturnStatus: MItEdits.MStatus): 
        '''
        currentEditString(self, ReturnStatus: MItEdits.MStatus) -> MString

        Synopsis
        -----
        Returns the ASCII string related to the current edit.

        Returns: 
        ----- 
        The ASCII string related to the current edit

        Parameters:
        -----
        ReturnStatus: MItEdits.MStatus
        	[out] -> return status


        '''
        pass

    def currentEditType(self, ReturnStatus: MItEdits.MStatus): 
        '''
        currentEditType(self, ReturnStatus: MItEdits.MStatus) -> MEdit.MEdit

        Synopsis
        -----
        Returns the enum related to the type of the current edit.

        Returns: 
        ----- 
        The current reference or assembly edit type or kNullEdit if there
        is no current edit.

        Parameters:
        -----
        ReturnStatus: MItEdits.MStatus
        	[out] -> return status


        '''
        pass

    def removeCurrentEdit(self, ReturnStatus: MItEdits.MStatus): 
        '''
        removeCurrentEdit(self, ReturnStatus: MItEdits.MStatus) -> bool

        Synopsis
        -----
        Removes the current edit. Edits can only be removed from top-
        level assemblies/references.Edits from nested
        assemblies/references are physically saved in those nested files.
        So we do not have write access to them from the main scene, and
        thus, they cannot be removed.Where possible, the remove operation
        will simply reverse the edit. For example, if the current edit is
        a setAttr edit, the value of the attribute will be returned to
        its previous value.Once an edit has been removed, the iterator
        will point to a null operation, which can be skipped using
        next(). If the iterator is reset, this null operation will still
        be present, and must be skipped.NOTE: This method must be used
        with care. Removing just one specific edit from a group of
        related edits may leave your scene in an undesirable state. For
        example, if you removed just one connection in a complex shading
        network, the network may not function correctly.

        Returns: 
        ----- 
        True if the edit was removed successfully. False if the edit is
        stored on a nested assembly or reference.

        Parameters:
        -----
        ReturnStatus: MItEdits.MStatus
        	[out] -> return status


        '''
        pass

    def edit(self, ReturnStatus: MItEdits.MStatus): 
        '''
        edit(self, ReturnStatus: MItEdits.MStatus) -> MEdit

        Synopsis
        -----

        Returns: 
        ----- 
        The current edit.

        Parameters:
        -----
        ReturnStatus: MItEdits.MStatus
        	[out] -> return status


        '''
        pass

    def addRemoveAttrEdit(self, ReturnStatus: MItEdits.MStatus): 
        '''
        addRemoveAttrEdit(self, ReturnStatus: MItEdits.MStatus) -> MAddRemoveAttrEdit

        Synopsis
        -----
        Returns the current edit if the current edit is an edit for
        adding or removing an attribute. The method currentEditType can
        be used to validate whether the current edit is of the
        appropriate type. An edit for adding or removing an attribute
        indicates that an attribute has been added or removed since the
        file was referenced.Note that whenever an attribute is added and
        the new attribute is keyable, an associated setAttr edit will
        also be added to record the fact that the attribute keyable.

        Returns: 
        ----- 
        The add or remove attribute edit

        Parameters:
        -----
        ReturnStatus: MItEdits.MStatus
        	[out] -> return status


        '''
        pass

    def setAttrEdit(self, ReturnStatus: MItEdits.MStatus): 
        '''
        setAttrEdit(self, ReturnStatus: MItEdits.MStatus) -> MSetAttrEdit

        Synopsis
        -----
        Returns the current edit if the current edit is a setAttr edit.
        The method currentEditType can be used to validate whether or not
        the current edit is a setAttr edit. A setAttr edit is a
        modification to a plug value on an object from a reference or
        assembly.

        Returns: 
        ----- 
        The setAttr edit.

        Parameters:
        -----
        ReturnStatus: MItEdits.MStatus
        	[out] -> return status


        '''
        pass

    def parentingEdit(self, ReturnStatus: MItEdits.MStatus): 
        '''
        parentingEdit(self, ReturnStatus: MItEdits.MStatus) -> MParentingEdit

        Synopsis
        -----
        Returns the current edit if the current edit is a parenting edit.
        The method currentEditType can be used to validate whether or not
        the current edit is a parenting edit. Parenting edits are
        modifications to the parent or child of an object from a
        reference or an assembly.

        Returns: 
        ----- 
        The parenting edit.

        Parameters:
        -----
        ReturnStatus: MItEdits.MStatus
        	[out] -> return status


        '''
        pass

    def fcurveEdit(self, ReturnStatus: MItEdits.MStatus): 
        '''
        fcurveEdit(self, ReturnStatus: MItEdits.MStatus) -> MFcurveEdit

        Synopsis
        -----
        Returns the current edit if the current edit is an fcurve edit.
        The method currentEditType can be used to validate whether or not
        the current edit is an fcurve edit. An fcurve edit is a
        modification to an animCurve from a reference.

        Returns: 
        ----- 
        The fcurve edit.

        Parameters:
        -----
        ReturnStatus: MItEdits.MStatus
        	[out] -> return status


        '''
        pass

    def connectDisconnectEdit(self, ReturnStatus: MItEdits.MStatus): 
        '''
        connectDisconnectEdit(self, ReturnStatus: MItEdits.MStatus) -> MConnectDisconnectAttrEdit

        Synopsis
        -----
        Returns the current edit if the current edit is a connection or
        disconnection edit. The method currentEditType can be used to
        validate whether the current edit is a connection or
        disconnection edit. A connection or disconnection edit indicates
        that a connection has been made or broken since the file or
        assembly was referenced.

        Returns: 
        ----- 
        The connection or disconnection edit.

        Parameters:
        -----
        ReturnStatus: MItEdits.MStatus
        	[out] -> return status


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class EditStatus:
    '''The status of edits this iterator will visit. 
    Non-functional class.  Values for this enum:
    SUCCESSFUL_EDITS
    ALL_EDITS
    '''

    def __init__(self):
        pass

    def SUCCESSFUL_EDITS(self):
        '''This is an enum of EditStatus.
        - Description: Visit successful edits only. 
        - Value: 0
        '''
        pass

    def ALL_EDITS(self):
        '''This is an enum of EditStatus.
        - Description: Visit all the edits. 
        - Value: 1
        '''
        pass

class Direction:
    '''The direction in which the iterator will visit its edits. 
    Non-functional class.  Values for this enum:
    kForward
    kReverse
    '''

    def __init__(self):
        pass

    def kForward(self):
        '''This is an enum of Direction.
        - Description: Visit the edits in the order in which they were added. 
        - Value: 0
        '''
        pass

    def kReverse(self):
        '''This is an enum of Direction.
        - Description: Visit the edits in the reverse order from how they were added. 
        - Value: 1
        '''
        pass

class MItGeometry:
    '''Iterator class for geometry data.
This class is the iterator class for geometry data, and can be
used to loop over the CVs of NURBS, the points of subds &
lattices, and the vertices of polygonal meshes.
Traversal of a geometry group within a compute() method.
'''
    def __init__(self):
        pass


    def isDone(self, ReturnStatus: MItGeometry.MStatus): 
        '''
        isDone(self, ReturnStatus: MItGeometry.MStatus) -> bool

        Synopsis
        -----
        Returns true if the iteration is finished, i.e. there are no more
        components to iterate on.

        Returns: 
        ----- 
        Bool true if There are no more components to iterate on, false
        otherwise.

        Parameters:
        -----
        ReturnStatus: MItGeometry.MStatus
        	[out] -> Status code


        '''
        pass

    def next(self): 
        '''
        next(self)

        Synopsis
        -----
        Advance to the next component in the iteration. If the iterator
        is already at the last component then this method has no effect.
        Use isDone to determine if the iterator is at the last component.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def position(self, space: MSpace.MSpace,
                        ReturnStatus: MItGeometry.MStatus): 
        '''
        position(self, space: MSpace.MSpace,
                        ReturnStatus: MItGeometry.MStatus) -> MPoint

        Synopsis
        -----
        Return the position of the current point/CV/vertex component.

        Returns: 
        ----- 
        The current component's position

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> The transformation space in which the operation is done 

        ReturnStatus: MItGeometry.MStatus
        	[out] -> Status code


        '''
        pass

    def normal(self, space: MSpace.MSpace,
                        ReturnStatus: MItGeometry.MStatus): 
        '''
        normal(self, space: MSpace.MSpace,
                        ReturnStatus: MItGeometry.MStatus) -> MVector

        Synopsis
        -----
        Return the normal of the current point/CV/vertex component.

        Returns: 
        ----- 
        The current component's normal

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> The transformation space in which the operation is done 

        ReturnStatus: MItGeometry.MStatus
        	[out] -> Status code


        '''
        pass

    def setPosition(self, pt: MPoint,
                        space: MSpace.MSpace): 
        '''
        setPosition(self, pt: MPoint,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the position of the current point/CV/vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        pt: MPoint
        	[in] -> New position. 

        space: MSpace.MSpace
        	[in] -> The transformation space in which the operation is done.


        '''
        pass

    def weight(self, ReturnStatus: MItGeometry.MStatus): 
        '''
        weight(self, ReturnStatus: MItGeometry.MStatus) -> MWeight

        Synopsis
        -----
        Return the weight of the current point/CV/vertex component.

        Returns: 
        ----- 
        The current component's weight

        Parameters:
        -----
        ReturnStatus: MItGeometry.MStatus
        	[out] -> Status code


        '''
        pass

    def index(self, ReturnStatus: MItGeometry.MStatus): 
        '''
        index(self, ReturnStatus: MItGeometry.MStatus) -> int

        Synopsis
        -----
        This method returns the index of the current point/CV/vertex
        component in the iteration. The index matches the index of the
        point into the array returned from the geometry, for example by
        using MFnMesh::getPoints() or MFnNurbsSurface::getCVs()

        Returns: 
        ----- 
        The index of the current point/CV/vertex.

        Parameters:
        -----
        ReturnStatus: MItGeometry.MStatus
        	[out] -> Status code


        '''
        pass

    def positionIndex(self, ReturnStatus: MItGeometry.MStatus): 
        '''
        positionIndex(self, ReturnStatus: MItGeometry.MStatus) -> int

        Synopsis
        -----
        Introduced in 2020.0 This method returns the position index of
        the current point/CV/vertex component in the iteration.The
        positionIndex matches the index of the point into the array that
        would be returned from an iterator over the entire geometry.Note
        that this can be different from index(). For most geometry types
        (like a Mesh) they will be the same, but for surfaces that wrap
        around and double up points like a NurbsSurface they can be
        different.

        Returns: 
        ----- 
        The index of the current point/CV/vertex.

        Parameters:
        -----
        ReturnStatus: MItGeometry.MStatus
        	[out] -> Status code


        '''
        pass

    def currentItem(self, ReturnStatus: MItGeometry.MStatus): 
        '''
        currentItem(self, ReturnStatus: MItGeometry.MStatus) -> MObject

        Synopsis
        -----
        This method returns the current component in the iteration.

        Returns: 
        ----- 
        The current component in the iteration.

        Parameters:
        -----
        ReturnStatus: MItGeometry.MStatus
        	[out] -> Status code


        '''
        pass

    def count(self, ReturnStatus: MItGeometry.MStatus): 
        '''
        count(self, ReturnStatus: MItGeometry.MStatus) -> int

        Synopsis
        -----
        Return the number of items in this iteration. This number will
        always be at least as large as the number of items, however in
        some cases it may be larger. It is useful if allocating space in
        an array to hold the results, since it will always be of
        sufficient size. If the exact number of items is required, use
        the exactCount method instead. The exactCount method is however
        significantly slower than this method.

        Returns: 
        ----- 
        The number of items that will be iterated

        Parameters:
        -----
        ReturnStatus: MItGeometry.MStatus
        	[out] -> Status code


        '''
        pass

    def exactCount(self, ReturnStatus: MItGeometry.MStatus): 
        '''
        exactCount(self, ReturnStatus: MItGeometry.MStatus) -> int

        Synopsis
        -----
        Return the exact number of items in this iteration. This method
        is significantly slower than the count() method, so use if only
        if the precise number is required.

        Returns: 
        ----- 
        The number of items that will be iterated

        Parameters:
        -----
        ReturnStatus: MItGeometry.MStatus
        	[out] -> Status code


        '''
        pass

    def reset(self): 
        '''
        reset(self)

        Synopsis
        -----
        Reset the iterator to the first component.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def allPositions(self, points: MPointArray,
                        space: MSpace.MSpace): 
        '''
        allPositions(self, points: MPointArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Return the position of all the points/CVs/vertices. This
        operation is faster than using the iterator to get values one by
        one, but uses more memory as it requires an array to hold all the
        values to be returned.

        Returns:
        -----
        None

        Parameters:
        -----
        points: MPointArray
        	[out] -> Storage for positions 

        space: MSpace.MSpace
        	[in] -> The transformation space in which the operation is done


        '''
        pass

    def setAllPositions(self, pt: MPointArray,
                        space: MSpace.MSpace): 
        '''
        setAllPositions(self, pt: MPointArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the position of all the points/CVs/vertices at once. This
        operation is faster than using the iterator to set values one by
        one, but uses more memory as it requires an array to hold all the
        values to be set.

        Returns:
        -----
        None

        Parameters:
        -----
        pt: MPointArray
        	[in] -> An array containing all the positions to be set 

        space: MSpace.MSpace
        	[in] -> The transformation space in which the operation is done


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MItInstancer:
    '''Particle iterator.
Maya's Particle Replacement aka Particle Instancing feature
allows geometry to be instanced and those instances transformed
using particles. More precisely, particles are replaced by
arbitrary DAG nodes which maya be transforms with many shapes
under them, and multiple DAG paths to those shapes.
The Instancer Iterator Class (
MItInstancer) provides methods for iterating over all the dag paths to the
shapes created in the scene by the replacement of particles by
dag nodes.
When particles are being replaced by a shape node there will be
one dag path corresponding with each particle. If, say, particles
are instead being replaced by a transform with five shape nodes
somewhere underneath it, then this iterator will visit five paths
for every particle. Dag-instancing is also respected: if the
given dag node has two child transforms each of which is a path
to one shape underneath them, then this iterator will visit two
paths. In other words, this iterator does not distinguish between
paths resulting from a multiplicity of actual shapes and paths
resulting from DAG-instances of individual shapes: all appear as
different paths for the current particle.
A simple usage might look like:
'''
    def __init__(self):
        pass


    def reset(self): 
        '''
        reset(self)

        Synopsis
        -----
        Moves the iterator to the first dag-path to the first replaced-
        particle in the scene. If none exist, then isDone() will be
        immediately true.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def next(self): 
        '''
        next(self)

        Synopsis
        -----
        Advances the iterator to the next replaced-particle dag-path in
        the scene. Calling reset(), then repeatedly calling this method
        until isDone() becomes true is equivalent to the following loop
        structure:

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def nextParticle(self): 
        '''
        nextParticle(self)

        Synopsis
        -----
        Advances the iterator to the next replaced-particle in the scene,
        skipping over any remaining dag-paths associated with the current
        replaced-particle. If there are no more particles associated with
        the current instancer then the iterator will advance to the next
        instancer in order to point at the next particle.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def nextInstancer(self): 
        '''
        nextInstancer(self)

        Synopsis
        -----
        Advances the iterator to the next instancer in the scene,
        skipping over any remaining particles associated with the current
        instancer.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isDone(self): 
        '''
        isDone(self) -> bool

        Synopsis
        -----
        Returns true if the iteration is finished, i.e. there are no more
        dag-paths to replaced-particles in the scene.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def instancer(self): 
        '''
        instancer(self) -> MObject

        Synopsis
        -----
        Returns the current instancer node as an MObject.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def instancerPath(self): 
        '''
        instancerPath(self) -> MDagPath

        Synopsis
        -----
        Returns the full DAG path to the instancer that generated the
        current particle instance. A NULL path will be returned if there
        is no current instancer being iterated

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def path(self): 
        '''
        path(self) -> MDagPath

        Synopsis
        -----
        Returns the replaced-particle dag-path which the iterator is
        currently pointing to. Each path is to a shape. If the particle
        is replaced by a shape directly then there will be only one path
        per particle. If a particle is replaced by a transform with many
        child shapes then each one of those shapes will have a path.
        Amongst the paths corresponding to a given particle there may be
        multiple paths to multiple shapes. If there is no such path, a
        null path will be returned.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def matrix(self): 
        '''
        matrix(self) -> MMatrix

        Synopsis
        -----
        Returns the transformation matrix represented by the current
        path. If there is no such path, identity matrix will be returned.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def instancerId(self): 
        '''
        instancerId(self) -> uintptr_t

        Synopsis
        -----
        Returns a unique identifier for the current instancer.
        Collectively, this id together with the particle id and the path
        id uniquely identify a "replaced particle".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def particleId(self): 
        '''
        particleId(self) -> int

        Synopsis
        -----
        Returns a unique identifier for the current particle.
        Collectively, this id together with the instancer id and the path
        id uniquely identify a "replaced particle".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def pathId(self): 
        '''
        pathId(self) -> int

        Synopsis
        -----
        Returns a unique identifier for the current path. Collectively,
        this id together with the instancer id and the particle id
        uniquely identify a "replaced particle".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MItMeshEdge:
    '''Polygon edge iterator.
This class is the edge iterator for polygonal surfaces.
The iterator functions in two modes depending on whether a
component is specified. When a component is not given or is NULL
the iteration will be over all edges for the polygon. When a
component is given this iterator will iterate over the edges
specified in the component. When iterating over components a DAG
path to the polygon must also be supplied.
'''
    def __init__(self):
        pass


    def isDone(self, ReturnStatus: MItMeshEdge.MStatus): 
        '''
        isDone(self, ReturnStatus: MItMeshEdge.MStatus) -> bool

        Synopsis
        -----
        Indicates if all of the edges have been traversed yet.

        Returns: 
        ----- 
        Boolean value: true All edges have been traversed, false
        otherwise.

        Parameters:
        -----
        ReturnStatus: MItMeshEdge.MStatus
        	[out] -> Status code


        '''
        pass

    def next(self): 
        '''
        next(self)

        Synopsis
        -----
        Advance to the next edge in the iteration.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def reset(self): 
        '''
        reset(self)

        Synopsis
        -----
        Reset the iterator to the first edge.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def reset(self, polyObject: MObject,
                        component: MObject): 
        '''
        reset(self, polyObject: MObject,
                        component: MObject)

        Synopsis
        -----
        Reset the iterator to the first edge in the supplied mesh. Uses
        the edges constrained by the given component. If component is
        null then the iteration will be for all edges in the given
        polygon. If component has invalid indices those will be
        automatically removed.

        Returns:
        -----
        None

        Parameters:
        -----
        polyObject: MObject
        	[in] -> The mesh object for the iteration 

        component: MObject
        	[in] -> The constraint object. May be a vertex, a face or an edge component


        '''
        pass

    @overload
    def reset(self, polyObject: MDagPath,
                        component: MObject): 
        '''
        reset(self, polyObject: MDagPath,
                        component: MObject)

        Synopsis
        -----
        Reset the iterator to the first edge in the supplied mesh. Uses
        the edges constrained by the given component. If component is
        null then the iteration will be for all edges in the given
        polygon. If component has invalid indices those will be
        automatically removed.

        Returns:
        -----
        None

        Parameters:
        -----
        polyObject: MDagPath
        	[in] -> The surface to iterate over 

        component: MObject
        	[in] -> The constraint object. May be a vertex, a face or an edge component


        '''
        pass

    def count(self, ReturnStatus: MItMeshEdge.MStatus): 
        '''
        count(self, ReturnStatus: MItMeshEdge.MStatus) -> int

        Synopsis
        -----
        Return the number of edges in this iteration.

        Returns: 
        ----- 
        The number of edges in the iteration

        Parameters:
        -----
        ReturnStatus: MItMeshEdge.MStatus
        	[out] -> Status code


        '''
        pass

    def center(self, space: MSpace.MSpace,
                        ReturnStatus: MItMeshEdge.MStatus): 
        '''
        center(self, space: MSpace.MSpace,
                        ReturnStatus: MItMeshEdge.MStatus) -> MPoint

        Synopsis
        -----
        Returns the center of the current edge.

        Returns: 
        ----- 
        The center of the current edge

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> The coordinate system for this operation 

        ReturnStatus: MItMeshEdge.MStatus
        	[out] -> Status code


        '''
        pass

    def point(self, index: int,
                        space: MSpace.MSpace,
                        ReturnStatus: MItMeshEdge.MStatus): 
        '''
        point(self, index: int,
                        space: MSpace.MSpace,
                        ReturnStatus: MItMeshEdge.MStatus) -> MPoint

        Synopsis
        -----
        Return the position of the specified vertex of the current edge.

        Returns: 
        ----- 
        The position of the edge vertex for the given index

        Parameters:
        -----
        index: int
        	[in] -> The vertex of the edge we wish to examine (0 or 1) 

        space: MSpace.MSpace
        	[in] -> The coordinate system for this operation 

        ReturnStatus: MItMeshEdge.MStatus
        	[out] -> Status code


        '''
        pass

    def setPoint(self, point: MPoint,
                        index: int,
                        space: MSpace.MSpace): 
        '''
        setPoint(self, point: MPoint,
                        index: int,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the specified vertex of the current edge to the given value.

        Returns:
        -----
        None

        Parameters:
        -----
        point: MPoint
        	[in] -> The new value for the edge 

        index: int
        	[in] -> The vertex index of the current edge we wish to set (0 or 1) 

        space: MSpace.MSpace
        	[in] -> The coordinate system for this operation


        '''
        pass

    def isSmooth(self, ReturnStatus: MItMeshEdge.MStatus): 
        '''
        isSmooth(self, ReturnStatus: MItMeshEdge.MStatus) -> bool

        Synopsis
        -----
        This method determines if the current edge in the iteration is
        smooth (soft).

        Returns: 
        ----- 
        Boolean value: true if the edge is smooth (soft), false if the
        edge is hard.

        Parameters:
        -----
        ReturnStatus: MItMeshEdge.MStatus
        	[out] -> Status code


        '''
        pass

    def setSmoothing(self, smooth: bool): 
        '''
        setSmoothing(self, smooth: bool)

        Synopsis
        -----
        This method sets the current edge to be hard or smooth (soft).
        The cleanupSmoothing method is no longer required to be called
        after setSmoothing in Maya3.0 and later versions.

        Returns:
        -----
        None

        Parameters:
        -----
        smooth: bool
        	[in] -> if true the edge will be smooth (soft), otherwise the edge will be hard.


        '''
        pass

    @overload
    def index(self, index: int,
                        ReturnStatus: MItMeshEdge.MStatus): 
        '''
        index(self, index: int,
                        ReturnStatus: MItMeshEdge.MStatus) -> int

        Synopsis
        -----
        This method returns a vertex index for the current edge based
        upon the specified index. The index can be either 0 or 1 since an
        edge is made up of exactly two vertices.

        Returns: 
        ----- 
        The index in the vertex list of the edge vertex requested

        Parameters:
        -----
        index: int
        	[in] -> The vertex index in current edge (0 or 1) 

        ReturnStatus: MItMeshEdge.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def index(self, ReturnStatus: MItMeshEdge.MStatus): 
        '''
        index(self, ReturnStatus: MItMeshEdge.MStatus) -> int

        Synopsis
        -----
        This method returns the index of the current edge in the
        iteration.

        Returns: 
        ----- 
        The index of the current edge in the iteration

        Parameters:
        -----
        ReturnStatus: MItMeshEdge.MStatus
        	[out] -> Status code


        '''
        pass

    def currentItem(self, ReturnStatus: MItMeshEdge.MStatus): 
        '''
        currentItem(self, ReturnStatus: MItMeshEdge.MStatus) -> MObject

        Synopsis
        -----
        Get the current edge in the iteration as a component. Components
        are used to specify one or more edges and are usefull in
        operating on groups of non-contiguous edges for a surface.
        Components do not contain any information about the surface that
        they refer to so an MDagPath must be specified when dealing with
        components.

        Returns: 
        ----- 
        The current edge in the interation

        Parameters:
        -----
        ReturnStatus: MItMeshEdge.MStatus
        	[out] -> Status code


        '''
        pass

    def updateSurface(self): 
        '''
        updateSurface(self)

        Synopsis
        -----
        Signal that this polygonal surface has changed and needs to
        redraw itself.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def geomChanged(self): 
        '''
        geomChanged(self)

        Synopsis
        -----
        Reset the geom pointer in the MItMeshEdge. If you're using
        MFnMesh to update Normals or Color per vertex while iterating,
        you must call geomChanged on the iterator immediately after the
        MFnMesh call to make sure that your geometry is up to date. A
        crash may result if this method is not called.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setIndex(self, index: int,
                        prevIndex: int): 
        '''
        setIndex(self, index: int,
                        prevIndex: int)

        Synopsis
        -----
        This method sets the index of the current edge to be accessed.
        The current edge will no longer be in sync with any previous
        iteration.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of desired edge to access. 

        prevIndex: int
        	[out] -> Index of the edge which was current before the change.


        '''
        pass

    def getConnectedFaces(self, faces: MIntArray,
                        ReturnStatus: MItMeshEdge.MStatus): 
        '''
        getConnectedFaces(self, faces: MIntArray,
                        ReturnStatus: MItMeshEdge.MStatus) -> int

        Synopsis
        -----
        This method returns an array containing the indices of the faces
        connected to the current edge. Normally a boundary edge will only
        have one face connected to it and an internal edge will have two,
        but if the mesh has manifold geometry then the edge may have
        three or more faces connected to it.

        Returns: 
        ----- 
        Number of connected faces

        Parameters:
        -----
        faces: MIntArray
        	[out] -> Array of face indices. 

        ReturnStatus: MItMeshEdge.MStatus
        	[out] -> Status code


        '''
        pass

    def getConnectedEdges(self, edges: MIntArray,
                        ReturnStatus: MItMeshEdge.MStatus): 
        '''
        getConnectedEdges(self, edges: MIntArray,
                        ReturnStatus: MItMeshEdge.MStatus) -> int

        Synopsis
        -----
        This method returns a list of edges connected to the current
        edge.

        Returns: 
        ----- 
        Number of connected edges

        Parameters:
        -----
        edges: MIntArray
        	[out] -> Array of edge indices. 

        ReturnStatus: MItMeshEdge.MStatus
        	[out] -> Status code


        '''
        pass

    def numConnectedFaces(self, faceCount: int): 
        '''
        numConnectedFaces(self, faceCount: int)

        Synopsis
        -----
        This method returns the number of faces (1 or 2 ) connected to
        the current edge.

        Returns:
        -----
        None

        Parameters:
        -----
        faceCount: int
        	[out] -> Number of connected faces


        '''
        pass

    def numConnectedEdges(self, edgeCount: int): 
        '''
        numConnectedEdges(self, edgeCount: int)

        Synopsis
        -----
        This method returns the number of edges connected to the current
        edge.

        Returns:
        -----
        None

        Parameters:
        -----
        edgeCount: int
        	[out] -> Number of connected edges.


        '''
        pass

    def connectedToFace(self, index: int,
                        ReturnStatus: MItMeshEdge.MStatus): 
        '''
        connectedToFace(self, index: int,
                        ReturnStatus: MItMeshEdge.MStatus) -> bool

        Synopsis
        -----
        This method determines whether the given face contains the
        current edge.

        Returns: 
        ----- 
        Boolean value: true if contained, false otherwise.

        Parameters:
        -----
        index: int
        	[in] -> Index of face to check. 

        ReturnStatus: MItMeshEdge.MStatus
        	[out] -> Status code


        '''
        pass

    def connectedToEdge(self, index: int,
                        ReturnStatus: MItMeshEdge.MStatus): 
        '''
        connectedToEdge(self, index: int,
                        ReturnStatus: MItMeshEdge.MStatus) -> bool

        Synopsis
        -----
        This method determines whether the given edge is connected to the
        current edge.

        Returns: 
        ----- 
        Boolean value: true if contained, false otherwise.

        Parameters:
        -----
        index: int
        	[in] -> Index of edge to check. 

        ReturnStatus: MItMeshEdge.MStatus
        	[in] -> Status code


        '''
        pass

    def onBoundary(self, ReturnStatus: MItMeshEdge.MStatus): 
        '''
        onBoundary(self, ReturnStatus: MItMeshEdge.MStatus) -> bool

        Synopsis
        -----
        This method checks to see if the current edge is a border edge.
        NOTE: it is possible to turn all edges into boundaries by
        extracting faces. In this case, onBoundary() will always return
        true even though it appears that there are internal edges.

        Returns: 
        ----- 
        Boolean value: true if it's a border edge, false otherwise.

        Parameters:
        -----
        ReturnStatus: MItMeshEdge.MStatus
        	[out] -> Status code


        '''
        pass

    def getLength(self, length: double,
                        space: MSpace.MSpace): 
        '''
        getLength(self, length: double,
                        space: MSpace.MSpace)

        Synopsis
        -----
        This method returns the length of the current edge.

        Returns:
        -----
        None

        Parameters:
        -----
        length: double
        	[out] -> length of edge 

        space: MSpace.MSpace
        	[in] -> Coordinate space in which to perform the operation.


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MItMeshFaceVertex:
    '''Face vertex iterator.
This class is the iterator for face vertices on polygonal
surfaces.
The iterator functions in two modes depending on whether a
component is specified. When a component is not given or is NULL
the iteration will be over all polygons for the surface. When a
component is given this iterator will iterate over the polygons
specified in the component. When iterating over components a DAG
path to the surface must also be supplied.
'''
    def __init__(self):
        pass


    def isDone(self, ReturnStatus: MItMeshFaceVertex.MStatus): 
        '''
        isDone(self, ReturnStatus: MItMeshFaceVertex.MStatus) -> bool

        Synopsis
        -----
        Indicates if all of the face vertices have been traversed.

        Returns: 
        ----- 
        Boolean value: true All face vertices have been traversed, false
        otherwise.

        Parameters:
        -----
        ReturnStatus: MItMeshFaceVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def next(self): 
        '''
        next(self)

        Synopsis
        -----
        Advance to the next face vertext in the iteration.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def reset(self): 
        '''
        reset(self)

        Synopsis
        -----
        Reset the iterator to the first face vertex.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def reset(self, polyObject: MObject): 
        '''
        reset(self, polyObject: MObject)

        Synopsis
        -----
        Reset the iterator to the first polygon in the supplied surface.

        Returns:
        -----
        None

        Parameters:
        -----
        polyObject: MObject
        	[in] -> The polygonal object for the iteration


        '''
        pass

    @overload
    def reset(self, polyObject: MDagPath,
                        component: MObject): 
        '''
        reset(self, polyObject: MDagPath,
                        component: MObject)

        Synopsis
        -----
        Reset the iterator with the given surface and component. If
        component is null then the iteration will be for all face
        vertices in the given surface.

        Returns:
        -----
        None

        Parameters:
        -----
        polyObject: MDagPath
        	[in] -> The surface to iterate over 

        component: MObject
        	[in] -> The polygons of the polyObject to iterate over


        '''
        pass

    def vertId(self, ReturnStatus: MItMeshFaceVertex.MStatus): 
        '''
        vertId(self, ReturnStatus: MItMeshFaceVertex.MStatus) -> int

        Synopsis
        -----
        Returns the index of the current face vertex.

        Returns: 
        ----- 
        The index of the current face vertex.

        Parameters:
        -----
        ReturnStatus: MItMeshFaceVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def faceId(self, ReturnStatus: MItMeshFaceVertex.MStatus): 
        '''
        faceId(self, ReturnStatus: MItMeshFaceVertex.MStatus) -> int

        Synopsis
        -----
        Returns the current face index.

        Returns: 
        ----- 
        The index of the current face.

        Parameters:
        -----
        ReturnStatus: MItMeshFaceVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def faceVertId(self, ReturnStatus: MItMeshFaceVertex.MStatus): 
        '''
        faceVertId(self, ReturnStatus: MItMeshFaceVertex.MStatus) -> int

        Synopsis
        -----
        Returns the relative index of the vertex within the current face.
        This index together with the faceId can be used for a fast access
        to get various info stored per vertex (normals, uvs, colors).

        Returns: 
        ----- 
        The relative index of the current vertex.

        Parameters:
        -----
        ReturnStatus: MItMeshFaceVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def currentItem(self, ReturnStatus: MItMeshFaceVertex.MStatus): 
        '''
        currentItem(self, ReturnStatus: MItMeshFaceVertex.MStatus) -> MObject

        Synopsis
        -----
        Returns the double componet index of the vertex and face.

        Returns: 
        ----- 
        An MObject containing the double index.

        Parameters:
        -----
        ReturnStatus: MItMeshFaceVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def position(self, space: MSpace.MSpace,
                        ReturnStatus: MItMeshFaceVertex.MStatus): 
        '''
        position(self, space: MSpace.MSpace,
                        ReturnStatus: MItMeshFaceVertex.MStatus) -> MPoint

        Synopsis
        -----
        Return the position of the current face vertex.

        Returns: 
        ----- 
        The vertex position

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> The coordinate system for this operation 

        ReturnStatus: MItMeshFaceVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def getNormal(self, normal: MVector,
                        space: MSpace.MSpace): 
        '''
        getNormal(self, normal: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Return the face vertex normal.

        Returns:
        -----
        None

        Parameters:
        -----
        normal: MVector
        	[out] -> Storage for the normal 

        space: MSpace.MSpace
        	[in] -> The transformation space


        '''
        pass

    def normalId(self, ReturnStatus: MItMeshFaceVertex.MStatus): 
        '''
        normalId(self, ReturnStatus: MItMeshFaceVertex.MStatus) -> int

        Synopsis
        -----
        Returns the normal index for the specified vertex. This index
        refers to an element in the normal array returned by
        MFnMesh::getNormals. These normals are per-polygon per-vertex
        normals. See the MFnMesh description for more information on
        normals.

        Returns: 
        ----- 
        The index of the normal for the current vertex

        Parameters:
        -----
        ReturnStatus: MItMeshFaceVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def tangentId(self, ReturnStatus: MItMeshFaceVertex.MStatus): 
        '''
        tangentId(self, ReturnStatus: MItMeshFaceVertex.MStatus) -> int

        Synopsis
        -----
        Returns the tangent (or binormal) index for the specified vertex.
        This index refers to an element in the normal array returned by
        MFnMesh::getTangents(). These tangent or binormals are per-
        polygon per-vertex. See the MFnMesh description for more
        information on tangents and binormals.

        Returns: 
        ----- 
        The index of the tangent for the current vertex

        Parameters:
        -----
        ReturnStatus: MItMeshFaceVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def getTangent(self, space: MSpace.MSpace,
                        uvSet: MString,
                        ReturnStatus: MItMeshFaceVertex.MStatus): 
        '''
        getTangent(self, space: MSpace.MSpace,
                        uvSet: MString,
                        ReturnStatus: MItMeshFaceVertex.MStatus) -> MVector

        Synopsis
        -----
        Return the face vertex tangent associated with the given UV set.
        The tangent is defined as the surface tangent of the polygon
        running in the U direction.

        Returns: 
        ----- 
        The normalized tangent vector. A null vector will be returned if
        the tangent can't be found.

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> The transformation space. 

        uvSet: MString
        	[in] -> The name of the uv set. 

        ReturnStatus: MItMeshFaceVertex.MStatus
        	[out] -> 


        '''
        pass

    def getBinormal(self, space: MSpace.MSpace,
                        uvSet: MString,
                        ReturnStatus: MItMeshFaceVertex.MStatus): 
        '''
        getBinormal(self, space: MSpace.MSpace,
                        uvSet: MString,
                        ReturnStatus: MItMeshFaceVertex.MStatus) -> MVector

        Synopsis
        -----
        Return the face vertex binormal associated with the UV set.

        Returns: 
        ----- 
        The normalized binormal vector. A null vector will be returned if
        the tangent can't be found.

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> The transformation space 

        uvSet: MString
        	[in] -> The name of the associated UV set. 

        ReturnStatus: MItMeshFaceVertex.MStatus
        	[out] -> 


        '''
        pass

    @overload
    def hasUVs(self, ReturnStatus: MItMeshFaceVertex.MStatus): 
        '''
        hasUVs(self, ReturnStatus: MItMeshFaceVertex.MStatus) -> bool

        Synopsis
        -----
        Does this face vertex has UV's mapped or not.

        Returns: 
        ----- 
        Boolean value: true if the face vertex has UV's mapped, false
        otherwise.

        Parameters:
        -----
        ReturnStatus: MItMeshFaceVertex.MStatus
        	[in] -> Status Code


        '''
        pass

    @overload
    def hasUVs(self, uvSet: MString,
                        ReturnStatus: MItMeshFaceVertex.MStatus): 
        '''
        hasUVs(self, uvSet: MString,
                        ReturnStatus: MItMeshFaceVertex.MStatus) -> bool

        Synopsis
        -----
        Does this face vertex has UV's mapped or not in a given uv set.

        Returns: 
        ----- 
        Boolean value: true if the face vertex has UV's mapped, false
        otherwise.

        Parameters:
        -----
        uvSet: MString
        	[in] -> UV set to work with 

        ReturnStatus: MItMeshFaceVertex.MStatus
        	[in] -> Status Code


        '''
        pass

    def getUV(self, uvPoint: float2,
                        uvSet: MString): 
        '''
        getUV(self, uvPoint: float2,
                        uvSet: MString)

        Synopsis
        -----
        Return the texture coordinate for the current face vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        uvPoint: float2
        	[out] -> Storage for u and v values 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    @overload
    def getUVIndex(self, index: int,
                        uvSet: MString): 
        '''
        getUVIndex(self, index: int,
                        uvSet: MString)

        Synopsis
        -----
        Returns the index of the texture coordinate for the current face
        vertex. This index refers to an element of the texture coordinate
        array for the polygonal object returned by MFnMesh::getUVs.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[out] -> Storage for the texture coordinate index of the current face vertex 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    @overload
    def getUVIndex(self, index: int,
                        u: float,
                        v: float,
                        uvSet: MString): 
        '''
        getUVIndex(self, index: int,
                        u: float,
                        v: float,
                        uvSet: MString)

        Synopsis
        -----
        Return the index of the texture coordinate for the current face
        vertex. This index refers to an element of the texture coordinate
        array for the polygonal object returned by MFnMesh::getUVs.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[out] -> Storage for the texture coordinate index of the specified vertex 

        u: float
        	[out] -> Storage for u value 

        v: float
        	[out] -> Storage for v value 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def hasColor(self, ReturnStatus: MItMeshFaceVertex.MStatus): 
        '''
        hasColor(self, ReturnStatus: MItMeshFaceVertex.MStatus) -> bool

        Synopsis
        -----
        This method determines whether the current face vertex has color-
        per-vertex set.

        Returns: 
        ----- 
        Boolean value: true if at least one vertex has color, false
        otherwise.

        Parameters:
        -----
        ReturnStatus: MItMeshFaceVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def getColor(self, color: MColor,
                        colorSetName: MString): 
        '''
        getColor(self, color: MColor,
                        colorSetName: MString)

        Synopsis
        -----
        Return a color of the current face vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        color: MColor
        	[out] -> Current face vertex color 

        colorSetName: MString
        	[in] -> Name of the color set.


        '''
        pass

    def getColorIndex(self, colorIndex: int,
                        colorSetName: MString): 
        '''
        getColorIndex(self, colorIndex: int,
                        colorSetName: MString)

        Synopsis
        -----
        Return a color index of the current face vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        colorIndex: int
        	[out] -> Storage for the color index 

        colorSetName: MString
        	[in] -> Name of the color set.


        '''
        pass

    def updateSurface(self): 
        '''
        updateSurface(self)

        Synopsis
        -----
        Signal that this polygonal surface has changed and needs to
        redraw itself.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def geomChanged(self): 
        '''
        geomChanged(self)

        Synopsis
        -----
        Reset the geom pointer in the MItMeshFaceVertex.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setIndex(self, faceIndex: int,
                        faceVertIndex: int,
                        prevFaceId: int,
                        prevVertId: int): 
        '''
        setIndex(self, faceIndex: int,
                        faceVertIndex: int,
                        prevFaceId: int,
                        prevVertId: int)

        Synopsis
        -----
        This method sets the index of the current face vertex to be
        accessed. The current face vertex will no longer be in sync with
        any previous iteration.

        Returns:
        -----
        None

        Parameters:
        -----
        faceIndex: int
        	[in] -> Index of desired face to access. 

        faceVertIndex: int
        	[in] -> Face-relative index of desired vertex to access. 

        prevFaceId: int
        	[out] -> Index of the face which was current before the change. 

        prevVertId: int
        	[out] -> Face-relative index of the vertex which was current before the change.


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MItMeshPolygon:
    '''Polygon iterator.
This class is the iterator for polygonal surfaces (meshes).
The iterator functions in two modes depending on whether a
component is specified. When a component is not given or is NULL
the iteration will be over all polygons for the surface. When a
component is given this iterator will iterate over the polygons
(faces) specified in the component. When iterating over
components a DAG path to the surface must also be supplied.
'''
    def __init__(self):
        pass


    def isDone(self, ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        isDone(self, ReturnStatus: MItMeshPolygon.MStatus) -> bool

        Synopsis
        -----
        Indicates if all of the polygons have been traversed yet.

        Returns: 
        ----- 
        Boolean value: true if all polygons have been traversed, false
        otherwise.

        Parameters:
        -----
        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def next(self): 
        '''
        next(self)

        Synopsis
        -----
        Advance to the next polygon in the iteration.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def reset(self): 
        '''
        reset(self)

        Synopsis
        -----
        Reset the iterator to the first polygon.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def reset(self, polyObject: MObject): 
        '''
        reset(self, polyObject: MObject)

        Synopsis
        -----
        Reset the iterator to the first polygon in the supplied surface.

        Returns:
        -----
        None

        Parameters:
        -----
        polyObject: MObject
        	[in] -> The polygon for the iteration


        '''
        pass

    @overload
    def reset(self, polyObject: MDagPath,
                        component: MObject): 
        '''
        reset(self, polyObject: MDagPath,
                        component: MObject)

        Synopsis
        -----
        Reset the iterator with the given surface and component. If
        component is null then the iteration will be for all polygons in
        the given surface. If component has invalid indices those will be
        automatically removed.

        Returns:
        -----
        None

        Parameters:
        -----
        polyObject: MDagPath
        	[in] -> The surface (mesh) to iterate over 

        component: MObject
        	[in] -> The polygons (faces) of the polyObject to iterate over


        '''
        pass

    def count(self, ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        count(self, ReturnStatus: MItMeshPolygon.MStatus) -> int

        Synopsis
        -----
        Return the number of polygons in the iteration.

        Returns: 
        ----- 
        The number of polygons in the iteration

        Parameters:
        -----
        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def polygonVertexCount(self, ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        polygonVertexCount(self, ReturnStatus: MItMeshPolygon.MStatus) -> int

        Synopsis
        -----
        Return the number of vertices for the current polygon.

        Returns: 
        ----- 
        The number of vertices for the current polygon

        Parameters:
        -----
        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def center(self, space: MSpace.MSpace,
                        ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        center(self, space: MSpace.MSpace,
                        ReturnStatus: MItMeshPolygon.MStatus) -> MPoint

        Synopsis
        -----
        Return the position of the center of the current polygon.

        Returns: 
        ----- 
        The center of the current polygon

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> The coordinate system for this operation 

        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def currentItem(self, ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        currentItem(self, ReturnStatus: MItMeshPolygon.MStatus) -> MObject

        Synopsis
        -----
        Get the current polygon in the iteration as a component.
        Components are used to specify one or more polygons and are
        useful in operating on groups of non-contiguous polygons for a
        surface. Components do not contain any information about the
        surface that they refer to so an MDagPath must be specified when
        dealing with components.

        Returns: 
        ----- 
        The current polygon in the iteration

        Parameters:
        -----
        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def index(self, ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        index(self, ReturnStatus: MItMeshPolygon.MStatus) -> int

        Synopsis
        -----
        Returns the index of the current polygon.

        Returns: 
        ----- 
        The index of the current polygon

        Parameters:
        -----
        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def setIndex(self, index: int,
                        prevIndex: int): 
        '''
        setIndex(self, index: int,
                        prevIndex: int)

        Synopsis
        -----
        This method sets the index of the current face to be accessed.
        The current face will no longer be in sync with any previous
        iteration.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of desired face to access. 

        prevIndex: int
        	[in] -> The index of the current face in the iteration


        '''
        pass

    def vertexIndex(self, index: int,
                        ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        vertexIndex(self, index: int,
                        ReturnStatus: MItMeshPolygon.MStatus) -> int

        Synopsis
        -----
        Returns the object-relative index of the specified vertex of the
        current polygon. The index returned may be used to refer to an
        element in the vertex list returned by MFnMesh::getPoints.

        Returns: 
        ----- 
        The index in the polygon array of the given vertex

        Parameters:
        -----
        index: int
        	[in] -> The face-relative index of the vertex in the polygon 

        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def getVertices(self, vertices: MIntArray): 
        '''
        getVertices(self, vertices: MIntArray)

        Synopsis
        -----
        This method gets the indices of the vertices of the current face.

        Returns:
        -----
        None

        Parameters:
        -----
        vertices: MIntArray
        	[out] -> An array to place all the vertex indices into


        '''
        pass

    def point(self, index: int,
                        space: MSpace.MSpace,
                        ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        point(self, index: int,
                        space: MSpace.MSpace,
                        ReturnStatus: MItMeshPolygon.MStatus) -> MPoint

        Synopsis
        -----
        Return the position of the vertex at index in the current
        polygon.

        Returns: 
        ----- 
        The vertex position

        Parameters:
        -----
        index: int
        	[in] -> The face-relative index of the vertex in the current polygon 

        space: MSpace.MSpace
        	[in] -> The coordinate system for this operation 

        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def getPoints(self, pointArray: MPointArray,
                        space: MSpace.MSpace,
                        ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        getPoints(self, pointArray: MPointArray,
                        space: MSpace.MSpace,
                        ReturnStatus: MItMeshPolygon.MStatus)

        Synopsis
        -----
        Retrieves the positions of the vertices on the current
        face/polygon that the iterator is pointing to. Vertex positions
        will be inserted into the given array and will be indexed using
        face-relative vertex IDs (ie. ordered from 0 to (vertexCount of
        the face) - 1), which should not be confused with the vertexIDs
        of each vertex in relation to the entire mesh object.

        Returns:
        -----
        None

        Parameters:
        -----
        pointArray: MPointArray
        	[out] -> The array where the vertex positions will be stored 

        space: MSpace.MSpace
        	[in] -> The coordinate system for this operation 

        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def setPoint(self, point: MPoint,
                        index: int,
                        space: MSpace.MSpace): 
        '''
        setPoint(self, point: MPoint,
                        index: int,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the vertex at the given index in the current polygon.

        Returns:
        -----
        None

        Parameters:
        -----
        point: MPoint
        	[in] -> The new position for the vertex 

        index: int
        	[in] -> The face-relative index of the vertex in the current polygon 

        space: MSpace.MSpace
        	[in] -> The coordinate system for this operation


        '''
        pass

    def setPoints(self, pointArray: MPointArray,
                        space: MSpace.MSpace): 
        '''
        setPoints(self, pointArray: MPointArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Sets new locations for vertices of the current polygon that the
        iterator is pointing to.

        Returns:
        -----
        None

        Parameters:
        -----
        pointArray: MPointArray
        	[in] -> The new positions for the vertices. 

        space: MSpace.MSpace
        	[in] -> The coordinate system for this operation.


        '''
        pass

    def normalIndex(self, localVertexIndex: int,
                        ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        normalIndex(self, localVertexIndex: int,
                        ReturnStatus: MItMeshPolygon.MStatus) -> int

        Synopsis
        -----
        Returns the normal index for the specified vertex. This index
        refers to an element in the normal array returned by
        MFnMesh::getNormals. These normals are per-polygon per-vertex
        normals. See the MFnMesh description for more information on
        normals.

        Returns: 
        ----- 
        The index of the normal for the specified vertex

        Parameters:
        -----
        localVertexIndex: int
        	[in] -> The face-relative index of the vertex to examine for the current polygon 

        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def getNormal(self, normal: MVector,
                        space: MSpace.MSpace): 
        '''
        getNormal(self, normal: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Return the face normal of the current polygon.

        Returns:
        -----
        None

        Parameters:
        -----
        normal: MVector
        	[out] -> Storage for the normal 

        space: MSpace.MSpace
        	[in] -> The transformation space


        '''
        pass

    @overload
    def getNormal(self, index: int,
                        normal: MVector,
                        space: MSpace.MSpace): 
        '''
        getNormal(self, index: int,
                        normal: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Returns the vertex-face normal for the vertex in the current
        polygon.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> face-relative vertex index of the vertex whose normal to retrieve 

        normal: MVector
        	[out] -> Storage for the normal 

        space: MSpace.MSpace
        	[in] -> The transformation space


        '''
        pass

    def getNormals(self, normalArray: MVectorArray,
                        space: MSpace.MSpace): 
        '''
        getNormals(self, normalArray: MVectorArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Returns the normals for all vertices in the current face.

        Returns:
        -----
        None

        Parameters:
        -----
        normalArray: MVectorArray
        	[out] -> Storage for the normals 

        space: MSpace.MSpace
        	[in] -> The transformation space


        '''
        pass

    def tangentIndex(self, localVertexIndex: int,
                        ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        tangentIndex(self, localVertexIndex: int,
                        ReturnStatus: MItMeshPolygon.MStatus) -> int

        Synopsis
        -----
        Returns the tangent (or binormal) index for the specified vertex.
        This index refers to an element in the normal array returned by
        MFnMesh::getTangents. These tangent or binormals are per-polygon
        per-vertex. See the MFnMesh description for more information on
        tangents and binormals.

        Returns: 
        ----- 
        The index of the tangent for the specified vertex

        Parameters:
        -----
        localVertexIndex: int
        	[in] -> The face-relative index of the vertex to examine for the current polygon 

        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def hasUVs(self, ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        hasUVs(self, ReturnStatus: MItMeshPolygon.MStatus) -> bool

        Synopsis
        -----
        Tests whether this face has UV's mapped or not (either all the
        vertices for a face should have UV's, or none of them do, so the
        UV count for a face is either 0, or equal to the number of
        vertices).

        Returns: 
        ----- 
        Boolean value: true if the face has UV's mapped, false otherwise

        Parameters:
        -----
        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def hasUVs(self, uvSet: MString,
                        ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        hasUVs(self, uvSet: MString,
                        ReturnStatus: MItMeshPolygon.MStatus) -> bool

        Synopsis
        -----
        Tests whether this face has UV's mapped or not (either all the
        vertices for a face should have UV's, or none of them do, so the
        UV count for a face is either 0, or equal to the number of
        vertices).

        Returns: 
        ----- 
        Boolean value: true if the face has UV's mapped, false otherwise

        Parameters:
        -----
        uvSet: MString
        	[in] -> UV set to work with 

        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def setUV(self, vertexId: int,
                        uvPoint: float2,
                        uvSet: MString): 
        '''
        setUV(self, vertexId: int,
                        uvPoint: float2,
                        uvSet: MString)

        Synopsis
        -----
        Modify the UV value for the given vertex in the current face. If
        the face is not already mapped, this method will fail.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexId: int
        	[in] -> face-relative index of the vertex to set UV for. 

        uvPoint: float2
        	[in] -> The UV values to set it to 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def getUV(self, vertex: int,
                        uvPoint: float2,
                        uvSet: MString): 
        '''
        getUV(self, vertex: int,
                        uvPoint: float2,
                        uvSet: MString)

        Synopsis
        -----
        Return the texture coordinate for the given vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        vertex: int
        	[in] -> The face-relative vertex index to get UV for 

        uvPoint: float2
        	[out] -> Storage for u and v values 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def setUVs(self, uArray: MFloatArray,
                        vArray: MFloatArray,
                        uvSet: MString): 
        '''
        setUVs(self, uArray: MFloatArray,
                        vArray: MFloatArray,
                        uvSet: MString)

        Synopsis
        -----
        Modify the UV value for all vertices in the current face. If the
        face has not already been mapped, this method will fail.

        Returns:
        -----
        None

        Parameters:
        -----
        uArray: MFloatArray
        	[in] -> All the U values - in local face order 

        vArray: MFloatArray
        	[in] -> The corresponding V values 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def getUVs(self, uArray: MFloatArray,
                        vArray: MFloatArray,
                        uvSet: MString): 
        '''
        getUVs(self, uArray: MFloatArray,
                        vArray: MFloatArray,
                        uvSet: MString)

        Synopsis
        -----
        Return the all the texture coordinates for the vertices of this
        face (in local vertex order).

        Returns:
        -----
        None

        Parameters:
        -----
        uArray: MFloatArray
        	[out] -> Storage for u values 

        vArray: MFloatArray
        	[out] -> Storage for v values 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def getPointAtUV(self, pt: MPoint,
                        uvPoint: float2,
                        space: MSpace.MSpace,
                        uvSet: MString,
                        tolerance: float): 
        '''
        getPointAtUV(self, pt: MPoint,
                        uvPoint: float2,
                        space: MSpace.MSpace,
                        uvSet: MString,
                        tolerance: float)

        Synopsis
        -----
        Return the position of the point at the given UV value in the
        current polygon.

        Returns:
        -----
        None

        Parameters:
        -----
        pt: MPoint
        	[out] -> Space for the point 

        uvPoint: float2
        	[in] -> The UV value to try to locate 

        space: MSpace.MSpace
        	[in] -> The coordinate system for this operation 

        uvSet: MString
        	[in] -> UV set to work with 

        tolerance: float
        	[in] -> tolerance value to compare float data type


        '''
        pass

    def getAxisAtUV(self, normal: MVector,
                        uTangent: MVector,
                        vTangent: MVector,
                        uvPoint: float2,
                        space: MSpace.MSpace,
                        uvSet: MString,
                        tolerance: float): 
        '''
        getAxisAtUV(self, normal: MVector,
                        uTangent: MVector,
                        vTangent: MVector,
                        uvPoint: float2,
                        space: MSpace.MSpace,
                        uvSet: MString,
                        tolerance: float)

        Synopsis
        -----
        Return the axis of the point at the given UV value in the current
        polygon. The axis or affine space is defined by non-normalized
        and non-orthogonized U tangent, V tangent and normal. It's useful
        to detect local surface deformation for meshes with similar UV
        mapping.

        Returns:
        -----
        None

        Parameters:
        -----
        normal: MVector
        	[out] -> normal for the point 

        uTangent: MVector
        	[out] -> u tangent for the point 

        vTangent: MVector
        	[out] -> v tangent for the point 

        uvPoint: float2
        	[in] -> The UV value to try to locate 

        space: MSpace.MSpace
        	[in] -> The coordinate system for this operation 

        uvSet: MString
        	[in] -> UV set to work with 

        tolerance: float
        	[in] -> tolerance value to compare float data type


        '''
        pass

    def getUVAtPoint(self, pt: MPoint,
                        uvPoint: float2,
                        space: MSpace.MSpace,
                        uvSet: MString): 
        '''
        getUVAtPoint(self, pt: MPoint,
                        uvPoint: float2,
                        space: MSpace.MSpace,
                        uvSet: MString)

        Synopsis
        -----
        Find the point closest to the given point in the current polygon,
        and return the UV value at that point.

        Returns:
        -----
        None

        Parameters:
        -----
        pt: MPoint
        	[in] -> The point to try to get UV for 

        uvPoint: float2
        	[out] -> Storage for the UV value 

        space: MSpace.MSpace
        	[in] -> The coordinate system for this operation 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    @overload
    def getUVIndex(self, vertex: int,
                        index: int,
                        uvSet: MString): 
        '''
        getUVIndex(self, vertex: int,
                        index: int,
                        uvSet: MString)

        Synopsis
        -----
        Returns the index of the texture coordinate for the given vertex.
        This index refers to an element of the texture coordinate array
        for the polygonal object returned by MFnMesh::getUVs.

        Returns:
        -----
        None

        Parameters:
        -----
        vertex: int
        	[in] -> The face-relative vertex index of the current polygon 

        index: int
        	[out] -> Storage for the texture coordinate index of the specified vertex 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    @overload
    def getUVIndex(self, vertex: int,
                        index: int,
                        u: float,
                        v: float,
                        uvSet: MString): 
        '''
        getUVIndex(self, vertex: int,
                        index: int,
                        u: float,
                        v: float,
                        uvSet: MString)

        Synopsis
        -----
        Return the index of the texture coordinate for the given vertex.
        This index refers to an element of the texture coordinate array
        for the polygonal object returned by MFnMesh::getUVs.

        Returns:
        -----
        None

        Parameters:
        -----
        vertex: int
        	[in] -> The face-relative vertex index of the current polygon 

        index: int
        	[out] -> Storage for the texture coordinate index of the specified vertex 

        u: float
        	[out] -> Storage for u value 

        v: float
        	[out] -> Storage for v value 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    def getUVSetNames(self, setNames: MStringArray): 
        '''
        getUVSetNames(self, setNames: MStringArray)

        Synopsis
        -----
        This method is used to find the UV set names mapped to the
        current face.

        Returns:
        -----
        None

        Parameters:
        -----
        setNames: MStringArray
        	[out] -> The string array to return the UV sets names in


        '''
        pass

    @overload
    def hasColor(self, ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        hasColor(self, ReturnStatus: MItMeshPolygon.MStatus) -> bool

        Synopsis
        -----
        This method determines whether the current face has color-per-
        vertex set for any vertex.

        Returns: 
        ----- 
        Boolean value: true if at least one vertex has color, false
        otherwise.

        Parameters:
        -----
        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def hasColor(self, vertexIndex: int,
                        ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        hasColor(self, vertexIndex: int,
                        ReturnStatus: MItMeshPolygon.MStatus) -> bool

        Synopsis
        -----
        This method determines whether the current face has color-per-
        vertex set for the given vertex.

        Returns: 
        ----- 
        Boolean value: true if the given vertex has color, false
        otherwise.

        Parameters:
        -----
        vertexIndex: int
        	[in] -> face-relative vertex index to check for color on 

        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def getColor(self, color: MColor,
                        colorSetName: MString): 
        '''
        getColor(self, color: MColor,
                        colorSetName: MString)

        Synopsis
        -----
        This method gets the average color of the all the vertices in
        this face.

        Returns:
        -----
        None

        Parameters:
        -----
        color: MColor
        	[out] -> The average color 

        colorSetName: MString
        	[in] -> Name of the color set.


        '''
        pass

    @overload
    def getColor(self, color: MColor,
                        index: int): 
        '''
        getColor(self, color: MColor,
                        index: int)

        Synopsis
        -----
        This method gets the color of the specified vertex in this face.

        Returns:
        -----
        None

        Parameters:
        -----
        color: MColor
        	[out] -> The color to get 

        index: int
        	[in] -> The face-relative vertex index on this face


        '''
        pass

    def getColors(self, colors: MColorArray,
                        colorSetName: MString): 
        '''
        getColors(self, colors: MColorArray,
                        colorSetName: MString)

        Synopsis
        -----
        This method gets the color of the each vertex in the current
        face.

        Returns:
        -----
        None

        Parameters:
        -----
        colors: MColorArray
        	[out] -> Storage for the colors of the vertice in this face 

        colorSetName: MString
        	[in] -> Name of the color set.


        '''
        pass

    def numColors(self, colorCount: int,
                        colorSetName: MString): 
        '''
        numColors(self, colorCount: int,
                        colorSetName: MString)

        Synopsis
        -----
        This method checks for the number of colors on vertices in this
        face.

        Returns:
        -----
        None

        Parameters:
        -----
        colorCount: int
        	[out] -> Storage for the color count 

        colorSetName: MString
        	[in] -> Name of the color set.


        '''
        pass

    def getColorIndex(self, vertexIndex: int,
                        colorIndex: int,
                        colorSetName: MString): 
        '''
        getColorIndex(self, vertexIndex: int,
                        colorIndex: int,
                        colorSetName: MString)

        Synopsis
        -----
        This method returns the colorIndex for a vertex of the current
        face.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexIndex: int
        	[in] -> Face-relative index of vertex. 

        colorIndex: int
        	[out] -> Color index filled in this function. 

        colorSetName: MString
        	[in] -> Name of the color set.


        '''
        pass

    def getColorIndices(self, colorIndices: MIntArray,
                        colorSetName: MString): 
        '''
        getColorIndices(self, colorIndices: MIntArray,
                        colorSetName: MString)

        Synopsis
        -----
        This method returns the colorIndices for each vertex on the face.

        Returns:
        -----
        None

        Parameters:
        -----
        colorIndices: MIntArray
        	[out] -> Color index filled in this function. 

        colorSetName: MString
        	[in] -> Name of the color set.


        '''
        pass

    def hasValidTriangulation(self, ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        hasValidTriangulation(self, ReturnStatus: MItMeshPolygon.MStatus) -> bool

        Synopsis
        -----
        This method checks if the face has a valid triangulation. If it
        doesn't, then the face was bad geometry: it may gave degenerate
        points or cross over itself.

        Returns: 
        ----- 
        Boolean value: true the face has a valid triangulation false
        otherwise.

        Parameters:
        -----
        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def numTriangles(self, triCount: int): 
        '''
        numTriangles(self, triCount: int)

        Synopsis
        -----
        This Method checks for the number of triangles in this face in
        the current triangulation.

        Returns:
        -----
        None

        Parameters:
        -----
        triCount: int
        	[out] -> Storage for the triangle count


        '''
        pass

    def getTriangle(self, localTriIndex: int,
                        points: MPointArray,
                        vertexList: MIntArray,
                        space: MSpace.MSpace): 
        '''
        getTriangle(self, localTriIndex: int,
                        points: MPointArray,
                        vertexList: MIntArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Get the vertices and vertex positions of the given triangle in
        the current face's triangulation.

        Returns:
        -----
        None

        Parameters:
        -----
        localTriIndex: int
        	[in] -> Local index of the desired triangle in this face 

        points: MPointArray
        	[out] -> Storage for all the vertex points 

        vertexList: MIntArray
        	[out] -> Storage for all the vertex indices 

        space: MSpace.MSpace
        	[in] -> World Space or Object Space


        '''
        pass

    def getTriangles(self, points: MPointArray,
                        vertexList: MIntArray,
                        space: MSpace.MSpace): 
        '''
        getTriangles(self, points: MPointArray,
                        vertexList: MIntArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Get the vertices and vertex positions of all the triangles in the
        current face's triangulation.

        Returns:
        -----
        None

        Parameters:
        -----
        points: MPointArray
        	[out] -> Storage for all the vertex points 

        vertexList: MIntArray
        	[out] -> Storage for all the vertex indices 

        space: MSpace.MSpace
        	[in] -> World Space or Object Space


        '''
        pass

    def updateSurface(self): 
        '''
        updateSurface(self)

        Synopsis
        -----
        Signal that this polygonal surface has changed and needs to
        redraw itself.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def geomChanged(self): 
        '''
        geomChanged(self)

        Synopsis
        -----
        Reset the geom pointer in the MItMeshPolygon. This is now being
        handled automatically inside the iterator, and users should no
        longer need to call this method directly to sync up the iterator
        to changes made by MFnMesh

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getEdges(self, edges: MIntArray): 
        '''
        getEdges(self, edges: MIntArray)

        Synopsis
        -----
        This method gets the indices of the edges contained in the
        current face.

        Returns:
        -----
        None

        Parameters:
        -----
        edges: MIntArray
        	[out] -> An array to place all the edge indices into


        '''
        pass

    def getConnectedFaces(self, faces: MIntArray): 
        '''
        getConnectedFaces(self, faces: MIntArray)

        Synopsis
        -----
        This method gets the indices of the faces connected to the
        current face.

        Returns:
        -----
        None

        Parameters:
        -----
        faces: MIntArray
        	[out] -> An array to place all the face indices into


        '''
        pass

    def getConnectedEdges(self, edges: MIntArray): 
        '''
        getConnectedEdges(self, edges: MIntArray)

        Synopsis
        -----
        This method gets the indices of the edges connected to the
        vertices of the current face, but DOES not include the edges
        contained in the current face.

        Returns:
        -----
        None

        Parameters:
        -----
        edges: MIntArray
        	[out] -> An array to place all the edge indices into


        '''
        pass

    def getConnectedVertices(self, vertices: MIntArray): 
        '''
        getConnectedVertices(self, vertices: MIntArray)

        Synopsis
        -----
        This method gets the object-relative indices of the vertices
        surrounding the vertices of the current face, but does not
        include the vertices of the current face.

        Returns:
        -----
        None

        Parameters:
        -----
        vertices: MIntArray
        	[out] -> An array to stuff all the vertex indices into


        '''
        pass

    def isConnectedToFace(self, index: int,
                        ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        isConnectedToFace(self, index: int,
                        ReturnStatus: MItMeshPolygon.MStatus) -> bool

        Synopsis
        -----
        This method determines whether the given face is adjacent to the
        current face.

        Returns: 
        ----- 
        true if connected, false otherwise.

        Parameters:
        -----
        index: int
        	[in] -> Index of the face to be tested for 

        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def isConnectedToEdge(self, index: int,
                        ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        isConnectedToEdge(self, index: int,
                        ReturnStatus: MItMeshPolygon.MStatus) -> bool

        Synopsis
        -----
        This method determines whether the given edge is connected to a
        vertex in the current face.

        Returns: 
        ----- 
        Boolean value: true if connected, false otherwise.

        Parameters:
        -----
        index: int
        	[in] -> Index of the edge to be tested for 

        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def isConnectedToVertex(self, index: int,
                        ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        isConnectedToVertex(self, index: int,
                        ReturnStatus: MItMeshPolygon.MStatus) -> bool

        Synopsis
        -----
        This method determines whether the given vertex shares an edge
        with a vertex in the current face.

        Returns: 
        ----- 
        Boolean value: true if connected, false otherwise.

        Parameters:
        -----
        index: int
        	[in] -> Index of the vertex to be tested for 

        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def numConnectedFaces(self, faceCount: int): 
        '''
        numConnectedFaces(self, faceCount: int)

        Synopsis
        -----
        This method checks for the number of connected faces.

        Returns:
        -----
        None

        Parameters:
        -----
        faceCount: int
        	[out] -> Storage for the face count


        '''
        pass

    def numConnectedEdges(self, edgeCount: int): 
        '''
        numConnectedEdges(self, edgeCount: int)

        Synopsis
        -----
        This method checks for the number of connected edges on the
        vertices of this face.

        Returns:
        -----
        None

        Parameters:
        -----
        edgeCount: int
        	[out] -> Storage for the edge count


        '''
        pass

    def onBoundary(self, ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        onBoundary(self, ReturnStatus: MItMeshPolygon.MStatus) -> bool

        Synopsis
        -----
        This method determines whether the current face is on a boundary.

        Returns: 
        ----- 
        Boolean value: true if on a boundary, false otherwise.

        Parameters:
        -----
        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def getArea(self, area: double,
                        space: MSpace.MSpace): 
        '''
        getArea(self, area: double,
                        space: MSpace.MSpace)

        Synopsis
        -----
        This method gets the area of the face.

        Returns:
        -----
        None

        Parameters:
        -----
        area: double
        	[out] -> The area 

        space: MSpace.MSpace
        	[in] -> World Space or Object Space


        '''
        pass

    def zeroArea(self, ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        zeroArea(self, ReturnStatus: MItMeshPolygon.MStatus) -> bool

        Synopsis
        -----
        This method checks if its a zero area face.

        Returns: 
        ----- 
        Boolean value: true if the face has zero area, false otherwise.

        Parameters:
        -----
        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def getUVArea(self, area: double,
                        uvSet: MString): 
        '''
        getUVArea(self, area: double,
                        uvSet: MString)

        Synopsis
        -----
        This method gets the UV area of the face.

        Returns:
        -----
        None

        Parameters:
        -----
        area: double
        	[out] -> The uv area 

        uvSet: MString
        	[in] -> UV set to work with


        '''
        pass

    @overload
    def zeroUVArea(self, ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        zeroUVArea(self, ReturnStatus: MItMeshPolygon.MStatus) -> bool

        Synopsis
        -----
        This method checks if the UV area of the face is zero.

        Returns: 
        ----- 
        Boolean value: true if the face has zero UV area, false
        otherwise.

        Parameters:
        -----
        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def zeroUVArea(self, uvSet: MString,
                        ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        zeroUVArea(self, uvSet: MString,
                        ReturnStatus: MItMeshPolygon.MStatus) -> bool

        Synopsis
        -----
        This method checks if the UV area of the face is zero.

        Returns: 
        ----- 
        true if the face has zero UV area  false otherwise.

        Parameters:
        -----
        uvSet: MString
        	[in] -> UV set to work with 

        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def isConvex(self, ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        isConvex(self, ReturnStatus: MItMeshPolygon.MStatus) -> bool

        Synopsis
        -----
        This method checks if the face is convex.

        Returns: 
        ----- 
        Boolean value: true if the face is convex, false otherwise.

        Parameters:
        -----
        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def isStarlike(self, ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        isStarlike(self, ReturnStatus: MItMeshPolygon.MStatus) -> bool

        Synopsis
        -----
        This method checks if the face is starlike. That is, a line from
        the centre to any vertex lies entirely within the face.

        Returns: 
        ----- 
        Boolean value: true if the face is starlike, false otherwise.

        Parameters:
        -----
        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def isLamina(self, ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        isLamina(self, ReturnStatus: MItMeshPolygon.MStatus) -> bool

        Synopsis
        -----
        This method checks if the face is a lamina (the face is folded
        over onto itself).

        Returns: 
        ----- 
        Boolean value: true if the face is a lamina, false otherwise.

        Parameters:
        -----
        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def isHoled(self, ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        isHoled(self, ReturnStatus: MItMeshPolygon.MStatus) -> bool

        Synopsis
        -----
        This method checks if the face has any holes.

        Returns: 
        ----- 
        Boolean value: true the face has one or more holes, false
        otherwise.

        Parameters:
        -----
        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def isPlanar(self, ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        isPlanar(self, ReturnStatus: MItMeshPolygon.MStatus) -> bool

        Synopsis
        -----
        This method checks if the face is planar.

        Returns: 
        ----- 
        Boolean value: true the face is planar, false otherwise.

        Parameters:
        -----
        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def isUVReversed(self, uvSet: MString,
                        ReturnStatus: MItMeshPolygon.MStatus): 
        '''
        isUVReversed(self, uvSet: MString,
                        ReturnStatus: MItMeshPolygon.MStatus) -> bool

        Synopsis
        -----
        This method checks if the winding order of UV's for this face are
        reversed (clockwise), or not (counter clockwise)

        Returns: 
        ----- 
        Boolean value: true if the UV's are reversed (clockwise) false if
        the UV's are not reversed (counter clockwise).

        Parameters:
        -----
        uvSet: MString
        	[in] -> UV set to work with 

        ReturnStatus: MItMeshPolygon.MStatus
        	[out] -> Status code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MItMeshVertex:
    '''Polygon vertex iterator.
This class is the iterator for polygonal vertices.
The iterator functions in two modes depending on whether a
component is specified. When a component is not given or is NULL
the iteration will be over all vertices for the polygon. When a
component is given this iterator will iterate over the vertices
specified in the component. When iterating over components a DAG
path to the surface must also be supplied.
'''
    def __init__(self):
        pass


    def isDone(self, ReturnStatus: MItMeshVertex.MStatus): 
        '''
        isDone(self, ReturnStatus: MItMeshVertex.MStatus) -> bool

        Synopsis
        -----
        Indicates if all of the vertices have been traversed yet.

        Returns: 
        ----- 
        Boolean value: true if all vertices have been traversed, false
        otherwise.

        Parameters:
        -----
        ReturnStatus: MItMeshVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def next(self): 
        '''
        next(self)

        Synopsis
        -----
        Advance to the next vertex in the iteration.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def reset(self): 
        '''
        reset(self)

        Synopsis
        -----
        Reset the iterator to the first vertex.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def reset(self, polyObject: MObject): 
        '''
        reset(self, polyObject: MObject)

        Synopsis
        -----
        Reset the iterator to the first vertex in the supplied polygon.

        Returns:
        -----
        None

        Parameters:
        -----
        polyObject: MObject
        	[in] -> The polygon for the iteration


        '''
        pass

    @overload
    def reset(self, polyObject: MDagPath,
                        component: MObject): 
        '''
        reset(self, polyObject: MDagPath,
                        component: MObject)

        Synopsis
        -----
        Reset the iterator with the given polygon and component. If
        component is null then the iteration will be for all vertices in
        the given polygon. If component has invalid indices those will be
        automatically removed.

        Returns:
        -----
        None

        Parameters:
        -----
        polyObject: MDagPath
        	[in] -> The surface to iterate over 

        component: MObject
        	[in] -> The vertices of the polyObject to iterate over


        '''
        pass

    def count(self, ReturnStatus: MItMeshVertex.MStatus): 
        '''
        count(self, ReturnStatus: MItMeshVertex.MStatus) -> int

        Synopsis
        -----
        Return the number of vertices in the iteration.

        Returns: 
        ----- 
        The number of vertices in the iteration

        Parameters:
        -----
        ReturnStatus: MItMeshVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def index(self, ReturnStatus: MItMeshVertex.MStatus): 
        '''
        index(self, ReturnStatus: MItMeshVertex.MStatus) -> int

        Synopsis
        -----
        Returns the index of the current vertex in the vertex list for
        this polygonal object. Polygonal objects contain a list of
        vertices. Faces and edges are specified as indicies from this
        list, in this way vertices can be shared amoung faces and edges.

        Returns: 
        ----- 
        The index in the vertex list for the current vertex

        Parameters:
        -----
        ReturnStatus: MItMeshVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def currentItem(self, ReturnStatus: MItMeshVertex.MStatus): 
        '''
        currentItem(self, ReturnStatus: MItMeshVertex.MStatus) -> MObject

        Synopsis
        -----
        Get the current vertex in the iteration as a component.
        Components are used to specify one or more vertices and are
        usefull in operating on groups of non-contiguous vertices for a
        surface. Components do not contain any information about the
        surface that they refer to so an MDagPath must be specified when
        dealing with components.

        Returns: 
        ----- 
        The current vertex in the interation

        Parameters:
        -----
        ReturnStatus: MItMeshVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def position(self, space: MSpace.MSpace,
                        ReturnStatus: MItMeshVertex.MStatus): 
        '''
        position(self, space: MSpace.MSpace,
                        ReturnStatus: MItMeshVertex.MStatus) -> MPoint

        Synopsis
        -----
        Return the position of the current vertex in the specified space.
        Object space ignores all transformations for the polygon, world
        space includes all such transformations.

        Returns: 
        ----- 
        The position of the vertex in the specified space

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> The transformation space 

        ReturnStatus: MItMeshVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def setPosition(self, point: MPoint,
                        space: MSpace.MSpace): 
        '''
        setPosition(self, point: MPoint,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the position of the current vertex in the given space.

        Returns:
        -----
        None

        Parameters:
        -----
        point: MPoint
        	[in] -> The new position for the current vertex 

        space: MSpace.MSpace
        	[in] -> Transformation space


        '''
        pass

    def translateBy(self, vector: MVector,
                        space: MSpace.MSpace): 
        '''
        translateBy(self, vector: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Translate the current vertex by the amount specified by the given
        vector.

        Returns:
        -----
        None

        Parameters:
        -----
        vector: MVector
        	[in] -> The amount of translation 

        space: MSpace.MSpace
        	[in] -> The transformation space


        '''
        pass

    @overload
    def getNormal(self, vector: MVector,
                        space: MSpace.MSpace): 
        '''
        getNormal(self, vector: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Return the normal or averaged normal if unshared of the current
        vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        vector: MVector
        	[out] -> The normal. 

        space: MSpace.MSpace
        	[in] -> The transformation space.


        '''
        pass

    @overload
    def getNormal(self, vector: MVector,
                        faceIndex: int,
                        space: MSpace.MSpace): 
        '''
        getNormal(self, vector: MVector,
                        faceIndex: int,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Return the normal of the current vertex in the specified face.

        Returns:
        -----
        None

        Parameters:
        -----
        vector: MVector
        	[out] -> The normal. 

        faceIndex: int
        	[in] -> face index to get normal for 

        space: MSpace.MSpace
        	[in] -> The transformation space


        '''
        pass

    def getNormals(self, normalArray: MVectorArray,
                        space: MSpace.MSpace): 
        '''
        getNormals(self, normalArray: MVectorArray,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Return the normals of the current vertex for all faces.

        Returns:
        -----
        None

        Parameters:
        -----
        normalArray: MVectorArray
        	[out] -> The normals. 

        space: MSpace.MSpace
        	[in] -> The transformation space.


        '''
        pass

    def getNormalIndices(self, normalIndices: MIntArray): 
        '''
        getNormalIndices(self, normalIndices: MIntArray)

        Synopsis
        -----
        This method returns the normal indices of the face/vertex
        associated with the current vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        normalIndices: MIntArray
        	[out] -> The normal indices.


        '''
        pass

    def numUVs(self, uvCount: int,
                        uvSet: MString): 
        '''
        numUVs(self, uvCount: int,
                        uvSet: MString)

        Synopsis
        -----
        This method returns the number of unique UVs mapped on this
        vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        uvCount: int
        	[out] -> The UV count 

        uvSet: MString
        	[in] -> Name of the uv set to work with


        '''
        pass

    @overload
    def setUV(self, uvPoint: float2,
                        uvSet: MString): 
        '''
        setUV(self, uvPoint: float2,
                        uvSet: MString)

        Synopsis
        -----
        Set the shared UV value at this vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        uvPoint: float2
        	[in] -> The UV value to set. 

        uvSet: MString
        	[in] -> Name of the UV set to work with


        '''
        pass

    @overload
    def getUV(self, uvPoint: float2,
                        uvSet: MString): 
        '''
        getUV(self, uvPoint: float2,
                        uvSet: MString)

        Synopsis
        -----
        Get the shared UV value at this vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        uvPoint: float2
        	[out] -> UV value. 

        uvSet: MString
        	[in] -> Name of the uv set to work with.


        '''
        pass

    @overload
    def setUV(self, faceId: int,
                        uvPoint: float2,
                        uvSet: MString): 
        '''
        setUV(self, faceId: int,
                        uvPoint: float2,
                        uvSet: MString)

        Synopsis
        -----
        Set the UV value for the given face at the current vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        faceId: int
        	[in] -> Index of required face 

        uvPoint: float2
        	[in] -> Value of the UV point 

        uvSet: MString
        	[in] -> Name of the uv set to work with


        '''
        pass

    @overload
    def getUV(self, faceId: int,
                        uvPoint: float2,
                        uvSet: MString): 
        '''
        getUV(self, faceId: int,
                        uvPoint: float2,
                        uvSet: MString)

        Synopsis
        -----
        Get the UV value for the give facen at the current vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        faceId: int
        	[in] -> Index of the required face 

        uvPoint: float2
        	[out] -> UV value. 

        uvSet: MString
        	[in] -> Name of the uv set to work with


        '''
        pass

    def setUVs(self, uArray: MFloatArray,
                        vArray: MFloatArray,
                        faceIds: MIntArray,
                        uvSet: MString): 
        '''
        setUVs(self, uArray: MFloatArray,
                        vArray: MFloatArray,
                        faceIds: MIntArray,
                        uvSet: MString)

        Synopsis
        -----
        Set the UV value for the specified faces at the current vertex.
        If the face is not already mapped, the value will not be set. If
        at least ne face was previously mapped, the method should
        succeed. If no faces were mapped, the method will fail.

        Returns:
        -----
        None

        Parameters:
        -----
        uArray: MFloatArray
        	[in] -> All the U values - in local face order 

        vArray: MFloatArray
        	[in] -> The corresponding V values 

        faceIds: MIntArray
        	[in] -> The corresponding face Ids 

        uvSet: MString
        	[in] -> Name of the uv set to work with


        '''
        pass

    def getUVs(self, uArray: MFloatArray,
                        vArray: MFloatArray,
                        faceIds: MIntArray,
                        uvSet: MString): 
        '''
        getUVs(self, uArray: MFloatArray,
                        vArray: MFloatArray,
                        faceIds: MIntArray,
                        uvSet: MString)

        Synopsis
        -----
        Get the UV values for all mapped faces at the current vertex. If
        at least one face was mapped the method will succeed.

        Returns:
        -----
        None

        Parameters:
        -----
        uArray: MFloatArray
        	[out] -> U values in local face order. 

        vArray: MFloatArray
        	[out] -> V values in local face order. 

        faceIds: MIntArray
        	[out] -> The corresponding face Ids 

        uvSet: MString
        	[in] -> Name of the uv set to work with


        '''
        pass

    def getUVIndices(self, uvIndices: MIntArray,
                        uvSet: MString): 
        '''
        getUVIndices(self, uvIndices: MIntArray,
                        uvSet: MString)

        Synopsis
        -----
        This method returns the uv indices into the normal array see
        MFnMesh::getUVs() of the current vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        uvIndices: MIntArray
        	[out] -> UV indices. 

        uvSet: MString
        	[in] -> Name of the uv set.


        '''
        pass

    def updateSurface(self): 
        '''
        updateSurface(self)

        Synopsis
        -----
        Signal that this polygonal surface has changed and needs to
        redraw itself.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def geomChanged(self): 
        '''
        geomChanged(self)

        Synopsis
        -----
        Reset the geom pointer in the MItMeshVertex. If you're using
        MFnMesh to update Normals or Color per vertex while iterating,
        you must call geomChanged on the iteratior immediately after the
        MFnMesh call to make sure that your geometry is up to date. A
        crash may result if this method is not called. A similar approach
        must be taken for updating upstream vertex tweaks with an MPlug.
        After the update, call this method.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setIndex(self, index: int,
                        prevIndex: int): 
        '''
        setIndex(self, index: int,
                        prevIndex: int)

        Synopsis
        -----
        This method sets the index of the current vertex to be accessed.
        The current vertex will no longer be in sync with any previous
        iteration.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> Index of desired vertex to access. 

        prevIndex: int
        	[out] -> Index of vertex which was current before the change.


        '''
        pass

    def getConnectedFaces(self, faces: MIntArray): 
        '''
        getConnectedFaces(self, faces: MIntArray)

        Synopsis
        -----
        This method gets the indices of the faces connected to the
        current vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        faces: MIntArray
        	[out] -> Face indices.


        '''
        pass

    def getConnectedEdges(self, edges: MIntArray): 
        '''
        getConnectedEdges(self, edges: MIntArray)

        Synopsis
        -----
        This method gets the indices of the edges connected to the
        current vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        edges: MIntArray
        	[out] -> Edge indices.


        '''
        pass

    def getConnectedVertices(self, vertices: MIntArray): 
        '''
        getConnectedVertices(self, vertices: MIntArray)

        Synopsis
        -----
        This method gets the indices of the vertices surrounding the
        current vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        vertices: MIntArray
        	[out] -> Indices of connected vertices.


        '''
        pass

    def numConnectedFaces(self, faceCount: int): 
        '''
        numConnectedFaces(self, faceCount: int)

        Synopsis
        -----
        This Method checks for the number of Connected Faces.

        Returns:
        -----
        None

        Parameters:
        -----
        faceCount: int
        	[out] -> The number of connected faces.


        '''
        pass

    def numConnectedEdges(self, edgeCount: int): 
        '''
        numConnectedEdges(self, edgeCount: int)

        Synopsis
        -----
        This Method checks for the number of connected Edges on this
        vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        edgeCount: int
        	[out] -> The number of connected edges.


        '''
        pass

    def connectedToFace(self, index: int,
                        ReturnStatus: MItMeshVertex.MStatus): 
        '''
        connectedToFace(self, index: int,
                        ReturnStatus: MItMeshVertex.MStatus) -> bool

        Synopsis
        -----
        This method determines whether the given face contains the
        current vertex.

        Returns: 
        ----- 
        Boolean value: true if contained, false otherwise.

        Parameters:
        -----
        index: int
        	[in] -> Index of face to check. 

        ReturnStatus: MItMeshVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def connectedToEdge(self, index: int,
                        ReturnStatus: MItMeshVertex.MStatus): 
        '''
        connectedToEdge(self, index: int,
                        ReturnStatus: MItMeshVertex.MStatus) -> bool

        Synopsis
        -----
        This method determines whether the given edge contains the
        current vertex.

        Returns: 
        ----- 
        Boolean value: true if contained, false otherwise.

        Parameters:
        -----
        index: int
        	[in] -> Index of edge to check. 

        ReturnStatus: MItMeshVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def getOppositeVertex(self, vertexId: int,
                        edgeId: int): 
        '''
        getOppositeVertex(self, vertexId: int,
                        edgeId: int)

        Synopsis
        -----
        This gets the other vertex of the given edge.

        Returns:
        -----
        None

        Parameters:
        -----
        vertexId: int
        	[out] -> Id of the given edge's opposite vertex. 

        edgeId: int
        	[in] -> The edge to get the other vertex for


        '''
        pass

    def onBoundary(self, ReturnStatus: MItMeshVertex.MStatus): 
        '''
        onBoundary(self, ReturnStatus: MItMeshVertex.MStatus) -> bool

        Synopsis
        -----
        This method determines whether the current vertex is on a
        Boundary.

        Returns: 
        ----- 
        Boolean value: true if contained, false otherwise.

        Parameters:
        -----
        ReturnStatus: MItMeshVertex.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def hasColor(self, ReturnStatus: MItMeshVertex.MStatus): 
        '''
        hasColor(self, ReturnStatus: MItMeshVertex.MStatus) -> bool

        Synopsis
        -----
        This method determines whether the current Vertex has a color set
        for one or more faces.

        Returns: 
        ----- 
        Boolean value: true if a color is set for at least one face,
        false otherwise.

        Parameters:
        -----
        ReturnStatus: MItMeshVertex.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def hasColor(self, index: int,
                        ReturnStatus: MItMeshVertex.MStatus): 
        '''
        hasColor(self, index: int,
                        ReturnStatus: MItMeshVertex.MStatus) -> bool

        Synopsis
        -----
        This method determines whether the given face has a color set for
        the current vertex.

        Returns: 
        ----- 
        Boolean value: true if a color has been set, false otherwise.

        Parameters:
        -----
        index: int
        	[in] -> Index of face to check. 

        ReturnStatus: MItMeshVertex.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def getColor(self, color: MColor,
                        faceIndex: int,
                        colorSetName: MString): 
        '''
        getColor(self, color: MColor,
                        faceIndex: int,
                        colorSetName: MString)

        Synopsis
        -----
        This method gets the color of the current vertex in the specified
        face.

        Returns:
        -----
        None

        Parameters:
        -----
        color: MColor
        	[out] -> Color. 

        faceIndex: int
        	[in] -> The face to get the color for this vertex for 

        colorSetName: MString
        	[in] -> Name of the color set.


        '''
        pass

    @overload
    def getColor(self, color: MColor,
                        colorSetName: MString): 
        '''
        getColor(self, color: MColor,
                        colorSetName: MString)

        Synopsis
        -----
        This method gets the average color of the vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        color: MColor
        	[out] -> The average color 

        colorSetName: MString
        	[in] -> Name of the color set.


        '''
        pass

    def getColors(self, colors: MColorArray,
                        colorSetName: MString): 
        '''
        getColors(self, colors: MColorArray,
                        colorSetName: MString)

        Synopsis
        -----
        This method gets the colors of the current vertex for each face
        it belongs to. If no colors are assigned to the vertex at all,
        the return values will be (-1 -1 -1 1). If some but not all of
        the vertex/face colors have been explicitly set, the ones that
        have not been set will be (0, 0, 0, 1).

        Returns:
        -----
        None

        Parameters:
        -----
        colors: MColorArray
        	[out] -> Colors. 

        colorSetName: MString
        	[in] -> Name of the color set.


        '''
        pass

    def getColorIndices(self, colorIndices: MIntArray,
                        colorSetName: MString): 
        '''
        getColorIndices(self, colorIndices: MIntArray,
                        colorSetName: MString)

        Synopsis
        -----
        This method returns the colorIndices into the color array see
        MFnMesh::getColors() of the current vertex.

        Returns:
        -----
        None

        Parameters:
        -----
        colorIndices: MIntArray
        	[out] -> Color indices. 

        colorSetName: MString
        	[in] -> Name of the color set.


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MItSelectionList:
    '''Iterate over the items in the selection list.
Class for iterating over the items in an MSelection list. A
filter can be specified so that only those items of interest on a
selection list can be obtained.
If a filter is specified then the children of DAG selection items
will be searched if the selection item does not match the filter.
For example, if
 and a transform is selected then the underlying shape for the
transform will be in the iteration if it is a nurbs curve.
 (of a simple traversal)
 (of a traversal to find all active cameras)
'''
    def __init__(self):
        pass


    def isDone(self, ReturnStatus: MItSelectionList.MStatus): 
        '''
        isDone(self, ReturnStatus: MItSelectionList.MStatus) -> bool

        Synopsis
        -----
        Specifies whether or not there is anything more to iterator over.

        Returns: 
        ----- 
        true if there is nothing else to iterate over  false if there are
        more items left to iterate over

        Parameters:
        -----
        ReturnStatus: MItSelectionList.MStatus
        	[out] -> Status code


        '''
        pass

    def next(self): 
        '''
        next(self)

        Synopsis
        -----
        Advance to the next item. If components are selected then advance
        to next component.If a filter is specified then the next item
        will be one that matches the filter.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def reset(self): 
        '''
        reset(self)

        Synopsis
        -----
        Reset the iterator. If a filter has been specified then the
        current item will be the first selected item that matches the
        filter.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getDependNode(self, depNode: MObject): 
        '''
        getDependNode(self, depNode: MObject)

        Synopsis
        -----
        This method retrieves the dependency node of the current
        selection item.

        Returns:
        -----
        None

        Parameters:
        -----
        depNode: MObject
        	[out] -> a pointer the the dependency node to be retrieved Returns kNullObj and kFailure if components are selected or selected item does not contain a dependency node.


        '''
        pass

    @overload
    def getDagPath(self, dagPath: MDagPath,
                        component: MObject): 
        '''
        getDagPath(self, dagPath: MDagPath,
                        component: MObject)

        Synopsis
        -----
        This method retrieves the dag path and the components of the
        current selection item. If components are not selected then NULL
        is assigned to the component pointer.

        Returns:
        -----
        None

        Parameters:
        -----
        dagPath: MDagPath
        	[out] -> The dag path of the current selection item. 

        component: MObject
        	[out] -> A pointer to the selected components of the current selection item.


        '''
        pass

    @overload
    def getDagPath(self, dagPath: MDagPath): 
        '''
        getDagPath(self, dagPath: MDagPath)

        Synopsis
        -----
        This method retrieves the dag path of the current selection item.

        Returns:
        -----
        None

        Parameters:
        -----
        dagPath: MDagPath
        	[out] -> The dag path of the current selection item.


        '''
        pass

    def getPlug(self, plug: MPlug): 
        '''
        getPlug(self, plug: MPlug)

        Synopsis
        -----
        This method retrieves the plug of the current selection item.

        Returns:
        -----
        None

        Parameters:
        -----
        plug: MPlug
        	[out] -> The plug of the current selection item.


        '''
        pass

    def getStrings(self, array: MStringArray): 
        '''
        getStrings(self, array: MStringArray)

        Synopsis
        -----
        Get the string representation of the current item in the
        selection list. It is possible that it will require more than one
        string to represent the item (the item may contain groups of CVs
        for example), so a string array is used to pass back the results.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MStringArray
        	[out] -> Storage for the returned array.


        '''
        pass

    def itemType(self, ReturnStatus: MItSelectionList.MStatus): 
        '''
        itemType(self, ReturnStatus: MItSelectionList.MStatus) -> MItSelectionList.MItSelectionList

        Synopsis
        -----
        Returns the current selection item type.

        Returns: 
        ----- 
        kDagSelectionItem - selection item is in the DAG
        kAnimSelectionItem - selection item is a keyset  kDNselectionItem
        - selection item is a dependency node

        Parameters:
        -----
        ReturnStatus: MItSelectionList.MStatus
        	[out] -> Status code


        '''
        pass

    def setFilter(self, filter: MFn.MFn): 
        '''
        setFilter(self, filter: MFn.MFn)

        Synopsis
        -----
        Apply a filter to the iteration. Selection items not matching the
        filter type will be excluded from the iteration.

        Returns:
        -----
        None

        Parameters:
        -----
        filter: MFn.MFn
        	[in] -> The 


        '''
        pass

    def hasComponents(self, ReturnStatus: MItSelectionList.MStatus): 
        '''
        hasComponents(self, ReturnStatus: MItSelectionList.MStatus) -> bool

        Synopsis
        -----
        Returns whether or not the current selection item has components.

        Returns: 
        ----- 
        true the current selection item has components  false the current
        selection item does not have components

        Parameters:
        -----
        ReturnStatus: MItSelectionList.MStatus
        	[out] -> Status code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class selItemType:
    '''Types of items which can appear on a selection list. 
    Non-functional class.  Values for this enum:
    kDagSelectionItem
    kAnimSelectionItem
    kDNselectionItem
    kPlugSelectionItem
    '''

    def __init__(self):
        pass

    def kDagSelectionItem(self):
        '''This is an enum of selItemType.
        - Description: DAG node or component. 
        - Value: 0
        '''
        pass

    def kAnimSelectionItem(self):
        '''This is an enum of selItemType.
        - Description: keyset 
        - Value: 1
        '''
        pass

    def kDNselectionItem(self):
        '''This is an enum of selItemType.
        - Description: dependency node 
        - Value: 2
        '''
        pass

    def kPlugSelectionItem(self):
        '''This is an enum of selItemType.
        - Description: plug 
        - Value: 3
        '''
        pass

class MItSubdEdge:
    '''Subdiv edge iterator.
This class is the iterator for subdiv edges.
'''
    def __init__(self):
        pass


    def reset(self): 
        '''
        reset(self)

        Synopsis
        -----
        Reset the iterator to the first edge.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def next(self): 
        '''
        next(self)

        Synopsis
        -----
        Advance to the next edge in the iteration.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isDone(self, ReturnStatus: MItSubdEdge.MStatus): 
        '''
        isDone(self, ReturnStatus: MItSubdEdge.MStatus) -> bool

        Synopsis
        -----
        Indicates if all of the edges have been traversed yet.

        Returns: 
        ----- 
        true All vertices have been traversed  false There are more
        vertices in the iteration

        Parameters:
        -----
        ReturnStatus: MItSubdEdge.MStatus
        	[out] -> Status code


        '''
        pass

    def isValid(self, ReturnStatus: MItSubdEdge.MStatus): 
        '''
        isValid(self, ReturnStatus: MItSubdEdge.MStatus) -> bool

        Synopsis
        -----
        Checks if the iterator is valid.

        Returns: 
        ----- 
        bool Boolean to indicate whether the iterator is valid or not.

        Parameters:
        -----
        ReturnStatus: MItSubdEdge.MStatus
        	[out] -> Status code


        '''
        pass

    def level(self, ReturnStatus: MItSubdEdge.MStatus): 
        '''
        level(self, ReturnStatus: MItSubdEdge.MStatus) -> int

        Synopsis
        -----
        Returns the level of the subdiv object.

        Returns: 
        ----- 
        The level.

        Parameters:
        -----
        ReturnStatus: MItSubdEdge.MStatus
        	[out] -> Status code


        '''
        pass

    def setLevel(self, level: int,
                        ReturnStatus: MItSubdEdge.MStatus): 
        '''
        setLevel(self, level: int,
                        ReturnStatus: MItSubdEdge.MStatus)

        Synopsis
        -----
        Sets the level of the subdiv object.

        Returns:
        -----
        None

        Parameters:
        -----
        level: int
        	[in] -> Level of the subdiv 

        ReturnStatus: MItSubdEdge.MStatus
        	[out] -> Status code


        '''
        pass

    def index(self, ReturnStatus: MItSubdEdge.MStatus): 
        '''
        index(self, ReturnStatus: MItSubdEdge.MStatus) -> MUint64

        Synopsis
        -----
        Returns the index of the current edge in the edge list for this
        subdiv object.

        Returns: 
        ----- 
        The index in the edge list for the current edge

        Parameters:
        -----
        ReturnStatus: MItSubdEdge.MStatus
        	[out] -> Status code


        '''
        pass

    def isSharp(self, ReturnStatus: MItSubdEdge.MStatus): 
        '''
        isSharp(self, ReturnStatus: MItSubdEdge.MStatus) -> bool

        Synopsis
        -----
        Returns true if the edge is sharp.

        Returns: 
        ----- 
        boolean indicating whether the edge is sharp or not.

        Parameters:
        -----
        ReturnStatus: MItSubdEdge.MStatus
        	[out] -> Status code


        '''
        pass

    def setSharpness(self, sharp: bool,
                        ReturnStatus: MItSubdEdge.MStatus): 
        '''
        setSharpness(self, sharp: bool,
                        ReturnStatus: MItSubdEdge.MStatus)

        Synopsis
        -----
        Marks the edge as sharp.

        Returns:
        -----
        None

        Parameters:
        -----
        sharp: bool
        	[in] -> Boolean to mark the edge as sharp or not 

        ReturnStatus: MItSubdEdge.MStatus
        	[out] -> Status code


        '''
        pass

    def isBoundary(self, ReturnStatus: MItSubdEdge.MStatus): 
        '''
        isBoundary(self, ReturnStatus: MItSubdEdge.MStatus) -> bool

        Synopsis
        -----
        Checks if the edge is a boundary.

        Returns: 
        ----- 
        Boolean indicating whether the edge is boundary or not.

        Parameters:
        -----
        ReturnStatus: MItSubdEdge.MStatus
        	[out] -> Status code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MItSubdFace:
    '''Subdiv face iterator.
This class is the iterator for subdiv faces. It will iterate over
all of the surface's faces.
'''
    def __init__(self):
        pass


    def reset(self): 
        '''
        reset(self)

        Synopsis
        -----
        Reset the iterator to the first face.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def next(self): 
        '''
        next(self)

        Synopsis
        -----
        Advance to the next face in the iteration.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isDone(self, ReturnStatus: MItSubdFace.MStatus): 
        '''
        isDone(self, ReturnStatus: MItSubdFace.MStatus) -> bool

        Synopsis
        -----
        Indicates if all of the faces have been traversed yet.

        Returns: 
        ----- 
        true All vertices have been traversed  false There are more
        vertices in the iteration

        Parameters:
        -----
        ReturnStatus: MItSubdFace.MStatus
        	[out] -> Status code


        '''
        pass

    def isValid(self, ReturnStatus: MItSubdFace.MStatus): 
        '''
        isValid(self, ReturnStatus: MItSubdFace.MStatus) -> bool

        Synopsis
        -----
        Checks if the iterator is valid.

        Returns: 
        ----- 
        bool Boolean to indicate whether the iterator is valid or not.

        Parameters:
        -----
        ReturnStatus: MItSubdFace.MStatus
        	[out] -> Status code


        '''
        pass

    def level(self, ReturnStatus: MItSubdFace.MStatus): 
        '''
        level(self, ReturnStatus: MItSubdFace.MStatus) -> int

        Synopsis
        -----
        Returns the level of the subdiv object.

        Returns: 
        ----- 
        The level.

        Parameters:
        -----
        ReturnStatus: MItSubdFace.MStatus
        	[out] -> Status code


        '''
        pass

    def setLevel(self, level: int,
                        ReturnStatus: MItSubdFace.MStatus): 
        '''
        setLevel(self, level: int,
                        ReturnStatus: MItSubdFace.MStatus)

        Synopsis
        -----
        Sets the level of the subdiv object.

        Returns:
        -----
        None

        Parameters:
        -----
        level: int
        	[in] -> New level. 

        ReturnStatus: MItSubdFace.MStatus
        	[out] -> Status code


        '''
        pass

    def index(self, ReturnStatus: MItSubdFace.MStatus): 
        '''
        index(self, ReturnStatus: MItSubdFace.MStatus) -> MUint64

        Synopsis
        -----
        Returns the index of the current face for this subdiv object.

        Returns: 
        ----- 
        The index in the face list for the current face

        Parameters:
        -----
        ReturnStatus: MItSubdFace.MStatus
        	[out] -> Status code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MItSubdVertex:
    '''Subdiv vertex iterator.
This class is the iterator for subdiv vertices.
'''
    def __init__(self):
        pass


    def isDone(self, ReturnStatus: MItSubdVertex.MStatus): 
        '''
        isDone(self, ReturnStatus: MItSubdVertex.MStatus) -> bool

        Synopsis
        -----
        Indicates if all of the vertices have been traversed yet.

        Returns: 
        ----- 
        true All vertices have been traversed  false There are more
        vertices in the iteration

        Parameters:
        -----
        ReturnStatus: MItSubdVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def next(self): 
        '''
        next(self)

        Synopsis
        -----
        Advance to the next vertex in the iteration.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def reset(self): 
        '''
        reset(self)

        Synopsis
        -----
        Reset the iterator to the first vertex.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def level(self, ReturnStatus: MItSubdVertex.MStatus): 
        '''
        level(self, ReturnStatus: MItSubdVertex.MStatus) -> int

        Synopsis
        -----
        Returns the level of the subdiv object.

        Returns: 
        ----- 
        The level.

        Parameters:
        -----
        ReturnStatus: MItSubdVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def setLevel(self, level: int,
                        ReturnStatus: MItSubdVertex.MStatus): 
        '''
        setLevel(self, level: int,
                        ReturnStatus: MItSubdVertex.MStatus)

        Synopsis
        -----
        Sets the level of the subdiv object.

        Returns:
        -----
        None

        Parameters:
        -----
        level: int
        	[in] -> Level of the subdiv 

        ReturnStatus: MItSubdVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def isValid(self, ReturnStatus: MItSubdVertex.MStatus): 
        '''
        isValid(self, ReturnStatus: MItSubdVertex.MStatus) -> bool

        Synopsis
        -----
        Checks if the iterator is valid.

        Returns: 
        ----- 
        Boolean to indicate whether the iterator is valid or not.

        Parameters:
        -----
        ReturnStatus: MItSubdVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def index(self, ReturnStatus: MItSubdVertex.MStatus): 
        '''
        index(self, ReturnStatus: MItSubdVertex.MStatus) -> MUint64

        Synopsis
        -----
        Returns the index of the current vertex in the vertex list for
        this subdiv object.

        Returns: 
        ----- 
        The index in the vertex list for the current vertex

        Parameters:
        -----
        ReturnStatus: MItSubdVertex.MStatus
        	[out] -> Status code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MItSurfaceCV:
    '''NURBS surface CV iterator.
Iterator class for NURBS surface CVs.
 Translates the CVs for a surface in the X direction (world
space).
'''
    def __init__(self):
        pass


    def isDone(self, ReturnStatus: MItSurfaceCV.MStatus): 
        '''
        isDone(self, ReturnStatus: MItSurfaceCV.MStatus) -> bool

        Synopsis
        -----
        Returns true if the iteration is finished, i.e. there are no more
        CVs to iterate on.

        Returns: 
        ----- 
        Boolean value: true if there are no more CVs to iterate on, false
        otherwise.

        Parameters:
        -----
        ReturnStatus: MItSurfaceCV.MStatus
        	[out] -> Status code


        '''
        pass

    def isRowDone(self, ReturnStatus: MItSurfaceCV.MStatus): 
        '''
        isRowDone(self, ReturnStatus: MItSurfaceCV.MStatus) -> bool

        Synopsis
        -----
        Returns true if the current row has no more CVs to iterate over.
        The row can be in the U or V direction depending on what value of
        useURows has been set in the constructor.

        Returns: 
        ----- 
        Boolean value: true if the current row in the iteration is
        finished, false otherwise.

        Parameters:
        -----
        ReturnStatus: MItSurfaceCV.MStatus
        	[out] -> Status code


        '''
        pass

    def next(self): 
        '''
        next(self)

        Synopsis
        -----
        Advance to the next CV in the iteration. If the iterator is
        already at the last CV then this method has no effect. Use isDone
        to determine if the iterator is at the last CV.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def nextRow(self): 
        '''
        nextRow(self)

        Synopsis
        -----
        Advance to the next row in the iteration. The row can be in the U
        or V direction depending on what value of useURows has been set
        in the constructor.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def reset(self): 
        '''
        reset(self)

        Synopsis
        -----
        Reset the iterator to the first CV.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def reset(self, surface: MObject,
                        useURows: bool): 
        '''
        reset(self, surface: MObject,
                        useURows: bool)

        Synopsis
        -----
        Reset the iterator to iterate over all CVs on the specified
        surface.

        Returns:
        -----
        None

        Parameters:
        -----
        surface: MObject
        	[in] -> The surface for the iteration 

        useURows: bool
        	[in] -> If 


        '''
        pass

    @overload
    def reset(self, surface: MDagPath,
                        component: MObject,
                        useURows: bool): 
        '''
        reset(self, surface: MDagPath,
                        component: MObject,
                        useURows: bool)

        Synopsis
        -----
        Reset the iterator to iterate over the CVs of the given surface
        that are specified in the given component. If the component is
        NULL then the iteration will be over all CVs on the surface.

        Returns:
        -----
        None

        Parameters:
        -----
        surface: MDagPath
        	[in] -> The surface for the iteration 

        component: MObject
        	[in] -> A group of CVs to be iterated on 

        useURows: bool
        	[in] -> If 


        '''
        pass

    def position(self, space: MSpace.MSpace,
                        ReturnStatus: MItSurfaceCV.MStatus): 
        '''
        position(self, space: MSpace.MSpace,
                        ReturnStatus: MItSurfaceCV.MStatus) -> MPoint

        Synopsis
        -----
        Returns the position of the current CV in the iteration in the
        specified space.

        Returns: 
        ----- 
        The position of the current CV in the iteration

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> The coordinate space in which the CV is set 

        ReturnStatus: MItSurfaceCV.MStatus
        	[out] -> Status code


        '''
        pass

    def setPosition(self, point: MPoint,
                        space: MSpace.MSpace): 
        '''
        setPosition(self, point: MPoint,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the position of the current CV in the iteration to the
        specified point.

        Returns:
        -----
        None

        Parameters:
        -----
        point: MPoint
        	[out] -> The new position for the current CV in the iteration 

        space: MSpace.MSpace
        	[in] -> The coordinate space in which the CV is set


        '''
        pass

    def translateBy(self, vector: MVector,
                        space: MSpace.MSpace): 
        '''
        translateBy(self, vector: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Move the current CV in the iteration by the sepcified vector.

        Returns:
        -----
        None

        Parameters:
        -----
        vector: MVector
        	[out] -> The translation vector 

        space: MSpace.MSpace
        	[in] -> The coordinate space in which the CV is set


        '''
        pass

    def index(self, ReturnStatus: MItSurfaceCV.MStatus): 
        '''
        index(self, ReturnStatus: MItSurfaceCV.MStatus) -> int

        Synopsis
        -----
        Get the index of the current CV as it appears in CV array for
        this surface. The index returned is a single index. To convert
        this into a double (U,V) index:

        Returns: 
        ----- 
        The index for the current CV in the iteration

        Parameters:
        -----
        ReturnStatus: MItSurfaceCV.MStatus
        	[out] -> Status code


        '''
        pass

    def getIndex(self, indexU: int,
                        indexV: int): 
        '''
        getIndex(self, indexU: int,
                        indexV: int)

        Synopsis
        -----
        Get the index of the current CV as it appears in CV array for
        this surface. The index returned is a double (U,V) index. To
        convert this into a single index:

        Returns:
        -----
        None

        Parameters:
        -----
        indexU: int
        	[out] -> Storage for the u index 

        indexV: int
        	[out] -> Storage for the v index


        '''
        pass

    def currentItem(self, ReturnStatus: MItSurfaceCV.MStatus): 
        '''
        currentItem(self, ReturnStatus: MItSurfaceCV.MStatus) -> MObject

        Synopsis
        -----
        Get the current CV in the iteration as a component. Components
        are used to specify one or more CVs and are usefull in operating
        on groups of non-contiguous CVs for a curve or surface.
        Components do not contain any information about the surface that
        they refer to so an MDagPath must be specified when dealing with
        components.

        Returns: 
        ----- 
        The current CV in the interation

        Parameters:
        -----
        ReturnStatus: MItSurfaceCV.MStatus
        	[out] -> Status code


        '''
        pass

    def hasHistoryOnCreate(self, ReturnStatus: MItSurfaceCV.MStatus): 
        '''
        hasHistoryOnCreate(self, ReturnStatus: MItSurfaceCV.MStatus) -> bool

        Synopsis
        -----
        This method determines if the shape was created with history. If
        the object that this iterator is attached to is not a shape then
        this method will fail.

        Returns: 
        ----- 
        Boolean value: true if the shape has history, false otherwise.

        Parameters:
        -----
        ReturnStatus: MItSurfaceCV.MStatus
        	[out] -> 


        '''
        pass

    def updateSurface(self): 
        '''
        updateSurface(self)

        Synopsis
        -----
        This method is used to signal the surface that it has been
        changed and needs to redraw itself. When modifying a large number
        of CVs, it is most efficient to call this method after all of the
        CVs have been modified.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MLockMessage:
    '''Node and plug locking messages.
Plug locking was implemented with Maya 1.0. Individual plugs can
be locked so that their values cannot be changed. The locking
state is held within the plug. The plug's locked state can be
changed via the API with the method
MPlug::setLocked(bool), or, in MEL, using the command "setAttr -l {on,off}".
The ability to lock nodes was added with Maya 4.5. Node locking
prevents renaming, reparenting, deletion, and other node-related
changes. It also restricts the ability to change the state of any
plug locks. The intent is that the user relies upon plug locking
first, to lock the desired plugs they don't want to change, and
then uses node locking to lock the node itself. Node locking can
be set via MEL command, "lockNode", or via
MFnDependencyNode::setLocked(bool)MLockMessage class allows the API user to register callbacks that control how
Maya handles locks. The registered callbacks are invoked whenever
a query to the lock state is involved. Therefore, the callback
would be called even if the node was not locked.
When a callback is invoked, the API user will be given a decision
variable where they can place their decision. This decision
variable is a boolean, and the boolean can take on the following
values:
You must use caution when using these routines. The flow of
execution is interrupted when these callbacks are invoked.
Therefore, you should make your decision in a timely maanner or a
serious performance penalty will result. Also, you should NEVER
try to alter the DG state while executing within callback. This
includes quering/assigning a plug's value. You may, however,
examine state information like the lock state of the plug/node.
'''
    def __init__(self):
        pass


    def setNodeLockQueryCallback(self, node: MObject,
                        func: MLockMessage.MLockMessage,
                        clientData: void,
                        ReturnStatus: MLockMessage.MStatus): 
        '''
        setNodeLockQueryCallback(self, node: MObject,
                        func: MLockMessage.MLockMessage,
                        clientData: void,
                        ReturnStatus: MLockMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This methods registers a callback that is invoked in any locking
        condition on node properties, e.g. name, lock status, etc. When
        called, the API user can make a decision on how to handle the
        given locking situation. The programmer can either accept the
        default action, or they can deny the default action. The decision
        is returned through a decision variable which is passed to the
        callback function.The callback function takes the following
        parameters:The meanings of the node and aux parameters for each
        eventType, and default actions associated with those event types,
        are as follows:kRenamekDeletekLockNodekUnlockNodekAddAttrkRemoveA
        ttrkRenameAttrkUnlockAttrkLockAttr

        Returns: 
        ----- 
        A unique id for the callback.

        Parameters:
        -----
        node: MObject
        	[in] -> - The node to register the callback for. 

        func: MLockMessage.MLockMessage
        	[in] -> - Pointer to the callback function. 

        clientData: void
        	[in] -> - Client data that should be passed back to the callback. 

        ReturnStatus: MLockMessage.MStatus
        	[out] -> - status code


        '''
        pass

    def setNodeLockDAGQueryCallback(self, dagPath: MDagPath,
                        func: MLockMessage.MLockMessage,
                        clientData: void,
                        ReturnStatus: MLockMessage.MStatus): 
        '''
        setNodeLockDAGQueryCallback(self, dagPath: MDagPath,
                        func: MLockMessage.MLockMessage,
                        clientData: void,
                        ReturnStatus: MLockMessage.MStatus) -> MLockMessage.OPENMAYA_MAJOR_NAMESPACE_OPENMCallbackId

        Synopsis
        -----
        This methods registers a callback that is invoked in any
        situation involving a locking condition on DAG level changes.
        When called, the API user can make a decision on how to handle
        the given locking situation. The programmer can either accept the
        default action, or they can deny the default action. The decision
        is returned through a decision variable which is passed to the
        callback function.The callback function takes the following
        parameters:The meanings of the dagPath and otherPath parameters
        for each eventType, and default actions associated with those
        event types, are as follows:kGroupkUnGroupkReparentkChildReorderk
        CreateNodeInstancekCreateChildInstance

        Returns: 
        ----- 
        A unique id for the callback.

        Parameters:
        -----
        dagPath: MDagPath
        	[in] -> The path to attach the callback. 

        func: MLockMessage.MLockMessage
        	[in] -> - Pointer to the callback function. 

        clientData: void
        	[in] -> Client data that should be passed back to the callback. 

        ReturnStatus: MLockMessage.MStatus
        	[out] -> status code


        '''
        pass

    @overload
    def setPlugLockQueryCallback(self, plug: MPlug,
                        func: MLockMessage.MLockMessage,
                        clientData: void,
                        ReturnStatus: MLockMessage.MStatus): 
        '''
        setPlugLockQueryCallback(self, plug: MPlug,
                        func: MLockMessage.MLockMessage,
                        clientData: void,
                        ReturnStatus: MLockMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is invoked in any locking
        condition on a plug, e.g. plug unlock, plug lock, connections,
        etc. When the callback is invoked, the API programmer can make a
        decision on how to handle the given locking situation. The
        programmer can either accept the default action, or they can deny
        the default action. The decision is made through the decision
        variable described above.The callback function takes the
        following parameters:The meanings of the plug and otherPlug
        parameters for each eventType, and default actions associated
        with those event types, are as follows:kPlugLockAttrkPlugUnlockAt
        trkPlugAttrValChangekPlugRemoveAttrkPlugRenameAttrkPlugConnectkPl
        ugDisconnect

        Returns: 
        ----- 
        A unique id for the callback.

        Parameters:
        -----
        plug: MPlug
        	[in] -> - The plug to attach the callback. 

        func: MLockMessage.MLockMessage
        	[in] -> - Pointer to the callback function. 

        clientData: void
        	[in] -> - Client data that should be passed back to the callback. 

        ReturnStatus: MLockMessage.MStatus
        	[out] -> - status code


        '''
        pass

    @overload
    def setPlugLockQueryCallback(self, node: MObject,
                        func: MLockMessage.MLockMessage,
                        clientData: void,
                        ReturnStatus: MLockMessage.MStatus): 
        '''
        setPlugLockQueryCallback(self, node: MObject,
                        func: MLockMessage.MLockMessage,
                        clientData: void,
                        ReturnStatus: MLockMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is invoked in any locking
        condition on any plug of a given node, e.g. plug unlock, plug
        lock, connections, etc. When the callback is invoked, the API
        programmer can make a decision on how to handle the given locking
        situation. The programmer can either accept the default action,
        or they can deny the default action. The decision is returned
        through a decision variable which is passed to the callback
        function.The callback function takes the following parameters:If
        a lock event occurs on a plug which has callbacks registered both
        on the plug itself, using the previous method, and on the entire
        node, using this method, then only the plug-specific callback
        will be called. This allows you to have both plug-specific and
        node-wide callbacks on a node while ensuring that the most
        specific callback is the one called.The meanings of the plug and
        otherPlug parameters for each eventType, and the default actions
        associated with those event types, are described in the plug-
        specific version of the method, above.

        Returns: 
        ----- 
        A unique id for the callback.

        Parameters:
        -----
        node: MObject
        	[in] -> - The node to attach the callback. 

        func: MLockMessage.MLockMessage
        	[in] -> - Pointer to the callback function. 

        clientData: void
        	[in] -> - Client data that should be passed back to the callback. 

        ReturnStatus: MLockMessage.MStatus
        	[out] -> - status code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class LockPlugEvent:
    '''Plug related locking events. 
    Non-functional class.  Values for this enum:
    kInvalidPlug
    kPlugLockAttr
    kPlugUnlockAttr
    kPlugAttrValChange
    kPlugRemoveAttr
    kPlugRenameAttr
    kPlugConnect
    kPlugDisconnect
    kLastPlug
    '''

    def __init__(self):
        pass

    def kInvalidPlug(self):
        '''This is an enum of LockPlugEvent.
        - Description: An invalid plug event received. 
        - Value: 0
        '''
        pass

    def kPlugLockAttr(self):
        '''This is an enum of LockPlugEvent.
        - Description: User is trying to lock the plug. 
        - Value: 1
        '''
        pass

    def kPlugUnlockAttr(self):
        '''This is an enum of LockPlugEvent.
        - Description: User is trying to unlock the plug. 
        - Value: 2
        '''
        pass

    def kPlugAttrValChange(self):
        '''This is an enum of LockPlugEvent.
        - Description: Plug lock query on plug value change. 
        - Value: 3
        '''
        pass

    def kPlugRemoveAttr(self):
        '''This is an enum of LockPlugEvent.
        - Description: Plug lock query on a remove attribute event. 
        - Value: 4
        '''
        pass

    def kPlugRenameAttr(self):
        '''This is an enum of LockPlugEvent.
        - Description: Plug lock query on a rename attribute event. 
        - Value: 5
        '''
        pass

    def kPlugConnect(self):
        '''This is an enum of LockPlugEvent.
        - Description: Plug lock query on a connect to a locked attribute. 
        - Value: 6
        '''
        pass

    def kPlugDisconnect(self):
        '''This is an enum of LockPlugEvent.
        - Description: Plug lock query on a disconnect from a locked source attribute. 
        - Value: 7
        '''
        pass

    def kLastPlug(self):
        '''This is an enum of LockPlugEvent.
        - Description: Used for internal bounds checking. 
        - Value: 8
        '''
        pass

class LockDAGEvent:
    '''DAG related locking events. 
    Non-functional class.  Values for this enum:
    kInvalidDAG
    kGroup
    kUnGroup
    kReparent
    kChildReorder
    kCreateNodeInstance
    kCreateChildInstance
    kCreateParentInstance
    kLastDAG
    '''

    def __init__(self):
        pass

    def kInvalidDAG(self):
        '''This is an enum of LockDAGEvent.
        - Description: Invalid DAG event received. 
        - Value: 0
        '''
        pass

    def kGroup(self):
        '''This is an enum of LockDAGEvent.
        - Description: Lock query on group action. 
        - Value: 1
        '''
        pass

    def kUnGroup(self):
        '''This is an enum of LockDAGEvent.
        - Description: Lock query on ungroup action. 
        - Value: 2
        '''
        pass

    def kReparent(self):
        '''This is an enum of LockDAGEvent.
        - Description: Lock query on reparent action. 
        - Value: 3
        '''
        pass

    def kChildReorder(self):
        '''This is an enum of LockDAGEvent.
        - Description: Lock query on a child add action. 
        - Value: 4
        '''
        pass

    def kCreateNodeInstance(self):
        '''This is an enum of LockDAGEvent.
        - Description: Lock query on an instance event. 
        - Value: 5
        '''
        pass

    def kCreateChildInstance(self):
        '''This is an enum of LockDAGEvent.
        - Description: Lock query on node whose children will be instanced. 
        - Value: 6
        '''
        pass

    def kCreateParentInstance(self):
        '''This is an enum of LockDAGEvent.
        - Description: Lock query on node whose parent will be instanced. 
        - Value: 7
        '''
        pass

    def kLastDAG(self):
        '''This is an enum of LockDAGEvent.
        - Description: Used for internal bounds checking. 
        - Value: 8
        '''
        pass

class LockEvent:
    '''Miscellaneous lock event types. 
    Non-functional class.  Values for this enum:
    kInvalid
    kRename
    kDelete
    kLockNode
    kUnlockNode
    kAddAttr
    kRemoveAttr
    kRenameAttr
    kUnlockAttr
    kLockAttr
    kLast
    '''

    def __init__(self):
        pass

    def kInvalid(self):
        '''This is an enum of LockEvent.
        - Description: Invalid node lock event received. 
        - Value: 0
        '''
        pass

    def kRename(self):
        '''This is an enum of LockEvent.
        - Description: Lock query on a rename event. 
        - Value: 1
        '''
        pass

    def kDelete(self):
        '''This is an enum of LockEvent.
        - Description: Lock query on a delete event. 
        - Value: 2
        '''
        pass

    def kLockNode(self):
        '''This is an enum of LockEvent.
        - Description: Lock query on a lock event. 
        - Value: 3
        '''
        pass

    def kUnlockNode(self):
        '''This is an enum of LockEvent.
        - Description: Lock query on an unlock event. 
        - Value: 4
        '''
        pass

    def kAddAttr(self):
        '''This is an enum of LockEvent.
        - Description: Lock query on an add attribute event. 
        - Value: 5
        '''
        pass

    def kRemoveAttr(self):
        '''This is an enum of LockEvent.
        - Description: Lock query on an remove attribute event. 
        - Value: 6
        '''
        pass

    def kRenameAttr(self):
        '''This is an enum of LockEvent.
        - Description: Lock query on an rename attribute event. 
        - Value: 7
        '''
        pass

    def kUnlockAttr(self):
        '''This is an enum of LockEvent.
        - Description: Lock query on an unlock attribute event. 
        - Value: 8
        '''
        pass

    def kLockAttr(self):
        '''This is an enum of LockEvent.
        - Description: Lock query on a lock attribute event. 
        - Value: 9
        '''
        pass

    def kLast(self):
        '''This is an enum of LockEvent.
        - Description: Used for internal bounds checking. 
        - Value: 10
        '''
        pass

class MMatrix:
    '''A matrix math class for 4x4 matrices of doubles.
This class provides access to Maya's internal matrix math library
allowing matrices to be handled easily, and in a manner
compatible with internal Maya data structures.
All methods that query the matrix are threadsafe, all methods
that modify the matrix are not threadsafe.
'''
    def __init__(self):
        pass


    def __getitem__(self, row: int): 
        '''
        __getitem__(self, row: int) -> double*

        Synopsis
        -----
        Index operator. Returns an entire row of the matrix as an array
        of doubles.

        Returns: 
        ----- 
        double array containing the values of the specified row

        Parameters:
        -----
        row: int
        	[in] -> index of the row to access


        '''
        pass

    @overload
    def get(self, dest: double4): 
        '''
        get(self, dest: double4)

        Synopsis
        -----
        Fill a 4x4 matrix of doubles with the elements from the instance.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: double4
        	[out] -> 4x4 matrix of doubles to populate


        '''
        pass

    @overload
    def get(self, dest: float4): 
        '''
        get(self, dest: float4)

        Synopsis
        -----
        Fill a 4x4 matrix of floats with the elements from the instance.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: float4
        	[out] -> 4x4 matrix of floats to populate


        '''
        pass

    def transpose(self): 
        '''
        transpose(self) -> MMatrix

        Synopsis
        -----
        Compute and return the transpose of this instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setToIdentity(self): 
        '''
        setToIdentity(self) -> MMatrix

        Synopsis
        -----
        Set this instance to the 4x4 identity matrix.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setToProduct(self, left: MMatrix,
                        right: MMatrix): 
        '''
        setToProduct(self, left: MMatrix,
                        right: MMatrix) -> MMatrix

        Synopsis
        -----
        Set this instance to the inner product of the two argument
        matrices.

        Returns: 
        ----- 
        This matrix.

        Parameters:
        -----
        left: MMatrix
        	[in] -> the left hand matrix for the operation 

        right: MMatrix
        	[in] -> the right hand matrix for the operation


        '''
        pass

    def __radd__(self, right: MMatrix): 
        '''
        __radd__(self, right: MMatrix) -> MMatrix

        Synopsis
        -----
        The in place matrix addition operator. Modifies this matrix.

        Returns: 
        ----- 
        This matrix.

        Parameters:
        -----
        right: MMatrix
        	[in] -> Matrix to add.


        '''
        pass

    def __add__(self, right: MMatrix): 
        '''
        __add__(self, right: MMatrix) -> MMatrix

        Synopsis
        -----
        The matrix addition operator. Does not modify this matrix.

        Returns: 
        ----- 
        New matrix containing the result.

        Parameters:
        -----
        right: MMatrix
        	[in] -> Matrix to add to this one.


        '''
        pass

    def __rsub__(self, right: MMatrix): 
        '''
        __rsub__(self, right: MMatrix) -> MMatrix

        Synopsis
        -----
        The in place matrix subtraction operator. Modifies this matrix.

        Returns: 
        ----- 
        This matrix.

        Parameters:
        -----
        right: MMatrix
        	[in] -> Matrix to add to this one.


        '''
        pass

    def __sub__(self, right: MMatrix): 
        '''
        __sub__(self, right: MMatrix) -> MMatrix

        Synopsis
        -----
        The matrix subtraction operator. Does not modify this matrix.

        Returns: 
        ----- 
        New matrix containing the result.

        Parameters:
        -----
        right: MMatrix
        	[in] -> Matrix to subtract from this one.


        '''
        pass

    def __eq__(self, other: MMatrix): 
        '''
        __eq__(self, other: MMatrix) -> bool

        Synopsis
        -----
        The matrix equality operator. The matrices must be identical.

        Returns: 
        ----- 
        True if other contains the same values as this matrix, false
        otherwise.

        Parameters:
        -----
        other: MMatrix
        	[in] -> Matrix to compare against.


        '''
        pass

    def __neq__(self, other: MMatrix): 
        '''
        __neq__(self, other: MMatrix) -> bool

        Synopsis
        -----
        The matrix inequality operator.

        Returns: 
        ----- 
        False if other contains the same values as this matrix, true
        otherwise.

        Parameters:
        -----
        other: MMatrix
        	[in] -> Matrix to compare against.


        '''
        pass

    def inverse(self): 
        '''
        inverse(self) -> MMatrix

        Synopsis
        -----
        Compute and return the inverse of this instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def adjoint(self): 
        '''
        adjoint(self) -> MMatrix

        Synopsis
        -----
        Compute and return the adjoint of this instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def homogenize(self): 
        '''
        homogenize(self) -> MMatrix

        Synopsis
        -----
        Compute and return a homogenized version of this instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def det4x4(self): 
        '''
        det4x4(self) -> double

        Synopsis
        -----
        Compute and return the determinant of this instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def det3x3(self): 
        '''
        det3x3(self) -> double

        Synopsis
        -----
        Compute and return the determinant of the upper left 3x3
        submatrix of this instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isEquivalent(self, other: MMatrix,
                        tolerance: double): 
        '''
        isEquivalent(self, other: MMatrix,
                        tolerance: double) -> bool

        Synopsis
        -----
        Determine if the given matrix is equivalent to this instance
        within the specified tolerance.

        Returns: 
        ----- 
        True if the matrices are equivalent and false otherwise

        Parameters:
        -----
        other: MMatrix
        	[in] -> the matrix to compare to 

        tolerance: double
        	[in] -> the tolerance to use during the comparison


        '''
        pass

    def isSingular(self): 
        '''
        isSingular(self) -> bool

        Synopsis
        -----
        Determines if the given matrix is singular.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MMatrixArray:
    '''Array of
MMatrix data type.
This class implements an array of
MMatrix's. Common convenience functions are available, and the
implementation is compatible with the internal Maya
implementation so that it can be passed efficiently between
plugins and internal maya data structures.
'''
    def __init__(self):
        pass


    @overload
    def __getitem__(self, index: unsigned): 
        '''
        __getitem__(self, index: unsigned) -> const MMatrix&

        Synopsis
        -----
        Index operator. Returns the value of the element at the given
        index. No range checking is done - valid indices are 0 to
        length()-1.

        Returns: 
        ----- 
        The value of the indicated element.

        Parameters:
        -----
        index: unsigned
        	[in] -> the index of the element whose value is to be returned


        '''
        pass

    def set(self, element: MMatrix,
                        index: unsigned): 
        '''
        set(self, element: MMatrix,
                        index: unsigned)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated MMatrix
        value. NOTE: This method does not grow the array if the index is
        out of bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MMatrix
        	[in] -> the new value for the indicated element 

        index: unsigned
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    def setLength(self, length: unsigned): 
        '''
        setLength(self, length: unsigned)

        Synopsis
        -----
        Set the length of the array. This will grow and shrink the array
        as desired. Elements that are grown have uninitialized values,
        while those which are shrunk will lose the data contained in the
        deleted elements (ie. it will release the memory).

        Returns:
        -----
        None

        Parameters:
        -----
        length: unsigned
        	[in] -> the new size of the array 


        '''
        pass

    def length(self): 
        '''
        length(self)

        Synopsis
        -----
        Returns the number of elements in the instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def remove(self, index: unsigned): 
        '''
        remove(self, index: unsigned)

        Synopsis
        -----
        Remove the array element at the given index. All array elements
        following the removed element are shifted toward the first
        element.

        Returns:
        -----
        None

        Parameters:
        -----
        index: unsigned
        	[in] -> index of the element to be removed


        '''
        pass

    def insert(self, element: MMatrix,
                        index: unsigned): 
        '''
        insert(self, element: MMatrix,
                        index: unsigned)

        Synopsis
        -----
        Inserts a new value into the array at the given index. The
        initial element at that index, and all following elements, are
        shifted towards the last. If the array cannot be expanded in size
        by 1 element, then the insert will fail and the existing array
        will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MMatrix
        	[in] -> the new value to insert into the array 

        index: unsigned
        	[in] -> the index of the element to set to the the new value


        '''
        pass

    def append(self, element: MMatrix): 
        '''
        append(self, element: MMatrix)

        Synopsis
        -----
        Adds a new element to the end of the array. If the array cannot
        be expanded in size by 1 element, then the append will fail and
        the existing array will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MMatrix
        	[in] -> the value for the new last element


        '''
        pass

    def copy(self, source: MMatrixArray): 
        '''
        copy(self, source: MMatrixArray)

        Synopsis
        -----
        Copy the contents of the source array to this array.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MMatrixArray
        	[in] -> array to copy from


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clear the contents of the array. After this operation the length
        method will return 0. This does not change the amount of memory
        allocated to the array, only the number of valid elements in it.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setSizeIncrement(self, newIncrement: unsigned): 
        '''
        setSizeIncrement(self, newIncrement: unsigned)

        Synopsis
        -----
        Set the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        newIncrement: unsigned
        	[in] -> the new increment 


        '''
        pass

    def sizeIncrement(self): 
        '''
        sizeIncrement(self)

        Synopsis
        -----
        Return the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def __getitem__(self, index: unsigned): 
        '''
        __getitem__(self, index: unsigned) -> MMatrix

        Synopsis
        -----
        Index operator allowing assignment to an element of the array.
        Returns a reference to the element at the given index. No range
        checking is done - valid indices are 0 to length()-1.

        Returns: 
        ----- 
        A reference to the indicated element

        Parameters:
        -----
        index: unsigned
        	[in] -> the index of the desired element


        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MMatrixArray.MMatrixArray

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MMatrixArray.MMatrixArray

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MMatrixArray.MMatrixArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MMatrixArray.MMatrixArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MMatrixArray.MMatrixArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MMatrixArray.MMatrixArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MMeshIntersector:
    '''Mesh intersector.
The
MMeshIntersector class contains methods for efficiently finding the closest point
on a mesh. An octree algorithm is used to find the closest point.
The
create() method builds the internal data required for the algorithm. As a
result, calls to it should be minimized as it is a heavy
operation.
This class allows multiple threads to evaluate closest points
simultaneously as the method getClosestPoint is threadsafe.
'''
    def __init__(self):
        pass


    def create(self, meshObject: MObject,
                        matrix: MMatrix,
                        facesOfInterest: MIntArray): 
        '''
        create(self, meshObject: MObject,
                        matrix: MMatrix,
                        facesOfInterest: MIntArray)

        Synopsis
        -----
        Changed in 2020.0 This method creates the data required by the
        intersector.It is a heavy operation that should be called only
        when necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        meshObject: MObject
        	[in] -> a kMesh or kMeshData object 

        matrix: MMatrix
        	[in] -> specify the mapping to apply for transforming points that are specified in the getClosestPoint method into the object space of the mesh. 

        facesOfInterest: MIntArray
        	[in] -> faces to be considered by the intersector.


        '''
        pass

    def isCreated(self): 
        '''
        isCreated(self) -> bool

        Synopsis
        -----
        This method returns true if the intersector is created. False is
        return otherwise.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getClosestPoint(self, point: MPoint,
                        meshPoint: MPointOnMesh,
                        maxDistance: double): 
        '''
        getClosestPoint(self, point: MPoint,
                        meshPoint: MPointOnMesh,
                        maxDistance: double)

        Synopsis
        -----
        This method finds the closest point. Information is returned in
        the meshPoint object.This method is threadsafe.

        Returns:
        -----
        None

        Parameters:
        -----
        point: MPoint
        	[in] -> Specifies the location for which to evaluate the closest point on the mesh. `point' is transformed using the matrix parameter passed to the 

        meshPoint: MPointOnMesh
        	[out] -> Resulting closest point in object space. 

        maxDistance: double
        	[in] -> Maximum distance to consider in object space.


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MMeshSmoothOptions:
    '''Options for control of smooth mesh generation.
The
MMeshSmoothOptions class encapsulates settings that control the generation of
smoothed version of a mesh. Meant for use with
MFnMesh::generateSmoothMesh().
'''
    def __init__(self):
        pass


    def setDivisions(self, numDivisions: int,
                        ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        setDivisions(self, numDivisions: int,
                        ReturnStatus: MMeshSmoothOptions.MStatus)

        Synopsis
        -----
        Sets the number of divisions stored in this options object.

        Returns:
        -----
        None

        Parameters:
        -----
        numDivisions: int
        	[in] -> Number of divisions. 

        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code (see below)


        '''
        pass

    def divisions(self, ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        divisions(self, ReturnStatus: MMeshSmoothOptions.MStatus) -> int

        Synopsis
        -----
        Retrieves the level of smoothing these options specify to perform
        on the mesh.

        Returns: 
        ----- 
        The smoothing level

        Parameters:
        -----
        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code (see below)


        '''
        pass

    def setSmoothness(self, smoothness: float,
                        ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        setSmoothness(self, smoothness: float,
                        ReturnStatus: MMeshSmoothOptions.MStatus)

        Synopsis
        -----
        Sets the the smoothness parameter for this set of smooth options
        which has range [0,1] where 1 smooths the faces as much as
        possible.

        Returns:
        -----
        None

        Parameters:
        -----
        smoothness: float
        	[in] -> The smoothness 

        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code (see below)


        '''
        pass

    def smoothness(self, ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        smoothness(self, ReturnStatus: MMeshSmoothOptions.MStatus) -> float

        Synopsis
        -----
        Retrieves the smoothness parameter for this set of smooth options
        which has range [0,1] where 1 smooths the faces as much as
        possible.

        Returns: 
        ----- 
        The smoothness parameter

        Parameters:
        -----
        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code (see below)


        '''
        pass

    def setSmoothUVs(self, smoothUVs: bool,
                        ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        setSmoothUVs(self, smoothUVs: bool,
                        ReturnStatus: MMeshSmoothOptions.MStatus)

        Synopsis
        -----
        Sets whether or not these options specify to smooth UVs as well
        as geometry.

        Returns:
        -----
        None

        Parameters:
        -----
        smoothUVs: bool
        	[in] -> True if UVs should be smoothed 

        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code (see below)


        '''
        pass

    def smoothUVs(self, ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        smoothUVs(self, ReturnStatus: MMeshSmoothOptions.MStatus) -> bool

        Synopsis
        -----
        Retrieves whether or not these options specify to smooth UVs as
        well as geometry.

        Returns: 
        ----- 
        True if UVs are set to be smoothed

        Parameters:
        -----
        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code (see below)


        '''
        pass

    def setPropEdgeHardness(self, propEdgeHardness: bool,
                        ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        setPropEdgeHardness(self, propEdgeHardness: bool,
                        ReturnStatus: MMeshSmoothOptions.MStatus)

        Synopsis
        -----
        Sets whether or not these options specify that smooth mesh edges
        which are a result of edges from the base cage will share the
        hardness value.

        Returns:
        -----
        None

        Parameters:
        -----
        propEdgeHardness: bool
        	[in] -> True if smooth edges should share hardness with the base cage 

        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code (see below)


        '''
        pass

    def propEdgeHardness(self, ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        propEdgeHardness(self, ReturnStatus: MMeshSmoothOptions.MStatus) -> bool

        Synopsis
        -----
        Retrieves whether or not these options specify that the smooth
        mesh edges which are a result of edges from the base cage will
        share the same hardness value.

        Returns: 
        ----- 
        True if smooth edges share hardness with the base cage

        Parameters:
        -----
        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code (see below)


        '''
        pass

    def setKeepBorderEdge(self, keepBorderEdge: bool,
                        ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        setKeepBorderEdge(self, keepBorderEdge: bool,
                        ReturnStatus: MMeshSmoothOptions.MStatus)

        Synopsis
        -----
        Sets whether or not these options specify that border edges will
        not be smoothed.

        Returns:
        -----
        None

        Parameters:
        -----
        keepBorderEdge: bool
        	[in] -> True if border edges should not be smoothed 

        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code (see below)


        '''
        pass

    def keepBorderEdge(self, ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        keepBorderEdge(self, ReturnStatus: MMeshSmoothOptions.MStatus) -> bool

        Synopsis
        -----
        Retrieves whether or not these options specify that border edges
        will not be smoothed.

        Returns: 
        ----- 
        True if border edges will not be smoothed

        Parameters:
        -----
        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code (see below)


        '''
        pass

    def setKeepHardEdge(self, keepHardEdge: bool,
                        ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        setKeepHardEdge(self, keepHardEdge: bool,
                        ReturnStatus: MMeshSmoothOptions.MStatus)

        Synopsis
        -----
        Sets whether or not these options specify that hard edges will
        not be smoothed.

        Returns:
        -----
        None

        Parameters:
        -----
        keepHardEdge: bool
        	[in] -> True if hard edges should not be smoothed 

        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code (see below)


        '''
        pass

    def keepHardEdge(self, ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        keepHardEdge(self, ReturnStatus: MMeshSmoothOptions.MStatus) -> bool

        Synopsis
        -----
        Retrieves whether or not these options specify that hard edges
        will not be smoothed.

        Returns: 
        ----- 
        True if hard edges will not be smoothed

        Parameters:
        -----
        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code (see below)


        '''
        pass

    def setBoundaryRule(self, rule: MMeshSmoothOptions.MMeshSmoothOptions,
                        ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        setBoundaryRule(self, rule: MMeshSmoothOptions.MMeshSmoothOptions,
                        ReturnStatus: MMeshSmoothOptions.MStatus)

        Synopsis
        -----
        Set the rule used to determine how boundary edges and vertices
        are creased. By default, creases are automatically applied to all
        boundary edges and all vertices that have only 2 incident edges
        prior to being converted to a smooth mesh.The possible rules are:

        Returns:
        -----
        None

        Parameters:
        -----
        rule: MMeshSmoothOptions.MMeshSmoothOptions
        	[in] -> to apply 

        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code


        '''
        pass

    def boundaryRule(self, ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        boundaryRule(self, ReturnStatus: MMeshSmoothOptions.MStatus) -> MMeshSmoothOptions.MMeshSmoothOptions

        Synopsis
        -----
        Returns the current value for the boundary rule. See
        setBoundaryRule() for more details.

        Returns: 
        ----- 
        Boundary rule.

        Parameters:
        -----
        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code


        '''
        pass

    def setOpenSubdivVertexBoundary(self, rule: MMeshSmoothOptions.MMeshSmoothOptions,
                        ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        setOpenSubdivVertexBoundary(self, rule: MMeshSmoothOptions.MMeshSmoothOptions,
                        ReturnStatus: MMeshSmoothOptions.MStatus)

        Synopsis
        -----
        Set the rule used to determine how boundary edges and vertices
        are creased. The possible rules are:

        Returns:
        -----
        None

        Parameters:
        -----
        rule: MMeshSmoothOptions.MMeshSmoothOptions
        	[in] -> to apply 

        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code


        '''
        pass

    def openSubdivVertexBoundary(self, ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        openSubdivVertexBoundary(self, ReturnStatus: MMeshSmoothOptions.MStatus) -> MMeshSmoothOptions.MMeshSmoothOptions

        Synopsis
        -----
        Returns the current value for the vertex boundary rule. See
        setOpenSubdivVertexBoundary() for more details.

        Returns: 
        ----- 
        Vertex Boundary.

        Parameters:
        -----
        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code


        '''
        pass

    def setOpenSubdivFaceVaryingBoundary(self, rule: MMeshSmoothOptions.MMeshSmoothOptions,
                        ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        setOpenSubdivFaceVaryingBoundary(self, rule: MMeshSmoothOptions.MMeshSmoothOptions,
                        ReturnStatus: MMeshSmoothOptions.MStatus)

        Synopsis
        -----
        Set the boundary rule used to determine how face varying data is
        interpolated. Specifically this determines how UVs are smoothed
        by OpenSubdiv becease UVs are treated as face varying data.The
        possible rules are:

        Returns:
        -----
        None

        Parameters:
        -----
        rule: MMeshSmoothOptions.MMeshSmoothOptions
        	[in] -> to apply 

        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code


        '''
        pass

    def openSubdivFaceVaryingBoundary(self, ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        openSubdivFaceVaryingBoundary(self, ReturnStatus: MMeshSmoothOptions.MStatus) -> MMeshSmoothOptions.MMeshSmoothOptions

        Synopsis
        -----
        Returns the current value for the face varing (UV) boundary rule.
        See setOpenSubdivFaceVaryingBoundary() for more details.

        Returns: 
        ----- 
        UV Smoothing.

        Parameters:
        -----
        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code


        '''
        pass

    def setOpenSubdivSmoothTriangles(self, smoothTriangles: bool,
                        ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        setOpenSubdivSmoothTriangles(self, smoothTriangles: bool,
                        ReturnStatus: MMeshSmoothOptions.MStatus)

        Synopsis
        -----
        Sets whether or not "smooth triangles" is enabled.

        Returns:
        -----
        None

        Parameters:
        -----
        smoothTriangles: bool
        	[in] -> True if smooth triangles is to be enabled. 

        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code (see below)


        '''
        pass

    def openSubdivSmoothTriangles(self, ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        openSubdivSmoothTriangles(self, ReturnStatus: MMeshSmoothOptions.MStatus) -> bool

        Synopsis
        -----
        Retrieves whether or not smooth triangles is enabled.

        Returns: 
        ----- 
        True if smooth triangles is enabled.

        Parameters:
        -----
        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code (see below)


        '''
        pass

    def setOpenSubdivCreaseMethod(self, method: MMeshSmoothOptions.MMeshSmoothOptions,
                        ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        setOpenSubdivCreaseMethod(self, method: MMeshSmoothOptions.MMeshSmoothOptions,
                        ReturnStatus: MMeshSmoothOptions.MStatus)

        Synopsis
        -----
        Set the OpenSubdiv crease method. The possible rules are:

        Returns:
        -----
        None

        Parameters:
        -----
        method: MMeshSmoothOptions.MMeshSmoothOptions
        	[in] -> to apply 

        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code


        '''
        pass

    def openSubdivCreaseMethod(self, ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        openSubdivCreaseMethod(self, ReturnStatus: MMeshSmoothOptions.MStatus) -> MMeshSmoothOptions.MMeshSmoothOptions

        Synopsis
        -----
        Returns the current OpenSubdiv crease method. See
        setOpenSubdivCreaseMethod() for more details.

        Returns: 
        ----- 
        Crease method.

        Parameters:
        -----
        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code


        '''
        pass

    def setSubdivisionType(self, subdivision: MMeshSmoothOptions.MMeshSmoothOptions,
                        ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        setSubdivisionType(self, subdivision: MMeshSmoothOptions.MMeshSmoothOptions,
                        ReturnStatus: MMeshSmoothOptions.MStatus)

        Synopsis
        -----
        Set the subdivision algorithm used to control mesh smoothing. The
        default subdivision algorithm is Maya Catmull-Clark.

        Returns:
        -----
        None

        Parameters:
        -----
        subdivision: MMeshSmoothOptions.MMeshSmoothOptions
        	[in] -> algorithm to use 

        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code


        '''
        pass

    def subdivisionType(self, ReturnStatus: MMeshSmoothOptions.MStatus): 
        '''
        subdivisionType(self, ReturnStatus: MMeshSmoothOptions.MStatus) -> MMeshSmoothOptions.MMeshSmoothOptions

        Synopsis
        -----
        Returns the current value for the subdivision type. See
        setSubdivisionType() for more details.

        Returns: 
        ----- 
        Subdivision type.

        Parameters:
        -----
        ReturnStatus: MMeshSmoothOptions.MStatus
        	[out] -> Status code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class SubdivisionType:
    '''Specifies subdivision algorithm to use for mesh smoothing. 
    Non-functional class.  Values for this enum:
    kInvalidSubdivision
    kCatmullClark
    kOpenSubdivCatmullClarkUniform
    kOpenSubdivCatmullClarkAdaptive
    kLastSubdivision
    '''

    def __init__(self):
        pass

    def kInvalidSubdivision(self):
        '''This is an enum of SubdivisionType.
        - Description: Invalid value. 
        - Value: -1
        '''
        pass

    def kCatmullClark(self):
        '''This is an enum of SubdivisionType.
        - Description: Maya Catmull-Clark. 
        - Value: 0
        '''
        pass

    def kOpenSubdivCatmullClarkUniform(self):
        '''This is an enum of SubdivisionType.
        - Description: OpenSubdiv Uniform. 
        - Value: 2
        '''
        pass

    def kOpenSubdivCatmullClarkAdaptive(self):
        '''This is an enum of SubdivisionType.
        - Description: OpenSubdiv Adaptive. 
        - Value: 3
        '''
        pass

    def kLastSubdivision(self):
        '''This is an enum of SubdivisionType.
        - Description: Last enum value. 
        - Value: 4
        '''
        pass

class BoundaryRule:
    '''Specifies how to apply boundary creasing to subd poly object. 
    Non-functional class.  Values for this enum:
    kInvalid
    kLegacy
    kCreaseAll
    kCreaseEdge
    kLast
    '''

    def __init__(self):
        pass

    def kInvalid(self):
        '''This is an enum of BoundaryRule.
        - Description: Invalid value. 
        - Value: -1
        '''
        pass

    def kLegacy(self):
        '''This is an enum of BoundaryRule.
        - Description: Uses the legacy algorithm, which performed no creasing. 
        - Value: 0
        '''
        pass

    def kCreaseAll(self):
        '''This is an enum of BoundaryRule.
        - Description: Crease boundary edges & vertices with valence of exactly 2. 
        - Value: 1
        '''
        pass

    def kCreaseEdge(self):
        '''This is an enum of BoundaryRule.
        - Description: Crease boundary edges only. 
        - Value: 2
        '''
        pass

    def kLast(self):
        '''This is an enum of BoundaryRule.
        - Description: Last enum value. 
        - Value: 3
        '''
        pass

class OpenSubdivVertexBoundary:
    '''OpenSubdiv vertex boundary rules. 
    Non-functional class.  Values for this enum:
    kInvalidBoundary
    kNone
    kSharpEdgesAndCorners
    kSharpEdges
    kAlwaysSharp
    kLastBoundary
    '''

    def __init__(self):
        pass

    def kInvalidBoundary(self):
        '''This is an enum of OpenSubdivVertexBoundary.
        - Description: Invalid value. 
        - Value: -1
        '''
        pass

    def kNone(self):
        '''This is an enum of OpenSubdivVertexBoundary.
        - Description: None. 
        - Value: 0
        '''
        pass

    def kSharpEdgesAndCorners(self):
        '''This is an enum of OpenSubdivVertexBoundary.
        - Description: Don't smooth edges & corners. 
        - Value: 1
        '''
        pass

    def kSharpEdges(self):
        '''This is an enum of OpenSubdivVertexBoundary.
        - Description: Don't smooth edges. 
        - Value: 2
        '''
        pass

    def kAlwaysSharp(self):
        '''This is an enum of OpenSubdivVertexBoundary.
        - Description: Use legacy boundary rules. 
        - Value: 3
        '''
        pass

    def kLastBoundary(self):
        '''This is an enum of OpenSubdivVertexBoundary.
        - Description: Last enum value. 
        - Value: 4
        '''
        pass

class OpenSubdivCreaseMethod:
    '''OpenSubdiv crease method. 
    Non-functional class.  Values for this enum:
    kInvalidCreaseMethod
    kNormal
    kChaikin
    kLastCreaseMethod
    '''

    def __init__(self):
        pass

    def kInvalidCreaseMethod(self):
        '''This is an enum of OpenSubdivCreaseMethod.
        - Description: Invalid value. 
        - Value: -1
        '''
        pass

    def kNormal(self):
        '''This is an enum of OpenSubdivCreaseMethod.
        - Description: Normal crease method. 
        - Value: 0
        '''
        pass

    def kChaikin(self):
        '''This is an enum of OpenSubdivCreaseMethod.
        - Description: Chaikin crease method. 
        - Value: 1
        '''
        pass

    def kLastCreaseMethod(self):
        '''This is an enum of OpenSubdivCreaseMethod.
        - Description: Last enum value. 
        - Value: 2
        '''
        pass

class MMessage:
    '''Message base class.
This is the base class for message callbacks. This base class
allows the user to remove a message callback. To register a
callback, the user must use the addCallback methods in the
message classes which inherit from this base class.
When a callback is added a number or id is returned. This id is
used to keep track of the callback and is necessary for removing
it. A callback id with the value 'NULL' represents an invalid
callback. Use the removeCallback member function of this class
for removing a callback.
It is the user's responsibility to keep track of the callback
id's and remove all callbacks for a plug-in when it is unloaded.
Care must be taken when a callback executes while Maya is reading
a scene file as the scene may be temporarily in an inconsistent
state, which could give incorrect results.
For example, consider a scene which has two nodes, X and Y, with
a connection from
 to
. A "node added" message (see
MDGMessage::addNodeAddedCallback) will be sent out for Y as soon as it is added to the scene, but
before the connection has been made to
. If a callback were to read the value of
 at this point it would get the wrong result.
The difficulties are compounded by the fact that Maya's normal
Dependency Graph evaluation and dirty propagation mechanisms are
disabled during a file read. In our example above, retrieving the
value of
 will mark the plug as clean. When the connection is from
 is subsequently made, Y.in won't be marked dirty because dirty
propagation is disabled. As a result, when the file read has
completed and Maya draws the new scene,
 will not be re-evaluated which may produce an error in the draw.
For these reasons, callbacks should avoid querying or modifying
the DG in any way during file read. They should not add or remove
nodes, make or break connections, change parenting, set or
retrieve plug values, etc. Even something as innocuous as a call
to
MFnDagNode::isIntermediateObject may cause problems since it queries the value of the node's
 plug. All such actions should be postponed until the file read
has completed.
'''
    def __init__(self):
        pass


    def removeCallback(self, id: MCallbackId): 
        '''
        removeCallback(self, id: MCallbackId)

        Synopsis
        -----
        Remove the specified callback from maya. This method must be
        called for all callbacks registered by a plug-in before that
        plug-in is unloaded.

        Returns:
        -----
        None

        Parameters:
        -----
        id: MCallbackId
        	[in] -> identifier of callback to be removed


        '''
        pass

    def removeCallbacks(self, idList: MCallbackIdArray): 
        '''
        removeCallbacks(self, idList: MCallbackIdArray)

        Synopsis
        -----
        Remove all of the specified callbacks from maya. This method must
        be called for all callbacks registered by a plug-in before that
        plug-in is unloaded.

        Returns:
        -----
        None

        Parameters:
        -----
        idList: MCallbackIdArray
        	[in] -> identifier list of callbacks to be removed


        '''
        pass

    def currentCallbackId(self, ReturnStatus: MMessage.MStatus): 
        '''
        currentCallbackId(self, ReturnStatus: MMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        Return the callback ID of the currently executing callback. If
        called outside of a callback, an invalid MCallbackId and failed
        status will be returned.

        Returns: 
        ----- 
        Callback ID of currently executing callback

        Parameters:
        -----
        ReturnStatus: MMessage.MStatus
        	[in] -> Status code


        '''
        pass

    def nodeCallbacks(self, node: MObject,
                        ids: MCallbackIdArray): 
        '''
        nodeCallbacks(self, node: MObject,
                        ids: MCallbackIdArray)

        Synopsis
        -----
        Returns a list of callback IDs associated registered to a given
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        node: MObject
        	[in] -> Node to query for callbacks. 

        ids: MCallbackIdArray
        	[out] -> MCallbackId array to store the list of callback IDs.


        '''
        pass

    def stopRegisteringCallableScript(self): 
        '''
        stopRegisteringCallableScript(self)

        Synopsis
        -----
        Introduced in 2019.0 Stop this MMessage object from being
        passed.This could be due to a validation error as SWIG is
        automatically setting fRegisteringCallableScript to true prior to
        validating arguments.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setCallableInfo(self, info: MMessage.MPluginCallableInfo): 
        '''
        setCallableInfo(self, info: MMessage.MPluginCallableInfo) -> staticvoid

        Synopsis
        -----
        Introduced in 2020.0

        Returns:
        -----
        None

        Parameters:
        -----
        info: MMessage.MPluginCallableInfo
        	[in] -> 


        '''
        pass

    def getCallableInfo(self): 
        '''
        getCallableInfo(self) -> static MPluginCallableInfo*

        Synopsis
        -----
        Introduced in 2020.0

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def stealCallableInfo(self): 
        '''
        stealCallableInfo(self) -> static MPluginCallableInfo*

        Synopsis
        -----
        Introduced in 2020.0

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class Action:
    '''Callback result action codes. 
    Non-functional class.  Values for this enum:
    kDefaultAction
    kDoNotDoAction
    kDoAction
    '''

    def __init__(self):
        pass

    def kDefaultAction(self):
        '''This is an enum of Action.
        - Description: do the action or not, whatever is the default 
        - Value: 0
        '''
        pass

    def kDoNotDoAction(self):
        '''This is an enum of Action.
        - Description: do not do the action 
        - Value: 1
        '''
        pass

    def kDoAction(self):
        '''This is an enum of Action.
        - Description: do the action 
        - Value: 2
        '''
        pass

class MModelMessage:
    '''Scene messages.
This class is used to register callbacks for model related
messages.
The addCallback method registers a function that will be executed
whenever the specified message occurs. An id is returned and is
used to remove the callback.
To remove a callback use
MMessage::removeCallback. All callbacks that are registered by a plug-in must be removed
by that plug-in when it is unloaded. Failure to do so will result
in a fatal error.
'''
    def __init__(self):
        pass


    def addCallback(self, msg: MModelMessage.MModelMessage,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MModelMessage.MStatus): 
        '''
        addCallback(self, msg: MModelMessage.MModelMessage,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MModelMessage.MStatus) -> MModelMessage.OPENMAYA_MAJOR_NAMESPACE_OPENMCallbackId

        Synopsis
        -----
        Adds a new callback for the specified model message.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        msg: MModelMessage.MModelMessage
        	[in] -> the model message that will trigger the callback 

        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> user data that will be passed to the callback function 

        ReturnStatus: MModelMessage.MStatus
        	[out] -> Status code


        '''
        pass

    def addBeforeDuplicateCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MModelMessage.MStatus): 
        '''
        addBeforeDuplicateCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MModelMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        Before duplicate callback. This method registers a callback that
        is called whenever a duplicate command is made.The callback will
        be called before anything is duplicated.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MModelMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addPostDuplicateNodeListCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MModelMessage.MStatus): 
        '''
        addPostDuplicateNodeListCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MModelMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        After duplicate callback, with nodes (originals and duplicates)
        provided in their own lists. This method registers a callback
        that is called after a duplicate command is made.The callback
        will be called after everything is duplicated, and provides a
        list of originals and duplicates, each in their own MObject
        arrays.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MModelMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addAfterDuplicateCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MModelMessage.MStatus): 
        '''
        addAfterDuplicateCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MModelMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        After duplicate callback. This method registers a callback that
        is called after a duplicate command is made.The callback will be
        called after everything is duplicated.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MModelMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addNodeAddedToModelCallback(self, dagNode: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MModelMessage.MStatus): 
        '''
        addNodeAddedToModelCallback(self, dagNode: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MModelMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        Node added to model message. This method registers a callback
        that is called when a dag node is about to be added to the Maya
        model.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        dagNode: MObject
        	[in] -> Node that should acquire the callback 

        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MModelMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addNodeRemovedFromModelCallback(self, dagNode: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MModelMessage.MStatus): 
        '''
        addNodeRemovedFromModelCallback(self, dagNode: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MModelMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        Node removed from model message. This method registers a callback
        that is called when the specified dag node is being removed from
        the Maya model.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        dagNode: MObject
        	[in] -> Node that should acquire the callback 

        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MModelMessage.MStatus
        	[out] -> status code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class Message:
    '''Message types supported by the addCallback method. 
    Non-functional class.  Values for this enum:
    kActiveListModified
    '''

    def __init__(self):
        pass

    def kActiveListModified(self):
        '''This is an enum of Message.
        - Description: active selection changes 
        - Value: 0
        '''
        pass

class MNamespace:
    '''Namespace.
The
MNamespace class contains methods for efficiently accessing Maya's
namespace functionality. In Maya, namespaces form a packaging
scheme for defining collections of objects. You can also have a
namespace contain other namespaces and thus define a hierarchy.
In Maya, namespaces are used by default with file referencing to
collect all the objects from the given referenced file.
Namespaces are also used for naming UI elements, and of course
the user can create namespaces on their own to collect objects
together in a logical fashion.
Here are some important definitions:
When specifying the name of an object in a namespace, the
namespace name should prefix the name, separated by a colon
character (":"). There is a special namespace, the root
namespace, which lives at the root of the namespace tree. In
effect, the name of the root namespace is the empty string. For
example, if we have the object "sphere" and it exists in the root
namespace, we could use ":sphere" to identify it.
Since namespaces can be hierarchical, when completely specifying
a name one could have several colons and namespaces names in the
pathname. If we have the namespace ":a:b:c" that contains the
object "sphere", the full namepath for the object would be thus:
The leading colon specifies that the namespace lookup occur from
the root-level downwards. In effect, the namespace "a" is a child
of the root namespace, and "b" is a child of "a", and "c" a child
of "b".
Maya has the concept of a "current" namespace. On startup, this
defaults to the root namespace. Some operations within Maya are
based off the current namespace. For example, if the 'parent'
parameter is not specified to
MNamespace::addNamespace() then the newly created namespace will be a child of the current
namespace.
Maya actually has the concept of name lookup based off the
current namespace as opposed to lookup based off the root-level
namespace which is the default behaviour. In relative mode, if we
had the object ":a:b:c:sphere" and the current namespace were
":a:b", we would refer to the sphere as "c:sphere". Similarly, by
setting the current namespace to be ":a:b:c" we could then refer
directly to sphere in an operation such as a "setAttr", e.g.
If relative mode is off, names are root-relative, thus we would
need to refer to the sphere as follows. Note that when relative
mode is off, Maya assumes the root namespace to base name lookups
on:
Also, we can always specify an absolute namepath (one that starts
with a leading colon). An absolute namepath will work with
relative name lookup enabled or disabled and is thus an easy way
of referring to objects in a way that is name lookup-independent.
The relative mode feature is designed to allow users to write
namespace-independent code which is intended to operate upon
whatever namespace is current. The method
MNamespace::currentNamespace() allows you to query the name of the current namespace.
Relative mode can ge toggled using either
MNamespace::setRelativeNames() or the "namespace" command. Turning relative mode "off" causes
name lookup to be based off the root namespace. Continuing our
example where the current namespace is ":a:b" to refer to the
sphere we would now need to use:
Maya provides the "namespace" and "namespaceInfo" commands for
dealing with namespaces from the command level, and there are
also UI features which control and edit namespaces. All of these
work harmoniously with the
MNamespace class.
It is important that any user code which exercises
MNamespace methods that modify (rather than query) handle undo. For
example, if writing a plug-in command that creates a new
namespace, the plug-in needs to handle removal of the namespace
on undo.
The
MNamespace class contains methods to create and remove namespaces, set and
query the current namespace, and edit and query the contents of
namespaces.
To add individual objects to a namespace, use
MSelectionList::add() which is well suited for handling multiple objects having the
same name as well as hierarchical namespaces.
'''
    def __init__(self):
        pass


    def addNamespace(self, name: MString,
                        parent: MString): 
        '''
        addNamespace(self, name: MString,
                        parent: MString) -> MNamespace.OPENMAYA_MAJOR_NAMESPACE_OPEN MStatus

        Synopsis
        -----
        Create the namespace `name'. If the `parent' namespace is given
        the new namespace will be a child of `parent', otherwise the new
        namespace will be a child of the current namespace. The new
        namespace is added, but not made current. To make the new
        namespace be current use MNamespace::setCurrentNamespace(). Note
        that adding a namespace changes the scene, so any code that calls
        this method needs to handle undo.

        Returns: 
        ----- 
        The return status code.

        Parameters:
        -----
        name: MString
        	[in] -> The new namespace to create. A qualified or unqualified name may be used. If a qualified name is used and one or more of the higher level namespaces do not already exist, they will be created automatically. For example, if the new name is "a:b:c" and "a" does not yet exist, then it will be created automatically and "b" automatically created beneath it and finally "c" will be created beneath "b". If the supplied name contains invalid characters it will first be modified as per the 

        parent: MString
        	[in] -> The fully qualified name of the namespace under which the new one is to be created. If not provided then the current namespace will be used. If the name of the new namespace is absolute (i.e. begins with a colon, ":a:b:c") then the 'parent' parameter will be ignored and the new namespace will be created under the root namespace.


        '''
        pass

    def validateName(self, name: MString,
                        ReturnStatus: MNamespace.MStatus): 
        '''
        validateName(self, name: MString,
                        ReturnStatus: MNamespace.MStatus) -> MString

        Synopsis
        -----
        Convert the specified name to a validated name which contains no
        illegal characters. The leading illegal characters will be
        removed and other illegal characters will be converted to '_'.For
        example, name "@name@space@" will be converted to
        "name_space_".If the entire name consists solely of illegal
        characters, e.g. "123" which contains only leading digits, then
        the returned string will be empty.

        Returns: 
        ----- 
        The validated name which contains no illegal characters.

        Parameters:
        -----
        name: MString
        	[in] -> the specified name 

        ReturnStatus: MNamespace.MStatus
        	[out] -> optionally returns the status code.


        '''
        pass

    def currentNamespace(self, ReturnStatus: MNamespace.MStatus): 
        '''
        currentNamespace(self, ReturnStatus: MNamespace.MStatus) -> MString

        Synopsis
        -----
        Get the name of the current namespace. This name is returned as
        an absolute namepath (i.e. fully qualfied from the root namespace
        downwards, ":a:b:c").

        Returns: 
        ----- 
        The name of the current namespace as an absolute namepath.

        Parameters:
        -----
        ReturnStatus: MNamespace.MStatus
        	[out] -> optionally returns the status code.


        '''
        pass

    def setCurrentNamespace(self, name: MString): 
        '''
        setCurrentNamespace(self, name: MString)

        Synopsis
        -----
        Set the specified namespace to be the current namespace. The
        `name' parameter you specify is relative to whatever namespace is
        current, but any namespace can be specified by passing an
        absolute name (e.g. :a:b:c). Note that making a namespace current
        changes the scene, so any code that calls this method needs to
        handle undo.To make the root namespace become current, use:status
        =MNamespace::setCurrentNamespace(MNamespace::rootNamespace());

        Returns:
        -----
        None

        Parameters:
        -----
        name: MString
        	[in] -> the name of the namespace to make current.


        '''
        pass

    @overload
    def getNamespaces(self, recurse: bool,
                        ReturnStatus: MNamespace.MStatus): 
        '''
        getNamespaces(self, recurse: bool,
                        ReturnStatus: MNamespace.MStatus) -> MStringArray

        Synopsis
        -----
        Return a list of all namespaces in the current namespace. Notes:
        1) Names returned are always absolute (e.g. :a:b:sphere). 2) The
        list returned is just the child namespaces (and descendents if
        `recurse' is true). It thus never contains the root namespace in
        the list returned.

        Returns: 
        ----- 
        The list of namespaces in the current namespace.

        Parameters:
        -----
        recurse: bool
        	[in] -> optional parameter to control whether all namespaces or just top-level namespaces are returned. A value of false (the default if unspecified) causes only the top-level namespaces to be returned. If true, all namespaces will be listed. 

        ReturnStatus: MNamespace.MStatus
        	[out] -> optionally returns the status code.


        '''
        pass

    @overload
    def getNamespaces(self, parentNamespace: MString,
                        recurse: bool,
                        ReturnStatus: MNamespace.MStatus): 
        '''
        getNamespaces(self, parentNamespace: MString,
                        recurse: bool,
                        ReturnStatus: MNamespace.MStatus) -> MStringArray

        Synopsis
        -----
        Return a list of all child namespaces of `parentNamespace', with
        the option to list only direct children versus all descendents.
        To list ALL namespaces in Maya, from the root downwards, specify
        the root namespace, i.e.:MStringArray namespaces; namespaces =
        MNamepsace::getNamespaces( MNamespace::rootNamespace() );Note:
        names returned are always absolute (e.g. :a:b:sphere).

        Returns: 
        ----- 
        The list of namespaces in the namespace specified via the
        'namespacesToQuery' parameter.

        Parameters:
        -----
        parentNamespace: MString
        	[in] -> the namespace to query. 

        recurse: bool
        	[in] -> optional parameter to control whether all descendents or just the direct children are returned. A value of false (the default if unspecified) causes only the direct children of `parentNamespace' to be listed. A value of true causes all descendent namespaces to be returned. 

        ReturnStatus: MNamespace.MStatus
        	[out] -> optionally returns the status code.


        '''
        pass

    def namespaceExists(self, name: MString,
                        ReturnStatus: MNamespace.MStatus): 
        '''
        namespaceExists(self, name: MString,
                        ReturnStatus: MNamespace.MStatus) -> bool

        Synopsis
        -----
        Check if a given namespace exists.

        Returns: 
        ----- 
        true the namespace with the given name exists.  false the
        namespace with the given name does not exist.

        Parameters:
        -----
        name: MString
        	[in] -> the name of the namespace to search for. 

        ReturnStatus: MNamespace.MStatus
        	[out] -> optionally returns the status code.


        '''
        pass

    def parentNamespace(self, ReturnStatus: MNamespace.MStatus): 
        '''
        parentNamespace(self, ReturnStatus: MNamespace.MStatus) -> MString

        Synopsis
        -----
        Get the name of the current namespace's parent. This name is
        returned as an absolute namepath (i.e. fully qualfied from the
        root namespace downwards, ":a:b"). If the root namespace is
        current, this method returns an error.

        Returns: 
        ----- 
        The name of the current namespace's parent as an absolute
        namepath.

        Parameters:
        -----
        ReturnStatus: MNamespace.MStatus
        	[out] -> optionally returns the status code.


        '''
        pass

    def removeNamespace(self, name: MString,
                        removeContents: bool): 
        '''
        removeNamespace(self, name: MString,
                        removeContents: bool)

        Synopsis
        -----
        Remove the specified namespace. Note that removing a namespace
        changes the scene, so any code that calls this method needs to
        handle undo.

        Returns:
        -----
        None

        Parameters:
        -----
        name: MString
        	[in] -> specifies the namespace to remove. 

        removeContents: bool
        	[in] -> detemine if remove contents of namespace


        '''
        pass

    def renameNamespace(self, oldName: MString,
                        newName: MString,
                        parent: MString): 
        '''
        renameNamespace(self, oldName: MString,
                        newName: MString,
                        parent: MString)

        Synopsis
        -----
        Rename the specified namespace to a new name with optional parent
        name. Note that removing a namespace changes the scene, so any
        code that calls this method needs to handle undo.

        Returns:
        -----
        None

        Parameters:
        -----
        oldName: MString
        	[in] -> the name of the namespace to rename. 

        newName: MString
        	[in] -> the new name for the namespace. If the supplied name contains invalid characters it will first be modified as per the 

        parent: MString
        	[in] -> optionally provides the name of the new parent.


        '''
        pass

    def getNamespaceObjects(self, parentNamespace: MString,
                        recurse: bool,
                        ReturnStatus: MNamespace.MStatus): 
        '''
        getNamespaceObjects(self, parentNamespace: MString,
                        recurse: bool,
                        ReturnStatus: MNamespace.MStatus) -> MObjectArray

        Synopsis
        -----
        Return an array of MObjects representing the object contained
        within the specified namespace. To query the current namespace,
        call this method in this way:MObjectArray objs; objs =
        MNamespace::getNamespaceObjects( MNamespace::currentNamespace() )

        Returns: 
        ----- 
        The list of objects that belong to the namespace specified by the
        'parentNamespace' parameter. If the 'recurse' parameter was also
        specified as true, the list will contain the objects belonging to
        any child namespaces.

        Parameters:
        -----
        parentNamespace: MString
        	[in] -> namepath of namespace to query. 

        recurse: bool
        	[in] -> Optional parameter to control whether objects within all descendant namespaces should be returned, or only objects within the specified namespace `parentNamespace' should be returned. 

        ReturnStatus: MNamespace.MStatus
        	[out] -> optionally returns the status code.


        '''
        pass

    def moveNamespace(self, src: MString,
                        dst: MString,
                        force: bool): 
        '''
        moveNamespace(self, src: MString,
                        dst: MString,
                        force: bool)

        Synopsis
        -----
        Move the contents of the namespace `src' into the namespace
        `dst'. Note that moving namespace contents changes the scene, so
        any code that calls this method needs to handle undo.

        Returns:
        -----
        None

        Parameters:
        -----
        src: MString
        	[in] -> source namespace from which objects will be moved. 

        dst: MString
        	[in] -> destination namespace to which objects will be moved. 

        force: bool
        	[in] -> optional parameter which if true forces the move even if name clashes occur, in which case nodes are renamed to ensure uniqueness. If false, the move will not happen if there are clashes. The default value is false.


        '''
        pass

    def rootNamespace(self, ReturnStatus: MNamespace.MStatus): 
        '''
        rootNamespace(self, ReturnStatus: MNamespace.MStatus) -> MString

        Synopsis
        -----
        Get the name of the root namespace. This name is an absolute
        namepath (i.e. prefixed by a ":"). An example use of this method
        would be to set the current namespace to the root namespace, and
        this could be done as follows:status=MNamespace::setCurrentNamesp
        ace(MNamespace::rootNamespace());Another example would be to test
        if the current namespace is the root, e.g.if (
        MNamespace::currentNamespace() == MNamespace::rootNamespace() ) {

        Returns: 
        ----- 
        The name of the root namespace as an absolute namepath.

        Parameters:
        -----
        ReturnStatus: MNamespace.MStatus
        	[out] -> optionally returns the status code from the operation.


        '''
        pass

    def relativeNames(self, ReturnStatus: MNamespace.MStatus): 
        '''
        relativeNames(self, ReturnStatus: MNamespace.MStatus) -> bool

        Synopsis
        -----
        Query Maya's current "relative name lookup" state. Relative name
        lookup causes lookups to be relative to the current namespace. By
        default, relative name lookup in Maya is off, which causes name
        lookups to be relative to the root namespace. For example, if you
        have the object :a:b:sphere, and the current namespace is ":a:b",
        in relative name lookup mode you can issue a command likesetAttr
        sphere.translateX 10;If relative name lookup is off, you need to
        specify the full namepath, e.g.setAttr a:b:sphere.translateX 10;

        Returns: 
        ----- 
        true if relatve name lookup is on, false otherwise.

        Parameters:
        -----
        ReturnStatus: MNamespace.MStatus
        	[out] -> returns the status of the query.


        '''
        pass

    def setRelativeNames(self, newState: bool): 
        '''
        setRelativeNames(self, newState: bool)

        Synopsis
        -----
        Set relative name lookup mode. Note that turning on or off
        relativeNames mode can change the scene, so any code that calls
        this method needs to handle undo. See MNamespace::relativeNames()
        for details on relative name lookup.Note: relative name lookup
        mode is intended for bracketing user code which needs to be
        namespace-independent. Leaving relative name lookup enabled
        outside of your specific code could cause functionality such as
        3rd-party plugins that assume absolute name lookup to fail.

        Returns:
        -----
        None

        Parameters:
        -----
        newState: bool
        	[in] -> true to turn on relative name lookup, false to turn it off. Maya's default setting is false.


        '''
        pass

    def getNamespaceFromName(self, fullName: MString,
                        ReturnStatus: MNamespace.MStatus): 
        '''
        getNamespaceFromName(self, fullName: MString,
                        ReturnStatus: MNamespace.MStatus) -> MString

        Synopsis
        -----
        Get namespace from a full name. For example, given a full name:
        "a:b:c:d:ball" this method would return: "a:b:c:d".NOTE: there is
        no testing to ensure that the name actually refers to an object
        that exists.

        Returns: 
        ----- 
        Returns the namespace from the full name.

        Parameters:
        -----
        fullName: MString
        	[in] -> the full name. 

        ReturnStatus: MNamespace.MStatus
        	[out] -> returns the status of the operation.


        '''
        pass

    def stripNamespaceFromName(self, fullName: MString,
                        ReturnStatus: MNamespace.MStatus): 
        '''
        stripNamespaceFromName(self, fullName: MString,
                        ReturnStatus: MNamespace.MStatus) -> MString

        Synopsis
        -----
        Strips the namespace from a full name. For example, given a full
        name: "a:b:c:d:ball" this method would return: "ball".NOTE: there
        is no testing to ensure that the name actually refers to an
        object that exists.

        Returns: 
        ----- 
        Returns the name part of a full name.

        Parameters:
        -----
        fullName: MString
        	[in] -> the full name. 

        ReturnStatus: MNamespace.MStatus
        	[out] -> returns the status of the operation.


        '''
        pass

    def makeNamepathAbsolute(self, namepath: MString,
                        ReturnStatus: MNamespace.MStatus): 
        '''
        makeNamepathAbsolute(self, namepath: MString,
                        ReturnStatus: MNamespace.MStatus) -> MString

        Synopsis
        -----
        Make a namepath which is relative to the root into an absolute
        namepath. For example, given the namepath "a:sphere" this method
        returns ":a:sphere". It also culls out duplicate and trailing
        separators, e.g. "a:b::c:" will return ":a:b:c".NOTE: there is no
        testing to ensure that the name actually refers to an object that
        exists.

        Returns: 
        ----- 
        The absolute namepath.

        Parameters:
        -----
        namepath: MString
        	[in] -> the root-relative namepath. 

        ReturnStatus: MNamespace.MStatus
        	[out] -> returns the status of the operation.


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MNodeClass:
    '''A class for performing node class-level operations in the
dependency graph.
MNodeClass allows the manipulation of dependency graph node classes.
Operations specific to a particular node should instead use
MFnDependencyNode.
'''
    def __init__(self):
        pass


    def typeId(self): 
        '''
        typeId(self) -> MTypeId

        Synopsis
        -----
        Returns the type id of this node class. The type is is the 4 byte
        code that is used in the binary file format to identify the type
        of this node.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def typeName(self): 
        '''
        typeName(self) -> MString

        Synopsis
        -----
        Returns the type name of this node class. The string returned is
        the name of the node type as it is used in the ascii file format.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def classification(self): 
        '''
        classification(self) -> MString

        Synopsis
        -----
        Retrieves the classification string for a node class. This is a
        string that is used in dependency nodes that are also shaders to
        provide more detailed type information to the rendering system.
        See the documentation for the MEL commands getClassification and
        listNodeTypes for information on the strings that can be
        provided.User-defined nodes set this value through a parameter to
        MFnPlugin::registerNode.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def addToClassification(self, str: MString): 
        '''
        addToClassification(self, str: MString)

        Synopsis
        -----
        Adds to the node class's classification string. See the
        classification() method, above.Adding to the classification
        string is useful in conjunction with the MSwatchRenderRegister
        API, to override the swatch rendering of built-in Maya node
        types. Adding the classification 'swatch/File' causes nodes to
        use a simple default icon instead of their usual swatch
        rendering.

        Returns:
        -----
        None

        Parameters:
        -----
        str: MString
        	[in] -> The string to add to the classification


        '''
        pass

    def removeFromClassification(self, str: MString): 
        '''
        removeFromClassification(self, str: MString)

        Synopsis
        -----
        Removes an element from the node class's classification string.
        See the classification() method, above.

        Returns:
        -----
        None

        Parameters:
        -----
        str: MString
        	[in] -> The string to remove from the classification


        '''
        pass

    def pluginName(self, ReturnStatus: MNodeClass.MStatus): 
        '''
        pluginName(self, ReturnStatus: MNodeClass.MStatus) -> MString

        Synopsis
        -----
        Returns the name of the plug-in this node class was defined in.
        The name returned is the name of the plug-in on disk, and may
        contain pathname separators (such as `/') and drive letters (e.g.
        C:).

        Returns: 
        ----- 
        The name of the plug-in

        Parameters:
        -----
        ReturnStatus: MNodeClass.MStatus
        	[out] -> return status


        '''
        pass

    def addExtensionAttribute(self, attr: MObject): 
        '''
        addExtensionAttribute(self, attr: MObject)

        Synopsis
        -----
        Adds an extension attribute to the node class. An extension
        attribute is a class-level attribute which has been added
        dynamically to a node class. Because it is added at the class
        level, all nodes of that class will have the given attribute, and
        will only store the attribute's value if it differs from the
        default.

        Returns:
        -----
        None

        Parameters:
        -----
        attr: MObject
        	[in] -> The attribute to add


        '''
        pass

    def removeExtensionAttribute(self, attr: MObject): 
        '''
        removeExtensionAttribute(self, attr: MObject)

        Synopsis
        -----
        Removes an extension attribute from the node class. An extension
        attribute is a class-level attribute which has been added
        dynamically to a node class. Because it is added at the class
        level, all nodes of that class will have the given attribute, and
        will only store the attribute's value if it differs from the
        default.

        Returns:
        -----
        None

        Parameters:
        -----
        attr: MObject
        	[in] -> The attribute to remove


        '''
        pass

    def removeExtensionAttributeIfUnset(self, attr: MObject): 
        '''
        removeExtensionAttributeIfUnset(self, attr: MObject)

        Synopsis
        -----
        Removes an extension attribute from the given dependency node
        type but only if there are no nodes in the graph with non-default
        values for this attribute. An extension attribute is a class-
        level attribute which has been added dynamically to a node class.
        Because it is added at the class level, all nodes of that class
        will have the given attribute. This method will only remove the
        attribute if any of its node values differs from the default.

        Returns:
        -----
        None

        Parameters:
        -----
        attr: MObject
        	[in] -> The attribute to remove


        '''
        pass

    def getAttributes(self, attr: MObjectArray): 
        '''
        getAttributes(self, attr: MObjectArray)

        Synopsis
        -----
        Get the list of attributes for the node class.

        Returns:
        -----
        None

        Parameters:
        -----
        attr: MObjectArray
        	[out] -> The list of attributes


        '''
        pass

    def attributeCount(self, ReturnStatus: MNodeClass.MStatus): 
        '''
        attributeCount(self, ReturnStatus: MNodeClass.MStatus) -> int

        Synopsis
        -----
        Get the number of attributes for the node class.

        Returns: 
        ----- 
        The number of attributes.

        Parameters:
        -----
        ReturnStatus: MNodeClass.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def attribute(self, index: int,
                        ReturnStatus: MNodeClass.MStatus): 
        '''
        attribute(self, index: int,
                        ReturnStatus: MNodeClass.MStatus) -> MObject

        Synopsis
        -----
        Finds the attribute of this node class at the given index. Index
        order is based on the order in which the attributes were added to
        the class.

        Returns: 
        ----- 
        The attribute, or kNullObj if no attribute existed at the given
        index

        Parameters:
        -----
        index: int
        	[in] -> the index of the attribute 

        ReturnStatus: MNodeClass.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def attribute(self, attrName: MString,
                        ReturnStatus: MNodeClass.MStatus): 
        '''
        attribute(self, attrName: MString,
                        ReturnStatus: MNodeClass.MStatus) -> MObject

        Synopsis
        -----
        Finds the attribute of this node class that has the given name.

        Returns: 
        ----- 
        The attribute, or kNullObj if no attribute with the given name
        could be found

        Parameters:
        -----
        attrName: MString
        	[in] -> name of the attribute to find 

        ReturnStatus: MNodeClass.MStatus
        	[out] -> return status


        '''
        pass

    def hasAttribute(self, attrName: MString,
                        ReturnStatus: MNodeClass.MStatus): 
        '''
        hasAttribute(self, attrName: MString,
                        ReturnStatus: MNodeClass.MStatus) -> bool

        Synopsis
        -----
        Returns true if the node class already has an attribute with the
        given name.

        Returns: 
        ----- 
        true if the node class has attribute, false otherwise.

        Parameters:
        -----
        attrName: MString
        	[in] -> Name of attribute to be checked. 

        ReturnStatus: MNodeClass.MStatus
        	[out] -> return status


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MNodeMessage:
    '''Dependency node messages.
This class is used to register callbacks for dependency node
messages of specific dependency nodes.
There are 5 add callback methods which will add callbacks for the
following messages
The first parameter passed to each of the add callback methods is
the dependency node that will trigger the callback.
Callbacks that are registered for attribute
changed/addedOrRemoved messages will be passed an
AttributeMessage value as a parameter. This value indicates the
type of attribute message that has occurred. See the
AttributeMessage enum for all available messages.
Each method returns an id which is used to remove the callback.
To remove a callback use
MMessage::removeCallback. All callbacks that are registered by a plug-in must be removed
by that plug-in when it is unloaded. Failure to do so will result
in a fatal error.
'''
    def __init__(self):
        pass


    def addAttributeChangedCallback(self, node: MObject,
                        func: MNodeMessage.MNodeMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus): 
        '''
        addAttributeChangedCallback(self, node: MObject,
                        func: MNodeMessage.MNodeMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus) -> MNodeMessage.OPENMAYA_MAJOR_NAMESPACE_OPENMCallbackId

        Synopsis
        -----
        This method registers a callback for attribute changed messages.
        See the AttributeChanged enum for a list of all possible messages
        that will trigger the callback.Note: Attribute Changed messages
        will not be generated while Maya is either in playback or
        scrubbing modes. If you need to do something during playback or
        scrubbing you will have to register a callback for the
        timeChanged message which is the only message message that is
        sent during those modes.The callback function will be passed the
        type of attribute message that has occurred, the plug(s) for the
        attributes, and any client data that the user wishes to pass
        in.Example callback ( prints out a message when a connection is
        made or broken ) :

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MObject
        	[in] -> the node to register the callback for. If this is a NULL 

        func: MNodeMessage.MNodeMessage
        	[in] -> the callback function, which takes the following parameters: 

        clientData: void
        	[in] -> User defined data that will be passed to the callback function 

        ReturnStatus: MNodeMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addAttributeAddedOrRemovedCallback(self, node: MObject,
                        func: MNodeMessage.MNodeMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus): 
        '''
        addAttributeAddedOrRemovedCallback(self, node: MObject,
                        func: MNodeMessage.MNodeMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        Registers callbacks for attribute add/removed messages. This is a
        more specific version of addAttributeChanged as only attribute
        added and attribute removed messages will trigger the callback.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MObject
        	[in] -> the node to register the callback for 

        func: MNodeMessage.MNodeMessage
        	[in] -> the callback function, which takes the following parameters: 

        clientData: void
        	[in] -> User defined data that will be passed to the callback function 

        ReturnStatus: MNodeMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addNodeDirtyCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus): 
        '''
        addNodeDirtyCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        Registers a callback for node dirty messages.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MObject
        	[in] -> the node to register the callback for 

        func: MMessage.MMessage
        	[in] -> the callback function, which takes the following parameters: 

        clientData: void
        	[in] -> User defined data that will be passed to the callback function 

        ReturnStatus: MNodeMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addNodeDirtyPlugCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus): 
        '''
        addNodeDirtyPlugCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        Registers a callback for node dirty messages. This callback
        provides the plug on the node that was dirtied. Only provides
        dirty information on input plugs.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MObject
        	[in] -> the node to register the callback for 

        func: MMessage.MMessage
        	[in] -> the callback function, which takes the following parameters: 

        clientData: void
        	[in] -> User defined data that will be passed to the callback function 

        ReturnStatus: MNodeMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addNameChangedCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus): 
        '''
        addNameChangedCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        Registers a callback for name changed messages.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MObject
        	[in] -> the node. If this is a NULL 

        func: MMessage.MMessage
        	[in] -> the callback function, which takes the following parameters: 

        clientData: void
        	[in] -> User defined data that will be passed to the callback function 

        ReturnStatus: MNodeMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addUuidChangedCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus): 
        '''
        addUuidChangedCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        Registers a callback for UUID changed messages.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MObject
        	[in] -> the node. If this is a NULL 

        func: MMessage.MMessage
        	[in] -> the callback function, which takes the following parameters: 

        clientData: void
        	[in] -> User defined data that will be passed to the callback function 

        ReturnStatus: MNodeMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addNodeAboutToDeleteCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus): 
        '''
        addNodeAboutToDeleteCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        Registers a callback which will get called when a node is about
        to be deleted. The callback will be passed the MDGModifer that
        will be used to delete the node. This modifier can be used to do
        any DG modifications, such as disconnections, before the node is
        deleted. These operations are also stored and performed when the
        deletion operation is undone or redone.The callback registered
        with this method will only get called when the deletion operation
        is first performed. Undos and redos will be handled solely
        through the MDGModifier which was passed to the callback on the
        original deletion. If you also wish to receive notification of
        deletion events when they are redone, you should register an
        additional callback using addNodePreRemovalCallback().When a node
        is deleted Maya automatically breaks all connections to that
        node. This process takes place after the callback has been
        called. This means that if you use the passed-in MDGModifier to
        break any connections to the node you must be sure to call the
        modifier's doIt() method before returning from the callback.
        Otherwise Maya will see that the connections still exist and try
        to delete them again, which can lead to errors.The example below
        shows a callback function which takes the connection coming into
        the node's input attribute and reconnects it to all of the plugs
        connected to the node's output attribute:Note that it uses the
        passed-in MDGModifier to perform all the disconnections and
        connections. This ensures that if the deletion is undone or
        redone then all of the connections will be restored
        correctly.After it is done breaking connections, the callback
        calls the modifier's doIt() method to commit those
        disconnections. As noted above, this is necessary to ensure that
        Maya doesn't see the connections and try to break them again
        later on.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MObject
        	[in] -> the node to register the callback for 

        func: MMessage.MMessage
        	[in] -> the callback function, which takes the following parameters: 

        clientData: void
        	[in] -> User defined data that will be passed to the callback function 

        ReturnStatus: MNodeMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addNodePreRemovalCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus): 
        '''
        addNodePreRemovalCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        Registers a callback which will get called before a node is
        deleted. This callback is called before connections on the node
        are removed. Unlike the aboutToDelete callback, this callback
        will be invoked whenever the node is deleted, even during a
        redo.Pre-removal and aboutToDelete callbacks serve different
        purposes. If DG changes need to be made when a node is deleted,
        the aboutToDelete callback should be used to add undoable
        operations to an MDGModifier to perform these changes. When the
        desired actions cannot be accomplished using the MDGModifier
        passed to the aboutToDelete callback, this callback can be used
        to receive notification of the deletion event, even during
        redo.Note that this callback method should not perform any DG
        operations.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MObject
        	[in] -> the node to register the callback for 

        func: MMessage.MMessage
        	[in] -> the callback function, which takes the following parameters: 

        clientData: void
        	[in] -> User defined data that will be passed to the callback function 

        ReturnStatus: MNodeMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addNodeDestroyedCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus): 
        '''
        addNodeDestroyedCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        NodeDestroyed callback. Registers a callback which will get
        called when a node's destructor is called.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MObject
        	[in] -> the node to register the callback for 

        func: MMessage.MMessage
        	[in] -> the callback function, which takes the following parameters: 

        clientData: void
        	[in] -> User defined data that will be passed to the callback function 

        ReturnStatus: MNodeMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addKeyableChangeOverride(self, plug: MPlug,
                        func: MNodeMessage.MNodeMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus): 
        '''
        addKeyableChangeOverride(self, plug: MPlug,
                        func: MNodeMessage.MNodeMessage,
                        clientData: void,
                        ReturnStatus: MNodeMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        Attribute keyable state change override. This method registers a
        callback that is invoked by any class that changes the keyable
        state of an attribute.When the callback is invoked, the API
        programmer can make a decision on how to handle the given keyable
        change event. The programmer can either accept the the keyable
        state change by returning a decision == 'true' or reject it by
        returning decision == 'false'.Note: you can only attach one
        callback keyable change override callback per attribute. It is an
        error to attach more than one callback to the same attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        plug: MPlug
        	[in] -> The plug to which to attach the callback. 

        func: MNodeMessage.MNodeMessage
        	[in] -> the callback function, which takes the following parameters: 

        clientData: void
        	[in] -> User defined data passed back to the user. 

        ReturnStatus: MNodeMessage.MStatus
        	[in] -> status code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class AttributeMessage:
    '''The type of attribute changed/addedOrRemoved messages that has occurred. 
    Non-functional class.  Values for this enum:
    kConnectionMade
    kConnectionBroken
    kAttributeEval
    kAttributeSet
    kAttributeLocked
    kAttributeUnlocked
    kAttributeAdded
    kAttributeRemoved
    kAttributeRenamed
    kAttributeKeyable
    kAttributeUnkeyable
    kIncomingDirection
    kAttributeArrayAdded
    kAttributeArrayRemoved
    kOtherPlugSet
    kLast
    '''

    def __init__(self):
        pass

    def kConnectionMade(self):
        '''This is an enum of AttributeMessage.
        - Description: a connection has been made to an attribute of this node 
        - Value: 1
        '''
        pass

    def kConnectionBroken(self):
        '''This is an enum of AttributeMessage.
        - Description: a connection has been broken for an attribute of this node 
        - Value: 2
        '''
        pass

    def kAttributeEval(self):
        '''This is an enum of AttributeMessage.
        - Description: an attribute of this node has been evaluated 
        - Value: 4
        '''
        pass

    def kAttributeSet(self):
        '''This is an enum of AttributeMessage.
        - Description: an attribute value of this node has been set 
        - Value: 8
        '''
        pass

    def kAttributeLocked(self):
        '''This is an enum of AttributeMessage.
        - Description: an attribute of this node has been locked 
        - Value: 16
        '''
        pass

    def kAttributeUnlocked(self):
        '''This is an enum of AttributeMessage.
        - Description: an attribute of this node has been unlocked 
        - Value: 32
        '''
        pass

    def kAttributeAdded(self):
        '''This is an enum of AttributeMessage.
        - Description: an attribute has been added to this node 
        - Value: 64
        '''
        pass

    def kAttributeRemoved(self):
        '''This is an enum of AttributeMessage.
        - Description: an attribute has been removed from this node 
        - Value: 128
        '''
        pass

    def kAttributeRenamed(self):
        '''This is an enum of AttributeMessage.
        - Description: an attribute of this node has had an alias added, removed, or renamed 
        - Value: 256
        '''
        pass

    def kAttributeKeyable(self):
        '''This is an enum of AttributeMessage.
        - Description: an attribute of this node has been marked keyable 
        - Value: 512
        '''
        pass

    def kAttributeUnkeyable(self):
        '''This is an enum of AttributeMessage.
        - Description: an attribute of this node has been marked unkeyable 
        - Value: 1024
        '''
        pass

    def kIncomingDirection(self):
        '''This is an enum of AttributeMessage.
        - Description: the connection was coming into the node 
        - Value: 2048
        '''
        pass

    def kAttributeArrayAdded(self):
        '''This is an enum of AttributeMessage.
        - Description: an array attribute has been added to this node 
        - Value: 4096
        '''
        pass

    def kAttributeArrayRemoved(self):
        '''This is an enum of AttributeMessage.
        - Description: an array attribute has been removed from this node 
        - Value: 8192
        '''
        pass

    def kOtherPlugSet(self):
        '''This is an enum of AttributeMessage.
        - Description: the otherPlug data has been set 
        - Value: 16384
        '''
        pass

    def kLast(self):
        '''This is an enum of AttributeMessage.
        - Description: last value of the enum 
        - Value: 32768
        '''
        pass

class KeyableChangeMsg:
    '''Allows you to prevent attributes from becoming (un)keyable. 
    Non-functional class.  Values for this enum:
    kKeyChangeInvalid
    kMakeKeyable
    kMakeUnkeyable
    kKeyChangeLast
    '''

    def __init__(self):
        pass

    def kKeyChangeInvalid(self):
        '''This is an enum of KeyableChangeMsg.
        - Description:  
        - Value: 0
        '''
        pass

    def kMakeKeyable(self):
        '''This is an enum of KeyableChangeMsg.
        - Description:  
        - Value: 1
        '''
        pass

    def kMakeUnkeyable(self):
        '''This is an enum of KeyableChangeMsg.
        - Description:  
        - Value: 2
        '''
        pass

    def kKeyChangeLast(self):
        '''This is an enum of KeyableChangeMsg.
        - Description:  
        - Value: 3
        '''
        pass

class MNurbsIntersector:
    '''Nurbs intersector.
The
MNurbsIntersector class contains methods for efficiently finding the closest point
to a NURBS surface. A tree-based algorithm is used to find the
closest point.
The
create() method builds the internal data required for the algorithm. As a
result, calls to it should be minimized as it is a heavy
operation. If the NURBS surface or matrix changes, you will need
to recreate the tree based data to correspond, again using the
create() method.
This class is not threadsafe.
'''
    def __init__(self):
        pass


    def create(self, nurbsObject: MObject,
                        matrix: MMatrix): 
        '''
        create(self, nurbsObject: MObject,
                        matrix: MMatrix)

        Synopsis
        -----
        This method creates the data required by the intersector. It is a
        heavy operation that should be called only when necessary, such
        as when the underlying NURBS surface or the matrix changes.

        Returns:
        -----
        None

        Parameters:
        -----
        nurbsObject: MObject
        	[in] -> a NURBS surface object . 

        matrix: MMatrix
        	[in] -> specify the mapping to apply for transforming points that are specified in the getClosestPoint method into the object space of the NURBS surface.


        '''
        pass

    def isCreated(self): 
        '''
        isCreated(self) -> bool

        Synopsis
        -----
        This method returns true if the intersector is created. False is
        returned otherwise.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getClosestPoint(self, point: MPoint,
                        nurbsPoint: MPointOnNurbs,
                        maxDistance: double): 
        '''
        getClosestPoint(self, point: MPoint,
                        nurbsPoint: MPointOnNurbs,
                        maxDistance: double)

        Synopsis
        -----
        This method finds the closest point. Information is returned in
        the nurbsPoint object.

        Returns:
        -----
        None

        Parameters:
        -----
        point: MPoint
        	[in] -> Specifies the location for which to evaluate the closest point on the NURBS surface. `point' is transformed using the matrix parameter passed to the 

        nurbsPoint: MPointOnNurbs
        	[out] -> Resulting closest point in object space. 

        maxDistance: double
        	[in] -> Maximum distance to consider in object space.


        '''
        pass

    def getIntersects(self, rayStartingPoint: MPoint,
                        alongThisDirection: MVector,
                        uArray: MDoubleArray,
                        vArray: MDoubleArray,
                        points: MPointArray,
                        tolerance: double): 
        '''
        getIntersects(self, rayStartingPoint: MPoint,
                        alongThisDirection: MVector,
                        uArray: MDoubleArray,
                        vArray: MDoubleArray,
                        points: MPointArray,
                        tolerance: double)

        Synopsis
        -----
        This method finds all the points of intersection of the NURBS
        surface with a ray (a vector at a point). The points are returned
        in the points object, and the U and V parameters of the points
        are returned in the uArray and vArray objects respectively.

        Returns:
        -----
        None

        Parameters:
        -----
        rayStartingPoint: MPoint
        	[in] -> Starting location of ray to test 

        alongThisDirection: MVector
        	[in] -> Direction of ray to test 

        uArray: MDoubleArray
        	[in] -> U parameters of intersection (if any) 

        vArray: MDoubleArray
        	[in] -> V parameters of intersection (if any) 

        points: MPointArray
        	[out] -> Storage for points of intersection (if any) 

        tolerance: double
        	[in] -> The epsilon value in the calculation


        '''
        pass

    def getIntersect(self, rayStartingPoint: MPoint,
                        alongThisDirection: MVector,
                        u: double,
                        v: double,
                        pntOfIntersection: MPoint,
                        tolerance: double): 
        '''
        getIntersect(self, rayStartingPoint: MPoint,
                        alongThisDirection: MVector,
                        u: double,
                        v: double,
                        pntOfIntersection: MPoint,
                        tolerance: double)

        Synopsis
        -----
        This method finds the first point of intersection of the NURBS
        surface with a ray (a vector at a point). The point is returned
        in the pntOfIntersection object, and the U and V parameters of
        the point are returned in the u and v variables respectively.

        Returns:
        -----
        None

        Parameters:
        -----
        rayStartingPoint: MPoint
        	[in] -> Starting location of ray to test 

        alongThisDirection: MVector
        	[in] -> Direction of ray to test 

        u: double
        	[out] -> U parameter of intersection (if any) 

        v: double
        	[out] -> V parameter of intersection (if any) 

        pntOfIntersection: MPoint
        	[out] -> Storage for closest point of intersection (if any) 

        tolerance: double
        	[in] -> The epsilon value in the calculation


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MObject:
    '''Generic Class for Accessing Internal Maya Objects.
Determine the exact type (
MFn::Type) of an
MObject within Maya.
Determine if an Object exists.
Determine if an Object is compatible with a specific Function
Set.
MObject is the generic class for accessing all Maya internal modelling,
animation and rendering Objects, collectively referred to as
Model Objects, through the API. This includes all Dependency
Graph (DG) Nodes, of which Directed Acyclic Graph (DAG) Nodes are
a subset.
Each instance of an
MObject represents a specific Node or Attribute on a Node in the DG.
Under the C++ class scheme MObjects simply have type
MObject with no base or derived hierarchy. However, MObjects may be many
different types of Model objects, from Attributes to transforms,
including components of geometry such as Control Vertices (CV),
faces, edges and vertices. This allows many different types of
objects to be moved accessed through the API without undue
concern on the part of plug-in developers for the type of object
being manipulated.
Since it is impractical to provide every applicable method in
MObjects, the methods applicable to Maya Objects are encapsulated
in Function Sets. Function Sets can be attached to compatible
MObjects to provide an external interface to methods appropriate
to that
MObject.
The link between an
MObject and the role it performs as a Maya Model object, as well as the
compatibility between MObjects and Function Sets is managed by
the API Run-Time Type Identification (RTTI) system. The two key
concepts of this system are the Maya Object type and the Function
Set type (both in
MFn::Type). All MObjects have one and only one Maya Object type. All
Function Sets have one and only one Function Set type. MObjects
may, however, be compatible with many types of Function Sets.
This compatibility follows the class hierarchy of the Function
Sets. Thus an
MObject with Maya Object type
MFn::kNurbsSurface would be compatible with
MFnNurbsSurface,
MFnDagNode,
MFnDependencyNode, MFnNamedObject and
MFnBase.
Use the
apiType() method to determine the type (
MFn::Type) of the Maya Model Object.
Use
hasFn() to determine if the Object is comaptible with a given Function
Set.
Use
isNull() to determine if the internal Maya Object exists.
'''
    def __init__(self):
        pass


    def hasFn(self, fs: MFn.MFn): 
        '''
        hasFn(self, fs: MFn.MFn) -> bool

        Synopsis
        -----
        Determines the whether or not the internal Object is compatible
        with the given Function Type.

        Returns: 
        ----- 
        true Is compatible  false Is not compatible, or is null (object
        does not exist).

        Parameters:
        -----
        fs: MFn.MFn
        	[in] -> Function Set type


        '''
        pass

    def isNull(self): 
        '''
        isNull(self) -> bool

        Synopsis
        -----
        Determines the whether or not an internal Object exists.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def apiType(self): 
        '''
        apiType(self) -> MFn.MFn

        Synopsis
        -----
        Determines the exact type of the Maya internal Object. If the
        object does not exist (is null), returns MFn::kInvalid.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def apiTypeStr(self): 
        '''
        apiTypeStr(self) -> char*

        Synopsis
        -----
        Returns a string that gives the object's type is a readable form.
        This is useful for debugging when type of an object needs to be
        printed.If the object does not exist (is null), returns
        "kInvalid".

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def __eq__(self, other: MObject): 
        '''
        __eq__(self, other: MObject) -> bool

        Synopsis
        -----
        The comparison operator. Returns true if both MObjects refer to
        the same Maya object.

        Returns:
        -----
        None

        Parameters:
        -----
        other: MObject
        	[in] -> 


        '''
        pass

    def __neq__(self, other: MObject): 
        '''
        __neq__(self, other: MObject) -> bool

        Synopsis
        -----
        The inequality operator. Returns true if the MObjects refer to
        different Maya objects.

        Returns:
        -----
        None

        Parameters:
        -----
        other: MObject
        	[in] -> 


        '''
        pass

class MObjectArray:
    '''Array of MObjects data type.
This class implements an array of MObjects. Common convenience
functions are available, and the implementation is compatible
with the internal Maya implementation so that it can be passed
efficiently between plugins and internal maya data structures.
'''
    def __init__(self):
        pass


    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> const MObject&

        Synopsis
        -----
        Index operator. Returns the value of the element at the given
        index. No range checking is done - valid indices are 0 to
        length()-1.

        Returns: 
        ----- 
        A reference to the indicated element

        Parameters:
        -----
        index: int
        	[in] -> the index of the desired element


        '''
        pass

    def set(self, element: MObject,
                        index: int): 
        '''
        set(self, element: MObject,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated MObject
        value.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MObject
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    def setLength(self, length: int): 
        '''
        setLength(self, length: int)

        Synopsis
        -----
        Set the length of the array. This will grow and shrink the array
        as desired. Elements that are grown have uninitialized values,
        while those which are shrunk will lose the data contained in the
        deleted elements (ie. it will release the memory).

        Returns:
        -----
        None

        Parameters:
        -----
        length: int
        	[in] -> the new size of the array 


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Returns the number of elements in the instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Remove the array element at the given index. All array elements
        following the removed element are shifted toward the first
        element.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> index of the element to be removed


        '''
        pass

    def insert(self, element: MObject,
                        index: int): 
        '''
        insert(self, element: MObject,
                        index: int)

        Synopsis
        -----
        Inserts a new value into the array at the given index. The
        initial element at that index, and all following elements, are
        shifted towards the last. If the array cannot be expanded in size
        by 1 element, then the insert will fail and the existing array
        will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MObject
        	[in] -> the new value to insert into the array 

        index: int
        	[in] -> the index of the element to set to the the new value


        '''
        pass

    def append(self, element: MObject): 
        '''
        append(self, element: MObject)

        Synopsis
        -----
        Adds a new element to the end of the array. If the array cannot
        be expanded in size by 1 element, then the append will fail and
        the existing array will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MObject
        	[in] -> the value for the new last element


        '''
        pass

    def copy(self, source: MObjectArray): 
        '''
        copy(self, source: MObjectArray)

        Synopsis
        -----
        Copy the contents of the source array to this array.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MObjectArray
        	[in] -> array to copy from


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clear the contents of the array. After this operation the length
        method will return 0. This does not change the amount of memory
        allocated to the array, only the number of valid elements in it.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setSizeIncrement(self, newIncrement: int): 
        '''
        setSizeIncrement(self, newIncrement: int)

        Synopsis
        -----
        Set the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        newIncrement: int
        	[in] -> the new increment 


        '''
        pass

    def sizeIncrement(self): 
        '''
        sizeIncrement(self) -> int

        Synopsis
        -----
        Return the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MObjectArray.MObjectArray

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MObjectArray.MObjectArray

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MObjectArray.MObjectArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MObjectArray.MObjectArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MObjectArray.MObjectArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MObjectArray.MObjectArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MObjectHandle:
    '''Generic Class for validating MObjects.
MObjectHandle is a wrapper class for the
MObject class. An
MObjectHandle will provide a user with added information on the validity of an
MObject. Each
MObjectHandle that is created registers an entry into a table to maintain
state tracking of the
MObject that the handle was created for. This will help users track when
an
MObject is invalid and should be re-retrieved.
'''
    def __init__(self):
        pass


    def object(self): 
        '''
        object(self) -> MObject

        Synopsis
        -----
        Returns the MObject associated with this handle. The returned
        MObject will be MObject::kNullObj if the object is invalid.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def objectRef(self): 
        '''
        objectRef(self) -> const MObject&

        Synopsis
        -----
        Returns the MObject associated with this handle. This provides
        read-only access to the MObject that MObjectHandle holds onto.
        This method will always return the object that belongs to
        MObjectHandle regardless of its validity. API users should use
        caution when using MObject data when it is not valid, and should
        never use the data when MObjectHandle indicates that the MObject
        is NOT alive.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def hashCode(self): 
        '''
        hashCode(self) -> int

        Synopsis
        -----
        Returns a hash code for the internal Maya object referenced by
        the MObject within this MObjectHandle. If the MObject is null or
        no longer alive then 0 will be returned, otherwise the hash code
        is guaranteed to be non-zero.The returned hash code is not
        unique: several internal Maya objects may return the same code.
        However different MObjectHandles whose MObjects refer to the same
        internal Maya object will return the same hash code.This provides
        a way for using internal Maya objects as keys in hash-based
        lookups.For example, Python dictionaries use a hash lookup, based
        on the key's __hash__() method. If you try to use MObjectHandles
        as keys in a dictionary you will find that two different
        MObjectHandles which refer to the same internal Maya object will
        not match. This is because Python's default __hash__() method is
        only looking at the MObjectHandles themselves, not what they
        contain. So different MObjectHandles can produce different
        __hash__() values even if they refer to the same internal Maya
        object.To get around this you can create a container class or a
        derived class which defines its own __hash__() method which
        returns the MObjectHandle's hashCode():An object's hash code is
        not guaranteed to remain the same from one Maya session to
        another, nor if it is removed from the scene and subsequently
        restored in any way, such as deleting a node and then undoing the
        deletion, reloading the scene file, etc.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isValid(self): 
        '''
        isValid(self) -> bool

        Synopsis
        -----
        Returns the validity of the associated MObject.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isAlive(self): 
        '''
        isAlive(self) -> bool

        Synopsis
        -----
        Returns the live state of the associated MObject. An object can
        still be 'alive' but not 'valid' (eg. a deleted object that
        resides in the undo queue).

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def __eq__(self, obj: MObject): 
        '''
        __eq__(self, obj: MObject) -> bool

        Synopsis
        -----
        Returns true if the MObjectHandle is a handle for the given
        MObject.

        Returns: 
        ----- 
        true if the MObject is handled by the MObjectHandle, false
        otherwise.

        Parameters:
        -----
        obj: MObject
        	[in] -> MObject


        '''
        pass

    @overload
    def __eq__(self, handle: MObjectHandle): 
        '''
        __eq__(self, handle: MObjectHandle) -> bool

        Synopsis
        -----
        Returns true if the MObjectHandle handles the same MObject as
        this MObjectHandle.

        Returns: 
        ----- 
        true if the MObjectHandles are the same, false otherwise.

        Parameters:
        -----
        handle: MObjectHandle
        	[in] -> MObjectHandle


        '''
        pass

    @overload
    def __neq__(self, obj: MObject): 
        '''
        __neq__(self, obj: MObject) -> bool

        Synopsis
        -----
        Returns true if the MObjectHandle is not a handle for the given
        MObject.

        Returns: 
        ----- 
        true if the MObject is not handled by the MObjectHandle, false
        otherwise.

        Parameters:
        -----
        obj: MObject
        	[in] -> MObject


        '''
        pass

    @overload
    def __neq__(self, handle: MObjectHandle): 
        '''
        __neq__(self, handle: MObjectHandle) -> bool

        Synopsis
        -----
        Returns true if the MObjectHandle does not handle the same
        MObject as this MObjectHandle.

        Returns: 
        ----- 
        true MObjectHandles are not the same, false otherwise.

        Parameters:
        -----
        handle: MObjectHandle
        	[in] -> MObjectHandle


        '''
        pass

    def objectHashCode(self, obj: MObject): 
        '''
        objectHashCode(self, obj: MObject) -> int

        Synopsis
        -----
        Returns a hash code for the provided MObject. The user is
        responsible for the validity of the provided MObject when using
        this method.The returned hash code may not be unique: several
        internal Maya objects may return the same code. However different
        MObjectHandles whose MObjects refer to the same internal Maya
        object will return the same hash code.This provides a way for
        using internal Maya objects as keys in hash-based lookups.Note:
        The construction and destruction of MObjectHandle is not thread
        safe. If your plug-in requires threading, you should use
        MObjectHandle::objectHashCode() instead.

        Returns: 
        ----- 
        The hash code.

        Parameters:
        -----
        obj: MObject
        	[in] -> MObject


        '''
        pass

class MObjectSetMessage:
    '''Object Set Messages.
This class is used to register callbacks for object set messages
received by specific sets.
There is 1 add callback method which will add callbacks for the
following message
The first parameter passed to each of the add callback methods is
the object set depenency node that will trigger the callback. The
second parameter specifies the callback function and the optional
third parameter specifies the callback argument.
Each method returns an id which is used to remove the callback.
To remove a callback use
MMessage::removeCallback(). All callbacks that are registered by a plug-in must be removed
by that plug-in when it is unloaded. Failure to do so will result
in a fatal error.
'''
    def __init__(self):
        pass


    def addSetMembersModifiedCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MObjectSetMessage.MStatus): 
        '''
        addSetMembersModifiedCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MObjectSetMessage.MStatus) -> MObjectSetMessage.OPENMAYA_MAJOR_NAMESPACE_OPENMCallbackId

        Synopsis
        -----
        Registers callbacks for set modified messages.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MObject
        	[in] -> the set to register the callback for 

        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data that will be passed to the callback function 

        ReturnStatus: MObjectSetMessage.MStatus
        	[out] -> status code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MPaintMessage:
    '''Scene messages.
This class is used to register callbacks for paint related
messages.
The addCallback method registers a function that will be executed
whenever the specified message occurs. An id is returned and is
used to remove the callback.
To remove a callback use
MMessage::removeCallback. All callbacks that are registered by a plug-in must be removed
by that plug-in when it is unloaded. Failure to do so will result
in a fatal error.
'''
    def __init__(self):
        pass


    def addVertexColorCallback(self, func: MPaintMessage.MPathObjectPlugColorsFunction,
                        clientData: void,
                        ReturnStatus: MPaintMessage.MStatus): 
        '''
        addVertexColorCallback(self, func: MPaintMessage.MPathObjectPlugColorsFunction,
                        clientData: void,
                        ReturnStatus: MPaintMessage.MStatus) -> MPaintMessage.OPENMAYA_MAJOR_NAMESPACE_OPENMCallbackId

        Synopsis
        -----
        Adds a new callback on vertex color paint. Note: the 'colors'
        parameter supplied to the callback function contains a color per
        vertex, even if the type of the component being painted is faces.
        To interpret the colors when faces are being painted, it will be
        necessary to query the vertex count of each face and step over
        that many vertices while iterating the array.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MPaintMessage.MPathObjectPlugColorsFunction
        	[in] -> the callback function 

        clientData: void
        	[in] -> user data that will be passed to the callback function 

        ReturnStatus: MPaintMessage.MStatus
        	[out] -> Status code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MParentingEdit:
    '''Class for describing edits to parenting.
This class is used to represent information about edits to
parenting. Such edits occur when a file is referenced and changes
are made to the dag hierarchy of nodes within that reference.
When a reference is unloaded, only the name of the nodes involved
may be queried successfully. When the referenced file is loaded,
the nodes themselves may also be queried.
The
MItEdits class may be used to iterate over all the edits on a given
reference or assembly.
'''
    def __init__(self):
        pass


    def parentedObject(self, ReturnStatus: MParentingEdit.MStatus): 
        '''
        parentedObject(self, ReturnStatus: MParentingEdit.MStatus) -> MObject

        Synopsis
        -----
        Returns the dag object which was parented in this edit. The
        parented object can only be returned when the related reference
        or assembly is loaded. When the reference or assembly is
        unloaded, only the name of the parented object may be queried
        successfully. queried.

        Returns: 
        ----- 
        The dag object which was parented in this edit

        Parameters:
        -----
        ReturnStatus: MParentingEdit.MStatus
        	[out] -> Status Code


        '''
        pass

    def parent(self, ReturnStatus: MParentingEdit.MStatus): 
        '''
        parent(self, ReturnStatus: MParentingEdit.MStatus) -> MParentingEdit.OPENMAYA_MAJOR_NAMESPACE_OPEN MObject

        Synopsis
        -----
        Returns the parent dag object involved in this edit. The parent
        can only be returned when the related reference or assembly is
        loaded. When the reference or assembly is unloaded, only the
        parent name string may be queried successfully.

        Returns: 
        ----- 
        The parent dag object involved in this edit

        Parameters:
        -----
        ReturnStatus: MParentingEdit.MStatus
        	[out] -> Status Code


        '''
        pass

    def parentedObjectName(self, ReturnStatus: MParentingEdit.MStatus): 
        '''
        parentedObjectName(self, ReturnStatus: MParentingEdit.MStatus) -> MString

        Synopsis
        -----
        Returns the dag object which was parented in this edit. The
        parented object can only be returned when the related reference
        or assembly is loaded. When the reference or assembly is
        unloaded, only the name of the parented object may be queried
        successfully. queried.

        Returns: 
        ----- 
        The dag object which was parented in this edit

        Parameters:
        -----
        ReturnStatus: MParentingEdit.MStatus
        	[out] -> Status Code


        '''
        pass

    def parentName(self, ReturnStatus: MParentingEdit.MStatus): 
        '''
        parentName(self, ReturnStatus: MParentingEdit.MStatus) -> MString

        Synopsis
        -----
        Returns the name of the parent dag object involved in this edit.

        Returns: 
        ----- 
        The name of the parent dag object involved in this edit

        Parameters:
        -----
        ReturnStatus: MParentingEdit.MStatus
        	[out] -> Status Code


        '''
        pass

    def editType(self, ReturnStatus: MParentingEdit.MStatus): 
        '''
        editType(self, ReturnStatus: MParentingEdit.MStatus) -> MEdit.MEdit

        Synopsis
        -----
        Virtual method used to return the edit type of this edit, which
        is MEdit::kParentEdit. Reimplemented from MEdit.

        Returns: 
        ----- 
        MEdit::kParentEdit

        Parameters:
        -----
        ReturnStatus: MParentingEdit.MStatus
        	[out] -> return status


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MPlane:
    '''A plane equation.
This class describes a mathematical plane.
'''
    def __init__(self):
        pass


    def normal(self): 
        '''
        normal(self) -> MVector

        Synopsis
        -----
        Returns the normal of the plane.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def distance(self): 
        '''
        distance(self) -> double

        Synopsis
        -----
        Returns the distance of the plane along the normal.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def setPlane(self, a: double,
                        b: double,
                        c: double,
                        d: double): 
        '''
        setPlane(self, a: double,
                        b: double,
                        c: double,
                        d: double)

        Synopsis
        -----
        Directly set the equation of the plane in the form: ax + by +cz +
        d = 0.

        Returns:
        -----
        None

        Parameters:
        -----
        a: double
        	[in] -> The plane equation's x coefficent 

        b: double
        	[in] -> The plane equation's y coefficent 

        c: double
        	[in] -> The plane equation's z coefficent 

        d: double
        	[in] -> The plane equation's constant distance term 


        '''
        pass

    @overload
    def setPlane(self, n: MVector,
                        d: double): 
        '''
        setPlane(self, n: MVector,
                        d: double)

        Synopsis
        -----
        Set the equation of the plane from a normal and offset.

        Returns:
        -----
        None

        Parameters:
        -----
        n: MVector
        	[in] -> The plane's normal 

        d: double
        	[in] -> The offset of the plane along the normal 


        '''
        pass

    @overload
    def distance(self, point: MVector): 
        '''
        distance(self, point: MVector) -> double

        Synopsis
        -----
        Returns the unsigned distance from the plane to the specified
        point.

        Returns: 
        ----- 
        The distance from the specified point to the plane.

        Parameters:
        -----
        point: MVector
        	[in] -> The point from which to calculate the distance


        '''
        pass

    def directedDistance(self, point: MVector): 
        '''
        directedDistance(self, point: MVector) -> double

        Synopsis
        -----
        Returns the signed distance from the plane to the specified
        point.

        Returns: 
        ----- 
        The distance from the specified point to the plane.

        Parameters:
        -----
        point: MVector
        	[in] -> The point from which to calculate the distance


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MPlug:
    '''Create and Access dependency node plugs.
MPlug provides methods for creating plugs, and accessing the plugs'
dependency node and attributes.
A plug is a point on a dependency node where a particular
attribute can be connected. In simple cases the plug and
attribute are equivalent. When you have array attributes,
however, the plug is more specific in that it indicates which of
the array elements is to be connected.
There are two main types of plugs: networked plugs and non-
networked plugs. Non-networked plugs can be considered user plugs
as they are created by users and belong to users. Networked plugs
can be considered dependency node plugs as they are part of the
dependency graph and can only be referenced by users.
In every dependency node there is a network or "tree" of plugs
indicating connections that have been made to attributes of the
node. The plugs in this tree are known as
 plugs as they belong to the dependency node's network.
 plugs are plugs that you can create in order to establish a new
connection to an attribute, or to get or set a value on an
attribute. When a connection is made using these plugs, a
networked version of the plug is created and added to the
dependency nodes network.
A
 plug cannot be explicitly created. They are created when a
connection is established for some attribute of the node. Since
the allocation of networked plugs is managed exclusively by Maya,
a plugin should never reference a networked plug after changes
are made to the DG. Instead, use a non-networked version of the
plug, or get a new reference to the networked plug.
All a
 plug knows is how to uniquely describe the attribute that it
references, in fact the purpose of a non-networked plug is to
specify, without ambiguity, an attribute of a dependency node. A
non-networked plug contains an array of array indices that plot
the path from the root plug to this plug.
For simple attributes the plug and attribute are equivalent.
Compound attributes are also unambiguous. A plug that refers to
an array attribute, however, is more complex as it can refer to
the
 or an
 in the array.
Several methods are provided for navigating the plug tree. The
child() method can be used to retrieve the
 of a
. The
elementByLogicalIndex() and
elementByPhysicalIndex() methods can be used to retrieve the element plugs of an array
plug. The
parent() and
array() methods traverse the tree in the opposite direction:
parent() retrieves a compound plug from a child plug, and
array() retrieves an array plug from an element plug.
Since connections to arrays are sparse, element plugs have both
logical and physical indexes. The logical indexes are used by
MEL, and are sparse. Physical indexes, on the other hand, are not
sparse. It is guaranteed that the physical indexes will range
from 0 to
numElements() - 1. Using the physical indexes, iterating over the element
plugs in an array is easy:
This is equivalent to calling
elementByPhysicalIndex() since the bracket operator uses physical indexes.
The ancestry of a plug is the tree above the plug: any parents or
arrays which this plug belongs to. The
selectAncestorLogicalIndex() method provides quick access to element plugs without walking
the plug tree. A plug does not need to exist in the datablock or
plug tree in order to be constructed using
selectAncestorLogicalIndex(), but once a value is requested or set on the plug, it will be
added to the datablock if it was not there already. For example:
Once a value has been added to an array plug, it will usually
remain in the datablock as long as the scene is open. The
exception is for attributes that have their disconnect behavior
set to kDelete: data for these attributes will be deleted when
their connection is broken. When a file is saved, only array
values that are not at their default values will be written out.
Therefore, the number of elements in an array plug may change
when the file is read in again.
'''
    def __init__(self):
        pass


    def setAttribute(self, attribute: MObject): 
        '''
        setAttribute(self, attribute: MObject)

        Synopsis
        -----
        This method is a convenience routine to allow quick movement
        between attributes on a single node. If the current plug is a
        networked plug, it becomes a new non-networked plug referring to
        the requested attribute. If the current plug is a non-networked
        plug, it is changed to refer to the requested attribute.The
        passed attribute must be the attribute of a plug on the current
        node.

        Returns:
        -----
        None

        Parameters:
        -----
        attribute: MObject
        	[in] -> attribute to change the plug to


        '''
        pass

    def attribute(self, ReturnStatus: MPlug.MStatus): 
        '''
        attribute(self, ReturnStatus: MPlug.MStatus) -> MObject

        Synopsis
        -----
        This method returns the attribute that this plug refers to.

        Returns: 
        ----- 
        The attribute that this plug refers to.

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def node(self, ReturnStatus: MPlug.MStatus): 
        '''
        node(self, ReturnStatus: MPlug.MStatus) -> MObject

        Synopsis
        -----
        Returns the dependency node that this plug belongs to.

        Returns: 
        ----- 
        A pointer to this plug's dependency node.

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def name(self, ReturnStatus: MPlug.MStatus): 
        '''
        name(self, ReturnStatus: MPlug.MStatus) -> MString

        Synopsis
        -----
        Returns the name of this plug in the form
        'nodeName.attributeName'.

        Returns: 
        ----- 
        The name of this node

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> return status


        '''
        pass

    def partialName(self, includeNodeName: bool,
                        includeNonMandatoryIndices: bool,
                        includeInstancedIndices: bool,
                        useAlias: bool,
                        useFullAttributePath: bool,
                        useLongNames: bool,
                        ReturnStatus: MPlug.MStatus): 
        '''
        partialName(self, includeNodeName: bool,
                        includeNonMandatoryIndices: bool,
                        includeInstancedIndices: bool,
                        useAlias: bool,
                        useFullAttributePath: bool,
                        useLongNames: bool,
                        ReturnStatus: MPlug.MStatus) -> MString

        Synopsis
        -----
        By default, this method returns the shortest possible name for
        the plug, but its parameters can be used to add parts back in.

        Returns: 
        ----- 
        The name of the plug.

        Parameters:
        -----
        includeNodeName: bool
        	[in] -> If true, then the plug's node name is prefixed to the name of the plug, with a dot separating it from the attribute name. If false, then just the attribute name is returned. (default: false)

        includeNonMandatoryIndices: bool
        	[in] -> If the plug's attribute is a non-instanced element of a multi which is NOT marked as 

        includeInstancedIndices: bool
        	[in] -> If the plug's attribute is an element of an instanced multi, then setting this parameter true will cause the array index to be included in the returned string. For example, if you are planning to append the returned plug name to a node's dagPath, then the instance index is unnecessary as it can be determined from the dagPath. (default: false)

        useAlias: bool
        	[in] -> Display aliased name if alias exists. (default: false)

        useFullAttributePath: bool
        	[in] -> Normally, the plug's attribute path is compressed so that any compound ancestors which do not serve to uniquely identify the plug are removed. Setting this parameter true will cause the full attribute path to be used. (default: false)

        useLongNames: bool
        	[in] -> Normally, short attribute names are used. Setting this true will cause long names to be used. (default: false)

        ReturnStatus: MPlug.MStatus
        	[out] -> Return status.


        '''
        pass

    def getSetAttrCmds(self, cmds: MStringArray,
                        valueSelector: MPlug.MPlug,
                        useLongNames: bool): 
        '''
        getSetAttrCmds(self, cmds: MStringArray,
                        valueSelector: MPlug.MPlug,
                        useLongNames: bool)

        Synopsis
        -----
        Returns an array of strings containing setAttr commands for this
        plug and all of its descendent plugs.

        Returns:
        -----
        None

        Parameters:
        -----
        cmds: MStringArray
        	[out] -> 

        valueSelector: MPlug.MPlug
        	[in] -> 

        useLongNames: bool
        	[in] -> 


        '''
        pass

    def isNetworked(self, ReturnStatus: MPlug.MStatus): 
        '''
        isNetworked(self, ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        This method determines if the plug is networked or non-networked.
        Networked plugs are part of a dependency node network and define
        points where connections have been made to the nodes
        attributes.Non-networked plugs are user created plugs that are
        used to refer to an attribute of a node so that it can be
        connected. If the attribute that the plug refers to has been
        connected then there will also be a corresponding networked plug.

        Returns: 
        ----- 
        true  false

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def isArray(self, ReturnStatus: MPlug.MStatus): 
        '''
        isArray(self, ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        This method determines if the plug is an array plug. Array plugs
        refer to array attributes and contain element plugs.

        Returns: 
        ----- 
        true  false

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def isElement(self, ReturnStatus: MPlug.MStatus): 
        '''
        isElement(self, ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        This method determines if the plug is an element plug. Element
        plugs refer to array attributes and are members of array plugs.

        Returns: 
        ----- 
        true  false

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def isCompound(self, ReturnStatus: MPlug.MStatus): 
        '''
        isCompound(self, ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        This method determines if the plug is a compound plug. Compound
        plugs refer to compound attributes and have child plugs.

        Returns: 
        ----- 
        true  false

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def isChild(self, ReturnStatus: MPlug.MStatus): 
        '''
        isChild(self, ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        This method determines if the plug is a child plug. A child
        plug's parent is always a compound plug.

        Returns: 
        ----- 
        true  false

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def isProcedural(self, ReturnStatus: MPlug.MStatus): 
        '''
        isProcedural(self, ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        This method determines if the plug is a procedural plug. A
        procedural plug is one which is created by Maya's internal
        procedures or by the nodes themselves and which should not be
        saved to or restored from files.

        Returns: 
        ----- 
        true  false

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def logicalIndex(self, ReturnStatus: MPlug.MStatus): 
        '''
        logicalIndex(self, ReturnStatus: MPlug.MStatus) -> int

        Synopsis
        -----
        Returns the logical index of the element this plug refers to. The
        logical index is a sparse index, equivalent to the array index
        used in MEL.This plug must be an element plug, and may be either
        networked or non-networked.

        Returns: 
        ----- 
        The logical array index of the element this plug refers to

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def isProxy(self, ReturnStatus: MPlug.MStatus): 
        '''
        isProxy(self, ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        Introduced in 2023.0 Returns true if this plug is a proxy plug.A
        proxy plug is used for connection forwarding to another plug and
        does not have an associated datablock.

        Returns: 
        ----- 
        true  false

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def selectAncestorLogicalIndex(self, index: int,
                        attribute: MObject): 
        '''
        selectAncestorLogicalIndex(self, index: int,
                        attribute: MObject)

        Synopsis
        -----
        This method is a convenience routine to allow quick iteration and
        construction of plugs with array plugs in their ancestry. It
        selects a plug into the current object by changing an ancestor
        array's logical index.The passed attribute must be either the
        attribute of the current plug, or the attribute of an ancestor's
        plug. It must be an array attribute. By default, it refers to the
        attribute of the current plug.If the passed attribute is the
        attribute of this plug, then this plug will change to refer to
        its indexth element plug.For example, consider the following
        attribute tree. The topmost attribute is a compound attribute
        "in". It consists of two children: an enum attribute "operation"
        and a typed attribute "value". Both "value" and "in" are array
        attributes. To iterate through all of the values, you could write
        a loop like this:This method is only valid for non-networked
        plugs since networked plugs are part of a dependency node and can
        only be modified by making or breaking connections.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> index value to be set 

        attribute: MObject
        	[in] -> array attribute whose index will be changed


        '''
        pass

    def getExistingArrayAttributeIndices(self, indices: MIntArray,
                        ReturnStatus: MPlug.MStatus): 
        '''
        getExistingArrayAttributeIndices(self, indices: MIntArray,
                        ReturnStatus: MPlug.MStatus) -> int

        Synopsis
        -----
        This method will return a list of the logical indices of the
        elements in an array attribute that are either connected or have
        had their value set. This method is useful when the logical
        indices of connected/set elements are sparse.

        Returns: 
        ----- 
        The number of set/connected elements

        Parameters:
        -----
        indices: MIntArray
        	[in] -> A list to store the logical indices of the set/connected elements. 

        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def numElements(self, ReturnStatus: MPlug.MStatus): 
        '''
        numElements(self, ReturnStatus: MPlug.MStatus) -> int

        Synopsis
        -----
        Return the total number of elements in the datablock of this
        array plug. The return count will include all existing non-
        connected elements plus connected elements if they have been
        evaluated. It will not include connected elements that have not
        yet been placed into the datablock. The method
        MPlug::evaluateNumElements can be used in the situation where you
        want an accurate count that includes all connected elements.This
        method is only valid for array plugs, as no other plugs have
        elements.

        Returns: 
        ----- 
        Total number of elements

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def evaluateNumElements(self, ReturnStatus: MPlug.MStatus): 
        '''
        evaluateNumElements(self, ReturnStatus: MPlug.MStatus) -> int

        Synopsis
        -----
        Return the total number of elements in the datablock of this
        array plug. The return count will include both connected and non-
        connected elements, and will perform an evaluate in order to make
        sure that the datablock is as up-to-date as possible since some
        nodes do not place array elements into the datablock until the
        attribute is evaluated.Because this method performs an evaluate,
        it should not be called from within the compute of a node.
        Instead, if you want to know the number of elements in an array
        plug while in a compute, use either MDataBlock::inputArrayValue
        or MDataBlock::outputArrayValue because they are more efficient
        and will not result in recursion.This method is only valid for
        array plugs, as no other plugs have elements.

        Returns: 
        ----- 
        Total number of elements

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def numChildren(self, ReturnStatus: MPlug.MStatus): 
        '''
        numChildren(self, ReturnStatus: MPlug.MStatus) -> int

        Synopsis
        -----
        Return the total number of children of this compound plug. This
        method is only valid for networked plugs as non-networked plugs
        contain no information about their children. If this plug is non-
        networked then a networked version of the plug will be used. If a
        networked plug does not exist then 0 will be returned.This method
        is also only valid for compound plugs or the root plug, since no
        other plugs have children.

        Returns: 
        ----- 
        Total number of children

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def numConnectedElements(self, ReturnStatus: MPlug.MStatus): 
        '''
        numConnectedElements(self, ReturnStatus: MPlug.MStatus) -> int

        Synopsis
        -----
        Return the total number of connected element plugs belonging to
        this array plug. This method is only valid for networked plugs as
        non-networked plugs contain no information about their children.
        If this plug is non-networked then a networked version of the
        plug will be used. If a networked plug does not exist then 0 will
        be returned.This method is also only valid for array plugs, as no
        other plugs have elements.

        Returns: 
        ----- 
        Total number of elements

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def numConnectedChildren(self, ReturnStatus: MPlug.MStatus): 
        '''
        numConnectedChildren(self, ReturnStatus: MPlug.MStatus) -> int

        Synopsis
        -----
        Return the number of children of this plug that are connected in
        the dependency graph. This method is only valid for networked
        plugs as non-networked plugs contain no information about their
        children. If this plug is non-networked then a networked version
        of the plug will be used. If a networked plug does not exist then
        0 will be returned.This method is only valid for compound plugs,
        since no other plugs have children.

        Returns: 
        ----- 
        Total number of children

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    @overload
    def child(self, obj: MObject,
                        ReturnStatus: MPlug.MStatus): 
        '''
        child(self, obj: MObject,
                        ReturnStatus: MPlug.MStatus) -> MPlug

        Synopsis
        -----
        Returns a plug to a given attribute that is a child of this plug.
        This method is only valid for compound plugs that are not
        arrays.NOTE: To retrieve the child of a compound array plug the
        array index has to be specified by calling elementByLogicalIndex
        first.

        Returns: 
        ----- 
        The child plug

        Parameters:
        -----
        obj: MObject
        	[in] -> The child attribute. 

        ReturnStatus: MPlug.MStatus
        	[out] -> Status code.


        '''
        pass

    @overload
    def child(self, index: int,
                        ReturnStatus: MPlug.MStatus): 
        '''
        child(self, index: int,
                        ReturnStatus: MPlug.MStatus) -> MPlug

        Synopsis
        -----
        Returns a plug to a given attribute that is a child of this plug.
        This method is only valid for compound plugs that are not
        arrays.NOTE: To retrieve the child of a compound array plug the
        array index has to be specified by calling elementByLogicalIndex
        first.

        Returns: 
        ----- 
        The child plug

        Parameters:
        -----
        index: int
        	[in] -> The index of the plug to be found 

        ReturnStatus: MPlug.MStatus
        	[out] -> Status code.


        '''
        pass

    def parent(self, ReturnStatus: MPlug.MStatus): 
        '''
        parent(self, ReturnStatus: MPlug.MStatus) -> MPlug

        Synopsis
        -----
        Returns the parent plug. The parent plug will always be a
        compound plug. This method is only valid for networked child
        plugs.

        Returns: 
        ----- 
        The parent of this plug.

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[in] -> Status Code


        '''
        pass

    def array(self, ReturnStatus: MPlug.MStatus): 
        '''
        array(self, ReturnStatus: MPlug.MStatus) -> MPlug

        Synopsis
        -----
        Returns the array to which this element plug belongs. This method
        is only valid for networked element plugs.

        Returns: 
        ----- 
        The array of this plug.

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def elementByLogicalIndex(self, index: int,
                        ReturnStatus: MPlug.MStatus): 
        '''
        elementByLogicalIndex(self, index: int,
                        ReturnStatus: MPlug.MStatus) -> MPlug

        Synopsis
        -----
        This method will find and return a plug with the given logical
        index. The logical index is the sparse array index used in MEL
        scripts. If a plug does not exist at the given Index, Maya will
        create a plug at that index. This is not the case with
        elementByPhysicalIndex(). If needed, elementByLogicalIndex can be
        used to expand an array plug on a node. It is important to note
        that Maya assumes that all such plugs serve a purpose and it will
        not free non-networked plugs that result from such an array
        expansion.The returned plug may or may not be connected.

        Returns: 
        ----- 
        A plug with the given index

        Parameters:
        -----
        index: int
        	[in] -> The index of the plug to be found 

        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def elementByPhysicalIndex(self, index: int,
                        ReturnStatus: MPlug.MStatus): 
        '''
        elementByPhysicalIndex(self, index: int,
                        ReturnStatus: MPlug.MStatus) -> MPlug

        Synopsis
        -----
        This method will find and return a plug with the given physical
        index. The index can range from 0 to numElements() - 1. This
        function is particularly useful for iteration through the element
        plugs of an array plug. It is equivalent to operator [] (int)
        This method is only valid for array plugs.If the returned plug is
        networked, the networked plug will be returned. Otherwise, a non-
        networked plug will be returned.

        Returns: 
        ----- 
        A plug with the given index

        Parameters:
        -----
        index: int
        	[in] -> The physical array index of the plug to be found 

        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def connectionByPhysicalIndex(self, index: int,
                        ReturnStatus: MPlug.MStatus): 
        '''
        connectionByPhysicalIndex(self, index: int,
                        ReturnStatus: MPlug.MStatus) -> MPlug

        Synopsis
        -----
        This method will find and return a connected plug with the given
        physical index for its connection. The index can range from 0 to
        numConnectedElements() - 1. This method varies from
        elementByPhysicalIndex in that elementByPhysicalIndex will return
        plugs pointing to all existing data in the datablock regardless
        of whether the plug is connected or not.This method is only valid
        for array plugs.

        Returns: 
        ----- 
        A plug with the given index

        Parameters:
        -----
        index: int
        	[in] -> The physical array index of the plug to be found 

        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def connectedTo(self, array: MPlugArray,
                        asDst: bool,
                        asSrc: bool,
                        ReturnStatus: MPlug.MStatus): 
        '''
        connectedTo(self, array: MPlugArray,
                        asDst: bool,
                        asSrc: bool,
                        ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        This method finds all of the plugs that this plug is connected
        with. This method will always produce the networked version of
        the connected plugs.NOTE: When asDst=true you are asking for a
        plug connecting in to this one i.e. a source plug that is driving
        this plug's value. There will only be one of these, or none.NOTE:
        When asSrc=true you are asking for all plugs connecting out from
        this one i.e. destination plugs whose values are driven by this
        one. There can be any arbitrary number of these and order is not
        guaranteed so if you look for a specific output/destination plug
        be sure to check all of them.It is generally not a good idea to
        ask for both at the same time since you won't know which are
        sources or destinations without checking. If you are only
        interested in the existence of a connection not the actual
        plug(s) to which this one is connected then use the appropriate
        connection check methods:
        isSource()/isDestination()/isConnected().Calling this method with
        both asDst and asSrc set to false will do nothing.

        Returns: 
        ----- 
        true If the plug has connections as either source or destination.
        Note that the array is filled in only with the type of connecting
        plugs requested by asSrc and asDst. Therefore, the method could
        return true while the array has nothing in it if, for example,
        the plug has connections as source but the user passes asSrc =
        false to the method. The parameters asSrc and asDst have no
        effect on the boolean return value.  false If this plug has no
        connections

        Parameters:
        -----
        array: MPlugArray
        	[in] -> Location for storing connected plugs (allocated by the caller) 

        asDst: bool
        	[in] -> Check connections with this plug as destination. If there are such connections, put them in array. 

        asSrc: bool
        	[in] -> Check connections with this plug as source. If there are such connections, put them in array. 

        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def isConnected(self, ReturnStatus: MPlug.MStatus): 
        '''
        isConnected(self, ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        Determines if this plug is connected to one or more plugs.

        Returns: 
        ----- 
        true If this plug is connected to another plug  false If this
        plug is not connected to another plug

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def source(self, ReturnStatus: MPlug.MStatus): 
        '''
        source(self, ReturnStatus: MPlug.MStatus) -> MPlug

        Synopsis
        -----
        If this plug is a destination, return the source plug connected
        to it. If this plug is not a destination, a null plug is
        returned.This method will produce the networked version of the
        connected plug.

        Returns: 
        ----- 
        Source plug, or null plug if not a destination.

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def destinations(self, theDestinations: MPlugArray,
                        ReturnStatus: MPlug.MStatus): 
        '''
        destinations(self, theDestinations: MPlugArray,
                        ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        If this plug is a source, return the destination plugs connected
        to it. If this plug is not a source, a null plug is returned.This
        method will produce the networked version of the connected plug.

        Returns: 
        ----- 
        Returns true if the plug has one or more destinations.

        Parameters:
        -----
        theDestinations: MPlugArray
        	[in] -> Location for storing connected plugs (allocated by the caller). The array is first cleared, then the destination plugs are added. 

        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def sourceWithConversion(self, ReturnStatus: MPlug.MStatus): 
        '''
        sourceWithConversion(self, ReturnStatus: MPlug.MStatus) -> MPlug

        Synopsis
        -----
        If this plug is a destination, return the source plug connected
        to it. This method is very similar to the source() method. The
        only difference is that the source() method skips over any unit
        conversion node connected to this destination, and returns the
        source of the unit conversion node.sourceWithConversion() does
        not skip over unit conversion nodes, and returns the source plug
        on a unit conversion node, if present.Note that the behavior of
        connectedTo() is identical to sourceWithConversion(), that is, do
        not skip over unit conversion nodes.

        Returns: 
        ----- 
        Source plug, or null plug if not a destination.

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def destinationsWithConversions(self, theDestinations: MPlugArray,
                        ReturnStatus: MPlug.MStatus): 
        '''
        destinationsWithConversions(self, theDestinations: MPlugArray,
                        ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        If this plug is a source, return the destination plugs connected
        to it. This method is very similar to the destinations() method.
        The only difference is that the destinations() method skips over
        any unit conversion node connected to this source, and returns
        the destination of the unit conversion
        node.destinationsWithConversions() does not skip over unit
        conversion nodes, and returns the destination plug on a unit
        conversion node, if present.Note that the behavior of
        connectedTo() is identical to destinationsWithConversions(), that
        is, do not skip over unit conversion nodes.

        Returns: 
        ----- 
        Returns true if the plug has one or more destinations.

        Parameters:
        -----
        theDestinations: MPlugArray
        	[in] -> Location for storing connected plugs (allocated by the caller). The array is first cleared, then the destination plugs are added. 

        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def isKeyable(self, ReturnStatus: MPlug.MStatus): 
        '''
        isKeyable(self, ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        Determines if this plug is keyable. The default keyability of a
        plug is determined by its attribute, and can be retrieved using
        MFnAttribute::isKeyable. Keyable plugs will be keyed by AutoKey
        and the Set Keyframe UI. Non-keyable plugs prevent the user from
        setting keys via the obvious UI provided for keying. Being non-
        keyable is not a hard block against adding keys to an attribute.

        Returns: 
        ----- 
        true If this plug is keyable  false If this plug is not keyable

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def setKeyable(self, keyable: bool): 
        '''
        setKeyable(self, keyable: bool)

        Synopsis
        -----
        This overrides the default keyability of a plug set with
        MFnAttribute::setKeyable. Keyable plugs will be keyed by AutoKey
        and the Set Keyframe UI. Non-keyable plugs prevent the user from
        setting keys via the obvious UI provided for keying. Being non-
        keyable is not a hard block against adding keys to an attribute.

        Returns:
        -----
        None

        Parameters:
        -----
        keyable: bool
        	[in] -> True if this plug should be keyable


        '''
        pass

    def isLocked(self, ReturnStatus: MPlug.MStatus): 
        '''
        isLocked(self, ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        Determines the locked state of this plug's value. A plug's locked
        state determines whether or not the plug's value can be changed.

        Returns: 
        ----- 
        true If this plug's value is locked  false If this plug's value
        is not locked

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def setLocked(self, locked: bool): 
        '''
        setLocked(self, locked: bool)

        Synopsis
        -----
        Sets the locked state for this plug's value. A plug's locked
        state determines whether or not the plug's value can be changed.

        Returns:
        -----
        None

        Parameters:
        -----
        locked: bool
        	[in] -> True if this plug's value is to be locked


        '''
        pass

    def isChannelBoxFlagSet(self, ReturnStatus: MPlug.MStatus): 
        '''
        isChannelBoxFlagSet(self, ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        Returns true if this plug or its attribute has its channel box
        flag set. Attributes will appear in the channel box if their
        channel box flag is set or if they are keyable.

        Returns: 
        ----- 
        true channel box flag has been set  false channel box flag has
        not been set

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def setChannelBox(self, inChannelBox: bool): 
        '''
        setChannelBox(self, inChannelBox: bool)

        Synopsis
        -----
        Sets whether this plug is displayed in the channel box. This
        overrides the default display of a plug set with
        MFnAttribute::setChannelBox. Keyable attributes are always shown
        in the channel box so this flag is ignored on keyable plugs.

        Returns:
        -----
        None

        Parameters:
        -----
        inChannelBox: bool
        	[in] -> True if this plug should be displayed in the channel box


        '''
        pass

    def isCachingFlagSet(self, ReturnStatus: MPlug.MStatus): 
        '''
        isCachingFlagSet(self, ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        Returns true if this plug or its attribute has its caching flag
        set.

        Returns: 
        ----- 
        true caching flag has been set  false caching flag has not been
        set

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def setCaching(self, isCaching: bool): 
        '''
        setCaching(self, isCaching: bool)

        Synopsis
        -----
        Sets whether this plug is cached internally. Note: turning
        caching on for a plug will force the plug to become networked.
        Network plugs take longer to look up in the DG; therefore you
        should only make a plug cached only if you are certain that the
        network plug look-up will take less than the saved evaluation
        cost.Not all plugs can be made cached (or un-cached). If the
        attribute is defined to be cached, then you cannot uncache the
        attribute. As well, you cannot define caching on element plugs.

        Returns:
        -----
        None

        Parameters:
        -----
        isCaching: bool
        	[in] -> True if this plug should be cached


        '''
        pass

    def isNull(self, ReturnStatus: MPlug.MStatus): 
        '''
        isNull(self, ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        This method determines whether this plug is valid. A plug is
        valid if it refers to an attribute.

        Returns: 
        ----- 
        true this plug is not valid  false this plug is valid

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def info(self, ReturnStatus: MPlug.MStatus): 
        '''
        info(self, ReturnStatus: MPlug.MStatus) -> MString

        Synopsis
        -----
        This method returns a string containing the name of the node this
        plug belongs to and the attributes that the plug refers to. The
        string is of the form dependNode:atr1.atr2[].attr3 ...This method
        is useful for debugging purposes.

        Returns: 
        ----- 
        Returns a string containing dependency node and attribute
        information for this plug.

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def isFromReferencedFile(self, ReturnStatus: MPlug.MStatus): 
        '''
        isFromReferencedFile(self, ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        This method determines whether this plug came from a referenced
        file. A plug is considered to have come from a referenced file if
        it is connected and that connection was made within a referenced
        file.

        Returns: 
        ----- 
        true plug was created within a referenced file  false plug was
        created within the current scene

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def isDynamic(self, ReturnStatus: MPlug.MStatus): 
        '''
        isDynamic(self, ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        Determines whether the attribute is of dynamic type or not.

        Returns: 
        ----- 
        true If the attribute is dynamic  false If this attribute is not
        added by user.

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def isIgnoredWhenRendering(self, ReturnStatus: MPlug.MStatus): 
        '''
        isIgnoredWhenRendering(self, ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        Determines whether a connection to the attribute should be
        ignored during rendering.

        Returns: 
        ----- 
        true If connected, the attribute should be ingored during
        rendering.  false If connected, the attribute should not be
        ingored during rendering.

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def isDefaultValue(self, forceEval: bool,
                        ReturnStatus: MPlug.MStatus): 
        '''
        isDefaultValue(self, forceEval: bool,
                        ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        This method determines if the plug value is equivalent to the
        plug's default value. Optionally, disable evaluation of the plug
        before testing its value against the plug's default value.
        Disabling this option represents a performance optimization in
        cases where the plug's value is known to be valid and correct.

        Returns:
        -----
        None

        Parameters:
        -----
        forceEval: bool
        	[in] -> Evaluate the plug prior to test. 

        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def isFreeToChange(self, checkParents: bool,
                        checkChildren: bool,
                        ReturnStatus: MPlug.MStatus): 
        '''
        isFreeToChange(self, checkParents: bool,
                        checkChildren: bool,
                        ReturnStatus: MPlug.MStatus) -> MPlug.MPlug

        Synopsis
        -----
        Returns true if the plug's value is allowed to be set directly. A
        plug isFreeToChange if it is not locked, and it is not a
        destination or if it is a destination, then it must be a special
        case (such as connected to an anim curve).Normally this is not
        something that needs to be checked, since the DG or MEL
        operations take care of this for you.If the parents are not free
        to change, then the children will not be free to change. However
        if the parents are free to change, some children may not be free
        to change.

        Returns: 
        ----- 
        kFreeToChange All tested plugs are free to change.
        kNotFreeToChange Some of the tested plugs are not free to change.
        kChildrenNotFreeToChange Some of the children are not free to
        change.

        Parameters:
        -----
        checkParents: bool
        	[in] -> Check parent plugs. 

        checkChildren: bool
        	[in] -> Check child plugs. 

        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def constructHandle(self, mBlock: MDataBlock): 
        '''
        constructHandle(self, mBlock: MDataBlock) -> MDataHandle

        Synopsis
        -----
        This method returns a data handle constructed for this plug.

        Returns:
        -----
        None

        Parameters:
        -----
        mBlock: MDataBlock
        	[in] -> 


        '''
        pass

    def asMObject(self, ReturnStatus: MPlug.MStatus): 
        '''
        asMObject(self, ReturnStatus: MPlug.MStatus) -> MObject

        Synopsis
        -----
        Retrieve the value in the current evaluation context of the
        attribute this plug references. This method returns a copy of the
        attribute value for the plug and not a reference. The setObject
        method of this class can be used to modify the plug's value.

        Returns: 
        ----- 
        Value of plug as an MObject

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def asMDataHandle(self, ReturnStatus: MPlug.MStatus): 
        '''
        asMDataHandle(self, ReturnStatus: MPlug.MStatus) -> MDataHandle

        Synopsis
        -----
        Retrieve the value in the current evaluation context of the
        attribute this plug references. This method is useful when
        wanting to retrieve an entire set of values from an array plug
        with a single call. An MArrayDataHandle can then be constructed
        from the returned MDataHandle to access the array data values.

        Returns: 
        ----- 
        Value of plug as an MDataHandle. When done using the returned
        handle, the caller must destroy it using MPlug::destructHandle().

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def asDouble(self, ReturnStatus: MPlug.MStatus): 
        '''
        asDouble(self, ReturnStatus: MPlug.MStatus) -> double

        Synopsis
        -----
        Retrieve the value in the current evaluation context of the
        attribute this plug references.

        Returns: 
        ----- 
        Value of plug as a double

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def asFloat(self, ReturnStatus: MPlug.MStatus): 
        '''
        asFloat(self, ReturnStatus: MPlug.MStatus) -> float

        Synopsis
        -----
        Retrieve the value in the current evaluation context of the
        attribute this plug references.

        Returns: 
        ----- 
        Value of plug as a float

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def asInt64(self, ReturnStatus: MPlug.MStatus): 
        '''
        asInt64(self, ReturnStatus: MPlug.MStatus) -> MPlug.MInt64

        Synopsis
        -----
        Retrieve the value in the current evaluation context of the
        attribute this plug references.

        Returns: 
        ----- 
        Value of plug as an int

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def asInt(self, ReturnStatus: MPlug.MStatus): 
        '''
        asInt(self, ReturnStatus: MPlug.MStatus) -> int

        Synopsis
        -----
        Retrieve the value in the current evaluation context of the
        attribute this plug references.

        Returns: 
        ----- 
        Value of plug as an int

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def asShort(self, ReturnStatus: MPlug.MStatus): 
        '''
        asShort(self, ReturnStatus: MPlug.MStatus) -> short

        Synopsis
        -----
        Retrieve the value in the current evaluation context of the
        attribute this plug references.

        Returns: 
        ----- 
        Value of plug as a short

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def asBool(self, ReturnStatus: MPlug.MStatus): 
        '''
        asBool(self, ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        Retrieve the value in the current evaluation context of the
        attribute this plug references.

        Returns: 
        ----- 
        Value of plug as a bool

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def asMDistance(self, ReturnStatus: MPlug.MStatus): 
        '''
        asMDistance(self, ReturnStatus: MPlug.MStatus) -> MDistance

        Synopsis
        -----
        Retrieve the value in the current evaluation context of the
        attribute this plug references.

        Returns: 
        ----- 
        Value of plug as an MDistance

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def asMAngle(self, ReturnStatus: MPlug.MStatus): 
        '''
        asMAngle(self, ReturnStatus: MPlug.MStatus) -> MAngle

        Synopsis
        -----
        Retrieve the value in the current evaluation context of the
        attribute this plug references.

        Returns: 
        ----- 
        Value of plug as an MAngle

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def asMTime(self, ReturnStatus: MPlug.MStatus): 
        '''
        asMTime(self, ReturnStatus: MPlug.MStatus) -> MTime

        Synopsis
        -----
        Retrieve the value in the current evaluation context of the
        attribute this plug references.

        Returns: 
        ----- 
        Value of plug as an MTime

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def asChar(self, ReturnStatus: MPlug.MStatus): 
        '''
        asChar(self, ReturnStatus: MPlug.MStatus) -> char

        Synopsis
        -----
        Retrieve the value in the current evaluation context of the
        attribute this plug references.

        Returns: 
        ----- 
        Value of plug as a char

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[in] -> Status Code


        '''
        pass

    def asString(self, ReturnStatus: MPlug.MStatus): 
        '''
        asString(self, ReturnStatus: MPlug.MStatus) -> MString

        Synopsis
        -----
        Retrieve the value in the current evaluation context of the
        attribute this plug references.

        Returns: 
        ----- 
        Value of plug as an MString

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> Status Code


        '''
        pass

    def setMObject(self, val: MObject): 
        '''
        setMObject(self, val: MObject)

        Synopsis
        -----
        Set the current value of the attribute this plug references. If
        the attribute is the destination of a connection then setting the
        value will have no effect as once the node is re-evaluated the
        attribute value will be reset.

        Returns:
        -----
        None

        Parameters:
        -----
        val: MObject
        	[in] -> The value to which the attribute will be set


        '''
        pass

    def setMPxData(self, val: MPxData): 
        '''
        setMPxData(self, val: MPxData)

        Synopsis
        -----
        Set the current value of the attribute this plug references. If
        the attribute is the destination of a connection then setting the
        value will have no effect as once the node is re-evaluated the
        attribute value will be reset.

        Returns:
        -----
        None

        Parameters:
        -----
        val: MPxData
        	[in] -> The value to which the attribute will be set


        '''
        pass

    def setMDataHandle(self, handle: MDataHandle): 
        '''
        setMDataHandle(self, handle: MDataHandle)

        Synopsis
        -----
        Set the current value of the attribute this plug references with
        the values in the handle. This method is most useful when the
        plug is an array plug, and you've filled the handle with data.
        Sending the value using this version of setValue will set the
        handle's data into the datablock and send out the appropriate
        attributeChanged messages to update the UI related to the
        attribute.If the attribute is the destination of a connection
        then setting the value will have no effect as once the node is
        re-evaluated the attribute value will be reset.

        Returns:
        -----
        None

        Parameters:
        -----
        handle: MDataHandle
        	[in] -> The handle containing the data to which the attribute will be set


        '''
        pass

    def setDouble(self, val: double): 
        '''
        setDouble(self, val: double)

        Synopsis
        -----
        Set the current value of the attribute this plug references. If
        the attribute is the destination of a connection then setting the
        value will have no effect as once the node is re-evaluated the
        attribute value will be reset.

        Returns:
        -----
        None

        Parameters:
        -----
        val: double
        	[in] -> The value to which the attribute will be set


        '''
        pass

    def setFloat(self, val: float): 
        '''
        setFloat(self, val: float)

        Synopsis
        -----
        Set the current value of the attribute this plug references. If
        the attribute is the destination of a connection then setting the
        value will have no effect as once the node is re-evaluated the
        attribute value will be reset.

        Returns:
        -----
        None

        Parameters:
        -----
        val: float
        	[in] -> The value to which the attribute will be set


        '''
        pass

    def setInt64(self, val: MPlug.MInt64): 
        '''
        setInt64(self, val: MPlug.MInt64)

        Synopsis
        -----
        Set the current value of the attribute this plug references. If
        the attribute is the destination of a connection then setting the
        value will have no effect as once the node is re-evaluated the
        attribute value will be reset.

        Returns:
        -----
        None

        Parameters:
        -----
        val: MPlug.MInt64
        	[in] -> The value to which the attribute will be set


        '''
        pass

    def setInt(self, val: int): 
        '''
        setInt(self, val: int)

        Synopsis
        -----
        Set the current value of the attribute this plug references. If
        the attribute is the destination of a connection then setting the
        value will have no effect as once the node is re-evaluated the
        attribute value will be reset.

        Returns:
        -----
        None

        Parameters:
        -----
        val: int
        	[in] -> The value to which the attribute will be set


        '''
        pass

    def setShort(self, val: short): 
        '''
        setShort(self, val: short)

        Synopsis
        -----
        Set the current value of the attribute this plug references. If
        the attribute is the destination of a connection then setting the
        value will have no effect as once the node is re-evaluated the
        attribute value will be reset.

        Returns:
        -----
        None

        Parameters:
        -----
        val: short
        	[in] -> The value to which the attribute will be set


        '''
        pass

    def setBool(self, val: bool): 
        '''
        setBool(self, val: bool)

        Synopsis
        -----
        Set the current value of the attribute this plug references. If
        the attribute is the destination of a connection then setting the
        value will have no effect as once the node is re-evaluated the
        attribute value will be reset.

        Returns:
        -----
        None

        Parameters:
        -----
        val: bool
        	[in] -> The value to which the attribute will be set


        '''
        pass

    def setMDistance(self, val: MDistance): 
        '''
        setMDistance(self, val: MDistance)

        Synopsis
        -----
        Set the current value of the attribute this plug references. If
        the attribute is the destination of a connection then setting the
        value will have no effect as once the node is re-evaluated the
        attribute value will be reset.

        Returns:
        -----
        None

        Parameters:
        -----
        val: MDistance
        	[in] -> The value to which the attribute will be set


        '''
        pass

    def setMAngle(self, val: MAngle): 
        '''
        setMAngle(self, val: MAngle)

        Synopsis
        -----
        Set the current value of the attribute this plug references. If
        the attribute is the destination of a connection then setting the
        value will have no effect as once the node is re-evaluated the
        attribute value will be reset.

        Returns:
        -----
        None

        Parameters:
        -----
        val: MAngle
        	[in] -> The value to which the attribute will be set


        '''
        pass

    def setMTime(self, val: MTime): 
        '''
        setMTime(self, val: MTime)

        Synopsis
        -----
        Set the current value of the attribute this plug references. If
        the attribute is the destination of a connection then setting the
        value will have no effect as once the node is re-evaluated the
        attribute value will be reset.

        Returns:
        -----
        None

        Parameters:
        -----
        val: MTime
        	[in] -> The value to which the attribute will be set


        '''
        pass

    def setChar(self, val: char): 
        '''
        setChar(self, val: char)

        Synopsis
        -----
        Set the current value of the attribute this plug references. If
        the attribute is the destination of a connection then setting the
        value will have no effect as once the node is re-evaluated the
        attribute value will be reset.

        Returns:
        -----
        None

        Parameters:
        -----
        val: char
        	[in] -> The value to which the attribute will be set


        '''
        pass

    def setString(self, val: MString): 
        '''
        setString(self, val: MString)

        Synopsis
        -----
        Set the current value of the attribute this plug references. If
        the attribute is the destination of a connection then setting the
        value will have no effect as once the node is re-evaluated the
        attribute value will be reset.

        Returns:
        -----
        None

        Parameters:
        -----
        val: MString
        	[in] -> The value to which the attribute will be set


        '''
        pass

    def proxied(self): 
        '''
        proxied(self) -> MPlug

        Synopsis
        -----
        Introduced in 2023.0 Returns the proxied plug for this plug.If
        this plug is an empty plug or not a proxy plug it will simply
        return itself. If this plug is a proxy but unconnected it will
        return a null plug. If this plug is valid and it is a proxy plug
        then it will return the proxied plug. Note that proxy attributes
        can be chained together so a proxy plug can be a proxy for
        another proxy plug. If that is the case, proxied will recurse
        until it finds the proxied plug in the chain of connections.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def __getitem__(self, physicalIndex: int): 
        '''
        __getitem__(self, physicalIndex: int) -> MPlug

        Synopsis
        -----
        This method will find and return a plug with the given physical
        index. This is the same as the elementByPhysicalIndex method.

        Returns: 
        ----- 
        A plug with the given index

        Parameters:
        -----
        physicalIndex: int
        	[in] -> Array index of child plug


        '''
        pass

    def isExactlyEqual(self, other: MPlug): 
        '''
        isExactlyEqual(self, other: MPlug) -> bool

        Synopsis
        -----
        Introduced in 2024.0 Exact comparison method for MPlugs.Plugs are
        considered exactly equal if they refer to the same node,
        attribute and multi-index.If either or both plugs are null, the
        plugs are not considered equal.

        Returns: 
        ----- 
        true If the plugs are exactly equal  false If the plugs are not
        exactly equal

        Parameters:
        -----
        other: MPlug
        	[in] -> Other plug to compare against


        '''
        pass

    @overload
    def __eq__(self, other: MPlug): 
        '''
        __eq__(self, other: MPlug) -> bool

        Synopsis
        -----
        Comparison operator for MPlugs. Plugs are considered equal if
        they refer to the same node and attribute.If either or both plugs
        are null, the plugs are not considered equal.

        Returns: 
        ----- 
        true If the plugs are equal  false If the plugs are not equal

        Parameters:
        -----
        other: MPlug
        	[in] -> Other plug to compare against


        '''
        pass

    @overload
    def __eq__(self, attr: MObject): 
        '''
        __eq__(self, attr: MObject) -> bool

        Synopsis
        -----
        Comparison operator for a plug and an attribute. This actually
        compares the plug's attribute against the other attribute.

        Returns: 
        ----- 
        true If the plug's attribute is equal  false If the plug's
        attribute is not equal

        Parameters:
        -----
        attr: MObject
        	[in] -> Attribute to compare against


        '''
        pass

    @overload
    def __neq__(self, other: MPlug): 
        '''
        __neq__(self, other: MPlug) -> bool

        Synopsis
        -----
        The inequality operator for MPlugs. Plugs are considered equal if
        they refer to the same node and attribute.If either or both plugs
        are null, the plugs are not considered equal.

        Returns: 
        ----- 
        true If the plugs are not equal  false If the plugs are equal

        Parameters:
        -----
        other: MPlug
        	[in] -> Other plug to compare against


        '''
        pass

    @overload
    def __neq__(self, attr: MObject): 
        '''
        __neq__(self, attr: MObject) -> bool

        Synopsis
        -----
        The inequality operator for a plug and an attribute. This
        actually compares the plug's attribute against the other
        attribute.

        Returns: 
        ----- 
        true If the plug's attribute is not equal  false If the plug's
        attribute is equal

        Parameters:
        -----
        attr: MObject
        	[in] -> Attribute to compare against


        '''
        pass

    def setNumElements(self, elements: int): 
        '''
        setNumElements(self, elements: int)

        Synopsis
        -----
        The method is used to pre-allocate the number of elements that an
        array plug will contain. The plug passed to this method must be
        an array plug and there must be no elements already allocated.The
        numElements() method is used to find the number of elements
        already in the array plug.

        Returns:
        -----
        None

        Parameters:
        -----
        elements: int
        	[in] -> new array size


        '''
        pass

    def isSource(self, ReturnStatus: MPlug.MStatus): 
        '''
        isSource(self, ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        Determines if this plug is connected as a source.

        Returns: 
        ----- 
        true  plug is connected as a source  false  plug is not connected
        as a source

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> pointer to a status code object


        '''
        pass

    def isDestination(self, ReturnStatus: MPlug.MStatus): 
        '''
        isDestination(self, ReturnStatus: MPlug.MStatus) -> bool

        Synopsis
        -----
        Determines if this plug is connected as a destination.

        Returns: 
        ----- 
        true  plug is connected as a destination  false  plug is not
        connected as a destination

        Parameters:
        -----
        ReturnStatus: MPlug.MStatus
        	[out] -> pointer to a status code object


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MValueSelector:
    '''Which values to generate setAttr commands for. 
    Non-functional class.  Values for this enum:
    kAll
    kNonDefault
    kChanged
    kLastAttrSelector
    '''

    def __init__(self):
        pass

    def kAll(self):
        '''This is an enum of MValueSelector.
        - Description: All values. 
        - Value: 0
        '''
        pass

    def kNonDefault(self):
        '''This is an enum of MValueSelector.
        - Description: Non default values. 
        - Value: 1
        '''
        pass

    def kChanged(self):
        '''This is an enum of MValueSelector.
        - Description: Changed values. 
        - Value: 2
        '''
        pass

    def kLastAttrSelector(self):
        '''This is an enum of MValueSelector.
        - Description: Last value, for counting. 
        - Value: 3
        '''
        pass

class FreeToChangeState:
    '''Plug state returned by isFreeToChange. 
    Non-functional class.  Values for this enum:
    kFreeToChange
    kNotFreeToChange
    kChildrenNotFreeToChange
    '''

    def __init__(self):
        pass

    def kFreeToChange(self):
        '''This is an enum of FreeToChangeState.
        - Description: All tested plugs are free to change. 
        - Value: 0
        '''
        pass

    def kNotFreeToChange(self):
        '''This is an enum of FreeToChangeState.
        - Description: Some of the tested plugs are not free to change. 
        - Value: 1
        '''
        pass

    def kChildrenNotFreeToChange(self):
        '''This is an enum of FreeToChangeState.
        - Description: Some of the children are not free to change. 
        - Value: 2
        '''
        pass

class MPlugArray:
    '''Array of MPlugs data type.
This class implements an array of MPlugs. Common convenience
functions are available, and the implementation is compatible
with the internal Maya implementation so that it can be passed
efficiently between plugins and internal maya data structures.
'''
    def __init__(self):
        pass


    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> const MPlug&

        Synopsis
        -----
        Index operator. Returns the value of the element at the given
        index. No range checking is done - valid indices are 0 to
        length()-1.

        Returns: 
        ----- 
        The value of the indicated element

        Parameters:
        -----
        index: int
        	[in] -> the index of the desired element


        '''
        pass

    def set(self, element: MPlug,
                        index: int): 
        '''
        set(self, element: MPlug,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated MPlug
        value.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MPlug
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    def setLength(self, length: int): 
        '''
        setLength(self, length: int)

        Synopsis
        -----
        Set the length of the array. This will grow and shrink the array
        as desired. Elements that are grown have uninitialized values,
        while those which are shrunk will lose the data contained in the
        deleted elements (ie. it will release the memory).

        Returns:
        -----
        None

        Parameters:
        -----
        length: int
        	[in] -> the new size of the array 


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Returns the number of elements in the instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Remove the array element at the given index. All array elements
        following the removed element are shifted toward the first
        element.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> index of the element to be removed


        '''
        pass

    def insert(self, element: MPlug,
                        index: int): 
        '''
        insert(self, element: MPlug,
                        index: int)

        Synopsis
        -----
        Inserts a new value into the array at the given index. The
        initial element at that index, and all following elements, are
        shifted towards the last. If the array cannot be expanded in size
        by 1 element, then the insert will fail and the existing array
        will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MPlug
        	[in] -> the new value to insert into the array 

        index: int
        	[in] -> the index of the element to set to the the new value


        '''
        pass

    def append(self, element: MPlug): 
        '''
        append(self, element: MPlug)

        Synopsis
        -----
        Adds a new element to the end of the array. If the array cannot
        be expanded in size by 1 element, then the append will fail and
        the existing array will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MPlug
        	[in] -> the value for the new last element


        '''
        pass

    def copy(self, source: MPlugArray): 
        '''
        copy(self, source: MPlugArray)

        Synopsis
        -----
        Copy the contents of the source array to this array.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MPlugArray
        	[in] -> array to copy from


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clear the contents of the array. After this operation the length
        method will return 0. This does not change the amount of memory
        allocated to the array, only the number of valid elements in it.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setSizeIncrement(self, newIncrement: int): 
        '''
        setSizeIncrement(self, newIncrement: int)

        Synopsis
        -----
        Set the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        newIncrement: int
        	[in] -> the new increment 


        '''
        pass

    def sizeIncrement(self): 
        '''
        sizeIncrement(self) -> int

        Synopsis
        -----
        Return the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MPlugArray.MPlugArray

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MPlugArray.MPlugArray

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MPlugArray.MPlugArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MPlugArray.MPlugArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MPlugArray.MPlugArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MPlugArray.MPlugArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MPoint:
    '''Implementation of a point.
This class provides an implementation of a point. Numerous
convienence operators are provided to help with the manipulation
of points. This includes operators that work with the
MVector and
MMatrix classes.
All methods that query the point are threadsafe, all methods that
modify the point are not threadsafe.
'''
    def __init__(self):
        pass


    @overload
    def get(self, dest: double4): 
        '''
        get(self, dest: double4)

        Synopsis
        -----
        Copy the values of x, y, z, and w from the instance to the four
        elements of the given array of doubles.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: double4
        	[out] -> The four element array of doubles.


        '''
        pass

    @overload
    def get(self, dest: float4): 
        '''
        get(self, dest: float4)

        Synopsis
        -----
        Copy the values of x, y, z, and w from the instance to the four
        elements of the given array of floats.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: float4
        	[out] -> The four element array of floats.


        '''
        pass

    def __getitem__(self, i: int): 
        '''
        __getitem__(self, i: int) -> double

        Synopsis
        -----
        The index operator.

        Returns: 
        ----- 
        The value of the indicated component of the instance.

        Parameters:
        -----
        i: int
        	[in] -> Value indicating which component to return.


        '''
        pass

    @overload
    def __sub__(self, other: MPoint): 
        '''
        __sub__(self, other: MPoint) -> MVector

        Synopsis
        -----
        The subtraction operator for two MPoints. The result is the
        MVector from the other point to this instance.

        Returns: 
        ----- 
        MVector from the other point to this point

        Parameters:
        -----
        other: MPoint
        	[in] -> The other point.


        '''
        pass

    def __add__(self, other: MVector): 
        '''
        __add__(self, other: MVector) -> MPoint

        Synopsis
        -----
        The addition operator for adding an MVector to an MPoint. A new
        point is returned whose position is that of the original point
        translated by the vector.

        Returns: 
        ----- 
        The resulting point.

        Parameters:
        -----
        other: MVector
        	[in] -> Vector to add.


        '''
        pass

    @overload
    def __sub__(self, other: MVector): 
        '''
        __sub__(self, other: MVector) -> MPoint

        Synopsis
        -----
        The addition operator for subtracting an MVector from an MPoint.
        A new point is returned whose position is that of the original
        point translated by the inverse of the vector.

        Returns: 
        ----- 
        The resulting point.

        Parameters:
        -----
        other: MVector
        	[in] -> Vector to subtract.


        '''
        pass

    def __radd__(self, vector: MVector): 
        '''
        __radd__(self, vector: MVector) -> MPoint

        Synopsis
        -----
        The in-place addition operator for adding an MVector to an
        MPoint. The current instance is translated from its original
        position by the vector.

        Returns: 
        ----- 
        A reference to the resulting point.

        Parameters:
        -----
        vector: MVector
        	[in] -> Vector to add.


        '''
        pass

    def __rsub__(self, vector: MVector): 
        '''
        __rsub__(self, vector: MVector) -> MPoint

        Synopsis
        -----
        The in-place subtraction operator for subtracting an MVector from
        an MPoint. The current instance is translated from its original
        position by the inverse of the vector.

        Returns: 
        ----- 
        A reference to the resulting point.

        Parameters:
        -----
        vector: MVector
        	[in] -> Vector to subtract.


        '''
        pass

    def __div__(self, scale: double): 
        '''
        __div__(self, scale: double) -> MPoint

        Synopsis
        -----
        The division operator that allows the vector to by scaled by the
        given double parameter. The x, y, and z components are each
        divided by the parameter. The w component remains unchanged.

        Returns: 
        ----- 
        The resulting point.

        Parameters:
        -----
        scale: double
        	[in] -> The scale parameter.


        '''
        pass

    def __eq__(self, other: MPoint): 
        '''
        __eq__(self, other: MPoint) -> bool

        Synopsis
        -----
        The equality operator.

        Returns: 
        ----- 
        True if all of the x, y, z and w components of the two points are
        identical.

        Parameters:
        -----
        other: MPoint
        	[in] -> Point to compare with.


        '''
        pass

    def __neq__(self, other: MPoint): 
        '''
        __neq__(self, other: MPoint) -> bool

        Synopsis
        -----
        The inequality operator.

        Returns: 
        ----- 
        True if any of the x, y, z and w components of the two points are
        not identical.

        Parameters:
        -----
        other: MPoint
        	[in] -> Point to compare with.


        '''
        pass

    def cartesianize(self): 
        '''
        cartesianize(self) -> MPoint

        Synopsis
        -----
        If this point instance is of the form P(W*x, W*y, W*z, W), for
        some scale factor W != 0, then it is reset to be P(x, y, z, 1).
        This will only work correctly if the point is in homogenous form
        or cartesian form. If the point is in rational form, the results
        are not defined.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def rationalize(self): 
        '''
        rationalize(self) -> MPoint

        Synopsis
        -----
        If this point instance is of the form P(W*x, W*y, W*z, W) (ie. is
        in homogenous or (for W==1) cartesian form), for some scale
        factor W != 0, then it is reset to be P(x, y, z, W). This will
        only work correctly if the point is in homogenous or cartesian
        form. If the point is already in rational form, the resultsare
        not defined.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def homogenize(self): 
        '''
        homogenize(self) -> MPoint

        Synopsis
        -----
        If this point instance is of the form P(x, y, z, W) (ie. is in
        rational or (for W==1) cartesian form), for some scale factor W
        != 0, then it is reset to be P(W*x, W*y, W*z, W).

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def distanceTo(self, other: MPoint): 
        '''
        distanceTo(self, other: MPoint) -> double

        Synopsis
        -----
        Return the distance between this instance and the point passed as
        an argument.

        Returns: 
        ----- 
        The distance between the two points.

        Parameters:
        -----
        other: MPoint
        	[in] -> The point to compute the distance to.


        '''
        pass

    def isEquivalent(self, other: MPoint,
                        tol: double): 
        '''
        isEquivalent(self, other: MPoint,
                        tol: double) -> bool

        Synopsis
        -----
        Returns true if this instance of the point passed as an argument
        represent the same position within the specified tolerance.

        Returns: 
        ----- 
        True if the points are equal within the given tolerance and false
        otherwise.

        Parameters:
        -----
        other: MPoint
        	[in] -> The other point to compare to. 

        tol: double
        	[in] -> The tolerance to use during the comparison.


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MPointArray:
    '''Array of
MPoint data type.
This class implements an array of MPoints. Common convenience
functions are available, and the implementation is compatible
with the internal Maya implementation so that it can be passed
efficiently between plugins and internal maya data structures.
'''
    def __init__(self):
        pass


    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> const MPoint&

        Synopsis
        -----
        Index operator. Returns the value of the element at the given
        index. No range checking is done - valid indices are 0 to
        length()-1.

        Returns: 
        ----- 
        The value of the indicated element.

        Parameters:
        -----
        index: int
        	[in] -> the index of the element whose value is to be returned


        '''
        pass

    @overload
    def set(self, element: MPoint,
                        index: int): 
        '''
        set(self, element: MPoint,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated value.
        NOTE: This method does not grow the array if the index is out of
        bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MPoint
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    @overload
    def set(self, index: int,
                        x: double,
                        y: double,
                        z: double,
                        w: double): 
        '''
        set(self, index: int,
                        x: double,
                        y: double,
                        z: double,
                        w: double)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated values.
        The x component of the element is set to x, the y component to y,
        the z component to z, and the w component to w.NOTE: This method
        does not grow the array if the index is out of bounds. Only a
        valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the index of the element that is to be set to the the new value 

        x: double
        	[in] -> the new value for the x component 

        y: double
        	[in] -> the new value for the y component 

        z: double
        	[in] -> the new value for the z component,defaulted to 0 

        w: double
        	[in] -> the new value for the w component,defaulted to 1


        '''
        pass

    @overload
    def set(self, val: double4,
                        index: int): 
        '''
        set(self, val: double4,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated value.
        The x component of the element is set to val[0], the y component
        to val[1], the z component to val[2], and the w component to
        val[3].NOTE: This method does not grow the array if the index is
        out of bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        val: double4
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    @overload
    def set(self, val: float4,
                        index: int): 
        '''
        set(self, val: float4,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated value.
        The x component of the element is set to val[0], the y component
        to val[1], the z component to val[2], and the w component to
        val[3].NOTE: This method does not grow the array if the index is
        out of bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        val: float4
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    def setLength(self, length: int): 
        '''
        setLength(self, length: int)

        Synopsis
        -----
        Set the length of the array. This will grow and shrink the array
        as desired. Elements that are grown have uninitialized values,
        while those which are shrunk will lose the data contained in the
        deleted elements (ie. it will release the memory).

        Returns:
        -----
        None

        Parameters:
        -----
        length: int
        	[in] -> the new size of the array 


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Returns the number of elements in the instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Remove the array element at the given index. All array elements
        following the removed element are shifted toward the first
        element.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> index of the element to be removed


        '''
        pass

    def insert(self, element: MPoint,
                        index: int): 
        '''
        insert(self, element: MPoint,
                        index: int)

        Synopsis
        -----
        Inserts a new value into the array at the given index. The
        initial element at that index, and all following elements, are
        shifted towards the last. If the array cannot be expanded in size
        by 1 element, then the insert will fail and the existing array
        will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MPoint
        	[in] -> the new value to insert into the array 

        index: int
        	[in] -> the index of the element to set to the the new value


        '''
        pass

    @overload
    def append(self, element: MPoint): 
        '''
        append(self, element: MPoint)

        Synopsis
        -----
        Adds a new element to the end of the array. If the array cannot
        be expanded in size by 1 element, then the append will fail and
        the existing array will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MPoint
        	[in] -> the value for the new last element


        '''
        pass

    @overload
    def append(self, x: double,
                        y: double,
                        z: double,
                        w: double): 
        '''
        append(self, x: double,
                        y: double,
                        z: double,
                        w: double)

        Synopsis
        -----
        Adds a new element to the end of the array. The appended element
        has the indicated values for its x,y,z and w components. The x
        component of the element is set to x, the y component to y, the z
        component to z, and the w component to w.If the array cannot be
        expanded in size by 1 element, then the append will fail and the
        existing array will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        x: double
        	[in] -> the value for the x component 

        y: double
        	[in] -> the value for the y component 

        z: double
        	[in] -> the value for the z component, defaulted to 0 

        w: double
        	[in] -> the value for the w component, defaulted to 1


        '''
        pass

    def copy(self, source: MPointArray): 
        '''
        copy(self, source: MPointArray)

        Synopsis
        -----
        Copy the contents of the source array to this array.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MPointArray
        	[in] -> array to copy from


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clear the contents of the array. After this operation the length
        method will return 0. This does not change the amount of memory
        allocated to the array, only the number of valid elements in it.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def get(self, dest: double): 
        '''
        get(self, dest: double)

        Synopsis
        -----
        Copy the elements of the array into the C++ array of double
        arrays. No checking is done to ensure that the destination C++
        array of double arrays is large enough to hold all the elements
        of the instance.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: double
        	[out] -> the array to populate


        '''
        pass

    @overload
    def get(self, dest: float): 
        '''
        get(self, dest: float)

        Synopsis
        -----
        Copy the elements of the array into the C++ array of float
        arrays. No checking is done to ensure that the destination C++
        array of float arrays is large enough to hold all the elements of
        the instance.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: float
        	[out] -> the array to populate


        '''
        pass

    def setSizeIncrement(self, newIncrement: int): 
        '''
        setSizeIncrement(self, newIncrement: int)

        Synopsis
        -----
        Set the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        newIncrement: int
        	[in] -> the new increment 


        '''
        pass

    def sizeIncrement(self): 
        '''
        sizeIncrement(self) -> int

        Synopsis
        -----
        Return the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MPointArray.MPointArray

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MPointArray.MPointArray

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MPointArray.MPointArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MPointArray.MPointArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MPointArray.MPointArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MPointArray.MPointArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MPointOnMesh:
    '''Mesh intersector result.
This class is used to return information about a point on a mesh:
3D position, normal, barycentric coordinates, etc. Note that this
can be a point anywhere on the surface of the mesh, not just at
vertices.
'''
    def __init__(self):
        pass


    def getBarycentricCoords(self, u: float,
                        v: float): 
        '''
        getBarycentricCoords(self, u: float,
                        v: float)

        Synopsis
        -----
        This method returns the barycentric coordinates of the closest
        point on the mesh. If the triangle has vertices (a, b, c) then
        the point returned by getPoint() is at coordinates u*a + v*b + (1
        - u - v)*c. The barycentric coordinates are particularly useful
        when interpolating attributes from one mesh to another.

        Returns:
        -----
        None

        Parameters:
        -----
        u: float
        	[out] -> The relative contribution of the first vertex of the triangle. 

        v: float
        	[out] -> The relative contribution of the second vertex of the triangle. 


        '''
        pass

class MPolyMessage:
    '''Polygon component id change messages.
This class is used to register callbacks for poly component id
modification messages.
There is 1 add callback method which will add callbacks for the
following messages:
To remove a callback use
MMessage::removeCallback. All callbacks that are registered by a plug-in must be removed
by that plug-in when it is unloaded. Failure to do so will result
in a fatal error.
'''
    def __init__(self):
        pass


    def enum(self): 
        '''
        enum(self) -> anonymous

        Synopsis
        -----
        Values passed in addPolyComponentIdChangeCallback's
        "wantIdModifications" array to indicate which component id
        changes should trigger the callback. vertex component id changed
        edge component id changed face component id changed 

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def addPolyComponentIdChangedCallback(self, node: MObject,
                        wantIdModifications: bool,
                        count: int,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MPolyMessage.MStatus): 
        '''
        addPolyComponentIdChangedCallback(self, node: MObject,
                        wantIdModifications: bool,
                        count: int,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MPolyMessage.MStatus) -> MPolyMessage.OPENMAYA_MAJOR_NAMESPACE_OPENMCallbackId

        Synopsis
        -----
        This method registers a callback that should be called whenever a
        poly component id is modified. Currently, there are some cases
        where the component ids for a polygonal mesh can be modified
        without generating a callback or without generating a correct
        mapping. These cases are outlined below.Component id mapping
        should always work correctly when construction history is off. It
        should also work correctly when construction history is on and
        only the most recent operation is permitted to be adjusted (eg.
        changing the distance parameter for a merge vertex node, when
        merge vertices was the most recent operation.) In either case,
        undo will not produce a poly message callback.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MObject
        	[in] -> the node callback function should listen to 

        wantIdModifications: bool
        	[in] -> array of booleans specifying what arrays should be provided to the callback function when it is invoked. The entries in this array are kVertexIndex, kEdgeIndex, kFaceIndex for receiving vertex, edge, and face data in the callback respectively. 

        count: int
        	[in] -> the size of the array wantIdModifications 

        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MPolyMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addPolyTopologyChangedCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MPolyMessage.MStatus): 
        '''
        addPolyTopologyChangedCallback(self, node: MObject,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MPolyMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that will be called when a node
        impacting the topology of a meshShape is modified. Because the
        callback is invoked before the mesh has evaluated, the new
        topology data cannot be queried at the time the callback is
        received. If you want to receive a callback at a time when the
        new mesh data can be queried, use the following technique:

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MObject
        	[in] -> the node the callback function should listen to 

        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MPolyMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addUVSetChangedCallback(self, node: MObject,
                        func: MPolyMessage.MPolyMessage,
                        clientData: void,
                        ReturnStatus: MPolyMessage.MStatus): 
        '''
        addUVSetChangedCallback(self, node: MObject,
                        func: MPolyMessage.MPolyMessage,
                        clientData: void,
                        ReturnStatus: MPolyMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that will be called when UV set
        is modified.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MObject
        	[in] -> the node the callback function should listen to 

        func: MPolyMessage.MPolyMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MPolyMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addColorSetChangedCallback(self, node: MObject,
                        func: MPolyMessage.MPolyMessage,
                        clientData: void,
                        ReturnStatus: MPolyMessage.MStatus): 
        '''
        addColorSetChangedCallback(self, node: MObject,
                        func: MPolyMessage.MPolyMessage,
                        clientData: void,
                        ReturnStatus: MPolyMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        Introduced in 2019.0 This method registers a callback that will
        be called when color set is modified.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        node: MObject
        	[in] -> the node the callback function should listen to 

        func: MPolyMessage.MPolyMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MPolyMessage.MStatus
        	[out] -> status code


        '''
        pass

    def deletedId(self): 
        '''
        deletedId(self) -> int

        Synopsis
        -----
        This method returns a constant which is to be used to determine
        if a component id has been deleted. Compare component ids
        returned by the callback with the value return by this method. If
        they are the same then, the component id has been deleted.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MessageType:
    '''Types of UV set change messages. 
    Non-functional class.  Values for this enum:
    kUVSetAdded
    kUVSetDeleted
    kCurrentUVSetChanged
    '''

    def __init__(self):
        pass

    def kUVSetAdded(self):
        '''This is an enum of MessageType.
        - Description: new UV set added 
        - Value: 0
        '''
        pass

    def kUVSetDeleted(self):
        '''This is an enum of MessageType.
        - Description: UV set deleted. 
        - Value: 1
        '''
        pass

    def kCurrentUVSetChanged(self):
        '''This is an enum of MessageType.
        - Description: current UV set changed 
        - Value: 2
        '''
        pass

class ColorSetMessageType:
    '''Introduced in 2019.0 
    Non-functional class.  Values for this enum:
    kColorSetAdded
    kColorSetDeleted
    kCurrentColorSetChanged
    '''

    def __init__(self):
        pass

    def kColorSetAdded(self):
        '''This is an enum of ColorSetMessageType.
        - Description: new Color set added 
        - Value: 0
        '''
        pass

    def kColorSetDeleted(self):
        '''This is an enum of ColorSetMessageType.
        - Description: Color set deleted. 
        - Value: 1
        '''
        pass

    def kCurrentColorSetChanged(self):
        '''This is an enum of ColorSetMessageType.
        - Description: current Color set changed 
        - Value: 2
        '''
        pass

class MProfiler:
    '''Class for working with Maya's profiler.
MProfiler is a static class which provides access to Maya's profiler.
Maya's profiler is used to profile execution time of instrumented
code. User can review the profiling result in the Profiler
Window. Or use the MEL command "profiler" to save the profiling
result to a file.
The profiling results are represented by two types of events:
Normal Event and Signal Event. Normal Event has a duration
representing the execution time of the instrumented code. A
Signal Event only remembers the start moment and has no knowledge
about duration. It can be used in cases when the user does not
care about the duration but only cares if this event does happen.
This class provides access to profiler settings and the profiling
result. To instrument a specific code snippet you must create an
instance of MProfilerScope. See that class for more details.
This class does not provide the ability to start/stop the
recording. Recording can be started/stopped using either the
Profiler Window or the "profiler -sampling true/false" command.
When recording is active only those categories which have been
set to be recorded (i.e. categoryRecording(categoryId) returns
true) will have their profiling data included in the recording.
There are two ways to instrument code, one is to use
MProfiler::eventBegin and MProfier::eventEnd, which give user more flexible control
over when to start and stop the profiling for certain part of
code, but it is also the user's responsibility to call eventEnd
for eventBegin, if user fails to do so, the event will be taken
as a signal event. The other way is to use
MProfilingScope, which will stop the event automatically when the
MProfilingScope object is out of its life scope.
'''
    def __init__(self):
        pass


    def addCategory(self, categoryName: char,
                        categoryInfo: char): 
        '''
        addCategory(self, categoryName: char,
                        categoryInfo: char) -> int

        Synopsis
        -----
        Introduced in 2019.0 ============================================
        ========================== Add a new profiling category with a
        description.Categories can only be added when sampling is off and
        the buffer is empty.

        Returns: 
        ----- 
        Index of the newly added category or -1 if fail to add the
        category.

        Parameters:
        -----
        categoryName: char
        	[in] -> The name of the category to add. 

        categoryInfo: char
        	[in] -> The description of the category to add.


        '''
        pass

    def removeCategory(self, categoryName: char): 
        '''
        removeCategory(self, categoryName: char) -> int

        Synopsis
        -----
        =================================================================
        ===== Remove an existing profiling category. User can only remove
        category when the sampling is off and the buffer is empty.

        Returns: 
        ----- 
        Index of the removed category or -1 if fail to remove the
        category..

        Parameters:
        -----
        categoryName: char
        	[in] -> The name of the category to remove.


        '''
        pass

    def getAllCategories(self, categoryNames: MStringArray,
                        categoryInfo: MStringArray): 
        '''
        getAllCategories(self, categoryNames: MStringArray,
                        categoryInfo: MStringArray)

        Synopsis
        -----
        Introduced in 2019.0 ============================================
        ========================== Return an array of the existing
        category names and descriptions.The two arrays have matching
        indices.

        Returns:
        -----
        None

        Parameters:
        -----
        categoryNames: MStringArray
        	[out] -> The names of all the existing categories. 

        categoryInfo: MStringArray
        	[out] -> The descriptions of all the existing categories. 


        '''
        pass

    def getCategoryIndex(self, categoryName: char): 
        '''
        getCategoryIndex(self, categoryName: char) -> int

        Synopsis
        -----
        =================================================================
        ===== Returns the category index.

        Returns: 
        ----- 
        The index of the specified category. -1 if no category with this
        name.

        Parameters:
        -----
        categoryName: char
        	[in] -> Name of the category to query.


        '''
        pass

    def getCategoryName(self, categoryId: int): 
        '''
        getCategoryName(self, categoryId: int) -> char*

        Synopsis
        -----
        =================================================================
        ===== Returns the category name.

        Returns: 
        ----- 
        The name of the specified category.

        Parameters:
        -----
        categoryId: int
        	[in] -> Index of the category to query.


        '''
        pass

    def getCategoryInfo(self, categoryId: int): 
        '''
        getCategoryInfo(self, categoryId: int) -> char*

        Synopsis
        -----
        Introduced in 2019.0 ============================================
        ========================== Returns the category description.

        Returns: 
        ----- 
        The description of the specified category.

        Parameters:
        -----
        categoryId: int
        	[in] -> Index of the category to query.


        '''
        pass

    @overload
    def categoryRecording(self, categoryName: char): 
        '''
        categoryRecording(self, categoryName: char) -> bool

        Synopsis
        -----
        =================================================================
        ===== Determine if a given category is allowed to be recorded.

        Returns: 
        ----- 
        True if the specified category is currently being recorded,
        otherwise false.

        Parameters:
        -----
        categoryName: char
        	[in] -> Name of the category to query.


        '''
        pass

    @overload
    def categoryRecording(self, categoryId: int): 
        '''
        categoryRecording(self, categoryId: int) -> bool

        Synopsis
        -----
        =================================================================
        ===== Determine if a given category is allowed to be recorded.

        Returns: 
        ----- 
        True if the specified category is currently being recorded,
        otherwise false.

        Parameters:
        -----
        categoryId: int
        	[in] -> Index of the category to query.


        '''
        pass

    @overload
    def setCategoryRecording(self, categoryName: char,
                        active: bool): 
        '''
        setCategoryRecording(self, categoryName: char,
                        active: bool)

        Synopsis
        -----
        =================================================================
        ===== Enable or disable the recording of the given category.

        Returns:
        -----
        None

        Parameters:
        -----
        categoryName: char
        	[in] -> Name of the category to set. 

        active: bool
        	[in] -> If True, the category will be recorded when profiling starts. If False, the category will not be recorded when profiling starts. 


        '''
        pass

    @overload
    def setCategoryRecording(self, categoryId: int,
                        active: bool): 
        '''
        setCategoryRecording(self, categoryId: int,
                        active: bool)

        Synopsis
        -----
        =================================================================
        ===== Enable or disable the recording of the given category.

        Returns:
        -----
        None

        Parameters:
        -----
        categoryId: int
        	[in] -> The category to set. 

        active: bool
        	[in] -> If True, the category will be recorded when profiling starts. If False, the category will not be recorded when profiling starts. 


        '''
        pass

    def signalEvent(self, categoryId: int,
                        colorIndex: MProfiler.ProfilingColor,
                        eventName: char,
                        description: char): 
        '''
        signalEvent(self, categoryId: int,
                        colorIndex: MProfiler.ProfilingColor,
                        eventName: char,
                        description: char)

        Synopsis
        -----
        =================================================================
        ===== Sending out a profiling signal.

        Returns:
        -----
        None

        Parameters:
        -----
        categoryId: int
        	[in] -> The index of the category which the event belongs to. 

        colorIndex: MProfiler.ProfilingColor
        	[out] -> The color to draw the profiling result in Profiler Window. 

        eventName: char
        	[in] -> The name of the event. 

        description: char
        	[in] -> Description of the event. 


        '''
        pass

    def eventBegin(self, categoryId: int,
                        colorIndex: MProfiler.ProfilingColor,
                        eventName: char,
                        description: char): 
        '''
        eventBegin(self, categoryId: int,
                        colorIndex: MProfiler.ProfilingColor,
                        eventName: char,
                        description: char) -> int

        Synopsis
        -----
        =================================================================
        ===== Start a profiling event.

        Returns: 
        ----- 
        The index of the started event.

        Parameters:
        -----
        categoryId: int
        	[in] -> The index of the category which the event belongs to. 

        colorIndex: MProfiler.ProfilingColor
        	[out] -> The color to draw the profiling result in Profiler Window. 

        eventName: char
        	[in] -> The name of the event. 

        description: char
        	[in] -> Description of the event.


        '''
        pass

    def eventEnd(self, eventId: int): 
        '''
        eventEnd(self, eventId: int)

        Synopsis
        -----
        =================================================================
        ===== Stop a profiling event.

        Returns:
        -----
        None

        Parameters:
        -----
        eventId: int
        	[in] -> The index of the event to stop. 


        '''
        pass

    def getEventCount(self): 
        '''
        getEventCount(self) -> int

        Synopsis
        -----
        =================================================================
        ===== Returns the events count.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getEventTime(self, eventIndex: int): 
        '''
        getEventTime(self, eventIndex: int) -> MUint64

        Synopsis
        -----
        =================================================================
        ===== Returns the time the event happens in microseconds. If you
        need to convert this time to other time unit, please create a
        MTime(microseconds/1000, kMilliSeconds) then do all time
        conversions by MTime.

        Returns: 
        ----- 
        The time the event happens in microseconds.

        Parameters:
        -----
        eventIndex: int
        	[in] -> The index of the event in the profiling buffer.


        '''
        pass

    def getEventDuration(self, eventIndex: int): 
        '''
        getEventDuration(self, eventIndex: int) -> int

        Synopsis
        -----
        =================================================================
        ===== Returns the duration of the event in microseconds. Note
        that a signal event has a 0 duration. If you need to convert this
        time to other time unit, please create a MTime(microseconds/1000,
        kMilliSeconds) then do all time conversions by MTime.

        Returns: 
        ----- 
        The duration of the event in microseconds.

        Parameters:
        -----
        eventIndex: int
        	[in] -> The index of the event in the profiling buffer.


        '''
        pass

    def getEventName(self, eventIndex: int): 
        '''
        getEventName(self, eventIndex: int) -> char*

        Synopsis
        -----
        =================================================================
        ===== Returns the name of the specified event.

        Returns: 
        ----- 
        The name of the specified event.

        Parameters:
        -----
        eventIndex: int
        	[in] -> The index of the event in the profiling buffer.


        '''
        pass

    def getDescription(self, eventIndex: int): 
        '''
        getDescription(self, eventIndex: int) -> char*

        Synopsis
        -----
        =================================================================
        ===== Returns the event description.

        Returns: 
        ----- 
        The event description.

        Parameters:
        -----
        eventIndex: int
        	[in] -> The index of the event in the profiling buffer.


        '''
        pass

    def getEventCategory(self, eventIndex: int): 
        '''
        getEventCategory(self, eventIndex: int) -> int

        Synopsis
        -----
        =================================================================
        ===== Returns the category the event belongs to.

        Returns: 
        ----- 
        The category the event belongs to.

        Parameters:
        -----
        eventIndex: int
        	[in] -> The index of the event in the profiling buffer.


        '''
        pass

    def getThreadId(self, eventIndex: int): 
        '''
        getThreadId(self, eventIndex: int) -> int

        Synopsis
        -----
        =================================================================
        ===== Returns the thread id the event ran on.

        Returns: 
        ----- 
        The thread id the event ran on.

        Parameters:
        -----
        eventIndex: int
        	[in] -> The index of the event in the profiling buffer.


        '''
        pass

    def getCPUId(self, eventIndex: int): 
        '''
        getCPUId(self, eventIndex: int) -> int

        Synopsis
        -----
        =================================================================
        ===== Returns the CPU id the event ran on.

        Returns: 
        ----- 
        The CPU id the event ran on.

        Parameters:
        -----
        eventIndex: int
        	[in] -> The index of the event in the profiling buffer.


        '''
        pass

    def isSignalEvent(self, eventIndex: int): 
        '''
        isSignalEvent(self, eventIndex: int) -> bool

        Synopsis
        -----
        =================================================================
        ===== Determine if a given event is a Signal Event.

        Returns: 
        ----- 
        True if the event is a Single Event, false otherwise.

        Parameters:
        -----
        eventIndex: int
        	[in] -> The index of the event in the profiling buffer.


        '''
        pass

    def getColor(self, eventIndex: int): 
        '''
        getColor(self, eventIndex: int) -> MProfiler.MProfiler

        Synopsis
        -----
        =================================================================
        ===== Returns the color used to draw this event in the Profiler
        Window.

        Returns: 
        ----- 
        The color used to draw this event in the Profiler Window.

        Parameters:
        -----
        eventIndex: int
        	[in] -> The index of the event in the profiling buffer.


        '''
        pass

    def getThreadDuration(self, eventIndex: int): 
        '''
        getThreadDuration(self, eventIndex: int) -> int

        Synopsis
        -----
        =================================================================
        ===== Returns the duration of the thread for a given event in
        microseconds.

        Returns: 
        ----- 
        The duration of the thread in microseconds.

        Parameters:
        -----
        eventIndex: int
        	[in] -> The index of the event in the profiling buffer.


        '''
        pass

    def getBufferSize(self): 
        '''
        getBufferSize(self) -> int

        Synopsis
        -----
        =================================================================
        ===== Returns the profiling buffer size.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setBufferSize(self, sizeInMegaytes: int): 
        '''
        setBufferSize(self, sizeInMegaytes: int)

        Synopsis
        -----
        =================================================================
        ===== Set the new profiling buffer size. The new buffer size will
        take effect for next recording. Before next recording started,
        the events already in the buffer won't be affected.

        Returns:
        -----
        None

        Parameters:
        -----
        sizeInMegaytes: int
        	[in] -> The new profiling buffer size in megabytes.


        '''
        pass

    def recordingActive(self): 
        '''
        recordingActive(self) -> bool

        Synopsis
        -----
        =================================================================
        ===== Determine if recording is active.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def eventDataAvailable(self): 
        '''
        eventDataAvailable(self) -> bool

        Synopsis
        -----
        =================================================================
        ===== Determine if any recorded event data is available.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def resetRecording(self): 
        '''
        resetRecording(self) -> bool

        Synopsis
        -----
        =================================================================
        ===== Clear out any recorded data. If a recording is active
        (samplingActive() returns True) then the data will not be
        cleared.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setRecordingActive(self, val: bool): 
        '''
        setRecordingActive(self, val: bool)

        Synopsis
        -----
        =================================================================
        ===== Enable or disable recording

        Returns:
        -----
        None

        Parameters:
        -----
        val: bool
        	[in] -> Value for enabling 


        '''
        pass

    def saveRecording(self, fileName: MString): 
        '''
        saveRecording(self, fileName: MString) -> bool

        Synopsis
        -----
        =================================================================
        ===== Save recording to a specified file location

        Returns: 
        ----- 
        True if recording was saved.

        Parameters:
        -----
        fileName: MString
        	[in] -> File location to save to.


        '''
        pass

    def loadRecording(self, fileName: MString): 
        '''
        loadRecording(self, fileName: MString) -> bool

        Synopsis
        -----
        =================================================================
        ===== Load a recording from a specified file location

        Returns: 
        ----- 
        True if recording was loaded.

        Parameters:
        -----
        fileName: MString
        	[in] -> File location to load from.


        '''
        pass

    def isDataFromFile(self): 
        '''
        isDataFromFile(self) -> bool

        Synopsis
        -----
        =================================================================
        ===== Return if the current event data was loaded from file.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getNumberOfCPUs(self): 
        '''
        getNumberOfCPUs(self) -> int

        Synopsis
        -----
        =================================================================
        ===== Return the number of CPUS used for profiling. If the
        current event data is loaded from file (Events().fromFile()
        returns True) then the number from the loaded data will be
        returned.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        =================================================================
        ===== Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MProfilingScope:
    '''MProfilingScope is used to profile code execution time.
Profiling begins with the creation of an
MProfilingScope instance and ends when the instance is destroyed (e.g. when it
goes out of scope at the end of the block in which it was
declared).
For example, if you want to profile any code snippet, you can
instrument it like this:
 When profilingScope is out of its life scope, the profiling
stops.
You can also assign an associated node during the
instrumentation, then all the profiling events generated from
this instrumentation can benefit from the ability of the profiler
view to select an associated dependency node for certain events.
'''
    def __init__(self):
        pass


    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        =================================================================
        ===== Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MQuaternion:
    '''Quaternion math.
This class provides methods for working with Quaternions.
Quaternions can be used to specify orientations and rotations of
3-D objects relative to a starting reference, similar to the way
that cartesian vectors can be used to specify positions and
translations of 3-D objects relative to an origin. Quaternions
represent orientations as a single rotation, just as rectangular
co-ordinates represent position as a single vector.
'''
    def __init__(self):
        pass


    def asMatrix(self): 
        '''
        asMatrix(self) -> MMatrix

        Synopsis
        -----
        Converts a quaternion to a 4X4 homogeneous rotation matrix. The
        construction of the matrix assumes that the vectors are going to
        be multiplied on the left side of the matrix. If the quaternion's
        length has degenerated, this method will still produce a well
        behaved matrix.ReturnValue

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asEulerRotation(self): 
        '''
        asEulerRotation(self) -> MEulerRotation

        Synopsis
        -----
        Converts a quaternion to an euler rotation. ReturnValue

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setAxisAngle(self, axis: MVector,
                        theta: double): 
        '''
        setAxisAngle(self, axis: MVector,
                        theta: double) -> MQuaternion

        Synopsis
        -----
        Sets this quaternion to be the rotation as expressed by a pivot
        axis and a rotation theta (in radians) about that axis. If the
        axis is too small the quaternion returned will be the identity
        quaternion.

        Returns: 
        ----- 
        A reference to the quaternion that has had its axis and angle set

        Parameters:
        -----
        axis: MVector
        	[in] -> the axis about which to rotate 

        theta: double
        	[in] -> the angle of rotation about the axis in radians


        '''
        pass

    def getAxisAngle(self, axis: MVector,
                        theta: double): 
        '''
        getAxisAngle(self, axis: MVector,
                        theta: double) -> bool

        Synopsis
        -----
        Converts this quaternion into a user understandable
        representation. That is, the quaternion is represented as a pivot
        vector 'axis' and a rotation 'theta' (in radians) about that
        pivot vector.If the identity unit quaternion is attempted to be
        converted to the pivot axis and angle representation it will be
        set to a zero degree rotation about the axis that was passed in.
        (Note that any axis will do, since an infinity of axis with
        rotation of zero satisfy the identity rotation.) If the axis is
        zero length, then an arbitrary axis will be chosen (z-axis).

        Returns: 
        ----- 
        true angle != 0  false angle == 0 (uses arbitrary axis, if given
        axis not valid)

        Parameters:
        -----
        axis: MVector
        	[out] -> the axis about which the rotation occurs 

        theta: double
        	[out] -> the angle of rotation about the axis in radians


        '''
        pass

    def setToXAxis(self, theta: double): 
        '''
        setToXAxis(self, theta: double) -> MQuaternion

        Synopsis
        -----
        Sets this quaternion to be the rotation about the X axis of theta
        (in radians). If the length of the axis is too small the
        quaternion returned will be the identity quaternion.

        Returns: 
        ----- 
        A reference to the quaternion that has been set to rotate about
        the X axis by the given amount

        Parameters:
        -----
        theta: double
        	[in] -> the angle of rotation about the X axis in radians


        '''
        pass

    def setToYAxis(self, theta: double): 
        '''
        setToYAxis(self, theta: double) -> MQuaternion

        Synopsis
        -----
        Sets this quaternion to be the rotation about the Y axis of theta
        (in radians). If the length of the axis is too small the
        quaternion returned will be the identity quaternion.

        Returns: 
        ----- 
        A reference to the quaternion that has been set to rotate about
        the Y axis by the given amount

        Parameters:
        -----
        theta: double
        	[in] -> the angle of rotation about the Y axis in radians


        '''
        pass

    def setToZAxis(self, theta: double): 
        '''
        setToZAxis(self, theta: double) -> MQuaternion

        Synopsis
        -----
        Sets this quaternion to be the rotation about the Z axis of theta
        (in radians). If the length of the axis is too small the
        quaternion returned will be the identity quaternion.

        Returns: 
        ----- 
        A reference to the quaternion that has been set to rotate about
        the Z axis by the given amount

        Parameters:
        -----
        theta: double
        	[in] -> the angle of rotation about the Z axis in radians


        '''
        pass

    def get(self, dest: double4): 
        '''
        get(self, dest: double4)

        Synopsis
        -----
        Extracts the x, y, z, and w components of the quaternion and
        places them in elements 0, 1, 2, and 3 of the double array
        passed.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: double4
        	[out] -> the array of 4 doubles into which the results are placed.


        '''
        pass

    def __getitem__(self, i: int): 
        '''
        __getitem__(self, i: int) -> double

        Synopsis
        -----
        The index operator. If its argument is 0 it will return the x
        component of the quaternion. If its argument is 1 it will return
        the y component of the quaternion. If its argument is 2 it will
        return the z component of the quaternion. If its argument is 3 it
        will return the w component of the quaternion.

        Returns: 
        ----- 
        The component of the quaternion corresponding to the index

        Parameters:
        -----
        i: int
        	[in] -> value indicating which component to return


        '''
        pass

    def __add__(self, other: MQuaternion): 
        '''
        __add__(self, other: MQuaternion) -> MQuaternion

        Synopsis
        -----
        The quaternion addition operator.

        Returns: 
        ----- 
        The sum of the two quaternions

        Parameters:
        -----
        other: MQuaternion
        	[in] -> the quaternion to be added to this quaternion


        '''
        pass

    @overload
    def __sub__(self, other: MQuaternion): 
        '''
        __sub__(self, other: MQuaternion) -> MQuaternion

        Synopsis
        -----
        The quaternion subtraction operator.

        Returns: 
        ----- 
        The quaternion that results from the subtraction

        Parameters:
        -----
        other: MQuaternion
        	[in] -> the quaternion to be subtracted from this quaternion


        '''
        pass

    @overload
    def __sub__(self): 
        '''
        __sub__(self) -> MQuaternion

        Synopsis
        -----
        The unary minus operator. Negates the value of each of the x, y,
        z, and w components of the quaternion.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def negateIt(self): 
        '''
        negateIt(self) -> MQuaternion

        Synopsis
        -----
        Performs an in place negation of the quaternion. The result is a
        quaternion whose x, y, z, and w values have been negated.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def __eq__(self, other: MQuaternion): 
        '''
        __eq__(self, other: MQuaternion) -> bool

        Synopsis
        -----
        The quaternion equality operator. This returns true if all four
        of the x, y, z, and w components are identical.

        Returns: 
        ----- 
        true the quaternions are identical  false the quaternions are not
        identical

        Parameters:
        -----
        other: MQuaternion
        	[in] -> the quaternion to be compared with this quaternion


        '''
        pass

    def __neq__(self, other: MQuaternion): 
        '''
        __neq__(self, other: MQuaternion) -> bool

        Synopsis
        -----
        The quaternion inequality operator. This returns false if all
        four of the x, y, z, and w components are identical.

        Returns: 
        ----- 
        true the quaternions are not identical  false the quaternions are
        identical

        Parameters:
        -----
        other: MQuaternion
        	[in] -> the quaternion to be compared with this quaternion


        '''
        pass

    def isEquivalent(self, other: MQuaternion,
                        tolerance: double): 
        '''
        isEquivalent(self, other: MQuaternion,
                        tolerance: double) -> bool

        Synopsis
        -----
        This method returns true if this quaternion is equal, within some
        given tolerance, to the other quaternion. 'tolerance' defaults to
        kQuaternionEpsilon which is 1.0e-10

        Returns: 
        ----- 
        true the quaternions are equivalent  false the quaternions are
        not equivalent

        Parameters:
        -----
        other: MQuaternion
        	[in] -> the quaternion to be compared with this quaternion 

        tolerance: double
        	[in] -> the amount of variation allowed for equivalency


        '''
        pass

    def scaleIt(self, scale: double): 
        '''
        scaleIt(self, scale: double) -> MQuaternion

        Synopsis
        -----
        Performs an in place scaling of the quaternion. The result is a
        quaternion whose x, y, z, and w values have been scaled by the
        specified amount.

        Returns: 
        ----- 
        A reference to the quaternion that has been scaled

        Parameters:
        -----
        scale: double
        	[in] -> the amount by which the quaternion should be scaled


        '''
        pass

    def normal(self): 
        '''
        normal(self) -> MQuaternion

        Synopsis
        -----
        Returns the normal of this quaternion. The result is a quaternion
        of unit length.If the quaternion is zero or has a very small
        length it will instead be set to the multiplicative identity.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def normalizeIt(self): 
        '''
        normalizeIt(self) -> MQuaternion

        Synopsis
        -----
        Performs an in place normalization of this quaternion. The result
        is a quaternion of unit length.If the quaternion is zero or has a
        very small length it will instead be set to the multiplicative
        identity.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def conjugate(self): 
        '''
        conjugate(self) -> MQuaternion

        Synopsis
        -----
        Returns the conjugate of this quaternion. The result is a
        quaternion whose x, y, and z values have been negated.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def conjugateIt(self): 
        '''
        conjugateIt(self) -> MQuaternion

        Synopsis
        -----
        Performs an in place conjugation of this quaternion. The result
        is a quaternion whose x, y, and z values have been negated.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def inverse(self): 
        '''
        inverse(self) -> MQuaternion

        Synopsis
        -----
        Returns the inverse of this quaternion.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def invertIt(self): 
        '''
        invertIt(self) -> MQuaternion

        Synopsis
        -----
        Performs an in place inversion of this quaternion.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def log(self): 
        '''
        log(self) -> MQuaternion

        Synopsis
        -----
        Returns the natural log of a quaternion. The precondition for
        using this method is that the quaternion must be normalized.Note
        that the log of a unit quaternion is not necessarily a unit
        quaternion.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def exp(self): 
        '''
        exp(self) -> MQuaternion

        Synopsis
        -----
        Exponentiates a quaternion that has a scalar part of zero. The
        precondition for using this method is that w is zero.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def slerp(self, p: MQuaternion,
                        q: MQuaternion,
                        t: double): 
        '''
        slerp(self, p: MQuaternion,
                        q: MQuaternion,
                        t: double) -> MQuaternion.OPENMAYA_EXPORT MQuaternion

        Synopsis
        -----
        Spherical linear interpolation (abbreviated as slerp) of unit
        quaternions. As t goes from 0 to 1, the quaternion returned goes
        from p to q. The interpolation always takes shortest path (in
        quaternion space) from p to q.

        Returns: 
        ----- 
        Quaternion that has been interpolated from p to q

        Parameters:
        -----
        p: MQuaternion
        	[in] -> quaternion to rotate from 

        q: MQuaternion
        	[in] -> quaternion to rotate to 

        t: double
        	[in] -> interpolation value


        '''
        pass

class MRampAttribute:
    '''Create and manipulate ramp attributes.
A ramp attribute consists of a set of entries describing a curve
which is used to map an input value onto an output value. Each
entry consists of an input
 ranging from 0 to 1, an output
 that position maps onto, and an enumerator indicating the type
of interpolation to use between that position and the next.
Currently two types of output values are a supported: a float, in
which case the attribute is displayed as a curve in the Attribute
Editor, or a color, in which case the attribute is displayed as a
color gradient, similar to how a ramp texture node is displayed.
The preferred way of creating a ramp is to use the
 set of methods. These methods will initialize the newly-created
ramp with input values.
A ramp must always have at least one entry. Ramp attributes
created with the
 and
 methods will automatically be given a default entry at position
0.0 with a value of 0.0 or black, depending upon the ramp type.
Any attempt to delete the last of a ramp's entries will fail.
This means that if you want to initialize a newly-created ramp
attribute with a specific set of entries you must add at least
one of your new entries first before deleting the default entry.
Alternatively, you can modify the default entry to match one of
your new entries and then add your remaining entries.
The
 set of methods can be used for setting existing ramps with new
entries, current entries are automatically removed and replaced
with the new ones.
 is perfect for initializing ramps created with the
 and
.
'''
    def __init__(self):
        pass


    def getNumEntries(self, ReturnStatus: MRampAttribute.MStatus): 
        '''
        getNumEntries(self, ReturnStatus: MRampAttribute.MStatus) -> int

        Synopsis
        -----
        Gets the number of entries in the ramp attribute.

        Returns: 
        ----- 
        The number of entries in the ramp attribute

        Parameters:
        -----
        ReturnStatus: MRampAttribute.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def getEntries(self, indices: MIntArray,
                        positions: MFloatArray,
                        values: MFloatArray,
                        interps: MIntArray,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        getEntries(self, indices: MIntArray,
                        positions: MFloatArray,
                        values: MFloatArray,
                        interps: MIntArray,
                        ReturnStatus: MRampAttribute.MStatus)

        Synopsis
        -----
        Gets all the entries in a ramp attribute. If the ramp is a color
        ramp, then this function will return a failure.

        Returns:
        -----
        None

        Parameters:
        -----
        indices: MIntArray
        	[out] -> unique values that specify each entry in the ramp 

        positions: MFloatArray
        	[out] -> the positions of each entry (can range from 0 to 1) 

        values: MFloatArray
        	[out] -> the values of the entries at each position (can range from 0 to 1) 

        interps: MIntArray
        	[out] -> array of 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> Status code.


        '''
        pass

    @overload
    def getEntries(self, indices: MIntArray,
                        positions: MFloatArray,
                        colors: MColorArray,
                        interps: MIntArray,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        getEntries(self, indices: MIntArray,
                        positions: MFloatArray,
                        colors: MColorArray,
                        interps: MIntArray,
                        ReturnStatus: MRampAttribute.MStatus)

        Synopsis
        -----
        Gets all the entries in a ramp attribute. If the ramp is a curve
        ramp, then this function will return a failure.

        Returns:
        -----
        None

        Parameters:
        -----
        indices: MIntArray
        	[out] -> unique values that specify each entry in the ramp 

        positions: MFloatArray
        	[out] -> the positions of each entry (can range from 0 to 1) 

        colors: MColorArray
        	[out] -> the colors of the entries at each position 

        interps: MIntArray
        	[out] -> array of 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> Status code.


        '''
        pass

    @overload
    def addEntries(self, positions: MFloatArray,
                        colors: MColorArray,
                        interps: MIntArray,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        addEntries(self, positions: MFloatArray,
                        colors: MColorArray,
                        interps: MIntArray,
                        ReturnStatus: MRampAttribute.MStatus)

        Synopsis
        -----
        Adds entries into a ramp attribute. If the ramp is a curve ramp,
        then this function will return a failure.

        Returns:
        -----
        None

        Parameters:
        -----
        positions: MFloatArray
        	[in] -> the positions of the new entries (can range from 0 to 1) 

        colors: MColorArray
        	[in] -> the colors of the new entries at each position 

        interps: MIntArray
        	[in] -> array of 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> Status code.


        '''
        pass

    @overload
    def addEntries(self, positions: MFloatArray,
                        values: MFloatArray,
                        interps: MIntArray,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        addEntries(self, positions: MFloatArray,
                        values: MFloatArray,
                        interps: MIntArray,
                        ReturnStatus: MRampAttribute.MStatus)

        Synopsis
        -----
        Adds entries into a ramp attribute. If the ramp is a color ramp,
        then this function will return a failure.

        Returns:
        -----
        None

        Parameters:
        -----
        positions: MFloatArray
        	[in] -> the positions of the new entries (can range from 0 to 1) 

        values: MFloatArray
        	[in] -> the values of the new entry at each position 

        interps: MIntArray
        	[in] -> array of 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> Status code.


        '''
        pass

    def deleteEntries(self, indices: MIntArray,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        deleteEntries(self, indices: MIntArray,
                        ReturnStatus: MRampAttribute.MStatus)

        Synopsis
        -----
        Deletes entries in the ramp attribute. If any one of the indices
        is incorrect, then this function will not delete any of the
        entries.A ramp attribute must always have at least one entry. Any
        attempt to delete the last remaining entry will fail.

        Returns:
        -----
        None

        Parameters:
        -----
        indices: MIntArray
        	[in] -> the entries that need to be deleted 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> Status code.


        '''
        pass

    def setColorAtIndex(self, color: MColor,
                        index: int,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        setColorAtIndex(self, color: MColor,
                        index: int,
                        ReturnStatus: MRampAttribute.MStatus)

        Synopsis
        -----
        Sets the color of a given entry. If there is no entry at the
        given index, then this method will return a failure. If this ramp
        is a curve ramp, then this method will return a failure.

        Returns:
        -----
        None

        Parameters:
        -----
        color: MColor
        	[in] -> the new color for the entry 

        index: int
        	[in] -> index of entry to change 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def setValueAtIndex(self, value: float,
                        index: int,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        setValueAtIndex(self, value: float,
                        index: int,
                        ReturnStatus: MRampAttribute.MStatus)

        Synopsis
        -----
        Sets the value of a given entry. If there is no entry at the
        given index, then this method will return a failure. If this ramp
        is a color ramp, then this method will return a failure.

        Returns:
        -----
        None

        Parameters:
        -----
        value: float
        	[in] -> the new value for the entry 

        index: int
        	[in] -> index of entry to change 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def setPositionAtIndex(self, position: float,
                        index: int,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        setPositionAtIndex(self, position: float,
                        index: int,
                        ReturnStatus: MRampAttribute.MStatus)

        Synopsis
        -----
        Sets the position of a given entry. If there is no entry at the
        given index, then this method will return a failure.

        Returns:
        -----
        None

        Parameters:
        -----
        position: float
        	[in] -> the new position for the entry 

        index: int
        	[in] -> index of entry to change 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def setInterpolationAtIndex(self, interp: MRampAttribute.MRampAttribute,
                        index: int,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        setInterpolationAtIndex(self, interp: MRampAttribute.MRampAttribute,
                        index: int,
                        ReturnStatus: MRampAttribute.MStatus)

        Synopsis
        -----
        Sets the interpolation of a given entry. If there is no entry at
        the given index, then this method will return a failure.

        Returns:
        -----
        None

        Parameters:
        -----
        interp: MRampAttribute.MRampAttribute
        	[in] -> the new interpolation for the entry 

        index: int
        	[in] -> index of entry to change 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def isColorRamp(self, ReturnStatus: MRampAttribute.MStatus): 
        '''
        isColorRamp(self, ReturnStatus: MRampAttribute.MStatus) -> bool

        Synopsis
        -----
        Checks to see whether this ramp is a color ramp.

        Returns: 
        ----- 
        true if the ramp is a color ramp, false otherwise

        Parameters:
        -----
        ReturnStatus: MRampAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def isCurveRamp(self, ReturnStatus: MRampAttribute.MStatus): 
        '''
        isCurveRamp(self, ReturnStatus: MRampAttribute.MStatus) -> bool

        Synopsis
        -----
        Checks to see whether this ramp is a curve ramp.

        Returns: 
        ----- 
        true if the ramp is a curve ramp, false otherwise

        Parameters:
        -----
        ReturnStatus: MRampAttribute.MStatus
        	[out] -> return status


        '''
        pass

    def getColorAtPosition(self, position: float,
                        color: MColor,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        getColorAtPosition(self, position: float,
                        color: MColor,
                        ReturnStatus: MRampAttribute.MStatus)

        Synopsis
        -----
        Gets the color at a position in the current evaluation context.
        Only use this version if you need to deliberately change the
        context of evaluation, e.g. to evaluate at a different time.If
        this ramp is a curve ramp, then this method will return a
        failure. If this ramp is empty, then this method will return a
        failure. If the position is out of range, either the start or end
        value will be returned.

        Returns:
        -----
        None

        Parameters:
        -----
        position: float
        	[in] -> the desired position 

        color: MColor
        	[in] -> the color at the position 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> Status code


        '''
        pass

    def getValueAtPosition(self, position: float,
                        value: float,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        getValueAtPosition(self, position: float,
                        value: float,
                        ReturnStatus: MRampAttribute.MStatus)

        Synopsis
        -----
        Gets the value at position in the current evaluation context. If
        this ramp is a color ramp, then this method will return a
        failure. If this ramp is empty, then this method will return a
        failure. If the position is out of range, either the start or end
        value will be returned.

        Returns:
        -----
        None

        Parameters:
        -----
        position: float
        	[in] -> the desired position 

        value: float
        	[out] -> the value at the position 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> 


        '''
        pass

    def sampleColorRamp(self, numberOfSamples: int,
                        colors: MColorArray,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        sampleColorRamp(self, numberOfSamples: int,
                        colors: MColorArray,
                        ReturnStatus: MRampAttribute.MStatus)

        Synopsis
        -----
        Perform a linear sampling of this color ramp at the current
        evaluation context and return the results. If this ramp is a
        curve ramp, then this method will return a failure. If this ramp
        is empty, then this method will return a failure. If the number
        of samples is less than two this method will return a failure.

        Returns:
        -----
        None

        Parameters:
        -----
        numberOfSamples: int
        	[in] -> The number of times to sample the ramp 

        colors: MColorArray
        	[out] -> The returned ramp samples 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> Status code


        '''
        pass

    def sampleValueRamp(self, numberOfSamples: int,
                        values: MFloatArray,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        sampleValueRamp(self, numberOfSamples: int,
                        values: MFloatArray,
                        ReturnStatus: MRampAttribute.MStatus)

        Synopsis
        -----
        Perform a linear sampling of this curve ramp in the current
        evaluation context and return the results. If this ramp is a
        color ramp, then this method will return a failure. If this ramp
        is empty, then this method will return a failure. If the number
        of samples is less than two this method will return a failure.

        Returns:
        -----
        None

        Parameters:
        -----
        numberOfSamples: int
        	[in] -> The number of times to sample the ramp 

        values: MFloatArray
        	[out] -> The returned ramp samples 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> Status code


        '''
        pass

    def hasIndex(self, index: int,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        hasIndex(self, index: int,
                        ReturnStatus: MRampAttribute.MStatus) -> bool

        Synopsis
        -----
        Returns true if this ramp attribute has an entry defined with a
        given index.

        Returns: 
        ----- 
        True if the index exists, false otherwise.

        Parameters:
        -----
        index: int
        	[in] -> Index to query. 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> Status code


        '''
        pass

    def sort(self, ascending: bool): 
        '''
        sort(self, ascending: bool)

        Synopsis
        -----
        Sort the ramp attribute entries by position in ascending or
        descending order, other arrays are sorted accordingly. Indices
        are also compressed during the operation.

        Returns:
        -----
        None

        Parameters:
        -----
        ascending: bool
        	[in] -> Option for sorting in ascending (default) or descending order.


        '''
        pass

    def pack(self): 
        '''
        pack(self)

        Synopsis
        -----
        Change the indices numbering by re-ordering them from 0.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def setRamp(self, value: float,
                        position: float,
                        interp: MRampAttribute.MInterpolation): 
        '''
        setRamp(self, value: float,
                        position: float,
                        interp: MRampAttribute.MInterpolation)

        Synopsis
        -----
        Sets this ramp attribute with one entry defined from a float,
        position and interpolation value. Existing entries are deleted
        before the new one is added.

        Returns:
        -----
        None

        Parameters:
        -----
        value: float
        	[in] -> Float value 

        position: float
        	[in] -> Desired position (defaults to 1.0) 

        interp: MRampAttribute.MInterpolation
        	[in] -> Interpolation value (defaults to MInterpolation::kLinear)


        '''
        pass

    @overload
    def setRamp(self, color: MColor,
                        position: float,
                        interp: MRampAttribute.MInterpolation): 
        '''
        setRamp(self, color: MColor,
                        position: float,
                        interp: MRampAttribute.MInterpolation)

        Synopsis
        -----
        Sets this ramp attribute with one entry defined from a color,
        position and interpolation value. Existing entries are deleted
        before the new one is added.

        Returns:
        -----
        None

        Parameters:
        -----
        color: MColor
        	[in] -> Color value 

        position: float
        	[in] -> Desired position (defaults to 1.0) 

        interp: MRampAttribute.MInterpolation
        	[in] -> Interpolation value (defaults to MInterpolation::kLinear)


        '''
        pass

    @overload
    def setRamp(self, values: MFloatArray,
                        positions: MFloatArray,
                        interps: MIntArray): 
        '''
        setRamp(self, values: MFloatArray,
                        positions: MFloatArray,
                        interps: MIntArray)

        Synopsis
        -----
        Sets this ramp attribute with entries defined from a set of
        float, position and interpolation value arrays. Existing entries
        are deleted before the new ones are added.

        Returns:
        -----
        None

        Parameters:
        -----
        values: MFloatArray
        	[in] -> Array of float value. 

        positions: MFloatArray
        	[in] -> Array of desired positions. 

        interps: MIntArray
        	[in] -> Array of interpolation values.


        '''
        pass

    @overload
    def setRamp(self, colors: MColorArray,
                        positions: MFloatArray,
                        interps: MIntArray): 
        '''
        setRamp(self, colors: MColorArray,
                        positions: MFloatArray,
                        interps: MIntArray)

        Synopsis
        -----
        Sets this ramp attribute with entries defined from a set of
        color, position and interpolation value arrays. Existing entries
        are deleted before the new ones are added.

        Returns:
        -----
        None

        Parameters:
        -----
        colors: MColorArray
        	[in] -> Array of color values. 

        positions: MFloatArray
        	[in] -> Array of desired positions. 

        interps: MIntArray
        	[in] -> Array of interpolation values.


        '''
        pass

    def createCurveRamp(self, attrLongName: MString,
                        attrShortName: MString,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        createCurveRamp(self, attrLongName: MString,
                        attrShortName: MString,
                        ReturnStatus: MRampAttribute.MStatus) -> MObject

        Synopsis
        -----
        This function creates the curve ramp attribute.

        Returns: 
        ----- 
        Curve ramp attribute, returned as MObject.

        Parameters:
        -----
        attrLongName: MString
        	[in] -> Long name of the curve ramp attribute 

        attrShortName: MString
        	[in] -> Short name of the curve ramp attribute 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> Return status


        '''
        pass

    def createColorRamp(self, attrLongName: MString,
                        attrShortName: MString,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        createColorRamp(self, attrLongName: MString,
                        attrShortName: MString,
                        ReturnStatus: MRampAttribute.MStatus) -> MObject

        Synopsis
        -----
        This function creates the color ramp attribute.

        Returns: 
        ----- 
        Color ramp attribute, returned as MObject.

        Parameters:
        -----
        attrLongName: MString
        	[in] -> Long name of the curve ramp attribute 

        attrShortName: MString
        	[in] -> Short name of the curve ramp attribute 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> return status


        '''
        pass

    @overload
    def createRamp(self, attrLongName: MString,
                        attrShortName: MString,
                        node: MObject,
                        value: float,
                        position: float,
                        interp: MRampAttribute.MInterpolation,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        createRamp(self, attrLongName: MString,
                        attrShortName: MString,
                        node: MObject,
                        value: float,
                        position: float,
                        interp: MRampAttribute.MInterpolation,
                        ReturnStatus: MRampAttribute.MStatus) -> MObject

        Synopsis
        -----
        Creates a new curve ramp attribute initialized with an entry
        defined from a float, position and interpolation value.

        Returns:
        -----
        None

        Parameters:
        -----
        attrLongName: MString
        	[in] -> Long name of the new curve ramp attribute 

        attrShortName: MString
        	[in] -> Short name of the new curve ramp attribute 

        node: MObject
        	[in] -> The node to which the new ramp attribute will be added 

        value: float
        	[in] -> Float value 

        position: float
        	[in] -> Desired position (defaults to 1.0) 

        interp: MRampAttribute.MInterpolation
        	[in] -> Interpolation value (defaults to MInterpolation::kLinear) 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def createRamp(self, attrLongName: MString,
                        attrShortName: MString,
                        node: MObject,
                        color: MColor,
                        position: float,
                        interp: MRampAttribute.MInterpolation,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        createRamp(self, attrLongName: MString,
                        attrShortName: MString,
                        node: MObject,
                        color: MColor,
                        position: float,
                        interp: MRampAttribute.MInterpolation,
                        ReturnStatus: MRampAttribute.MStatus) -> MObject

        Synopsis
        -----
        Creates a new color ramp attribute initialized with one entry
        defined from a color, position and interpolation value.

        Returns:
        -----
        None

        Parameters:
        -----
        attrLongName: MString
        	[in] -> Long name of the new curve ramp attribute 

        attrShortName: MString
        	[in] -> Short name of the new curve ramp attribute 

        node: MObject
        	[in] -> The node to which the new ramp attribute will be added 

        color: MColor
        	[in] -> MColor

        position: float
        	[in] -> Desired position (defaults to 1.0) 

        interp: MRampAttribute.MInterpolation
        	[in] -> Interpolation value (defaults to MInterpolation::kLinear) 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def createRamp(self, attrLongName: MString,
                        attrShortName: MString,
                        node: MObject,
                        values: MFloatArray,
                        positions: MFloatArray,
                        interps: MIntArray,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        createRamp(self, attrLongName: MString,
                        attrShortName: MString,
                        node: MObject,
                        values: MFloatArray,
                        positions: MFloatArray,
                        interps: MIntArray,
                        ReturnStatus: MRampAttribute.MStatus) -> MObject

        Synopsis
        -----
        Creates a new curve ramp attribute initialized with entries
        defined from a set of float, position and interpolation value
        arrays.

        Returns:
        -----
        None

        Parameters:
        -----
        attrLongName: MString
        	[in] -> Long name of the new curve ramp attribute 

        attrShortName: MString
        	[in] -> Short name of the new curve ramp attribute 

        node: MObject
        	[in] -> The node to which the new ramp attribute will be added 

        values: MFloatArray
        	[in] -> Array of float value. 

        positions: MFloatArray
        	[in] -> Array of desired positions. 

        interps: MIntArray
        	[in] -> Array of interpolation values. 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> Status code


        '''
        pass

    @overload
    def createRamp(self, attrLongName: MString,
                        attrShortName: MString,
                        node: MObject,
                        colors: MColorArray,
                        positions: MFloatArray,
                        interps: MIntArray,
                        ReturnStatus: MRampAttribute.MStatus): 
        '''
        createRamp(self, attrLongName: MString,
                        attrShortName: MString,
                        node: MObject,
                        colors: MColorArray,
                        positions: MFloatArray,
                        interps: MIntArray,
                        ReturnStatus: MRampAttribute.MStatus) -> MObject

        Synopsis
        -----
        Creates a new curve ramp attribute initialized with entries
        defined from a set of color, position and interpolation value
        arrays.

        Returns:
        -----
        None

        Parameters:
        -----
        attrLongName: MString
        	[in] -> Long name of the new curve ramp attribute 

        attrShortName: MString
        	[in] -> Short name of the new curve ramp attribute 

        node: MObject
        	[in] -> The node to which the new ramp attribute will be added 

        colors: MColorArray
        	[in] -> Array of color values 

        positions: MFloatArray
        	[in] -> Array of desired positions 

        interps: MIntArray
        	[in] -> Array of interpolation values 

        ReturnStatus: MRampAttribute.MStatus
        	[out] -> Status code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MInterpolation:
    '''Interpolation methods. 
    Non-functional class.  Values for this enum:
    kNone
    kLinear
    kSmooth
    kSpline
    '''

    def __init__(self):
        pass

    def kNone(self):
        '''This is an enum of MInterpolation.
        - Description:  
        - Value: 0
        '''
        pass

    def kLinear(self):
        '''This is an enum of MInterpolation.
        - Description:  
        - Value: 1
        '''
        pass

    def kSmooth(self):
        '''This is an enum of MInterpolation.
        - Description:  
        - Value: 2
        '''
        pass

    def kSpline(self):
        '''This is an enum of MInterpolation.
        - Description:  
        - Value: 3
        '''
        pass

class MRichSelection:
    '''Selection list supporting soft selection and symmetry.
This class implements a selection list that support soft
selection and symmetry.
The rich selection is split into two halves: the "normal" side,
and an optional symmetric component. Components on both sides can
include weight data which is used to specify both the amount of
influence and the proximity to the centre of symmetry.
In addition to the selected objects, the rich selection also
includes information about the axis of symmetry so that
operations can determine how to process any symmetric selection
(e.g. reflect transformations, etc).
'''
    def __init__(self):
        pass


    def getSelection(self, selection: MSelectionList): 
        '''
        getSelection(self, selection: MSelectionList)

        Synopsis
        -----
        Returns a copy of the non-symmetry component of the rich
        selection.

        Returns:
        -----
        None

        Parameters:
        -----
        selection: MSelectionList
        	[out] -> Storage for the selection list


        '''
        pass

    def getSymmetry(self, symmetry: MSelectionList): 
        '''
        getSymmetry(self, symmetry: MSelectionList)

        Synopsis
        -----
        Returns a copy of the symmetry component of the rich selection.

        Returns:
        -----
        None

        Parameters:
        -----
        symmetry: MSelectionList
        	[out] -> Storage for the symmetric selection list


        '''
        pass

    @overload
    def getSymmetryMatrix(self, symmetryMatrix: MMatrix,
                        space: MSpace.MSpace): 
        '''
        getSymmetryMatrix(self, symmetryMatrix: MMatrix,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Returns the raw symmetry matrix to use for the symmetric
        components of the rich selection. The caller is responsible for
        handling any necessary transformation space conversions when
        using this version of getSymmetryMatrix.

        Returns:
        -----
        None

        Parameters:
        -----
        symmetryMatrix: MMatrix
        	[out] -> Storage for the symmetry matrix 

        space: MSpace.MSpace
        	[out] -> The transformation space of the symmetryMatrix


        '''
        pass

    @overload
    def getSymmetryMatrix(self, path: MDagPath,
                        space: MSpace.MSpace,
                        symmetryMatrix: MMatrix): 
        '''
        getSymmetryMatrix(self, path: MDagPath,
                        space: MSpace.MSpace,
                        symmetryMatrix: MMatrix)

        Synopsis
        -----
        Returns the symmetry matrix to use for the symmetric component of
        the specified DAG object. This method handles any matrix space
        conversions for you.

        Returns:
        -----
        None

        Parameters:
        -----
        path: MDagPath
        	[in] -> The DAG path the matrix should be calculated for 

        space: MSpace.MSpace
        	[in] -> The space the matrix should be calculated in. Only kWorld and kObject are currently supported. 

        symmetryMatrix: MMatrix
        	[out] -> Storage for the symmetry matrix


        '''
        pass

    def getSymmetryPlane(self, path: MDagPath,
                        space: MSpace.MSpace,
                        symmetryPlane: MPlane): 
        '''
        getSymmetryPlane(self, path: MDagPath,
                        space: MSpace.MSpace,
                        symmetryPlane: MPlane)

        Synopsis
        -----
        Returns the plane of symmetry. This can be used to enforce seam
        weights in tools that support symmetry. Note that the direction
        of the plane carries no significance (specifically, having a
        positive offset from the plane does not imply a point is part of
        the non-symmetric selection).

        Returns:
        -----
        None

        Parameters:
        -----
        path: MDagPath
        	[in] -> The DAG path the plane should be calculated for 

        space: MSpace.MSpace
        	[in] -> The space the plane should be calculated in. Only kWorld and kObject are currently supported. 

        symmetryPlane: MPlane
        	[out] -> Storage for the symmetry plane


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        This method empties the rich selection.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setSelection(self, selection: MSelectionList): 
        '''
        setSelection(self, selection: MSelectionList)

        Synopsis
        -----
        Sets the non-symmetry component of the rich selection.

        Returns:
        -----
        None

        Parameters:
        -----
        selection: MSelectionList
        	[in] -> The selection list


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MSceneMessage:
    '''Scene messages.
This class is used to register callbacks for scene related
messages.
The addCallback method registers a function that will be executed
whenever the specified message occurs. An id is returned and is
used to remove the callback.
To remove a callback use
MMessage::removeCallback. All callbacks that are registered by a plug-in must be removed
by that plug-in when it is unloaded. Failure to do so will result
in a fatal error.
'''
    def __init__(self):
        pass


    def addCallback(self, msg: MSceneMessage.MSceneMessage,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MSceneMessage.MStatus): 
        '''
        addCallback(self, msg: MSceneMessage.MSceneMessage,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MSceneMessage.MStatus) -> MSceneMessage.OPENMAYA_MAJOR_NAMESPACE_OPENMCallbackId

        Synopsis
        -----
        Adds a new callback for the specified scene message. If a
        'before' message is sent, the corresponding 'after' message will
        be as well.Callbacks can be added to the following messages with
        this function:Note that for referencing, the creation of the
        reference (i.e. creation of the reference node and associated
        structures) is separate from the loading of the reference itself
        (i.e. read the nodes from file).The kBeforeCreateReference
        message will be sent when a reference is created. So it will
        happen for both loaded and unloaded references. But the
        kBeforeLoadReference message will only be sent when the file is
        read from disk.When opening a file with a loaded reference, the
        callback order is as follows,By default, edits to referenced
        objects will not be recorded during the execution of file I/O
        callbacks. A specific set of callbacks are provided that will
        enable the recording of reference edits during their execution as
        follows,The kExportStarted callback is sent after the
        kBeforeExport callback, once Maya has actually started to process
        the exported data. One important difference between the two
        callbacks is that the fileInfo command affects the exported scene
        when used in the kExportStarted callback, but affects the current
        scene in memory when used in the kBeforeExport callback.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        msg: MSceneMessage.MSceneMessage
        	[in] -> the scene message that will trigger the callback 

        func: MMessage.MMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> user data that will be passed to the callback function 

        ReturnStatus: MSceneMessage.MStatus
        	[out] -> Status code


        '''
        pass

    def addCheckCallback(self, msg: MSceneMessage.MSceneMessage,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MSceneMessage.MStatus): 
        '''
        addCheckCallback(self, msg: MSceneMessage.MSceneMessage,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MSceneMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This function adds a new callback for the specified scene
        message. The callback will have the ability to abort the current
        operation by returning false through its 'retCode'
        parameter.NOTE: The check message is sent out before the
        equivalent non-check type. As a result, if the check message
        aborts the operation, the equivalent non-check message type will
        not be sent.Callbacks can be added to the following messages with
        this function:

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        msg: MSceneMessage.MSceneMessage
        	[in] -> the scene message that will trigger the callback 

        func: MMessage.MMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> user data that will be passed to the callback function 

        ReturnStatus: MSceneMessage.MStatus
        	[out] -> Status code


        '''
        pass

    def addCheckFileCallback(self, msg: MSceneMessage.MSceneMessage,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MSceneMessage.MStatus): 
        '''
        addCheckFileCallback(self, msg: MSceneMessage.MSceneMessage,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MSceneMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This function adds a new callback for the specified scene
        message. This callback has the option to abort the current
        operation by setting the retCode parameter to false. The file
        parameter stores the target file for the current file IO
        operation, by modifying this file parameter the target file will
        be changed as well.NOTE: The check message is sent out before the
        equivalent non-check type. As a result, if the check message
        aborts the operation, the equivalent non-check message type will
        not be sent.Callbacks can be added to the following messages with
        this function:

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        msg: MSceneMessage.MSceneMessage
        	[in] -> the scene message that will trigger the callback 

        func: MMessage.MMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> user data that will be passed to the callback function 

        ReturnStatus: MSceneMessage.MStatus
        	[out] -> Status code


        '''
        pass

    def addStringArrayCallback(self, msg: MSceneMessage.MSceneMessage,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MSceneMessage.MStatus): 
        '''
        addStringArrayCallback(self, msg: MSceneMessage.MSceneMessage,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MSceneMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        Adds a new callback which takes a string array argument, in
        addition to the usual clientData. The messages which can be used
        with this method and the contents of the string array passed to
        their callbacks are as follows:To allow for future expansion
        callbacks should not rely on the number of array elements being
        exactly as given above. While there will not be fewer elements
        than given above, there may in future be more.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        msg: MSceneMessage.MSceneMessage
        	[in] -> the scene message that will trigger the callback 

        func: MMessage.MMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> user data that will be passed to the callback function 

        ReturnStatus: MSceneMessage.MStatus
        	[out] -> Status code


        '''
        pass

    def addReferenceCallback(self, msg: MSceneMessage.MSceneMessage,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MSceneMessage.MStatus): 
        '''
        addReferenceCallback(self, msg: MSceneMessage.MSceneMessage,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MSceneMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This function adds a new callback for the specified scene
        message. Callbacks can be added to the following messages with
        this function:

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        msg: MSceneMessage.MSceneMessage
        	[in] -> the scene message that will trigger the callback 

        func: MMessage.MMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> user data that will be passed to the callback function 

        ReturnStatus: MSceneMessage.MStatus
        	[out] -> Status code


        '''
        pass

    def addCheckReferenceCallback(self, msg: MSceneMessage.MSceneMessage,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MSceneMessage.MStatus): 
        '''
        addCheckReferenceCallback(self, msg: MSceneMessage.MSceneMessage,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MSceneMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This function adds a new callback for the specified scene
        message. The callback will have the ability to abort the current
        operation by returning false through its 'retCode'
        parameter.NOTE: The check message is sent out before the
        equivalent non-check type. As a result, if the check message
        aborts the operation, the equivalent non-check message type will
        not be sent.Callbacks can be added to the following messages with
        this function:

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        msg: MSceneMessage.MSceneMessage
        	[in] -> the scene message that will trigger the callback 

        func: MMessage.MMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> user data that will be passed to the callback function 

        ReturnStatus: MSceneMessage.MStatus
        	[out] -> Status code


        '''
        pass

    def addConnectionFailedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MSceneMessage.MStatus): 
        '''
        addConnectionFailedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MSceneMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called when a connection
        was unable to be made. Currently, the callback is only triggered
        during the reading of files (.ma or .mb) or of edits files
        (.editMA or .editMB files created by Maya's offline file
        support). The most common reasons why a connection would fail
        are:

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MSceneMessage.MStatus
        	[out] -> status code


        '''
        pass

    def addNamespaceRenamedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MSceneMessage.MStatus): 
        '''
        addNamespaceRenamedCallback(self, func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MSceneMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback that is called when a namespace
        is renamed.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        func: MMessage.MMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> User defined data passed to the callback function 

        ReturnStatus: MSceneMessage.MStatus
        	[out] -> status code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class Message:
    '''Events to which messages can be attached. 
    Non-functional class.  Values for this enum:
    kSceneUpdate
    kBeforeNew
    kAfterNew
    kBeforeImport
    kAfterImport
    kBeforeOpen
    kAfterOpen
    kBeforeFileRead
    kAfterFileRead
    kAfterSceneReadAndRecordEdits
    kBeforeExport
    kAfterExport
    kBeforeSave
    kAfterSave
    kBeforeReference
    kAfterReference
    kBeforeRemoveReference
    kAfterRemoveReference
    kBeforeImportReference
    kAfterImportReference
    kBeforeExportReference
    kAfterExportReference
    kBeforeUnloadReference
    kAfterUnloadReference
    kBeforeSoftwareRender
    kAfterSoftwareRender
    kBeforeSoftwareFrameRender
    kAfterSoftwareFrameRender
    kSoftwareRenderInterrupted
    kMayaInitialized
    kMayaExiting
    kBeforeNewCheck
    kBeforeOpenCheck
    kBeforeSaveCheck
    kBeforeImportCheck
    kBeforeExportCheck
    kBeforeLoadReference
    kAfterLoadReference
    kBeforeLoadReferenceCheck
    kBeforeReferenceCheck
    kBeforeCreateReferenceCheck
    kBeforePluginLoad
    kAfterPluginLoad
    kBeforePluginUnload
    kAfterPluginUnload
    kBeforeCreateReference
    kAfterCreateReference
    kExportStarted
    kBeforeLoadReferenceAndRecordEdits
    kAfterLoadReferenceAndRecordEdits
    kBeforeCreateReferenceAndRecordEdits
    kAfterCreateReferenceAndRecordEdits
    kLast
    '''

    def __init__(self):
        pass

    def kSceneUpdate(self):
        '''This is an enum of Message.
        - Description: Called after any operation that changes which files are loaded. 
        - Value: 0
        '''
        pass

    def kBeforeNew(self):
        '''This is an enum of Message.
        - Description: Called before a File > New operation. 
        - Value: 1
        '''
        pass

    def kAfterNew(self):
        '''This is an enum of Message.
        - Description: Called after a File > New operation. 
        - Value: 2
        '''
        pass

    def kBeforeImport(self):
        '''This is an enum of Message.
        - Description: Called before a File > Import operation. 
        - Value: 3
        '''
        pass

    def kAfterImport(self):
        '''This is an enum of Message.
        - Description: Called after a File > Import operation. 
        - Value: 4
        '''
        pass

    def kBeforeOpen(self):
        '''This is an enum of Message.
        - Description: Called before a File > Open operation. 
        - Value: 5
        '''
        pass

    def kAfterOpen(self):
        '''This is an enum of Message.
        - Description: Called after a File > Open operation. 
        - Value: 6
        '''
        pass

    def kBeforeFileRead(self):
        '''This is an enum of Message.
        - Description: Called immediately before any file read operation (open, import or reference) and while reading state (MFileIO::isReadingFile) is true. 
        - Value: 7
        '''
        pass

    def kAfterFileRead(self):
        '''This is an enum of Message.
        - Description: Called immediately after any file read operation (open, import or reference) and while reading state (MFileIO::isReadingFile) is true. 
        - Value: 8
        '''
        pass

    def kAfterSceneReadAndRecordEdits(self):
        '''This is an enum of Message.
        - Description: Call once after any file operation (open, import or reference) with reference edits recorded during the execution of the callback Note, isReadingFile is false during this callback. 
        - Value: 9
        '''
        pass

    def kBeforeExport(self):
        '''This is an enum of Message.
        - Description: Called before a File > Export operation. 
        - Value: 10
        '''
        pass

    def kAfterExport(self):
        '''This is an enum of Message.
        - Description: Called after a File > Export operation. 
        - Value: 11
        '''
        pass

    def kBeforeSave(self):
        '''This is an enum of Message.
        - Description: Called before a File > Save (or SaveAs) operation. 
        - Value: 12
        '''
        pass

    def kAfterSave(self):
        '''This is an enum of Message.
        - Description: Called after a File > Save (or SaveAs) operation. 
        - Value: 13
        '''
        pass

    def kBeforeReference(self):
        '''This is an enum of Message.
        - Description: Called before a File > Reference operation. Deprecated. Use kBeforeCreateReference/kBeforeLoadReference. 
        - Value: 14
        '''
        pass

    def kAfterReference(self):
        '''This is an enum of Message.
        - Description: Called after a File > Reference operation. Deprecated. Use kAfterCreateReference/kAfterLoadReference. 
        - Value: 15
        '''
        pass

    def kBeforeRemoveReference(self):
        '''This is an enum of Message.
        - Description: Called before a File > RemoveReference operation. 
        - Value: 16
        '''
        pass

    def kAfterRemoveReference(self):
        '''This is an enum of Message.
        - Description: Called after a File > RemoveReference operation. 
        - Value: 17
        '''
        pass

    def kBeforeImportReference(self):
        '''This is an enum of Message.
        - Description: Called before a File > ImportReference operation. 
        - Value: 18
        '''
        pass

    def kAfterImportReference(self):
        '''This is an enum of Message.
        - Description: Called after a File > ImportReference operation. 
        - Value: 19
        '''
        pass

    def kBeforeExportReference(self):
        '''This is an enum of Message.
        - Description: Called before a File > ExportReference operation. 
        - Value: 20
        '''
        pass

    def kAfterExportReference(self):
        '''This is an enum of Message.
        - Description: Called after a File > ExportReference operation. 
        - Value: 21
        '''
        pass

    def kBeforeUnloadReference(self):
        '''This is an enum of Message.
        - Description: Called before a File > UnloadReference operation. 
        - Value: 22
        '''
        pass

    def kAfterUnloadReference(self):
        '''This is an enum of Message.
        - Description: Called after a File > UnloadReference operation. 
        - Value: 23
        '''
        pass

    def kBeforeSoftwareRender(self):
        '''This is an enum of Message.
        - Description: Called before a Software Render begins. 
        - Value: 24
        '''
        pass

    def kAfterSoftwareRender(self):
        '''This is an enum of Message.
        - Description: Called after a Software Render ends. 
        - Value: 25
        '''
        pass

    def kBeforeSoftwareFrameRender(self):
        '''This is an enum of Message.
        - Description: Called before each frame of a Software Render. 
        - Value: 26
        '''
        pass

    def kAfterSoftwareFrameRender(self):
        '''This is an enum of Message.
        - Description: Called after each frame of a Software Render. 
        - Value: 27
        '''
        pass

    def kSoftwareRenderInterrupted(self):
        '''This is an enum of Message.
        - Description: Called when an interactive render is interrupted by the user. 
        - Value: 28
        '''
        pass

    def kMayaInitialized(self):
        '''This is an enum of Message.
        - Description: Called on interactive or batch startup after initialization. 
        - Value: 29
        '''
        pass

    def kMayaExiting(self):
        '''This is an enum of Message.
        - Description: Called just before Maya exits. 
        - Value: 30
        '''
        pass

    def kBeforeNewCheck(self):
        '''This is an enum of Message.
        - Description: Called prior to File > New operation, allows user to cancel action. 
        - Value: 31
        '''
        pass

    def kBeforeOpenCheck(self):
        '''This is an enum of Message.
        - Description: Called prior to File > Open operation, allows user to cancel action. 
        - Value: 32
        '''
        pass

    def kBeforeSaveCheck(self):
        '''This is an enum of Message.
        - Description: Called prior to File > Save operation, allows user to cancel action. 
        - Value: 33
        '''
        pass

    def kBeforeImportCheck(self):
        '''This is an enum of Message.
        - Description: Called prior to File > Import operation, allows user to cancel action. 
        - Value: 34
        '''
        pass

    def kBeforeExportCheck(self):
        '''This is an enum of Message.
        - Description: Called prior to File > Export operation, allows user to cancel action. 
        - Value: 35
        '''
        pass

    def kBeforeLoadReference(self):
        '''This is an enum of Message.
        - Description: Called before a File > LoadReference operation. 
        - Value: 36
        '''
        pass

    def kAfterLoadReference(self):
        '''This is an enum of Message.
        - Description: Called after a File > LoadReference operation. 
        - Value: 37
        '''
        pass

    def kBeforeLoadReferenceCheck(self):
        '''This is an enum of Message.
        - Description: Called before a File > LoadReference operation, allows user to cancel action. 
        - Value: 38
        '''
        pass

    def kBeforeReferenceCheck(self):
        '''This is an enum of Message.
        - Description: Called prior to a File > CreateReference operation, allows user to cancel action. Deprecated. Use kBeforeCreateReferenceCheck. 
        - Value: 39
        '''
        pass

    def kBeforeCreateReferenceCheck(self):
        '''This is an enum of Message.
        - Description: Called prior to a File > CreateReference operation, allows user to cancel action. 
        - Value: 39
        '''
        pass

    def kBeforePluginLoad(self):
        '''This is an enum of Message.
        - Description: Called prior to a plugin being loaded. 
        - Value: 40
        '''
        pass

    def kAfterPluginLoad(self):
        '''This is an enum of Message.
        - Description: Called after a plugin is loaded. 
        - Value: 41
        '''
        pass

    def kBeforePluginUnload(self):
        '''This is an enum of Message.
        - Description: Called prior to a plugin being unloaded. 
        - Value: 42
        '''
        pass

    def kAfterPluginUnload(self):
        '''This is an enum of Message.
        - Description: Called after a plugin is unloaded. 
        - Value: 43
        '''
        pass

    def kBeforeCreateReference(self):
        '''This is an enum of Message.
        - Description: Called before a File > CreateReference operation. 
        - Value: 44
        '''
        pass

    def kAfterCreateReference(self):
        '''This is an enum of Message.
        - Description: Called after a File > CreateReference operation. 
        - Value: 45
        '''
        pass

    def kExportStarted(self):
        '''This is an enum of Message.
        - Description: Called at the start of a File > Export operation, after the export file has become the active file. 
        - Value: 46
        '''
        pass

    def kBeforeLoadReferenceAndRecordEdits(self):
        '''This is an enum of Message.
        - Description: Same as kBeforeLoadReference except reference edits are recorded during the execution of the callback. 
        - Value: 47
        '''
        pass

    def kAfterLoadReferenceAndRecordEdits(self):
        '''This is an enum of Message.
        - Description: Same as kAfterLoadReference except reference edits are recorded during the execution of the callback. 
        - Value: 48
        '''
        pass

    def kBeforeCreateReferenceAndRecordEdits(self):
        '''This is an enum of Message.
        - Description: Same as kBeforeCreateReference except reference edits are recorded during the execution of the callback. 
        - Value: 49
        '''
        pass

    def kAfterCreateReferenceAndRecordEdits(self):
        '''This is an enum of Message.
        - Description: Same as kAfterCreateReference except reference edits are recorded during the execution of the callback. 
        - Value: 50
        '''
        pass

    def kLast(self):
        '''This is an enum of Message.
        - Description: Last value of the enum. 
        - Value: 51
        '''
        pass

class MScriptUtil:
    '''Utility class for working with pointers and references in Python.
Many of Maya's API methods require that one or more of their
parameters be passed as pointers or references. Their return
values, too, can be pointers or references.
In Python parameters of class types are passed by reference but
parameters of simple types, like integers and floats, are passed
by value, making it impossible to call those API methods from
Python. The
MScriptUtil class bridges this gap by providing methods which return
pointers to values of simple types and which can extract values
from such pointers. These pointers can also be used wherever an
API method requires a reference to a simple type or an array of a
simple type.
For example,
MTransformationMatrix::setShear() requires as its first parameter an array of three values of
simple type 'double'. To call setShear() from Python requires
using
MScriptUtil to create the array of doubles:
Similar code is required to get the shear value using
MTransformationMatrix::getShear(), but
MScriptUtil methods must also be used to extract the returned values from
the array:
If a method requires a reference or pointer to an enumerated
value, use a pointer to a short int instead.
An
MScriptUtil object keeps two sets of values internally: its
 values, and its
 values. The initial values are those supplied either in the
constructor or by calling one of the object's create*() methods.
The working values are those to which the as*Ptr() methods return
pointers.
Each time a create*() method is called it completely replaces the
old
 values with the new ones. The as*() methods (
asInt(),
asFloat(), etc) but
 the as*Ptr() methods, all return the first internal value,
converted to the appropriate type.
Each time an as*Ptr() method is called it completely replaces the
old
 values with new ones of the requested type and initializes them
from the initial values. If the type of the working values does
not match that of the initial values then appropriate conversions
are done. For example, if you have initialized an
MScriptUtil object with four doubles via a call to
createFromDouble(), then a subsequent call to
asBoolPtr() will allocate space for four boolean working values and
initialize them from the initial values by converting non-zero
values to true and zero values to false.
The separation of initial and working values means that changes
to the working values will not affect the initial values. For
example, if you pass the pointer returned by
asBoolPtr() to an API method which changes the working value it points to,
the object's initial value will remain unchanged and its
asInt() method will continue to return the same value as it did before
the API call.
The number of working values returned by the as*Ptr() methods
will match the number of initial values. Thus it is important
that you provide a sufficient number of initial values before
calling an as*Ptr() method. If no initial values are provided in
the
MScriptUtil constructor and none are subsequently supplied by calls to the
create*() methods, then the pointers returned by the as*Ptr()
methods won't have room to store even a single value, which will
likely lead to errors.
As already noted, each call to one of an object's as*Ptr()
methods completely replaces the old working values with new ones,
thus rendering invalid any pointers previously returned by that
object. This means that if you need multiple pointers for a
single API call, you will need multiple
MScriptUtil objects.
MFnMesh::getUV() provides an example of this:
When an
MScriptUtil object is destroyed any pointers to its data immediately become
invalid. Thus the following code will fail because the
MScriptUtil objects created by getUVPtrs() will go out of scope and be
destroyed when the function returns, rendering the pointers it
returns invalid:
To work, getUVPtrs() would have to preserve the
MScriptUtil objects in some way, such as passing them back to the caller as
well:
This class is admittedly cumbersome to use but it provides a way
of building parameters and accessing return values for methods
which would not otherwise be accessible from Python.
'''
    def __init__(self):
        pass


    def createFromInt(self, x: int,
                        y: int,
                        z: int,
                        w: int): 
        '''
        createFromInt(self, x: int,
                        y: int,
                        z: int,
                        w: int)

        Synopsis
        -----
        Create this object from 4 integers. Data already stored in this
        class will be cleared.

        Returns:
        -----
        None

        Parameters:
        -----
        x: int
        	[in] -> First integer value. 

        y: int
        	[in] -> Second integer value. 

        z: int
        	[in] -> Third integer value. 

        w: int
        	[in] -> Fourth integer value. 


        '''
        pass

    def createFromDouble(self, x: double,
                        y: double,
                        z: double,
                        w: double): 
        '''
        createFromDouble(self, x: double,
                        y: double,
                        z: double,
                        w: double)

        Synopsis
        -----
        Create this object from 4 doubles. Data already stored in this
        class will be cleared.

        Returns:
        -----
        None

        Parameters:
        -----
        x: double
        	[in] -> First double value. 

        y: double
        	[in] -> Second double value. 

        z: double
        	[in] -> Third double value. 

        w: double
        	[in] -> Fourth double value. 


        '''
        pass

    def createFromList(self, pythonList: void,
                        length: int): 
        '''
        createFromList(self, pythonList: void,
                        length: int) -> bool

        Synopsis
        -----
        Create this object with a python list and length. For example:
        scriptUtil.createFromList( (1.0,3.0,5.0,7.0,8.0,10.0,33.0), 7 )
        Data already stored in this class will be cleared.

        Returns:
        -----
        None

        Parameters:
        -----
        pythonList: void
        	[in] -> Python list of numeric values. 

        length: int
        	[in] -> Number of elements in the list. 


        '''
        pass

    def asIntPtr(self): 
        '''
        asIntPtr(self) -> int*

        Synopsis
        -----
        Return an integer pointer to the data of this class. NOTE: any
        previous pointer information returned by this object will be
        deleted.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asShortPtr(self): 
        '''
        asShortPtr(self) -> short*

        Synopsis
        -----
        Return a short pointer to the data of this class. NOTE: any
        previous pointer information returned by this object will be
        deleted.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asUshortPtr(self): 
        '''
        asUshortPtr(self) -> short*

        Synopsis
        -----
        Return an unsigned short pointer to the data of this class. NOTE:
        any previous pointer information returned by this object will be
        deleted.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asFloatPtr(self): 
        '''
        asFloatPtr(self) -> float*

        Synopsis
        -----
        Return a float pointer to the data of this class. NOTE: any
        previous pointer information returned by this object will be
        deleted.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asDoublePtr(self): 
        '''
        asDoublePtr(self) -> double*

        Synopsis
        -----
        Return a double pointer to the data of this class. NOTE: any
        previous pointer information returned by this object will be
        deleted.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asUintPtr(self): 
        '''
        asUintPtr(self) -> int*

        Synopsis
        -----
        Return an unsigned integer pointer to the data of this class.
        NOTE: any previous pointer information returned by this object
        will be deleted.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asBoolPtr(self): 
        '''
        asBoolPtr(self) -> bool*

        Synopsis
        -----
        Return a bool pointer to the data of this class. NOTE: any
        previous pointer information returned by this object will be
        deleted.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asCharPtr(self): 
        '''
        asCharPtr(self) -> char*

        Synopsis
        -----
        Return a char pointer to the data of this class. NOTE: any
        previous pointer information returned by this object will be
        deleted.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asUcharPtr(self): 
        '''
        asUcharPtr(self) -> char*

        Synopsis
        -----
        Return a unsigned char pointer to the data of this class. NOTE:
        any previous pointer information returned by this object will be
        deleted.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asInt2Ptr(self): 
        '''
        asInt2Ptr(self) -> MScriptUtil.Mint2*

        Synopsis
        -----
        Copy the data to a temporary array of the right type and return
        its address. Ensure that this object has been created with
        sufficient data.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asInt3Ptr(self): 
        '''
        asInt3Ptr(self) -> MScriptUtil.Mint3*

        Synopsis
        -----
        Copy the data to a temporary array of the right type and return
        its address. Ensure that this object has been created with
        sufficient data.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asInt4Ptr(self): 
        '''
        asInt4Ptr(self) -> MScriptUtil.Mint4*

        Synopsis
        -----
        Copy the data to a temporary array of the right type and return
        its address. Ensure that this object has been created with
        sufficient data.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asShort2Ptr(self): 
        '''
        asShort2Ptr(self) -> MScriptUtil.Mshort2*

        Synopsis
        -----
        Copy the data to a temporary array of the right type and return
        its address. Ensure that this object has been created with
        sufficient data.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asShort3Ptr(self): 
        '''
        asShort3Ptr(self) -> MScriptUtil.Mshort3*

        Synopsis
        -----
        Copy the data to a temporary array of the right type and return
        its address. Ensure that this object has been created with
        sufficient data.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asShort4Ptr(self): 
        '''
        asShort4Ptr(self) -> MScriptUtil.Mshort4*

        Synopsis
        -----
        Copy the data to a temporary array of the right type and return
        its address. Ensure that this object has been created with
        sufficient data.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asFloat2Ptr(self): 
        '''
        asFloat2Ptr(self) -> MScriptUtil.Mfloat2*

        Synopsis
        -----
        Copy the data to a temporary array of the right type and return
        its address. Ensure that this object has been created with
        sufficient data.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asFloat3Ptr(self): 
        '''
        asFloat3Ptr(self) -> MScriptUtil.Mfloat3*

        Synopsis
        -----
        Copy the data to a temporary array of the right type and return
        its address. Ensure that this object has been created with
        sufficient data.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asFloat4Ptr(self): 
        '''
        asFloat4Ptr(self) -> MScriptUtil.Mfloat4*

        Synopsis
        -----
        Copy the data to a temporary array of the right type and return
        its address. Ensure that this object has been created with
        sufficient data.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asDouble2Ptr(self): 
        '''
        asDouble2Ptr(self) -> MScriptUtil.Mdouble2*

        Synopsis
        -----
        Copy the data to a temporary array of the right type and return
        its address. Ensure that this object has been created with
        sufficient data.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asDouble3Ptr(self): 
        '''
        asDouble3Ptr(self) -> MScriptUtil.Mdouble3*

        Synopsis
        -----
        Copy the data to a temporary array of the right type and return
        its address. Ensure that this object has been created with
        sufficient data.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asDouble4Ptr(self): 
        '''
        asDouble4Ptr(self) -> MScriptUtil.Mdouble4*

        Synopsis
        -----
        Copy the data to a temporary array of the right type and return
        its address. Ensure that this object has been created with
        sufficient data.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asUint2Ptr(self): 
        '''
        asUint2Ptr(self) -> MScriptUtil.Muint2*

        Synopsis
        -----
        Copy the data to a temporary array of the right type and return
        its address. Ensure that this object has been created with
        sufficient data.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asUint3Ptr(self): 
        '''
        asUint3Ptr(self) -> MScriptUtil.Muint3*

        Synopsis
        -----
        Copy the data to a temporary array of the right type and return
        its address. Ensure that this object has been created with
        sufficient data.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asUint4Ptr(self): 
        '''
        asUint4Ptr(self) -> MScriptUtil.Muint4*

        Synopsis
        -----
        Copy the data to a temporary array of the right type and return
        its address. Ensure that this object has been created with
        sufficient data.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setInt(self, var: int,
                        value: int): 
        '''
        setInt(self, var: int,
                        value: int)

        Synopsis
        -----
        Set an integer reference value.

        Returns:
        -----
        None

        Parameters:
        -----
        var: int
        	[out] -> Reference to the variable to be assigned. 

        value: int
        	[in] -> Value to assign 


        '''
        pass

    def setShort(self, var: short,
                        value: int): 
        '''
        setShort(self, var: short,
                        value: int)

        Synopsis
        -----
        Set a short reference value.

        Returns:
        -----
        None

        Parameters:
        -----
        var: short
        	[out] -> Reference to the variable to be assigned. 

        value: int
        	[in] -> Value to assign 


        '''
        pass

    def setFloat(self, var: float,
                        value: double): 
        '''
        setFloat(self, var: float,
                        value: double)

        Synopsis
        -----
        Set a float reference value.

        Returns:
        -----
        None

        Parameters:
        -----
        var: float
        	[out] -> Reference to the variable to be assigned. 

        value: double
        	[in] -> Value to assign 


        '''
        pass

    def setDouble(self, var: double,
                        value: double): 
        '''
        setDouble(self, var: double,
                        value: double)

        Synopsis
        -----
        Set a double reference value.

        Returns:
        -----
        None

        Parameters:
        -----
        var: double
        	[out] -> Reference to the variable to be assigned. 

        value: double
        	[in] -> Value to assign 


        '''
        pass

    def setUint(self, var: int,
                        value: int): 
        '''
        setUint(self, var: int,
                        value: int)

        Synopsis
        -----
        Set an unsigned integer reference value.

        Returns:
        -----
        None

        Parameters:
        -----
        var: int
        	[out] -> Reference to the variable to be assigned. 

        value: int
        	[in] -> Value to assign 


        '''
        pass

    def setBool(self, var: bool,
                        value: int): 
        '''
        setBool(self, var: bool,
                        value: int)

        Synopsis
        -----
        Set a bool reference value.

        Returns:
        -----
        None

        Parameters:
        -----
        var: bool
        	[out] -> Reference to the variable to be assigned. 

        value: int
        	[in] -> Value to assign 


        '''
        pass

    def setChar(self, var: char,
                        value: int): 
        '''
        setChar(self, var: char,
                        value: int)

        Synopsis
        -----
        Set a char reference value.

        Returns:
        -----
        None

        Parameters:
        -----
        var: char
        	[out] -> Reference to the variable to be assigned. 

        value: int
        	[in] -> Value to assign 


        '''
        pass

    def setUchar(self, var: char,
                        value: int): 
        '''
        setUchar(self, var: char,
                        value: int)

        Synopsis
        -----
        Set an unsigned char reference value.

        Returns:
        -----
        None

        Parameters:
        -----
        var: char
        	[out] -> Reference to the variable to be assigned. 

        value: int
        	[in] -> Value to assign 


        '''
        pass

    def getInt(self, var: int): 
        '''
        getInt(self, var: int) -> int

        Synopsis
        -----
        Get the value of an integer reference.

        Returns:
        -----
        None

        Parameters:
        -----
        var: int
        	[out] -> Reference to the variable to return. 


        '''
        pass

    def getShort(self, var: short): 
        '''
        getShort(self, var: short) -> int

        Synopsis
        -----
        Get the value of a short reference.

        Returns:
        -----
        None

        Parameters:
        -----
        var: short
        	[in] -> Reference to the variable to return. 


        '''
        pass

    def getFloat(self, var: float): 
        '''
        getFloat(self, var: float) -> double

        Synopsis
        -----
        Get the values of a float reference.

        Returns:
        -----
        None

        Parameters:
        -----
        var: float
        	[out] -> Reference to the variable to return. 


        '''
        pass

    def getDouble(self, var: double): 
        '''
        getDouble(self, var: double) -> double

        Synopsis
        -----
        Get the value of a double reference.

        Returns:
        -----
        None

        Parameters:
        -----
        var: double
        	[out] -> Reference to the variable to return. 


        '''
        pass

    def getUint(self, var: int): 
        '''
        getUint(self, var: int) -> int

        Synopsis
        -----
        Get the value of an unsigned int reference.

        Returns:
        -----
        None

        Parameters:
        -----
        var: int
        	[out] -> Reference to the variable to return. 


        '''
        pass

    def getBool(self, var: bool): 
        '''
        getBool(self, var: bool) -> int

        Synopsis
        -----
        Get the value of a bool reference.

        Returns:
        -----
        None

        Parameters:
        -----
        var: bool
        	[in] -> Reference to the variable to return. 


        '''
        pass

    def getChar(self, var: char): 
        '''
        getChar(self, var: char) -> int

        Synopsis
        -----
        Get the value of a char reference.

        Returns:
        -----
        None

        Parameters:
        -----
        var: char
        	[in] -> Reference to the variable to return. 


        '''
        pass

    def getUchar(self, var: char): 
        '''
        getUchar(self, var: char) -> int

        Synopsis
        -----
        Get the value of an unsigned char reference.

        Returns:
        -----
        None

        Parameters:
        -----
        var: char
        	[in] -> Reference to the variable to return. 


        '''
        pass

    def setIntArray(self, var: int,
                        index: int,
                        value: int): 
        '''
        setIntArray(self, var: int,
                        index: int,
                        value: int) -> bool

        Synopsis
        -----
        Set an integer value in an array. Ensure that index is valid
        before calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: int
        	[out] -> Array to assign to. 

        index: int
        	[in] -> Index of the element to be modified. 

        value: int
        	[in] -> New value to be assigned.


        '''
        pass

    def setShortArray(self, var: short,
                        index: int,
                        value: int): 
        '''
        setShortArray(self, var: short,
                        index: int,
                        value: int) -> bool

        Synopsis
        -----
        Set a short value in an array. Ensure that index is valid before
        calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: short
        	[out] -> Array to assign to. 

        index: int
        	[in] -> Index of the element to be modified. 

        value: int
        	[in] -> New value to be assigned.


        '''
        pass

    def setFloatArray(self, var: float,
                        index: int,
                        value: double): 
        '''
        setFloatArray(self, var: float,
                        index: int,
                        value: double) -> bool

        Synopsis
        -----
        Set a float value in an array. Ensure that index is valid before
        calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: float
        	[out] -> Array to assign to. 

        index: int
        	[in] -> Index of the element to be modified. 

        value: double
        	[in] -> New value to be assigned.


        '''
        pass

    def setDoubleArray(self, var: double,
                        index: int,
                        value: double): 
        '''
        setDoubleArray(self, var: double,
                        index: int,
                        value: double) -> bool

        Synopsis
        -----
        Set a double value in an array. Ensure that index is valid before
        calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: double
        	[out] -> Array to assign to. 

        index: int
        	[in] -> Index of the element to be modified. 

        value: double
        	[in] -> New value to be assigned.


        '''
        pass

    def setUintArray(self, var: int,
                        index: int,
                        value: int): 
        '''
        setUintArray(self, var: int,
                        index: int,
                        value: int) -> bool

        Synopsis
        -----
        Set an unsigned integer value in an array. Ensure that index is
        valid before calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: int
        	[out] -> Array to assign to. 

        index: int
        	[in] -> Index of the element to be modified. 

        value: int
        	[in] -> New value to be assigned.


        '''
        pass

    def setUshortArray(self, var: short,
                        index: int,
                        value: int): 
        '''
        setUshortArray(self, var: short,
                        index: int,
                        value: int) -> bool

        Synopsis
        -----
        Set an unsigned short value in an array. Ensure that index is
        valid before calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: short
        	[out] -> Array to assign to. 

        index: int
        	[in] -> Index of the element to be modified. 

        value: int
        	[in] -> New value to be assigned.


        '''
        pass

    def setBoolArray(self, var: bool,
                        index: int,
                        value: int): 
        '''
        setBoolArray(self, var: bool,
                        index: int,
                        value: int) -> bool

        Synopsis
        -----
        Set a bool value in an array. Ensure that index is valid before
        calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: bool
        	[out] -> Array to assign to. 

        index: int
        	[in] -> Index of the element to be modified. 

        value: int
        	[in] -> New value to be assigned.


        '''
        pass

    def setCharArray(self, var: char,
                        index: int,
                        value: int): 
        '''
        setCharArray(self, var: char,
                        index: int,
                        value: int) -> bool

        Synopsis
        -----
        Set a char value in an array. Ensure that index is valid before
        calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: char
        	[out] -> Array to assign to. 

        index: int
        	[in] -> Index of the element to be modified. 

        value: int
        	[in] -> New value to be assigned.


        '''
        pass

    def setUcharArray(self, var: char,
                        index: int,
                        value: int): 
        '''
        setUcharArray(self, var: char,
                        index: int,
                        value: int) -> bool

        Synopsis
        -----
        Set an unsigned char value in an array. Ensure that index is
        valid before calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: char
        	[out] -> Array to assign to. 

        index: int
        	[in] -> Index of the element to be modified. 

        value: int
        	[in] -> New value to be assigned.


        '''
        pass

    def getIntArrayItem(self, var: int,
                        index: int): 
        '''
        getIntArrayItem(self, var: int,
                        index: int) -> int

        Synopsis
        -----
        Get a int value from an array. Ensure that index is valid before
        calling this method.

        Returns: 
        ----- 
        Value of the element.

        Parameters:
        -----
        var: int
        	[in] -> Array to read from. 

        index: int
        	[in] -> Index of the element to be returned.


        '''
        pass

    def getShortArrayItem(self, var: short,
                        index: int): 
        '''
        getShortArrayItem(self, var: short,
                        index: int) -> int

        Synopsis
        -----
        Get a short value from an array. Ensure that index is valid
        before calling this method.

        Returns: 
        ----- 
        Value of the element.

        Parameters:
        -----
        var: short
        	[in] -> Array to read from. 

        index: int
        	[in] -> Index of the element to be returned.


        '''
        pass

    def getFloatArrayItem(self, var: float,
                        index: int): 
        '''
        getFloatArrayItem(self, var: float,
                        index: int) -> double

        Synopsis
        -----
        Get a float value from an array. Ensure that index is valid
        before calling this method.

        Returns: 
        ----- 
        Value of the element.

        Parameters:
        -----
        var: float
        	[in] -> Array to read from. 

        index: int
        	[in] -> Index of the element to be returned.


        '''
        pass

    def getDoubleArrayItem(self, var: double,
                        index: int): 
        '''
        getDoubleArrayItem(self, var: double,
                        index: int) -> double

        Synopsis
        -----
        Get a double value from an array. Ensure that index is valid
        before calling this method.

        Returns: 
        ----- 
        Value of the element.

        Parameters:
        -----
        var: double
        	[in] -> Array to read from. 

        index: int
        	[in] -> Index of the element to be returned.


        '''
        pass

    def getUintArrayItem(self, var: int,
                        index: int): 
        '''
        getUintArrayItem(self, var: int,
                        index: int) -> int

        Synopsis
        -----
        Get an unsigned value from an array. Ensure that index is valid
        before calling this method.

        Returns: 
        ----- 
        Value of the element.

        Parameters:
        -----
        var: int
        	[in] -> Array to read from. 

        index: int
        	[in] -> Index of the element to be returned.


        '''
        pass

    def getUshortArrayItem(self, var: short,
                        index: int): 
        '''
        getUshortArrayItem(self, var: short,
                        index: int) -> int

        Synopsis
        -----
        Get an unsigned short value from an array. Ensure that index is
        valid before calling this method.

        Returns: 
        ----- 
        Value of the element.

        Parameters:
        -----
        var: short
        	[in] -> Array to read from. 

        index: int
        	[in] -> Index of the element to be returned.


        '''
        pass

    def getBoolArrayItem(self, var: bool,
                        index: int): 
        '''
        getBoolArrayItem(self, var: bool,
                        index: int) -> int

        Synopsis
        -----
        Get a bool value from an array. Ensure that index is valid before
        calling this method.

        Returns: 
        ----- 
        Value of the element.

        Parameters:
        -----
        var: bool
        	[in] -> Array to read from. 

        index: int
        	[in] -> Index of the element to be returned.


        '''
        pass

    def getCharArrayItem(self, var: char,
                        index: int): 
        '''
        getCharArrayItem(self, var: char,
                        index: int) -> int

        Synopsis
        -----
        Get a char value from an array. Ensure that index is valid before
        calling this method.

        Returns: 
        ----- 
        Value of the element.

        Parameters:
        -----
        var: char
        	[in] -> Array to read from. 

        index: int
        	[in] -> Index of the element to be returned.


        '''
        pass

    def getUcharArrayItem(self, var: char,
                        index: int): 
        '''
        getUcharArrayItem(self, var: char,
                        index: int) -> int

        Synopsis
        -----
        Get an unsigned char value from an array. Ensure that index is
        valid before calling this method.

        Returns: 
        ----- 
        Value of the element.

        Parameters:
        -----
        var: char
        	[in] -> Array to read from. 

        index: int
        	[in] -> Index of the element to be returned.


        '''
        pass

    def createMatrixFromList(self, pythonList: void,
                        matrix: MMatrix): 
        '''
        createMatrixFromList(self, pythonList: void,
                        matrix: MMatrix) -> bool

        Synopsis
        -----
        Create an MMatrix object from a list of 16 doubles. The
        pythonList parameter must be a python list (1.0,2.0,...).Calling
        this method from C++ is not advised.

        Returns: 
        ----- 
        True if the conversion is successful, false otherwise.

        Parameters:
        -----
        pythonList: void
        	[in] -> Python list of 16 numeric values. 

        matrix: MMatrix
        	[out] -> Resulting matrix.


        '''
        pass

    def createFloatMatrixFromList(self, pythonList: void,
                        matrix: MFloatMatrix): 
        '''
        createFloatMatrixFromList(self, pythonList: void,
                        matrix: MFloatMatrix) -> bool

        Synopsis
        -----
        Create an MFloatMatrix object from a list of 16 doubles. The
        pythonList parameter must be a python list (1.0,2.0,...).Calling
        this method from C++ is not advised.

        Returns: 
        ----- 
        True if the conversion is successful, false otherwise.

        Parameters:
        -----
        pythonList: void
        	[in] -> Python list of 16 numeric values. 

        matrix: MFloatMatrix
        	[out] -> Resulting matrix.


        '''
        pass

    def createIntArrayFromList(self, pythonList: void,
                        array: MIntArray): 
        '''
        createIntArrayFromList(self, pythonList: void,
                        array: MIntArray) -> bool

        Synopsis
        -----
        Create an MIntArray object from a python list. The pythonList
        parameter must be a python list (1.0,2.0,...).Calling this method
        from C++ is not advised.

        Returns: 
        ----- 
        True if the conversion is successful, false otherwise.

        Parameters:
        -----
        pythonList: void
        	[in] -> Python list of 16 numeric values. 

        array: MIntArray
        	[out] -> Resulting array.


        '''
        pass

    def createFloatArrayFromList(self, pythonList: void,
                        array: MFloatArray): 
        '''
        createFloatArrayFromList(self, pythonList: void,
                        array: MFloatArray) -> bool

        Synopsis
        -----
        Create an MFloatArray object from a python list. The pythonList
        parameter must be a python list (1.0,2.0,...).Calling this method
        from C++ is not advised.

        Returns: 
        ----- 
        True if the conversion is successful, false otherwise.

        Parameters:
        -----
        pythonList: void
        	[in] -> Python list of 16 numeric values. 

        array: MFloatArray
        	[out] -> Resulting array.


        '''
        pass

    def getInt2ArrayItem(self, var: int(*)2,
                        r: int,
                        c: int): 
        '''
        getInt2ArrayItem(self, var: int(*)2,
                        r: int,
                        c: int) -> int

        Synopsis
        -----
        Get a value from the two dimensional array. Ensure that indicies
        are valid before calling this method.

        Returns: 
        ----- 
        Value of the element: var[r][c]

        Parameters:
        -----
        var: int(*)2
        	[in] -> Array to read from. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array.


        '''
        pass

    def setInt2ArrayItem(self, var: int(*)2,
                        r: int,
                        c: int,
                        value: int): 
        '''
        setInt2ArrayItem(self, var: int(*)2,
                        r: int,
                        c: int,
                        value: int) -> bool

        Synopsis
        -----
        Set a value in the two dimensional array. Ensure that indices are
        valid before calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: int(*)2
        	[in] -> Array to assign to. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array. 

        value: int
        	[in] -> Value to set into the element.


        '''
        pass

    def getInt3ArrayItem(self, var: int(*)3,
                        r: int,
                        c: int): 
        '''
        getInt3ArrayItem(self, var: int(*)3,
                        r: int,
                        c: int) -> int

        Synopsis
        -----
        Get a value from the three dimensional array. Ensure that
        indicies are valid before calling this method.

        Returns: 
        ----- 
        Value of the element: var[r][c]

        Parameters:
        -----
        var: int(*)3
        	[in] -> Array to read from. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array.


        '''
        pass

    def setInt3ArrayItem(self, var: int(*)3,
                        r: int,
                        c: int,
                        value: int): 
        '''
        setInt3ArrayItem(self, var: int(*)3,
                        r: int,
                        c: int,
                        value: int) -> bool

        Synopsis
        -----
        Set a value in the three dimensional array. Ensure that indices
        are valid before calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: int(*)3
        	[in] -> Array to assign to. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array. 

        value: int
        	[in] -> Value to set into the element.


        '''
        pass

    def getInt4ArrayItem(self, var: int(*)4,
                        r: int,
                        c: int): 
        '''
        getInt4ArrayItem(self, var: int(*)4,
                        r: int,
                        c: int) -> int

        Synopsis
        -----
        Get a value from the four dimensional array. Ensure that indicies
        are valid before calling this method.

        Returns: 
        ----- 
        Value of the element: var[r][c]

        Parameters:
        -----
        var: int(*)4
        	[in] -> Array to read from. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array.


        '''
        pass

    def setInt4ArrayItem(self, var: int(*)4,
                        r: int,
                        c: int,
                        value: int): 
        '''
        setInt4ArrayItem(self, var: int(*)4,
                        r: int,
                        c: int,
                        value: int) -> bool

        Synopsis
        -----
        Set a value in the four dimensional array. Ensure that indices
        are valid before calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: int(*)4
        	[in] -> Array to assign to. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array. 

        value: int
        	[in] -> Value to set into the element.


        '''
        pass

    def getShort2ArrayItem(self, var: short(*)2,
                        r: int,
                        c: int): 
        '''
        getShort2ArrayItem(self, var: short(*)2,
                        r: int,
                        c: int) -> short

        Synopsis
        -----
        Get a value from the two dimensional array. Ensure that indicies
        are valid before calling this method.

        Returns: 
        ----- 
        Value of the element: var[r][c]

        Parameters:
        -----
        var: short(*)2
        	[in] -> Array to read from. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array.


        '''
        pass

    def setShort2ArrayItem(self, var: short(*)2,
                        r: int,
                        c: int,
                        value: short): 
        '''
        setShort2ArrayItem(self, var: short(*)2,
                        r: int,
                        c: int,
                        value: short) -> bool

        Synopsis
        -----
        Set a value in the two dimensional array. Ensure that indices are
        valid before calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: short(*)2
        	[in] -> Array to assign to. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array. 

        value: short
        	[in] -> Value to set into the element.


        '''
        pass

    def getShort3ArrayItem(self, var: short(*)3,
                        r: int,
                        c: int): 
        '''
        getShort3ArrayItem(self, var: short(*)3,
                        r: int,
                        c: int) -> short

        Synopsis
        -----
        Get a value from the three dimensional array. Ensure that
        indicies are valid before calling this method.

        Returns: 
        ----- 
        Value of the element: var[r][c]

        Parameters:
        -----
        var: short(*)3
        	[in] -> Array to read from. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array.


        '''
        pass

    def setShort3ArrayItem(self, var: short(*)3,
                        r: int,
                        c: int,
                        value: short): 
        '''
        setShort3ArrayItem(self, var: short(*)3,
                        r: int,
                        c: int,
                        value: short) -> bool

        Synopsis
        -----
        Set a value in the three dimensional array. Ensure that indices
        are valid before calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: short(*)3
        	[in] -> Array to assign to. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array. 

        value: short
        	[in] -> Value to set into the element.


        '''
        pass

    def getShort4ArrayItem(self, var: short(*)4,
                        r: int,
                        c: int): 
        '''
        getShort4ArrayItem(self, var: short(*)4,
                        r: int,
                        c: int) -> short

        Synopsis
        -----
        Get a value from the four dimensional array. Ensure that indicies
        are valid before calling this method.

        Returns: 
        ----- 
        Value of the element: var[r][c]

        Parameters:
        -----
        var: short(*)4
        	[in] -> Array to read from. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array.


        '''
        pass

    def setShort4ArrayItem(self, var: short(*)4,
                        r: int,
                        c: int,
                        value: short): 
        '''
        setShort4ArrayItem(self, var: short(*)4,
                        r: int,
                        c: int,
                        value: short) -> bool

        Synopsis
        -----
        Set a value in the two dimensional array. Ensure that indices are
        valid before calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: short(*)4
        	[in] -> Array to assign to. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array. 

        value: short
        	[in] -> Value to set into the element.


        '''
        pass

    def getFloat2ArrayItem(self, var: float(*)2,
                        r: int,
                        c: int): 
        '''
        getFloat2ArrayItem(self, var: float(*)2,
                        r: int,
                        c: int) -> float

        Synopsis
        -----
        Get a value from the two dimensional array. Ensure that indicies
        are valid before calling this method.

        Returns: 
        ----- 
        Value of the element: var[r][c]

        Parameters:
        -----
        var: float(*)2
        	[in] -> Array to read from. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array.


        '''
        pass

    def setFloat2ArrayItem(self, var: float(*)2,
                        r: int,
                        c: int,
                        value: float): 
        '''
        setFloat2ArrayItem(self, var: float(*)2,
                        r: int,
                        c: int,
                        value: float) -> bool

        Synopsis
        -----
        Set a value in the two dimensional array. Ensure that indices are
        valid before calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: float(*)2
        	[in] -> Array to assign to. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array. 

        value: float
        	[in] -> Value to set into the element.


        '''
        pass

    def getFloat3ArrayItem(self, var: float(*)3,
                        r: int,
                        c: int): 
        '''
        getFloat3ArrayItem(self, var: float(*)3,
                        r: int,
                        c: int) -> float

        Synopsis
        -----
        Get a value from the three dimensional array. Ensure that
        indicies are valid before calling this method.

        Returns: 
        ----- 
        Value of the element: var[r][c]

        Parameters:
        -----
        var: float(*)3
        	[in] -> Array to read from. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array.


        '''
        pass

    def setFloat3ArrayItem(self, var: float(*)3,
                        r: int,
                        c: int,
                        value: float): 
        '''
        setFloat3ArrayItem(self, var: float(*)3,
                        r: int,
                        c: int,
                        value: float) -> bool

        Synopsis
        -----
        Set a value in the three dimensional array. Ensure that indices
        are valid before calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: float(*)3
        	[in] -> Array to assign to. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array. 

        value: float
        	[in] -> Value to set into the element.


        '''
        pass

    def getFloat4ArrayItem(self, var: float(*)4,
                        r: int,
                        c: int): 
        '''
        getFloat4ArrayItem(self, var: float(*)4,
                        r: int,
                        c: int) -> float

        Synopsis
        -----
        Get a value from the four dimensional array. Ensure that indicies
        are valid before calling this method.

        Returns: 
        ----- 
        Value of the element: var[r][c]

        Parameters:
        -----
        var: float(*)4
        	[in] -> Array to read from. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array.


        '''
        pass

    def setFloat4ArrayItem(self, var: float(*)4,
                        r: int,
                        c: int,
                        value: float): 
        '''
        setFloat4ArrayItem(self, var: float(*)4,
                        r: int,
                        c: int,
                        value: float) -> bool

        Synopsis
        -----
        Set a value in the four dimensional array. Ensure that indices
        are valid before calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: float(*)4
        	[in] -> Array to assign to. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array. 

        value: float
        	[in] -> Value to set into the element.


        '''
        pass

    def getDouble2ArrayItem(self, var: double(*)2,
                        r: int,
                        c: int): 
        '''
        getDouble2ArrayItem(self, var: double(*)2,
                        r: int,
                        c: int) -> double

        Synopsis
        -----
        Get a value from the two dimensional array. Ensure that indicies
        are valid before calling this method.

        Returns: 
        ----- 
        Value of the element: var[r][c]

        Parameters:
        -----
        var: double(*)2
        	[in] -> Array to read from. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array.


        '''
        pass

    def setDouble2ArrayItem(self, var: double(*)2,
                        r: int,
                        c: int,
                        value: double): 
        '''
        setDouble2ArrayItem(self, var: double(*)2,
                        r: int,
                        c: int,
                        value: double) -> bool

        Synopsis
        -----
        Set a value in the two dimensional array. Ensure that indices are
        valid before calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: double(*)2
        	[in] -> Array to assign to. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array. 

        value: double
        	[in] -> Value to set into the element.


        '''
        pass

    def getDouble3ArrayItem(self, var: double(*)3,
                        r: int,
                        c: int): 
        '''
        getDouble3ArrayItem(self, var: double(*)3,
                        r: int,
                        c: int) -> double

        Synopsis
        -----
        Get a value from the three dimensional array. Ensure that
        indicies are valid before calling this method.

        Returns: 
        ----- 
        Value of the element: var[r][c]

        Parameters:
        -----
        var: double(*)3
        	[in] -> Array to read from. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array.


        '''
        pass

    def setDouble3ArrayItem(self, var: double(*)3,
                        r: int,
                        c: int,
                        value: double): 
        '''
        setDouble3ArrayItem(self, var: double(*)3,
                        r: int,
                        c: int,
                        value: double) -> bool

        Synopsis
        -----
        Set a value in the three dimensional array. Ensure that indices
        are valid before calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: double(*)3
        	[in] -> Array to assign to. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array. 

        value: double
        	[in] -> Value to set into the element.


        '''
        pass

    def getDouble4ArrayItem(self, var: double(*)4,
                        r: int,
                        c: int): 
        '''
        getDouble4ArrayItem(self, var: double(*)4,
                        r: int,
                        c: int) -> double

        Synopsis
        -----
        Get a value from the four dimensional array. Ensure that indicies
        are valid before calling this method.

        Returns: 
        ----- 
        Value of the element: var[r][c]

        Parameters:
        -----
        var: double(*)4
        	[in] -> Array to read from. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array.


        '''
        pass

    def setDouble4ArrayItem(self, var: double(*)4,
                        r: int,
                        c: int,
                        value: double): 
        '''
        setDouble4ArrayItem(self, var: double(*)4,
                        r: int,
                        c: int,
                        value: double) -> bool

        Synopsis
        -----
        Set a value in the four dimensional array. Ensure that indices
        are valid before calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: double(*)4
        	[in] -> Array to assign to. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array. 

        value: double
        	[in] -> Value to set into the element.


        '''
        pass

    def getUint2ArrayItem(self, var: int(*)2,
                        r: int,
                        c: int): 
        '''
        getUint2ArrayItem(self, var: int(*)2,
                        r: int,
                        c: int) -> int

        Synopsis
        -----
        Get a value from the two dimensional array. Ensure that indicies
        are valid before calling this method.

        Returns: 
        ----- 
        Value of the element: var[r][c]

        Parameters:
        -----
        var: int(*)2
        	[in] -> Array to read from. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array.


        '''
        pass

    def setUint2ArrayItem(self, var: int(*)2,
                        r: int,
                        c: int,
                        value: int): 
        '''
        setUint2ArrayItem(self, var: int(*)2,
                        r: int,
                        c: int,
                        value: int) -> bool

        Synopsis
        -----
        Set a value in the two dimensional array. Ensure that indices are
        valid before calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: int(*)2
        	[in] -> Array to assign to. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array. 

        value: int
        	[in] -> Value to set into the element.


        '''
        pass

    def getUint3ArrayItem(self, var: int(*)3,
                        r: int,
                        c: int): 
        '''
        getUint3ArrayItem(self, var: int(*)3,
                        r: int,
                        c: int) -> int

        Synopsis
        -----
        Get a value from the three dimensional array. Ensure that
        indicies are valid before calling this method.

        Returns: 
        ----- 
        Value of the element: var[r][c]

        Parameters:
        -----
        var: int(*)3
        	[in] -> Array to read from. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array.


        '''
        pass

    def setUint3ArrayItem(self, var: int(*)3,
                        r: int,
                        c: int,
                        value: int): 
        '''
        setUint3ArrayItem(self, var: int(*)3,
                        r: int,
                        c: int,
                        value: int) -> bool

        Synopsis
        -----
        Set a value in the three dimensional array. Ensure that indices
        are valid before calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: int(*)3
        	[in] -> Array to assign to. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array. 

        value: int
        	[in] -> Value to set into the element.


        '''
        pass

    def getUint4ArrayItem(self, var: int(*)4,
                        r: int,
                        c: int): 
        '''
        getUint4ArrayItem(self, var: int(*)4,
                        r: int,
                        c: int) -> int

        Synopsis
        -----
        Get a value from the four dimensional array. Ensure that indicies
        are valid before calling this method.

        Returns: 
        ----- 
        Value of the element: var[r][c]

        Parameters:
        -----
        var: int(*)4
        	[in] -> Array to read from. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array.


        '''
        pass

    def setUint4ArrayItem(self, var: int(*)4,
                        r: int,
                        c: int,
                        value: int): 
        '''
        setUint4ArrayItem(self, var: int(*)4,
                        r: int,
                        c: int,
                        value: int) -> bool

        Synopsis
        -----
        Set a value in the four dimensional array. Ensure that indices
        are valid before calling this method.

        Returns: 
        ----- 
        True on success, false otherwise.

        Parameters:
        -----
        var: int(*)4
        	[in] -> Array to assign to. 

        r: int
        	[in] -> First index in the array. 

        c: int
        	[in] -> Second index in the array. 

        value: int
        	[in] -> Value to set into the element.


        '''
        pass

class MSelectionList:
    '''A list of MObjects.
This class implements a list of MObjects.
The global selection list is a special case where the objects on
the list are also active objects in Maya.
Besides the usual list methods, this class also provides an add
method which retrieves objects from Maya, such as dependency
nodes, by name.
'''
    def __init__(self):
        pass


    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        This method empties the selection list.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isEmpty(self, ReturnStatus: MSelectionList.MStatus): 
        '''
        isEmpty(self, ReturnStatus: MSelectionList.MStatus) -> bool

        Synopsis
        -----
        Specifies whether or not the selection list contains any items.

        Returns: 
        ----- 
        true if the list is empty, false otherwise.

        Parameters:
        -----
        ReturnStatus: MSelectionList.MStatus
        	[in] -> Status flag


        '''
        pass

    def length(self, ReturnStatus: MSelectionList.MStatus): 
        '''
        length(self, ReturnStatus: MSelectionList.MStatus) -> int

        Synopsis
        -----
        This method returns the number of selection items in the list.

        Returns: 
        ----- 
        Number of items in the list

        Parameters:
        -----
        ReturnStatus: MSelectionList.MStatus
        	[out] -> flag


        '''
        pass

    def getDependNode(self, index: int,
                        depNode: MObject): 
        '''
        getDependNode(self, index: int,
                        depNode: MObject)

        Synopsis
        -----
        Get a handle for the dependency node of the given element of the
        selection list. Returns kNullObj and kFailure if selected item
        does not contain a dependency node.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the items position in the list 

        depNode: MObject
        	[out] -> storage for the result


        '''
        pass

    def getDagPath(self, index: int,
                        dagPath: MDagPath,
                        component: MObject): 
        '''
        getDagPath(self, index: int,
                        dagPath: MDagPath,
                        component: MObject)

        Synopsis
        -----
        Get the dag path and component (may be NULL) of the given element
        of the selection list.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the items position in the list 

        dagPath: MDagPath
        	[out] -> storage for the dag path of the item 

        component: MObject
        	[out] -> storage for a handle for the component. This will be null if there is no component


        '''
        pass

    @overload
    def getPlug(self, index: int,
                        plug: MPlug): 
        '''
        getPlug(self, index: int,
                        plug: MPlug)

        Synopsis
        -----
        Get the plug at the specified index of the selection list.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the items position in the list 

        plug: MPlug
        	[out] -> storage for the result


        '''
        pass

    @overload
    def getPlug(self, index: int,
                        convertComponents: bool,
                        plug: MPlug): 
        '''
        getPlug(self, index: int,
                        convertComponents: bool,
                        plug: MPlug)

        Synopsis
        -----
        Introduced in 2022.0 Get the plug at the specified index of the
        selection list.If convertComponents is true then components in
        the selection list that have a corresponding plug will return
        that instead.Note: This only works if the component selection can
        be converted into a single plug - single component or all
        components selected.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the items position in the list 

        convertComponents: bool
        	[in] -> if true returns the plug of the component in the selection 

        plug: MPlug
        	[out] -> storage for the result


        '''
        pass

    @overload
    def add(self, object: MObject,
                        mergeWithExisting: bool): 
        '''
        add(self, object: MObject,
                        mergeWithExisting: bool)

        Synopsis
        -----
        Add the specified DG node to the end of the selection list.

        Returns:
        -----
        None

        Parameters:
        -----
        object: MObject
        	[in] -> The object to add 

        mergeWithExisting: bool
        	[in] -> This parameter determines what to do if the given item is already present in the list: 


        '''
        pass

    @overload
    def add(self, object: MDagPath,
                        component: MObject,
                        mergeWithExisting: bool): 
        '''
        add(self, object: MDagPath,
                        component: MObject,
                        mergeWithExisting: bool)

        Synopsis
        -----
        Add the specified DG node to the end of the selection list.

        Returns:
        -----
        None

        Parameters:
        -----
        object: MDagPath
        	[in] -> The Dag Object to add 

        component: MObject
        	[in] -> components of the object 

        mergeWithExisting: bool
        	[in] -> This parameter determines what to do if the given item is already present in the list: 


        '''
        pass

    @overload
    def add(self, matchString: MString,
                        searchChildNamespacesToo: bool): 
        '''
        add(self, matchString: MString,
                        searchChildNamespacesToo: bool)

        Synopsis
        -----
        Add the specified object(s) to the selection list. There is an
        option to search all child namespaces. The object name should be
        specified in the same way it would be in the MEL language. It is
        possible to use wildcard characters, so multiple objects may be
        added in one method call.NOTE: the actual namespace being
        searched is important. In relativeNames mode (see the method
        MNamespace::relativeNames), the search starts in the current
        namespace but with relativeNames mode off, the search starts with
        the root namespace.

        Returns:
        -----
        None

        Parameters:
        -----
        matchString: MString
        	[in] -> object match string 

        searchChildNamespacesToo: bool
        	[in] -> optional parameter to specify that child namespaces will also be searched. A value of true enables child namespace searching; a value of false (the default) only searches within the namespace. See the above description for details on 


        '''
        pass

    @overload
    def add(self, plug: MPlug,
                        mergeWithExisting: bool): 
        '''
        add(self, plug: MPlug,
                        mergeWithExisting: bool)

        Synopsis
        -----
        Add the specified plug to the end of the selection list.

        Returns:
        -----
        None

        Parameters:
        -----
        plug: MPlug
        	[in] -> the plug to add 

        mergeWithExisting: bool
        	[in] -> This parameter determines what to do if the given item is already present in the list: 


        '''
        pass

    @overload
    def add(self, uuid: MUuid,
                        mergeWithExisting: bool): 
        '''
        add(self, uuid: MUuid,
                        mergeWithExisting: bool)

        Synopsis
        -----
        Add nodes matching the UUID to the selection list.

        Returns:
        -----
        None

        Parameters:
        -----
        uuid: MUuid
        	[in] -> the UUID with which to look up nodes 

        mergeWithExisting: bool
        	[in] -> merge new items with existing ones, or add unconditionally to end of list.


        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Removes the item at the given index from the list.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of the item to be removed


        '''
        pass

    @overload
    def replace(self, index: int,
                        item: MObject): 
        '''
        replace(self, index: int,
                        item: MObject)

        Synopsis
        -----
        Remove the item at the given index in the list and replace it
        with the given object. The given index must not be greater than
        the current number of items on the list.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of the item to remove from the list

        item: MObject
        	[in] -> A pointer to the replacement object 


        '''
        pass

    @overload
    def replace(self, index: int,
                        item: MDagPath,
                        component: MObject): 
        '''
        replace(self, index: int,
                        item: MDagPath,
                        component: MObject)

        Synopsis
        -----
        Remove the item at the given index in the list and replace it
        with the given Dag item (or components). The given index must not
        be greater than the current number of items on the list.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of the item to remove from the list

        item: MDagPath
        	[in] -> the new dag object to place into the list 

        component: MObject
        	[in] -> the components of 


        '''
        pass

    @overload
    def replace(self, index: int,
                        plug: MPlug): 
        '''
        replace(self, index: int,
                        plug: MPlug)

        Synopsis
        -----
        Remove the item at the given index in the list and replace it
        with the given plug. The given index must not be greater than the
        current number of items on the list.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> The index of the item to remove from the list

        plug: MPlug
        	[in] -> The replacement plug 


        '''
        pass

    @overload
    def hasItem(self, item: MObject,
                        ReturnStatus: MSelectionList.MStatus): 
        '''
        hasItem(self, item: MObject,
                        ReturnStatus: MSelectionList.MStatus) -> bool

        Synopsis
        -----
        Determines whether or not the given dependency node is in this
        selection list. Note that if the selection list contains a DAG
        node, the overloaded version of this method that takes an
        MDagPath must be used. A dag path will not compare identically to
        a DG node, even if they both refer to the same node.

        Returns: 
        ----- 
        true if the item is in this list, false otherwise

        Parameters:
        -----
        item: MObject
        	[in] -> The item to check for 

        ReturnStatus: MSelectionList.MStatus
        	[out] -> Status flag


        '''
        pass

    @overload
    def hasItem(self, item: MDagPath,
                        component: MObject,
                        ReturnStatus: MSelectionList.MStatus): 
        '''
        hasItem(self, item: MDagPath,
                        component: MObject,
                        ReturnStatus: MSelectionList.MStatus) -> bool

        Synopsis
        -----
        Determines whether or not the given DAG object is in this
        selection list. If the component argument is non-null, then this
        method will only return true of all the components of the given
        DAG object are on the selection list.

        Returns: 
        ----- 
        true if the item or component is in this list, false otherwise

        Parameters:
        -----
        item: MDagPath
        	[in] -> the DAG object to check for 

        component: MObject
        	[in] -> the components of 

        ReturnStatus: MSelectionList.MStatus
        	[out] -> Status flag


        '''
        pass

    @overload
    def hasItem(self, plug: MPlug,
                        ReturnStatus: MSelectionList.MStatus): 
        '''
        hasItem(self, plug: MPlug,
                        ReturnStatus: MSelectionList.MStatus) -> bool

        Synopsis
        -----
        Determines whether or not the given plug is in this selection
        list.

        Returns: 
        ----- 
        true if the plug is in this list, false otherwise

        Parameters:
        -----
        plug: MPlug
        	[in] -> The plug to check for 

        ReturnStatus: MSelectionList.MStatus
        	[out] -> Status flag


        '''
        pass

    def hasItemPartly(self, item: MDagPath,
                        component: MObject,
                        ReturnStatus: MSelectionList.MStatus): 
        '''
        hasItemPartly(self, item: MDagPath,
                        component: MObject,
                        ReturnStatus: MSelectionList.MStatus) -> bool

        Synopsis
        -----
        This method differs from hasItem in that it determines whether or
        not at least one of the components of the the given DAG object
        are in this selection list. This method is only applicable when
        multiple components are provided.

        Returns: 
        ----- 
        true if at least one of the components in this list, false
        otherwise

        Parameters:
        -----
        item: MDagPath
        	[in] -> the DAG object to check for 

        component: MObject
        	[in] -> the components of 

        ReturnStatus: MSelectionList.MStatus
        	[out] -> Status flag


        '''
        pass

    def toggle(self, item: MDagPath,
                        component: MObject): 
        '''
        toggle(self, item: MDagPath,
                        component: MObject)

        Synopsis
        -----
        Removes those components of the given selection item which are on
        the selection list, and adds those parts which are not. This
        method does nothing if no components are provided.

        Returns:
        -----
        None

        Parameters:
        -----
        item: MDagPath
        	[in] -> Dag object to be toggled 

        component: MObject
        	[in] -> components of the object


        '''
        pass

    @overload
    def merge(self, other: MSelectionList,
                        strategy: MSelectionList.MergeStrategy): 
        '''
        merge(self, other: MSelectionList,
                        strategy: MSelectionList.MergeStrategy)

        Synopsis
        -----
        Merge the two selection lists.

        Returns:
        -----
        None

        Parameters:
        -----
        other: MSelectionList
        	[in] -> the selection list to be merged. 

        strategy: MSelectionList.MergeStrategy
        	[in] -> the merging strategy. It can be one of the the following:


        '''
        pass

    @overload
    def merge(self, item: MDagPath,
                        component: MObject,
                        strategy: MSelectionList.MergeStrategy): 
        '''
        merge(self, item: MDagPath,
                        component: MObject,
                        strategy: MSelectionList.MergeStrategy)

        Synopsis
        -----
        Merge the given DAG object into the selection list.

        Returns:
        -----
        None

        Parameters:
        -----
        item: MDagPath
        	[in] -> the dependency node to be merged. 

        component: MObject
        	[in] -> components of the Dag object to add 

        strategy: MSelectionList.MergeStrategy
        	[in] -> the merging strategy. It can be one of the following:


        '''
        pass

    def intersect(self, other: MSelectionList,
                        expandToLeaves: bool): 
        '''
        intersect(self, other: MSelectionList,
                        expandToLeaves: bool)

        Synopsis
        -----
        Modify this list to contain the intersection of itself and the
        given list.

        Returns:
        -----
        None

        Parameters:
        -----
        other: MSelectionList
        	[in] -> the selection list to be intersected. 

        expandToLeaves: bool
        	[in] -> If expandToLeaves is true, the two lists will be copied and grown to include leaf nodes before performing the intersection.


        '''
        pass

    @overload
    def getSelectionStrings(self, array: MStringArray): 
        '''
        getSelectionStrings(self, array: MStringArray)

        Synopsis
        -----
        Gets the string representations of the items in the selection
        list. The strings will be in the format used by the scripting
        language.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MStringArray
        	[out] -> storage for the returned strings


        '''
        pass

    @overload
    def getSelectionStrings(self, index: int,
                        array: MStringArray): 
        '''
        getSelectionStrings(self, index: int,
                        array: MStringArray)

        Synopsis
        -----
        Gets the string representation of the given item in the selection
        list. The strings will be in the format used by the scripting
        language. More than one string will be returned in the case that
        the item in the selection list has a component that that contains
        elements that are not contiguous (eg CV's 2 and 8 are selected on
        a surface).

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> index of the element to get 

        array: MStringArray
        	[out] -> storage for the returned strings


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MergeStrategy:
    '''Specifies how to merge objects with those already in the list. 
    Non-functional class.  Values for this enum:
    kMergeNormal
    kXORWithList
    kRemoveFromList
    '''

    def __init__(self):
        pass

    def kMergeNormal(self):
        '''This is an enum of MergeStrategy.
        - Description: If the object is not already on the list, add it. 
        - Value: 0
        '''
        pass

    def kXORWithList(self):
        '''This is an enum of MergeStrategy.
        - Description: Exclusive OR: if the object is already on the list, remove it, otherwise add it. 
        - Value: 1
        '''
        pass

    def kRemoveFromList(self):
        '''This is an enum of MergeStrategy.
        - Description: Remove the object from the list. 
        - Value: 2
        '''
        pass

class MSelectionMask:
    '''Manage what is selectable in Maya. (OpenMaya) (OpenMaya.py)
Selection masks provide a way to control what is selectable in
Maya.
Selection masks can be created by OR'ing several types together,
or by using the addMask method to add a selection type to an
MSelectionMask.
Example - to set the object selection mask to nurbsSurfaces,
nurbsCurves, cameras, and lights
'''
    def __init__(self):
        pass


    @overload
    def setMask(self, selType: MSelectionMask.MSelectionMask): 
        '''
        setMask(self, selType: MSelectionMask.MSelectionMask)

        Synopsis
        -----
        Sets the selection mask to the specified selection type.

        Returns:
        -----
        None

        Parameters:
        -----
        selType: MSelectionMask.MSelectionMask
        	[in] -> the selection type to be set


        '''
        pass

    @overload
    def setMask(self, mask: MSelectionMask): 
        '''
        setMask(self, mask: MSelectionMask)

        Synopsis
        -----
        Sets the selection type for this mask to the selection type of
        the specified mask.

        Returns:
        -----
        None

        Parameters:
        -----
        mask: MSelectionMask
        	[in] -> the mask with the selection type to be set


        '''
        pass

    def addMask(self, selType: MSelectionMask.MSelectionMask): 
        '''
        addMask(self, selType: MSelectionMask.MSelectionMask)

        Synopsis
        -----
        Add the specified selection type to this mask.

        Returns:
        -----
        None

        Parameters:
        -----
        selType: MSelectionMask.MSelectionMask
        	[in] -> the selection type to add


        '''
        pass

    @overload
    def intersects(self, selType: MSelectionMask.MSelectionMask,
                        ReturnStatus: MSelectionMask.MStatus): 
        '''
        intersects(self, selType: MSelectionMask.MSelectionMask,
                        ReturnStatus: MSelectionMask.MStatus) -> bool

        Synopsis
        -----
        Returns true if the specified selection type is contained within
        this selection mask.

        Returns: 
        ----- 
        true the specified selection type is contained in this mask false
        the specified selection type is not in this mask

        Parameters:
        -----
        selType: MSelectionMask.MSelectionMask
        	[in] -> the selection type to test 

        ReturnStatus: MSelectionMask.MStatus
        	[out] -> status code


        '''
        pass

    @overload
    def intersects(self, mask: MSelectionMask,
                        ReturnStatus: MSelectionMask.MStatus): 
        '''
        intersects(self, mask: MSelectionMask,
                        ReturnStatus: MSelectionMask.MStatus) -> bool

        Synopsis
        -----
        Returns true if the specified selection mask is contained within
        this selection mask.

        Returns: 
        ----- 
        true the specified selection mask is contained in this mask false
        the specified selection mask is not in this mask

        Parameters:
        -----
        mask: MSelectionMask
        	[in] -> the selection mask to test 

        ReturnStatus: MSelectionMask.MStatus
        	[out] -> status code


        '''
        pass

    def registerSelectionType(self, selTypeName: MString,
                        priority: int): 
        '''
        registerSelectionType(self, selTypeName: MString,
                        priority: int) -> bool

        Synopsis
        -----
        Registers a new selection type. It is perfectly legal for 2 plug-
        ins to register the same selection type. Currently we use the
        registration count. The selection type is deleted only when
        deregisterSelectionType() as been called the same number of times
        as this function - registerSelectionType().When
        registerSelectionType() is invoked and the selection type already
        exists,we neither enable it nor change its priority, just add its
        registration count by 1. The reason is the user might has
        modified these values after loading the plug-in that has register
        the selection type the first time.

        Returns: 
        ----- 
        true The selection type was successfully registered.  false
        Failed to register the selection type.

        Parameters:
        -----
        selTypeName: MString
        	[in] -> Name of the selection type. 

        priority: int
        	[in] -> Priority of the selection type,see 'selectPriority' command.


        '''
        pass

    def deregisterSelectionType(self, selTypeName: MString): 
        '''
        deregisterSelectionType(self, selTypeName: MString) -> bool

        Synopsis
        -----
        Unregisters a previously registered selection type.

        Returns: 
        ----- 
        true The selection type was successfully unregistered.  false
        Failed to unregister the selection type.

        Parameters:
        -----
        selTypeName: MString
        	[in] -> Name of the selection type.


        '''
        pass

    def getSelectionTypePriority(self, selTypeName: MString): 
        '''
        getSelectionTypePriority(self, selTypeName: MString) -> int

        Synopsis
        -----
        Gets the selection priority corresponding to a given selection
        type.

        Returns: 
        ----- 
        The selection priority corresponding to a given selection type.
        return -1 if there is no select type named selTypeName.

        Parameters:
        -----
        selTypeName: MString
        	[in] -> Name of the selection type.


        '''
        pass

class SelectionType:
    '''Types of objects which can be selected. 
    Non-functional class.  Values for this enum:
    kSelectHandles
    kSelectLocalAxis
    kSelectIkHandles
    kSelectIkEndEffectors
    kSelectJoints
    kSelectLights
    kSelectCameras
    kSelectLattices
    kSelectClusters
    kSelectSculpts
    kSelectNurbsCurves
    kSelectNurbsSurfaces
    kSelectMeshes
    kSelectSubdiv
    kSelectSketchPlanes
    kSelectParticleShapes
    kSelectEmitters
    kSelectFields
    kSelectSprings
    kSelectRigidBodies
    kSelectRigidConstraints
    kSelectCollisionModels
    kSelectXYZLocators
    kSelectOrientationLocators
    kSelectUVLocators
    kSelectTextures
    kSelectCurves
    kSelectSurfaces
    kSelectLocators
    kSelectObjectsMask
    kSelectCVs
    kSelectHulls
    kSelectEditPoints
    kSelectMeshVerts
    kSelectMeshEdges
    kSelectMeshFreeEdges
    kSelectMeshFaces
    kSelectSubdivMeshPoints
    kSelectSubdivMeshEdges
    kSelectSubdivMeshFaces
    kSelectMeshUVs
    kSelectVertices
    kSelectEdges
    kSelectFacets
    kSelectMeshLines
    kSelectMeshComponents
    kSelectCurveParmPoints
    kSelectCurveKnots
    kSelectSurfaceParmPoints
    kSelectSurfaceKnots
    kSelectSurfaceRange
    kSelectSurfaceEdge
    kSelectIsoparms
    kSelectCurvesOnSurfaces
    kSelectPPStrokes
    kSelectLatticePoints
    kSelectParticles
    kSelectJointPivots
    kSelectScalePivots
    kSelectRotatePivots
    kSelectPivots
    kSelectSelectHandles
    kSelectComponentsMask
    kSelectAnimCurves
    kSelectAnimKeyframes
    kSelectAnimInTangents
    kSelectAnimOutTangents
    kSelectAnimMask
    kSelectAnimAny
    kSelectTemplates
    kSelectManipulators
    kSelectGuideLines
    kSelectPointsForGravity
    kSelectPointsOnCurvesForGravity
    kSelectPointsOnSurfacesForGravity
    kSelectObjectGroups
    kSelectSubdivMeshMaps
    kSelectFluids
    kSelectHairSystems
    kSelectFollicles
    kSelectNCloths
    kSelectNRigids
    kSelectDynamicConstraints
    kSelectNParticles
    '''

    def __init__(self):
        pass

    def kSelectHandles(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 0
        '''
        pass

    def kSelectLocalAxis(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 1
        '''
        pass

    def kSelectIkHandles(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 2
        '''
        pass

    def kSelectIkEndEffectors(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 3
        '''
        pass

    def kSelectJoints(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 4
        '''
        pass

    def kSelectLights(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 5
        '''
        pass

    def kSelectCameras(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 6
        '''
        pass

    def kSelectLattices(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 7
        '''
        pass

    def kSelectClusters(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 8
        '''
        pass

    def kSelectSculpts(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 9
        '''
        pass

    def kSelectNurbsCurves(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 10
        '''
        pass

    def kSelectNurbsSurfaces(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 11
        '''
        pass

    def kSelectMeshes(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 12
        '''
        pass

    def kSelectSubdiv(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 13
        '''
        pass

    def kSelectSketchPlanes(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 14
        '''
        pass

    def kSelectParticleShapes(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 15
        '''
        pass

    def kSelectEmitters(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 16
        '''
        pass

    def kSelectFields(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 17
        '''
        pass

    def kSelectSprings(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 18
        '''
        pass

    def kSelectRigidBodies(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 19
        '''
        pass

    def kSelectRigidConstraints(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 20
        '''
        pass

    def kSelectCollisionModels(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 21
        '''
        pass

    def kSelectXYZLocators(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 22
        '''
        pass

    def kSelectOrientationLocators(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 23
        '''
        pass

    def kSelectUVLocators(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 24
        '''
        pass

    def kSelectTextures(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 25
        '''
        pass

    def kSelectCurves(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 26
        '''
        pass

    def kSelectSurfaces(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 27
        '''
        pass

    def kSelectLocators(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 28
        '''
        pass

    def kSelectObjectsMask(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 29
        '''
        pass

    def kSelectCVs(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 30
        '''
        pass

    def kSelectHulls(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 31
        '''
        pass

    def kSelectEditPoints(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 32
        '''
        pass

    def kSelectMeshVerts(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 33
        '''
        pass

    def kSelectMeshEdges(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 34
        '''
        pass

    def kSelectMeshFreeEdges(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 35
        '''
        pass

    def kSelectMeshFaces(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 36
        '''
        pass

    def kSelectSubdivMeshPoints(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 37
        '''
        pass

    def kSelectSubdivMeshEdges(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 38
        '''
        pass

    def kSelectSubdivMeshFaces(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 39
        '''
        pass

    def kSelectMeshUVs(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 40
        '''
        pass

    def kSelectVertices(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 41
        '''
        pass

    def kSelectEdges(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 42
        '''
        pass

    def kSelectFacets(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 43
        '''
        pass

    def kSelectMeshLines(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 44
        '''
        pass

    def kSelectMeshComponents(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 45
        '''
        pass

    def kSelectCurveParmPoints(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 46
        '''
        pass

    def kSelectCurveKnots(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 47
        '''
        pass

    def kSelectSurfaceParmPoints(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 48
        '''
        pass

    def kSelectSurfaceKnots(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 49
        '''
        pass

    def kSelectSurfaceRange(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 50
        '''
        pass

    def kSelectSurfaceEdge(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 51
        '''
        pass

    def kSelectIsoparms(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 52
        '''
        pass

    def kSelectCurvesOnSurfaces(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 53
        '''
        pass

    def kSelectPPStrokes(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 54
        '''
        pass

    def kSelectLatticePoints(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 55
        '''
        pass

    def kSelectParticles(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 56
        '''
        pass

    def kSelectJointPivots(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 57
        '''
        pass

    def kSelectScalePivots(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 58
        '''
        pass

    def kSelectRotatePivots(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 59
        '''
        pass

    def kSelectPivots(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 60
        '''
        pass

    def kSelectSelectHandles(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 61
        '''
        pass

    def kSelectComponentsMask(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 62
        '''
        pass

    def kSelectAnimCurves(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 63
        '''
        pass

    def kSelectAnimKeyframes(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 64
        '''
        pass

    def kSelectAnimInTangents(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 65
        '''
        pass

    def kSelectAnimOutTangents(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 66
        '''
        pass

    def kSelectAnimMask(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 67
        '''
        pass

    def kSelectAnimAny(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 68
        '''
        pass

    def kSelectTemplates(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 69
        '''
        pass

    def kSelectManipulators(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 70
        '''
        pass

    def kSelectGuideLines(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 71
        '''
        pass

    def kSelectPointsForGravity(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 72
        '''
        pass

    def kSelectPointsOnCurvesForGravity(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 73
        '''
        pass

    def kSelectPointsOnSurfacesForGravity(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 74
        '''
        pass

    def kSelectObjectGroups(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 75
        '''
        pass

    def kSelectSubdivMeshMaps(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 76
        '''
        pass

    def kSelectFluids(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 77
        '''
        pass

    def kSelectHairSystems(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 78
        '''
        pass

    def kSelectFollicles(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 79
        '''
        pass

    def kSelectNCloths(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 80
        '''
        pass

    def kSelectNRigids(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 81
        '''
        pass

    def kSelectDynamicConstraints(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 82
        '''
        pass

    def kSelectNParticles(self):
        '''This is an enum of SelectionType.
        - Description:  
        - Value: 83
        '''
        pass

class MSetAttrEdit:
    '''Class for describing setAttr edits.
This class is used to return information about setAttr edits.
Such edits occur when a file is referenced and changes are made
to attributes within the file reference. When a reference is
unloaded, only the plug name may be queried successfully. When
the referenced file is loaded, the plug itself may also be
queried.
The
MItEdits class may be used to iterate over all the edits on a given
reference or assembly.
'''
    def __init__(self):
        pass


    def plug(self, ReturnStatus: MSetAttrEdit.MStatus): 
        '''
        plug(self, ReturnStatus: MSetAttrEdit.MStatus) -> MSetAttrEdit.OPENMAYA_MAJOR_NAMESPACE_OPEN MPlug

        Synopsis
        -----
        Returns the plug that was set for this edit. The plug can only be
        returned when the related reference or assembly is loaded and the
        edit was made from the top-level. Otherwise, only the plug name
        string can be queried, using MSetAttrEdit::plugName.

        Returns: 
        ----- 
        The plug that was set for this edit

        Parameters:
        -----
        ReturnStatus: MSetAttrEdit.MStatus
        	[out] -> Status Code


        '''
        pass

    def plugName(self, ReturnStatus: MSetAttrEdit.MStatus): 
        '''
        plugName(self, ReturnStatus: MSetAttrEdit.MStatus) -> MString

        Synopsis
        -----
        Returns the name of the plug that was set for this edit.

        Returns: 
        ----- 
        The name of the plug that was set for this edit

        Parameters:
        -----
        ReturnStatus: MSetAttrEdit.MStatus
        	[out] -> Status Code


        '''
        pass

    def editType(self, ReturnStatus: MSetAttrEdit.MStatus): 
        '''
        editType(self, ReturnStatus: MSetAttrEdit.MStatus) -> MEdit.MEdit

        Synopsis
        -----
        Virtual method used to return the edit type of this edit, which
        is MEdit::kSetAttrEdit. Reimplemented from MEdit.

        Returns: 
        ----- 
        MEdit::kSetAttrEdit

        Parameters:
        -----
        ReturnStatus: MSetAttrEdit.MStatus
        	[out] -> return status


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MSpace:
    '''Space transformation identifiers.
MSpace encompasses all of the types of transformation possible. The
MSpace identifiers are used to determine the space in which the user is
applying or querying transformation or component (i.e. vertex
positions) data of a Maya object.
Note that not all the
MSpace types can be passed into all methods which take an
MSpace as a parameter. The
MSpace enumerated type can be split into two parts, types which can be
passed into
MFnTransform and
MTransformationMatrix classes (kTransform, kPreTransform and kPostTransform) and types
which can be passed into shape classes such as
MFnMesh,
MFnNurbsSurface and
MFnCamera (kWorld and kObject).
The following is a description of each of the
MSpace types.
There are currently no methods in the API that return a result of
type
MSpace. This may be used for user defined methods that return a result
of type
MSpace to signify an invalid result.
The data applied or queried using the kTransform type represents
a transform's local (or relative) coordinates system. This type
is valid for methods of
MFnTransform and
MTransformationMatrix classes.
The data applied or queried using the kPreTransform type
represents pre-transformed matrix data. Given a matrix which has
had other matrix operations applied to it, this type is used to
obtain a matrix that does not taken into consideration any other
matrix operations. This type is valid for methods of the
MTransformationMatrix classes.
The data applied or queried using the kPostTransform type
represents post-transformed matrix data. Given a matrix which has
had other matrix operations applied to it, this type is used to
obtain a matrix that has taken into consideration all other
matrix operations. This type is valid for methods of the
MTransformationMatrix classes.
The data applied or queried using the kWorld type represents the
data for the objects world coordinates system. The results of
this type will take into consideration all the transforms in the
objects hierarchy. This type can be used with shape classes such
as
MFnMesh,
MFnNurbsSurface and
MFnCamera and the
MFnTransform class. Note that to get the proper world space transformation
data with
MSpace::kWorld you
 use the class constructor which initializes the function set
with an
MDagPath object.
The data applied or queried using the kObject type represents the
data for the objects local coordinates system. The results of
this type will be in the local space of the object (object
space). This enum can only be used with shape classes such as
MFnMesh,
MFnNurbsSurface and
MFnCamera.
This simply signifies the end of the
MSpace enumerated types. All values that precede this value represent a
coordinate system (with the exception of kInvalid which
represents an invalid result.)
There are four spaces in which to apply a transformation.
Transform Space - This space depends on the type of
transformation being applied. Transform nodes define a fixed
sequence of affine transformations. Basically, there is scale
followed by rotation and finally translation. There are four
spaces here:
1) The space before applying the scale.
 2) The space after the scale but before the rotation.
 3) The space between the rotation and translation.
 4) The space after the translation.
 Space 1) is pre-transform space.
 Space 4) is post-transform space.
 Spaces 2) and 3) define transform spaces.
If applying a transform space scale, this transform will be
applied after the current scale but before the rotation (space
2). If applying a transform space rotation, this transform will
be applied after the current rotation but before the translation.
Applying a translation in transform space, the translation will
be applied after the current translation.
'''
    def __init__(self):
        pass


class Space:
    '''Transformation spaces. 
    Non-functional class.  Values for this enum:
    kInvalid
    kTransform
    kPreTransform
    kPostTransform
    kWorld
    kObject
    kLast
    '''

    def __init__(self):
        pass

    def kInvalid(self):
        '''This is an enum of Space.
        - Description: Invalid value. 
        - Value: 0
        '''
        pass

    def kTransform(self):
        '''This is an enum of Space.
        - Description: Transform matrix (relative) space. 
        - Value: 1
        '''
        pass

    def kPreTransform(self):
        '''This is an enum of Space.
        - Description: Pre-transform matrix (geometry). 
        - Value: 2
        '''
        pass

    def kPostTransform(self):
        '''This is an enum of Space.
        - Description: Post-transform matrix (world) space. 
        - Value: 3
        '''
        pass

    def kWorld(self):
        '''This is an enum of Space.
        - Description: transform in world space. 
        - Value: 4
        '''
        pass

    def kObject(self):
        '''This is an enum of Space.
        - Description: Same as pre-transform space. 
        - Value: 2
        '''
        pass

    def kLast(self):
        '''This is an enum of Space.
        - Description: Last value, used for counting. 
        - Value: 5
        '''
        pass

class MStreamUtils:
    '''Stream functionality.
This class provides some standard stream functionality for
developers working in C++ or script. Write methods are provided
for writing to ASCII or binary. Read methods are only binary.
'''
    def __init__(self):
        pass


    def writeChar(self, outarg: std.std,
                        value: char,
                        binary: bool): 
        '''
        writeChar(self, outarg: std.std,
                        value: char,
                        binary: bool)

        Synopsis
        -----
        This method is used to write out a "char" value to an ostream.

        Returns:
        -----
        None

        Parameters:
        -----
        outarg: std.std
        	[in] -> 

        value: char
        	[in] -> 

        binary: bool
        	[in] -> 


        '''
        pass

    def writeCharBuffer(self, outarg: std.std,
                        value: char,
                        binary: bool): 
        '''
        writeCharBuffer(self, outarg: std.std,
                        value: char,
                        binary: bool)

        Synopsis
        -----
        This method is used to write out a mull-terminated string (const
        char*) to an ostream.

        Returns:
        -----
        None

        Parameters:
        -----
        outarg: std.std
        	[in] -> 

        value: char
        	[in] -> 

        binary: bool
        	[in] -> 


        '''
        pass

    def writeInt(self, outarg: std.std,
                        value: int,
                        binary: bool): 
        '''
        writeInt(self, outarg: std.std,
                        value: int,
                        binary: bool)

        Synopsis
        -----
        This method is used to write out a "int" value to an ostream.

        Returns:
        -----
        None

        Parameters:
        -----
        outarg: std.std
        	[in] -> 

        value: int
        	[in] -> 

        binary: bool
        	[in] -> 


        '''
        pass

    def writeFloat(self, outarg: std.std,
                        value: float,
                        binary: bool): 
        '''
        writeFloat(self, outarg: std.std,
                        value: float,
                        binary: bool)

        Synopsis
        -----
        This method is used to write out a "float" value to an ostream.

        Returns:
        -----
        None

        Parameters:
        -----
        outarg: std.std
        	[in] -> 

        value: float
        	[in] -> 

        binary: bool
        	[in] -> 


        '''
        pass

    def writeDouble(self, outarg: std.std,
                        value: double,
                        binary: bool): 
        '''
        writeDouble(self, outarg: std.std,
                        value: double,
                        binary: bool)

        Synopsis
        -----
        This method is used to write out a "double" value to an ostream.

        Returns:
        -----
        None

        Parameters:
        -----
        outarg: std.std
        	[in] -> 

        value: double
        	[in] -> 

        binary: bool
        	[in] -> 


        '''
        pass

    def readChar(self, inarg: std.std,
                        value: char,
                        binary: bool): 
        '''
        readChar(self, inarg: std.std,
                        value: char,
                        binary: bool)

        Synopsis
        -----
        This method is used to read a "char" binary value from an
        istream.

        Returns:
        -----
        None

        Parameters:
        -----
        inarg: std.std
        	[in] -> 

        value: char
        	[in] -> 

        binary: bool
        	[in] -> 


        '''
        pass

    def readCharBuffer(self, inarg: std.std,
                        value: char,
                        length: int,
                        binary: bool): 
        '''
        readCharBuffer(self, inarg: std.std,
                        value: char,
                        length: int,
                        binary: bool)

        Synopsis
        -----
        This method is used to read a character string (char*) from an
        istream.

        Returns:
        -----
        None

        Parameters:
        -----
        inarg: std.std
        	[in] -> 

        value: char
        	[in] -> 

        length: int
        	[in] -> 

        binary: bool
        	[in] -> 


        '''
        pass

    def readInt(self, inarg: std.std,
                        value: int,
                        binary: bool): 
        '''
        readInt(self, inarg: std.std,
                        value: int,
                        binary: bool)

        Synopsis
        -----
        This method is used to read a "int" binary value from an istream.

        Returns:
        -----
        None

        Parameters:
        -----
        inarg: std.std
        	[in] -> 

        value: int
        	[in] -> 

        binary: bool
        	[in] -> 


        '''
        pass

    def readFloat(self, inarg: std.std,
                        value: float,
                        binary: bool): 
        '''
        readFloat(self, inarg: std.std,
                        value: float,
                        binary: bool)

        Synopsis
        -----
        This method is used to read a "float" binary value from an
        istream.

        Returns:
        -----
        None

        Parameters:
        -----
        inarg: std.std
        	[in] -> 

        value: float
        	[in] -> 

        binary: bool
        	[in] -> 


        '''
        pass

    def readDouble(self, inarg: std.std,
                        value: double,
                        binary: bool): 
        '''
        readDouble(self, inarg: std.std,
                        value: double,
                        binary: bool)

        Synopsis
        -----
        This method is used to read a "double" binary value from an
        istream.

        Returns:
        -----
        None

        Parameters:
        -----
        inarg: std.std
        	[in] -> 

        value: double
        	[in] -> 

        binary: bool
        	[in] -> 


        '''
        pass

class MSyntax:
    '''Syntax for Commands.
This class is used to specify flags and arguments passed to
commands. Once the syntax of the command has been defined by
calls to the methods in this class, Maya will be able to
automatically parse invocations of the command and reject
syntactically invalid ones. When the
 method of the command is invoked, the provided argument list can
be parsed automatically into an instance of either the
MArgDatabase class (for commands) or
MArgParser class (for context commands) by passing the constructor for that
class both the argument list and the syntax object for the
command.
There are three type of arguments that can be specified via these
syntax methods:
 and
 are incompatible and must not be combined in the syntax
definition of a command. If an attempt is made to do so, neither
command arguments or objects will be accessible via the
MArgDatabase or
MArgParser classes.
The
 method is used to add a flag argument to a command. Flags need
to have a
 specified for them from the list of available types in the
MArgType enum and can take up to six parameters. Flags can be set
as being allowed multiple times on the command line be calling
the
 method.
The
 method is used to add a command argument to a command. Such
arguments must also have a
 specified for them from the list of available types in the
MArgType enum. If you specify an argument via this call, Maya
will reject an invocation of the command as being syntactically
invalid if an argument of the correct type is not provided. If
the type
 is provided, Maya will include the contents of the selection
list as the argument to the command.
The
 method is used to specify that the command requires an object
list. Parameters to this method allow you to specify minimum and
maximum numbers of objects. As well, if the
 method is used in conjunction with this, Maya will use the
contents of the selection list as the objects for the command if
none are specified.
The documentation for the
MArgDatabase and
MArgParser classes describe how to access the parsed information for a
command inside the doIt method of that command.
'''
    def __init__(self):
        pass


    def addFlag(self, shortName: char,
                        longName: char,
                        argType1: MSyntax.MArgType,
                        argType2: MSyntax.MArgType,
                        argType3: MSyntax.MArgType,
                        argType4: MSyntax.MArgType,
                        argType5: MSyntax.MArgType,
                        argType6: MSyntax.MArgType): 
        '''
        addFlag(self, shortName: char,
                        longName: char,
                        argType1: MSyntax.MArgType,
                        argType2: MSyntax.MArgType,
                        argType3: MSyntax.MArgType,
                        argType4: MSyntax.MArgType,
                        argType5: MSyntax.MArgType,
                        argType6: MSyntax.MArgType)

        Synopsis
        -----
        Adds a flag to the list of flags accepted for the given command.
        Also specifies any arguments required by the flag.

        Returns:
        -----
        None

        Parameters:
        -----
        shortName: char
        	[in] -> the string representing the short (< 4 character) version of the flag 

        longName: char
        	[in] -> the string representing the int (> 3 character) version of the flag 

        argType1: MSyntax.MArgType
        	[in] -> type of the argument required by the flag, if any 

        argType2: MSyntax.MArgType
        	[in] -> another type of the argument required by the flag, if any 

        argType3: MSyntax.MArgType
        	[in] -> another type of the argument required by the flag, if any 

        argType4: MSyntax.MArgType
        	[in] -> another type of the argument required by the flag, if any 

        argType5: MSyntax.MArgType
        	[in] -> another type of the argument required by the flag, if any 

        argType6: MSyntax.MArgType
        	[in] -> another type of the argument required by the flag, if any


        '''
        pass

    def makeFlagMultiUse(self, flag: char): 
        '''
        makeFlagMultiUse(self, flag: char)

        Synopsis
        -----
        Specifies that the given flag can be used by the command multiple
        times in on the same command line.

        Returns:
        -----
        None

        Parameters:
        -----
        flag: char
        	[in] -> the flag to be made multi-use


        '''
        pass

    def makeFlagQueryWithFullArgs(self, flag: char,
                        queryArgsAreOptional: bool): 
        '''
        makeFlagQueryWithFullArgs(self, flag: char,
                        queryArgsAreOptional: bool)

        Synopsis
        -----
        Specifies that the given flag will require all of its arguments
        in query mode. Usually flags do not take arguments in query mode,
        since you are getting values instead of setting them. However,
        sometimes it is necessary to take arguments on a flag to allow
        the user to provide information which will help specify the scope
        of a query.Note that query arguments may be set to be optional.
        In that case the flag will be accepted with arguments or without.
        In that case, you must check at runtime to see how many arguments
        where passed to the flag.

        Returns:
        -----
        None

        Parameters:
        -----
        flag: char
        	[in] -> the flag which should be set to use arguments during query 

        queryArgsAreOptional: bool
        	[in] -> set to true if the flag arguments are optional


        '''
        pass

    def addArg(self, arg: MSyntax.MArgType): 
        '''
        addArg(self, arg: MSyntax.MArgType)

        Synopsis
        -----
        Specifies the type of one of the arguments to the command. This
        method can be called multiple times to specify multiple arguments
        to the command.

        Returns:
        -----
        None

        Parameters:
        -----
        arg: MSyntax.MArgType
        	[in] -> the type of the argument to the command


        '''
        pass

    def useSelectionAsDefault(self, useSelectionList: bool): 
        '''
        useSelectionAsDefault(self, useSelectionList: bool)

        Synopsis
        -----
        Specifies that the command will use the current selection list as
        arguments to the command if the command requires objects and none
        are provided}.

        Returns:
        -----
        None

        Parameters:
        -----
        useSelectionList: bool
        	[in] -> if true, the command will use the current selection list as arguments if none are specified


        '''
        pass

    @overload
    def setObjectType(self, objectFormat: MSyntax.MObjectFormat,
                        minimumObjects: int): 
        '''
        setObjectType(self, objectFormat: MSyntax.MObjectFormat,
                        minimumObjects: int)

        Synopsis
        -----
        Specifies the representation of the objects passed to the command
        as either MObjects or MStrings. Also specifies the minimum number
        of objects required by the command.

        Returns:
        -----
        None

        Parameters:
        -----
        objectFormat: MSyntax.MObjectFormat
        	[in] -> the form of the objects passed to the command 

        minimumObjects: int
        	[in] -> the minimum number of objects required by the command


        '''
        pass

    @overload
    def setObjectType(self, objectFormat: MSyntax.MObjectFormat,
                        minimumObjects: int,
                        maximumObjects: int): 
        '''
        setObjectType(self, objectFormat: MSyntax.MObjectFormat,
                        minimumObjects: int,
                        maximumObjects: int)

        Synopsis
        -----
        Specifies the representation of the objects passed to the command
        as either MObjects or MStrings. Also specifies the upper and
        lower limits of the number of objects accepted by the command.

        Returns:
        -----
        None

        Parameters:
        -----
        objectFormat: MSyntax.MObjectFormat
        	[in] -> the form of the objects passed to the command 

        minimumObjects: int
        	[in] -> the lower limit of the number of objects 

        maximumObjects: int
        	[in] -> the upper limit of the number of objects


        '''
        pass

    def setMinObjects(self, minimumObjectCount: int): 
        '''
        setMinObjects(self, minimumObjectCount: int)

        Synopsis
        -----
        Specifies the lower limit on the number of objects accepted by
        the command.

        Returns:
        -----
        None

        Parameters:
        -----
        minimumObjectCount: int
        	[in] -> the lower limit of the number of objects 


        '''
        pass

    def setMaxObjects(self, maximumObjectCount: int): 
        '''
        setMaxObjects(self, maximumObjectCount: int)

        Synopsis
        -----
        Specifies the upper limit on the number of objects accepted by
        the command.

        Returns:
        -----
        None

        Parameters:
        -----
        maximumObjectCount: int
        	[in] -> the upper limit of the number of objects 


        '''
        pass

    def enableQuery(self, supportsQuery: bool): 
        '''
        enableQuery(self, supportsQuery: bool)

        Synopsis
        -----
        Sets whether or not the command supports the query flag ("-q").

        Returns:
        -----
        None

        Parameters:
        -----
        supportsQuery: bool
        	[in] -> if true, the command supports the query flag 


        '''
        pass

    def enableEdit(self, supportsEdit: bool): 
        '''
        enableEdit(self, supportsEdit: bool)

        Synopsis
        -----
        Sets whether or not the command supports the edit flag ("-e").

        Returns:
        -----
        None

        Parameters:
        -----
        supportsEdit: bool
        	[in] -> if true, the command supports the edit flag 


        '''
        pass

    def minObjects(self): 
        '''
        minObjects(self) -> int

        Synopsis
        -----
        Returns the lower limit on the number of objects accepted by the
        command.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def maxObjects(self): 
        '''
        maxObjects(self) -> int

        Synopsis
        -----
        Returns the upper limit on the number of objects accepted by the
        command.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def canQuery(self): 
        '''
        canQuery(self) -> bool

        Synopsis
        -----
        Returns whether or not the command supports the query flag
        ("-q").

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def canEdit(self): 
        '''
        canEdit(self) -> bool

        Synopsis
        -----
        Returns whether or not the command supports the edit flag ("-e").

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MArgType:
    '''Argument types. 
    Non-functional class.  Values for this enum:
    kInvalidArgType
    kNoArg
    kBoolean
    kLong
    kDouble
    kString
    kUnsigned
    kDistance
    kAngle
    kTime
    kSelectionItem
    kLastArgType
    '''

    def __init__(self):
        pass

    def kInvalidArgType(self):
        '''This is an enum of MArgType.
        - Description:  
        - Value: 0
        '''
        pass

    def kNoArg(self):
        '''This is an enum of MArgType.
        - Description:  
        - Value: 1
        '''
        pass

    def kBoolean(self):
        '''This is an enum of MArgType.
        - Description:  
        - Value: 2
        '''
        pass

    def kLong(self):
        '''This is an enum of MArgType.
        - Description:  
        - Value: 3
        '''
        pass

    def kDouble(self):
        '''This is an enum of MArgType.
        - Description:  
        - Value: 4
        '''
        pass

    def kString(self):
        '''This is an enum of MArgType.
        - Description:  
        - Value: 5
        '''
        pass

    def kUnsigned(self):
        '''This is an enum of MArgType.
        - Description:  
        - Value: 6
        '''
        pass

    def kDistance(self):
        '''This is an enum of MArgType.
        - Description:  
        - Value: 7
        '''
        pass

    def kAngle(self):
        '''This is an enum of MArgType.
        - Description:  
        - Value: 8
        '''
        pass

    def kTime(self):
        '''This is an enum of MArgType.
        - Description:  
        - Value: 9
        '''
        pass

    def kSelectionItem(self):
        '''This is an enum of MArgType.
        - Description:  
        - Value: 10
        '''
        pass

    def kLastArgType(self):
        '''This is an enum of MArgType.
        - Description:  
        - Value: 11
        '''
        pass

class MObjectFormat:
    '''Object list types. 
    Non-functional class.  Values for this enum:
    kInvalidObjectFormat
    kNone
    kStringObjects
    kSelectionList
    kLastObjectFormat
    '''

    def __init__(self):
        pass

    def kInvalidObjectFormat(self):
        '''This is an enum of MObjectFormat.
        - Description:  
        - Value: 0
        '''
        pass

    def kNone(self):
        '''This is an enum of MObjectFormat.
        - Description:  
        - Value: 1
        '''
        pass

    def kStringObjects(self):
        '''This is an enum of MObjectFormat.
        - Description:  
        - Value: 2
        '''
        pass

    def kSelectionList(self):
        '''This is an enum of MObjectFormat.
        - Description:  
        - Value: 3
        '''
        pass

    def kLastObjectFormat(self):
        '''This is an enum of MObjectFormat.
        - Description:  
        - Value: 4
        '''
        pass

class MTesselationParams:
    '''Tesselation parameters.
This class provides control over the tesselation operation. This
class is meant to be used in conjunction with the tesselate
method of
MFnNurbsSurface.
The tesselation operation works by building an initial mesh and
then refining that mesh until certain subdivision criteria are
met. This class provides control over both the method of
construction of the initial mesh and also the criteria for
subsequent refinement. The initial tesselation is specified by
the polygon output type, and the isoparm type. The secondary
tesselation (or subdivision) is specified by the tesselation
format.
 The output type can be specified as either
 or
. If triangles are specified then all the polygons in the initial
mesh will be triangles. If quads are specified then whenever
possible the polygons will be quads.
 The isoparm type specifies how the initial mesh is to be built.
 The subdivision criteria for refinement of the initial mesh is
specified as one of three formats;
 If the tesselation format is general then you can choose which
criteria you would like to use in the tesselation. For each
criterion, there is an "use" flag (in other words, is this used?)
together with the data for the criterion.
'''
    def __init__(self):
        pass


    def setFormatType(self, format: MTesselationParams.MTesselationParams): 
        '''
        setFormatType(self, format: MTesselationParams.MTesselationParams)

        Synopsis
        -----
        Sets the tesselation format. The tesselation format is used in
        the secondary tesselation stage to specify the subdivision
        criteria used in refining the initial mesh.

        Returns:
        -----
        None

        Parameters:
        -----
        format: MTesselationParams.MTesselationParams
        	[in] -> the subdivision format. See the class description for list of format types and descriptions. 


        '''
        pass

    def setOutputType(self, outputType: MTesselationParams.MTesselationParams): 
        '''
        setOutputType(self, outputType: MTesselationParams.MTesselationParams)

        Synopsis
        -----
        Specifies the type of polygons in the tesselated object. The
        output type can be specified as either triangles or quads. If
        triangles are specified then all the polygons in the tesselated
        object will be triangles. If quads are specified then whenever
        possible the polygons will be quads.

        Returns:
        -----
        None

        Parameters:
        -----
        outputType: MTesselationParams.MTesselationParams
        	[in] -> the type of polygon in the tesselated object 


        '''
        pass

    def setTriangleCount(self, count: int): 
        '''
        setTriangleCount(self, count: int)

        Synopsis
        -----
        Sets the approximate number of triangles for the tesselated
        object when the format is kTriangleCountFormat.

        Returns:
        -----
        None

        Parameters:
        -----
        count: int
        	[in] -> The approximate number of triangular polygons in the tesselated object 


        '''
        pass

    def setStdChordHeightRatio(self, value: double): 
        '''
        setStdChordHeightRatio(self, value: double)

        Synopsis
        -----
        Sets the chord height ratio which is used when the tesselation
        format is kStandardFitFormat.

        Returns:
        -----
        None

        Parameters:
        -----
        value: double
        	[in] -> the chord height ration value to be set 


        '''
        pass

    def setStdFractionalTolerance(self, value: double): 
        '''
        setStdFractionalTolerance(self, value: double)

        Synopsis
        -----
        Sets the fractional tolerance which is used when the tesselation
        format is kStandardFitFormat. The fractional tolerance is the
        fraction of box diagonal to be used as absolute 3-d fit
        tolerance. Suggested value: 0.01

        Returns:
        -----
        None

        Parameters:
        -----
        value: double
        	[in] -> the fractional tolerance value to be set 


        '''
        pass

    def setStdMinEdgeLength(self, value: double): 
        '''
        setStdMinEdgeLength(self, value: double)

        Synopsis
        -----
        Sets the minimum edge length which is used when the tesselation
        format is kStandardFitFormat. min_edge_fraction Fraction of box
        diagonal to be used as minimum 3-d edge length. Suggested value:
        0.0001

        Returns:
        -----
        None

        Parameters:
        -----
        value: double
        	[in] -> the minimum edge length to be set 


        '''
        pass

    def setSubdivisionFlag(self, subType: MTesselationParams.MTesselationParams,
                        use: bool): 
        '''
        setSubdivisionFlag(self, subType: MTesselationParams.MTesselationParams,
                        use: bool)

        Synopsis
        -----
        Sets the types of subdivision used when the tesselation format is
        general. This method allows you to set the types of subdivision
        to be performed after the initial mesh is created. The use flag
        specifies whether to use the given subdivision type in the
        secondary tesselation.

        Returns:
        -----
        None

        Parameters:
        -----
        subType: MTesselationParams.MTesselationParams
        	[in] -> the subdivision type to be specified 

        use: bool
        	[in] -> specifies whether to use subType subdivision 


        '''
        pass

    def setFitTolerance(self, value: double): 
        '''
        setFitTolerance(self, value: double)

        Synopsis
        -----
        Sets the absolute fit tolerance. This value is used when the
        subdivision criteria kUseFractionalTolerance has been set.NOTE:
        The maya renderer uses this subdivision criteria for chord
        height.

        Returns:
        -----
        None

        Parameters:
        -----
        value: double
        	[in] -> the new absolute fit tolerance value to be set 


        '''
        pass

    def setChordHeightRatio(self, value: double): 
        '''
        setChordHeightRatio(self, value: double)

        Synopsis
        -----
        Sets the chord height ratio. This value is used when the
        subdivision criteria kUseChordHeightRatio has been set.NOTE: The
        maya renderer uses relative fit tolerance for the chord height
        ration subdivision criteria.

        Returns:
        -----
        None

        Parameters:
        -----
        value: double
        	[in] -> the new chord height ratio value to be set 


        '''
        pass

    def setMinEdgeLength(self, value: double): 
        '''
        setMinEdgeLength(self, value: double)

        Synopsis
        -----
        Sets the minimum edge length. This value is used when the
        subdivision criteria kUseMinEdgeLength has been set.

        Returns:
        -----
        None

        Parameters:
        -----
        value: double
        	[in] -> the new minimum edge length value to be set 


        '''
        pass

    def setMaxEdgeLength(self, value: double): 
        '''
        setMaxEdgeLength(self, value: double)

        Synopsis
        -----
        Sets the maximum edge length. This value is used when the
        subdivision criteria kUseMaxEdgeLength has been set.

        Returns:
        -----
        None

        Parameters:
        -----
        value: double
        	[in] -> the new maximum edge length value to be set 


        '''
        pass

    def setMaxNumberPolys(self, value: int): 
        '''
        setMaxNumberPolys(self, value: int)

        Synopsis
        -----
        Sets the maximum number of polygons. This value is used when the
        subdivision criteria kUseMaxNumberPolys has been set.

        Returns:
        -----
        None

        Parameters:
        -----
        value: int
        	[in] -> the new maximum number of polygons value to be set 


        '''
        pass

    def setMaxSubdivisionLevel(self, value: double): 
        '''
        setMaxSubdivisionLevel(self, value: double)

        Synopsis
        -----
        Sets the maximum subdivision level. This value is used when the
        subdivision criteria kUseMaxSubdivisionLevel has been set.

        Returns:
        -----
        None

        Parameters:
        -----
        value: double
        	[in] -> the new maximum subdivision level value to be set 


        '''
        pass

    def setMinScreenSize(self, x: double,
                        y: double): 
        '''
        setMinScreenSize(self, x: double,
                        y: double)

        Synopsis
        -----
        If polygons are smaller than the specified screen size then the
        subdivision will not proceed. These values are used when the
        subdivision criteria kUseMinScreenSize has been set.

        Returns:
        -----
        None

        Parameters:
        -----
        x: double
        	[in] -> the width value to compare against 

        y: double
        	[in] -> the height value to compare against 


        '''
        pass

    def setWorldspaceToScreenTransform(self, value: MMatrix): 
        '''
        setWorldspaceToScreenTransform(self, value: MMatrix)

        Synopsis
        -----
        The transformation matrix used in the minimum screen size test
        for subdivision. This value is used when the subdivision criteria
        kUseMinScreenSize has been set.

        Returns:
        -----
        None

        Parameters:
        -----
        value: MMatrix
        	[in] -> The world-space transformation matrix 


        '''
        pass

    def setMaxUVRectangleSize(self, u: double,
                        v: double): 
        '''
        setMaxUVRectangleSize(self, u: double,
                        v: double)

        Synopsis
        -----
        Sets the maximum polygon size in uv-space for secondary
        tesselation. Polygons will be greater than the specified size.

        Returns:
        -----
        None

        Parameters:
        -----
        u: double
        	[in] -> horizontal screen space size 

        v: double
        	[in] -> vertical screen space size 


        '''
        pass

    def setRelativeFitTolerance(self, value: double): 
        '''
        setRelativeFitTolerance(self, value: double)

        Synopsis
        -----
        Sets the relative fit tolerance. This value is used when the
        subdivision criteria kUseRelativeTolerance has been set.NOTE: The
        maya renderer uses this subdivision criteria for chord height
        ratio. To match the value that the render tesselator uses, use
        1.0 - value.

        Returns:
        -----
        None

        Parameters:
        -----
        value: double
        	[in] -> the new relative fit tolerance value to be set 


        '''
        pass

    def setEdgeSmoothFactor(self, smoothness: double): 
        '''
        setEdgeSmoothFactor(self, smoothness: double)

        Synopsis
        -----
        Sets the edge smoothness factor used for the Edge Smooth
        secondary tesselation criteria. The value should be 0 (not
        smooth) to 1 (very smooth).NOTE: the maya renderer uses a value
        of 0.95 as the edge smoothness factor.

        Returns:
        -----
        None

        Parameters:
        -----
        smoothness: double
        	[in] -> a factor from 0(not smooth) to 1(very smooth) indicating nurbs-edge smoothness 


        '''
        pass

    def set3DDelta(self, delta: double): 
        '''
        set3DDelta(self, delta: double)

        Synopsis
        -----
        Sets the fraction of the box diagonal to be used as 3-d spacing
        for u- and v-isoparams on face/surface to make up the initial
        grid for the mesh. This is used when the tesselation format is
        kStandardFitFormat.NOTE: the maya renderer uses a default value
        of 0.1 for this value.

        Returns:
        -----
        None

        Parameters:
        -----
        delta: double
        	[in] -> the fractional spacing factor, a value between 0 and 1 


        '''
        pass

    def setUIsoparmType(self, uValue: MTesselationParams.IsoparmType): 
        '''
        setUIsoparmType(self, uValue: MTesselationParams.IsoparmType)

        Synopsis
        -----
        Sets the u-isoparm type to be used in the initial tesselation.

        Returns:
        -----
        None

        Parameters:
        -----
        uValue: MTesselationParams.IsoparmType
        	[in] -> the u-isoparm type 


        '''
        pass

    def setVIsoparmType(self, vValue: MTesselationParams.IsoparmType): 
        '''
        setVIsoparmType(self, vValue: MTesselationParams.IsoparmType)

        Synopsis
        -----
        Sets the v-isoparm type to be used in the initial tesselation.

        Returns:
        -----
        None

        Parameters:
        -----
        vValue: MTesselationParams.IsoparmType
        	[in] -> the v-isoparm type 


        '''
        pass

    def setUNumber(self, count: int): 
        '''
        setUNumber(self, count: int)

        Synopsis
        -----
        This is the number of u isoparms used in the initial tesselation.
        This value is only used for kSurface3DEquiSpaced,
        kSurfaceEquiSpaced, and kSpanEquiSpaced isoparm types.Note that
        in the resultant tessellation, any duplicate vertices and edges
        (eg at periodic boundaries) will be replaced with shared common
        vertices and edges.

        Returns:
        -----
        None

        Parameters:
        -----
        count: int
        	[in] -> the number of u isoparms 


        '''
        pass

    def setVNumber(self, count: int): 
        '''
        setVNumber(self, count: int)

        Synopsis
        -----
        This is the number of v isoparms used in the initial tesselation.
        This value is only used for kSurface3DEquiSpaced,
        kSurfaceEquiSpaced, and kSpanEquiSpaced isoparm types.Note that
        in the resultant tessellation, any duplicate vertices and edges
        (eg at periodic boundaries) will be replaced with shared common
        vertices and edges.

        Returns:
        -----
        None

        Parameters:
        -----
        count: int
        	[in] -> the number of v isoparms 


        '''
        pass

    def setBoundingBoxDiagonal(self, distance: double): 
        '''
        setBoundingBoxDiagonal(self, distance: double)

        Synopsis
        -----
        Sets the diagonal distance of the bounding box of the surface.

        Returns:
        -----
        None

        Parameters:
        -----
        distance: double
        	[in] -> the diagonal bounding box distance 


        '''
        pass

    def setUDistanceFraction(self, value: double): 
        '''
        setUDistanceFraction(self, value: double)

        Synopsis
        -----
        Sets the fraction of the 3D surface bounding box diagonal for the
        kSurface3DDistance isoparm type. The value is 0.0 for other
        types.

        Returns:
        -----
        None

        Parameters:
        -----
        value: double
        	[in] -> the bounding box distance fraction to set 


        '''
        pass

    def setVDistanceFraction(self, value: double): 
        '''
        setVDistanceFraction(self, value: double)

        Synopsis
        -----
        Sets the fraction of the 3D surface bounding box diagonal for the
        kSurface3DDistance isoparm type. The value is 0.0 for other
        types.

        Returns:
        -----
        None

        Parameters:
        -----
        value: double
        	[in] -> the bounding box distance fraction to set 


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class TessFormat:
    '''Tesselation formats. 
    Non-functional class.  Values for this enum:
    kTriangleCountFormat
    kStandardFitFormat
    kGeneralFormat
    '''

    def __init__(self):
        pass

    def kTriangleCountFormat(self):
        '''This is an enum of TessFormat.
        - Description:  
        - Value: 0
        '''
        pass

    def kStandardFitFormat(self):
        '''This is an enum of TessFormat.
        - Description:  
        - Value: 1
        '''
        pass

    def kGeneralFormat(self):
        '''This is an enum of TessFormat.
        - Description:  
        - Value: 2
        '''
        pass

class PolyType:
    '''Types of polygons to use in the result. 
    Non-functional class.  Values for this enum:
    kTriangles
    kQuads
    '''

    def __init__(self):
        pass

    def kTriangles(self):
        '''This is an enum of PolyType.
        - Description:  
        - Value: 0
        '''
        pass

    def kQuads(self):
        '''This is an enum of PolyType.
        - Description:  
        - Value: 1
        '''
        pass

class IsoparmType:
    '''Isoparm types. 
    Non-functional class.  Values for this enum:
    kSurface3DDistance
    kSurface3DEquiSpaced
    kSurfaceEquiSpaced
    kSpanEquiSpaced
    '''

    def __init__(self):
        pass

    def kSurface3DDistance(self):
        '''This is an enum of IsoparmType.
        - Description:  
        - Value: 0
        '''
        pass

    def kSurface3DEquiSpaced(self):
        '''This is an enum of IsoparmType.
        - Description:  
        - Value: 1
        '''
        pass

    def kSurfaceEquiSpaced(self):
        '''This is an enum of IsoparmType.
        - Description:  
        - Value: 2
        '''
        pass

    def kSpanEquiSpaced(self):
        '''This is an enum of IsoparmType.
        - Description:  
        - Value: 3
        '''
        pass

class SubdivisionType:
    '''Subdivision flags. 
    Non-functional class.  Values for this enum:
    kUseFractionalTolerance
    kUseChordHeightRatio
    kUseMinEdgeLength
    kUseMaxEdgeLength
    kUseMaxNumberPolys
    kUseMaxSubdivisionLevel
    kUseMinScreenSize
    kUseMaxUVRectangleSize
    kUseTriangleEdgeSwapping
    kUseRelativeTolerance
    kUseEdgeSmooth
    kLastFlag
    '''

    def __init__(self):
        pass

    def kUseFractionalTolerance(self):
        '''This is an enum of SubdivisionType.
        - Description:  
        - Value: 0
        '''
        pass

    def kUseChordHeightRatio(self):
        '''This is an enum of SubdivisionType.
        - Description:  
        - Value: 1
        '''
        pass

    def kUseMinEdgeLength(self):
        '''This is an enum of SubdivisionType.
        - Description:  
        - Value: 2
        '''
        pass

    def kUseMaxEdgeLength(self):
        '''This is an enum of SubdivisionType.
        - Description:  
        - Value: 3
        '''
        pass

    def kUseMaxNumberPolys(self):
        '''This is an enum of SubdivisionType.
        - Description:  
        - Value: 4
        '''
        pass

    def kUseMaxSubdivisionLevel(self):
        '''This is an enum of SubdivisionType.
        - Description:  
        - Value: 5
        '''
        pass

    def kUseMinScreenSize(self):
        '''This is an enum of SubdivisionType.
        - Description:  
        - Value: 6
        '''
        pass

    def kUseMaxUVRectangleSize(self):
        '''This is an enum of SubdivisionType.
        - Description:  
        - Value: 7
        '''
        pass

    def kUseTriangleEdgeSwapping(self):
        '''This is an enum of SubdivisionType.
        - Description:  
        - Value: 8
        '''
        pass

    def kUseRelativeTolerance(self):
        '''This is an enum of SubdivisionType.
        - Description:  
        - Value: 9
        '''
        pass

    def kUseEdgeSmooth(self):
        '''This is an enum of SubdivisionType.
        - Description:  
        - Value: 10
        '''
        pass

    def kLastFlag(self):
        '''This is an enum of SubdivisionType.
        - Description:  
        - Value: 11
        '''
        pass

class MTime:
    '''Set and retrieve animation time values in various unit systems.
The
MTime class provides a fundamental type for the Maya API to hold and
manipulate animation timing information in various unit systems.
All API methods that require or return timing information do so
through variables of this type.
If one desires to manipulate time in such a way that integer
changes in an
MTime instance result in integer changes in the
 displayed by the timeslider, then an
MTime instance should be created that uses
 units. This can be done either by using the default constructor,
or by passing the return value of the static method
 to the normal constructor. Once such an
MTime instance is created, its value will be equivalent to a
 on the timeslider.
It should be noted that while the timeslider displays
, a seemingly unitless value, Maya internally is operating based
on the desired
 (one of those specified by the
MTime::Unit enum. It is necessary for the API programmer to be aware of this
as
MTime instances are
 unitless and allow the manipulation of time in any desired
units.
'''
    def __init__(self):
        pass


    def unit(self): 
        '''
        unit(self) -> MTime.MTime

        Synopsis
        -----
        Returns the current units in effect for this instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def value(self): 
        '''
        value(self) -> double

        Synopsis
        -----
        Returns the current time value in the units that are currently in
        effect for this instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setUnit(self, newUnit: MTime.MTime): 
        '''
        setUnit(self, newUnit: MTime.MTime)

        Synopsis
        -----
        Set the current units in effect on this MTime instance. Note that
        this method only changes the current units in the instance, it
        does not affect the value. So, calls to the value method before
        and after a call to setUnit will return the same number, however,
        the interpretation of that number will be different due to the
        change in unit systems.

        Returns:
        -----
        None

        Parameters:
        -----
        newUnit: MTime.MTime
        	[in] -> an element of the 


        '''
        pass

    def setValue(self, newValue: double): 
        '''
        setValue(self, newValue: double)

        Synopsis
        -----
        Set the current time value in the current units for this
        instance.

        Returns:
        -----
        None

        Parameters:
        -----
        newValue: double
        	[in] -> The new time value.


        '''
        pass

    def as_func(self, newUnit: MTime.MTime): 
        '''
        as_func(self, newUnit: MTime.MTime) -> double

        Synopsis
        -----
        Returns the current time value in the given units. This does not
        affect the current units for the instance.

        Returns: 
        ----- 
        The current time value in the given units

        Parameters:
        -----
        newUnit: MTime.MTime
        	[in] -> an element of the 


        '''
        pass

    def asUnits(self, newUnit: MTime.MTime): 
        '''
        asUnits(self, newUnit: MTime.MTime) -> double

        Synopsis
        -----
        Returns the current time value in the given units. This does not
        affect the current units for the instance.

        Returns: 
        ----- 
        The current time value in the given units

        Parameters:
        -----
        newUnit: MTime.MTime
        	[in] -> an element of the 


        '''
        pass

    def uiUnit(self): 
        '''
        uiUnit(self) -> MTime.MTime

        Synopsis
        -----
        Returns the Working Units (or UI units) chosen in the settings of
        the prefs window. Maya's timeslider displays frames in these
        units.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setUIUnit(self, newUnit: MTime.MTime): 
        '''
        setUIUnit(self, newUnit: MTime.MTime)

        Synopsis
        -----
        Set the unit system to be used by the user in the UI. After the
        successful completion of this method, Maya's timeslider will be
        displaying frames in the specified units.

        Returns:
        -----
        None

        Parameters:
        -----
        newUnit: MTime.MTime
        	[in] -> an element of the 


        '''
        pass

    def __eq__(self, rhs: MTime): 
        '''
        __eq__(self, rhs: MTime) -> bool

        Synopsis
        -----
        Equality operator.

        Returns:
        -----
        None

        Parameters:
        -----
        rhs: MTime
        	[in] -> Right operand. 


        '''
        pass

    def __neq__(self, rhs: MTime): 
        '''
        __neq__(self, rhs: MTime) -> bool

        Synopsis
        -----
        InEquality operator.

        Returns:
        -----
        None

        Parameters:
        -----
        rhs: MTime
        	[in] -> Right operand. 


        '''
        pass

    @overload
    def __add__(self, rhs: MTime): 
        '''
        __add__(self, rhs: MTime) -> MTime

        Synopsis
        -----
        Addition with another MTime. The value of the MTime on the right
        is converted to the units of the MTime on the left. The two
        values are added together and returned in a new MTime. Neither of
        the operands is changed.

        Returns:
        -----
        None

        Parameters:
        -----
        rhs: MTime
        	[in] -> Right operand. 


        '''
        pass

    @overload
    def __radd__(self, rhs: MTime): 
        '''
        __radd__(self, rhs: MTime) -> MTime

        Synopsis
        -----
        In-place addition with another MTime. The value of the MTime on
        the right is converted to the units of the MTime on the left and
        added to it, leaving the result in the MTime on the left.

        Returns:
        -----
        None

        Parameters:
        -----
        rhs: MTime
        	[in] -> Right operand. 


        '''
        pass

    @overload
    def __add__(self, rhs: double): 
        '''
        __add__(self, rhs: double) -> MTime

        Synopsis
        -----
        Addition with a double. The double is interpreted as a number of
        frames in the units of the MTime instance to the left of the +
        operator. Thus, to increase time by five frames in the current
        units, add 5 to the instance.The result is returned in a new
        MTime. The MTime on the left is not modified.

        Returns:
        -----
        None

        Parameters:
        -----
        rhs: double
        	[in] -> Right operand. 


        '''
        pass

    @overload
    def __radd__(self, rhs: double): 
        '''
        __radd__(self, rhs: double) -> MTime

        Synopsis
        -----
        In-place addition with a double. The double is interpreted as a
        number of frames in the units of the MTime instance. Thus, to
        increase time by five frames in the current units, add 5 to the
        instance.The result is placed into the MTime on the left.

        Returns:
        -----
        None

        Parameters:
        -----
        rhs: double
        	[in] -> Right operand. 


        '''
        pass

    @overload
    def __sub__(self, rhs: MTime): 
        '''
        __sub__(self, rhs: MTime) -> MTime

        Synopsis
        -----
        Subtraction of another MTime. The MTime on the right is converted
        to the units of the MTime on the left and subtracted from the
        left's value. The result is returned in a new MTime. Neither of
        the two operands is modified.

        Returns:
        -----
        None

        Parameters:
        -----
        rhs: MTime
        	[in] -> Right operand. 


        '''
        pass

    @overload
    def __rsub__(self, rhs: MTime): 
        '''
        __rsub__(self, rhs: MTime) -> MTime

        Synopsis
        -----
        In-place subtraction of another MTime. The MTime on the right is
        converted to the units of the MTime on the left and subtracted
        from it. The result is placed in the MTime on the left.

        Returns:
        -----
        None

        Parameters:
        -----
        rhs: MTime
        	[in] -> Right operand. 


        '''
        pass

    @overload
    def __sub__(self, rhs: double): 
        '''
        __sub__(self, rhs: double) -> MTime

        Synopsis
        -----
        Subtraction of a double. The double is interpreted as a number of
        frames in the units of the MTime instance to the left of the -
        operator. Thus, to decrease time by five frames in the current
        units, subtract 5 from the instance.The result is returned in a
        new MTime. The MTime on the left is not modified.

        Returns:
        -----
        None

        Parameters:
        -----
        rhs: double
        	[in] -> Right operand. 


        '''
        pass

    @overload
    def __rsub__(self, rhs: double): 
        '''
        __rsub__(self, rhs: double) -> MTime

        Synopsis
        -----
        In-place Subtraction of a double. The double is interpreted as a
        number of frames in the units of the MTime instance. Thus, to
        decrease time by five frames in the current units, subtract 5
        from the instance.The result is placed into the MTime on the
        left.

        Returns:
        -----
        None

        Parameters:
        -----
        rhs: double
        	[in] -> Right operand. 


        '''
        pass

    def __div__(self, rhs: double): 
        '''
        __div__(self, rhs: double) -> MTime

        Synopsis
        -----
        Division by a scalar operator. Divide the instance to the left of
        the / operator by the given double, and assign the result to a
        new MTime instance.

        Returns:
        -----
        None

        Parameters:
        -----
        rhs: double
        	[in] -> the scalar to divide by. 


        '''
        pass

    def __rdiv__(self, rhs: double): 
        '''
        __rdiv__(self, rhs: double) -> MTime

        Synopsis
        -----
        In place division by a scalar operator. Divide the current
        instance by the given double.

        Returns:
        -----
        None

        Parameters:
        -----
        rhs: double
        	[in] -> the scalar to multiply by. 


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def ticksPerSecond(self): 
        '''
        ticksPerSecond(self) -> MTime.MTime

        Synopsis
        -----
        Returns the number of ticks per second, the smallest unit of time
        available.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class Unit:
    '''Time units. 
    Non-functional class.  Values for this enum:
    kInvalid
    kHours
    kMinutes
    kSeconds
    kMilliseconds
    kGames
    k15FPS
    kFilm
    k24FPS
    kPALFrame
    k25FPS
    kNTSCFrame
    k30FPS
    kShowScan
    k48FPS
    kPALField
    k50FPS
    kNTSCField
    k60FPS
    k2FPS
    k3FPS
    k4FPS
    k5FPS
    k6FPS
    k8FPS
    k10FPS
    k12FPS
    k16FPS
    k20FPS
    k40FPS
    k75FPS
    k80FPS
    k100FPS
    k120FPS
    k125FPS
    k150FPS
    k200FPS
    k240FPS
    k250FPS
    k300FPS
    k375FPS
    k400FPS
    k500FPS
    k600FPS
    k750FPS
    k1200FPS
    k1500FPS
    k2000FPS
    k3000FPS
    k6000FPS
    k23_976FPS
    k29_97FPS
    k29_97DF
    k47_952FPS
    k59_94FPS
    k44100FPS
    k48000FPS
    k90FPS
    k119_88FPS
    kUserDef
    kLast
    '''

    def __init__(self):
        pass

    def kInvalid(self):
        '''This is an enum of Unit.
        - Description: Invalid value. 
        - Value: 0
        '''
        pass

    def kHours(self):
        '''This is an enum of Unit.
        - Description: 3600 seconds 
        - Value: 1
        '''
        pass

    def kMinutes(self):
        '''This is an enum of Unit.
        - Description: 60 seconds 
        - Value: 2
        '''
        pass

    def kSeconds(self):
        '''This is an enum of Unit.
        - Description: 1 second 
        - Value: 3
        '''
        pass

    def kMilliseconds(self):
        '''This is an enum of Unit.
        - Description: 1/1000 of a second 
        - Value: 4
        '''
        pass

    def kGames(self):
        '''This is an enum of Unit.
        - Description: Deprecated:Use k15FPS instead. 
        - Value: 5
        '''
        pass

    def k15FPS(self):
        '''This is an enum of Unit.
        - Description: 15 frames per second 
        - Value: 5
        '''
        pass

    def kFilm(self):
        '''This is an enum of Unit.
        - Description: Deprecated:Use k24FPS instead. 
        - Value: 6
        '''
        pass

    def k24FPS(self):
        '''This is an enum of Unit.
        - Description: 24 frames per second 
        - Value: 6
        '''
        pass

    def kPALFrame(self):
        '''This is an enum of Unit.
        - Description: Deprecated:Use k25FPS instead. 
        - Value: 7
        '''
        pass

    def k25FPS(self):
        '''This is an enum of Unit.
        - Description: 25 frames per second 
        - Value: 7
        '''
        pass

    def kNTSCFrame(self):
        '''This is an enum of Unit.
        - Description: Deprecated:Use k30FPS instead. 
        - Value: 8
        '''
        pass

    def k30FPS(self):
        '''This is an enum of Unit.
        - Description: 30 frames per second 
        - Value: 8
        '''
        pass

    def kShowScan(self):
        '''This is an enum of Unit.
        - Description: Deprecated:Use k48FPS instead. 
        - Value: 9
        '''
        pass

    def k48FPS(self):
        '''This is an enum of Unit.
        - Description: twice the speed of film (48 frames per second) 
        - Value: 9
        '''
        pass

    def kPALField(self):
        '''This is an enum of Unit.
        - Description: Deprecated:Use k50FPS instead. 
        - Value: 10
        '''
        pass

    def k50FPS(self):
        '''This is an enum of Unit.
        - Description: twice the speed of PAL (50 frames per second) 
        - Value: 10
        '''
        pass

    def kNTSCField(self):
        '''This is an enum of Unit.
        - Description: Deprecated:Use k60FPS instead. 
        - Value: 11
        '''
        pass

    def k60FPS(self):
        '''This is an enum of Unit.
        - Description: twice the speed of NTSC (60 frames per second) 
        - Value: 11
        '''
        pass

    def k2FPS(self):
        '''This is an enum of Unit.
        - Description: 2 frames per second 
        - Value: 12
        '''
        pass

    def k3FPS(self):
        '''This is an enum of Unit.
        - Description: 3 frames per second 
        - Value: 13
        '''
        pass

    def k4FPS(self):
        '''This is an enum of Unit.
        - Description: 4 frames per second 
        - Value: 14
        '''
        pass

    def k5FPS(self):
        '''This is an enum of Unit.
        - Description: 5 frames per second 
        - Value: 15
        '''
        pass

    def k6FPS(self):
        '''This is an enum of Unit.
        - Description: 6 frames per second 
        - Value: 16
        '''
        pass

    def k8FPS(self):
        '''This is an enum of Unit.
        - Description: 8 frames per second 
        - Value: 17
        '''
        pass

    def k10FPS(self):
        '''This is an enum of Unit.
        - Description: 10 frames per second 
        - Value: 18
        '''
        pass

    def k12FPS(self):
        '''This is an enum of Unit.
        - Description: 12 frames per second 
        - Value: 19
        '''
        pass

    def k16FPS(self):
        '''This is an enum of Unit.
        - Description: 16 frames per second 
        - Value: 20
        '''
        pass

    def k20FPS(self):
        '''This is an enum of Unit.
        - Description: 20 frames per second 
        - Value: 21
        '''
        pass

    def k40FPS(self):
        '''This is an enum of Unit.
        - Description: 40 frames per second 
        - Value: 22
        '''
        pass

    def k75FPS(self):
        '''This is an enum of Unit.
        - Description: 75 frames per second 
        - Value: 23
        '''
        pass

    def k80FPS(self):
        '''This is an enum of Unit.
        - Description: 80 frames per second 
        - Value: 24
        '''
        pass

    def k100FPS(self):
        '''This is an enum of Unit.
        - Description: 100 frames per second 
        - Value: 25
        '''
        pass

    def k120FPS(self):
        '''This is an enum of Unit.
        - Description: 120 frames per second 
        - Value: 26
        '''
        pass

    def k125FPS(self):
        '''This is an enum of Unit.
        - Description: 125 frames per second 
        - Value: 27
        '''
        pass

    def k150FPS(self):
        '''This is an enum of Unit.
        - Description: 150 frames per second 
        - Value: 28
        '''
        pass

    def k200FPS(self):
        '''This is an enum of Unit.
        - Description: 200 frames per second 
        - Value: 29
        '''
        pass

    def k240FPS(self):
        '''This is an enum of Unit.
        - Description: 240 frames per second 
        - Value: 30
        '''
        pass

    def k250FPS(self):
        '''This is an enum of Unit.
        - Description: 250 frames per second 
        - Value: 31
        '''
        pass

    def k300FPS(self):
        '''This is an enum of Unit.
        - Description: 300 frames per second 
        - Value: 32
        '''
        pass

    def k375FPS(self):
        '''This is an enum of Unit.
        - Description: 375 frames per second 
        - Value: 33
        '''
        pass

    def k400FPS(self):
        '''This is an enum of Unit.
        - Description: 400 frames per second 
        - Value: 34
        '''
        pass

    def k500FPS(self):
        '''This is an enum of Unit.
        - Description: 500 frames per second 
        - Value: 35
        '''
        pass

    def k600FPS(self):
        '''This is an enum of Unit.
        - Description: 600 frames per second 
        - Value: 36
        '''
        pass

    def k750FPS(self):
        '''This is an enum of Unit.
        - Description: 750 frames per second 
        - Value: 37
        '''
        pass

    def k1200FPS(self):
        '''This is an enum of Unit.
        - Description: 1200 frames per second 
        - Value: 38
        '''
        pass

    def k1500FPS(self):
        '''This is an enum of Unit.
        - Description: 1500 frames per second 
        - Value: 39
        '''
        pass

    def k2000FPS(self):
        '''This is an enum of Unit.
        - Description: 2000 frames per second 
        - Value: 40
        '''
        pass

    def k3000FPS(self):
        '''This is an enum of Unit.
        - Description: 3000 frames per second 
        - Value: 41
        '''
        pass

    def k6000FPS(self):
        '''This is an enum of Unit.
        - Description: 6000 frames per second 
        - Value: 42
        '''
        pass

    def k23_976FPS(self):
        '''This is an enum of Unit.
        - Description: 23.976 frames per second 
        - Value: 43
        '''
        pass

    def k29_97FPS(self):
        '''This is an enum of Unit.
        - Description: 29.97 frames per second 
        - Value: 44
        '''
        pass

    def k29_97DF(self):
        '''This is an enum of Unit.
        - Description: 29.97 frames per second with DF TimeCode representation 
        - Value: 45
        '''
        pass

    def k47_952FPS(self):
        '''This is an enum of Unit.
        - Description: 47.952 frames per second 
        - Value: 46
        '''
        pass

    def k59_94FPS(self):
        '''This is an enum of Unit.
        - Description: 59.94 frames per second 
        - Value: 47
        '''
        pass

    def k44100FPS(self):
        '''This is an enum of Unit.
        - Description: 44100 frames per second 
        - Value: 48
        '''
        pass

    def k48000FPS(self):
        '''This is an enum of Unit.
        - Description: 48000 frames per second 
        - Value: 49
        '''
        pass

    def k90FPS(self):
        '''This is an enum of Unit.
        - Description: Introduced in 2019.0 2019.0:Introduced in this version. 90 frames per second 
        - Value: 50
        '''
        pass

    def k119_88FPS(self):
        '''This is an enum of Unit.
        - Description: Introduced in 2024.0 2024.0:Introduced in this version. 119.88 frames per second 
        - Value: 51
        '''
        pass

    def kUserDef(self):
        '''This is an enum of Unit.
        - Description: user defined units (not implemented yet) 
        - Value: 52
        '''
        pass

    def kLast(self):
        '''This is an enum of Unit.
        - Description: Last value, used for counting. 
        - Value: 53
        '''
        pass

class MTimer:
    '''This class works similar to timerX MEL command.
MTimer class provides the functionality for calculating the time
elapsed/consumed in executing a particular portion of the code.
The portion of the code to be timed is embedded inbetween the
calls to'
beginTimer()' and '
endTimer()'. A call to '
elapsedTime()' gives the time spent in executing that portion of the code. The
calculated time in seconds will be with 2 decimal accuracy.
'''
    def __init__(self):
        pass


    def __eq__(self, rhs: MTimer): 
        '''
        __eq__(self, rhs: MTimer) -> bool

        Synopsis
        -----
        Equality operator. Checks whether the start time and end time are
        same.

        Returns:
        -----
        None

        Parameters:
        -----
        rhs: MTimer
        	[in] -> The timer to compare with. 


        '''
        pass

    def __neq__(self, rhs: MTimer): 
        '''
        __neq__(self, rhs: MTimer) -> bool

        Synopsis
        -----
        InEquality operator.

        Returns:
        -----
        None

        Parameters:
        -----
        rhs: MTimer
        	[in] -> The timer to compare with. 


        '''
        pass

class MTimerMessage:
    '''Register callbacks that are based on a fixed time interval.
This class is used to register callbacks that are called at fixed
time intervals.
To remove a callback use
MMessage::removeCallback.
All callbacks that are registered by a plug-in must be removed by
that plug-in when it is unloaded. Failure to do so will result in
a fatal error.
'''
    def __init__(self):
        pass


    def addTimerCallback(self, period: float,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MTimerMessage.MStatus): 
        '''
        addTimerCallback(self, period: float,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MTimerMessage.MStatus) -> MTimerMessage.OPENMAYA_MAJOR_NAMESPACE_OPENMCallbackId

        Synopsis
        -----
        This method registers a callback which is called repeatedly with
        a specified period of time between calls. Each time the timer
        fires the callback will be placed on the idle queue for execution
        in the next idle cycle. If the timer fires again, before the
        previous invocation has completed execution, the new firing will
        be skipped.If the execution time of the callback exceeds half of
        its period then the next timeout will be skipped to give Maya
        time to process other tasks.The maximum resolution for this
        callback is about 1ms. The response is, however, not guaranteed
        because while multitasking, the OS may delay for an unspecified
        length of time before returning control to Maya.

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        period: float
        	[in] -> the period at which the callback will be executed (Measured in seconds) 

        func: MMessage.MMessage
        	[in] -> the callback function 

        clientData: void
        	[in] -> User defined data that will be passed to the callback function 

        ReturnStatus: MTimerMessage.MStatus
        	[out] -> status code


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MTimeArray:
    '''Array of
MTime data type.
This class implements an array of MTimes. Common convenience
functions are available, and the implementation is compatible
with the internal Maya implementation so that it can be passed
efficiently between plugins and internal maya data structures.
'''
    def __init__(self):
        pass


    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> const MTime&

        Synopsis
        -----
        Index operator. Returns the value of the element at the given
        index. No range checking is done - valid indices are 0 to
        length()-1.

        Returns: 
        ----- 
        A reference to the indicated element

        Parameters:
        -----
        index: int
        	[in] -> the index of the desired element


        '''
        pass

    def set(self, element: MTime,
                        index: int): 
        '''
        set(self, element: MTime,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated MTime
        value.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MTime
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    def setLength(self, length: int): 
        '''
        setLength(self, length: int)

        Synopsis
        -----
        Set the length of the array. This will grow and shrink the array
        as desired. Elements that are grown have uninitialized values,
        while those which are shrunk will lose the data contained in the
        deleted elements (ie. it will release the memory).

        Returns:
        -----
        None

        Parameters:
        -----
        length: int
        	[in] -> the new size of the array 


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Returns the number of elements in the instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Remove the array element at the given index. All array elements
        following the removed element are shifted toward the first
        element.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> index of the element to be removed


        '''
        pass

    def insert(self, element: MTime,
                        index: int): 
        '''
        insert(self, element: MTime,
                        index: int)

        Synopsis
        -----
        Inserts a new value into the array at the given index. The
        initial element at that index, and all following elements, are
        shifted towards the last. If the array cannot be expanded in size
        by 1 element, then the insert will fail and the existing array
        will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MTime
        	[in] -> the new value to insert into the array 

        index: int
        	[in] -> the index of the element to set to the the new value


        '''
        pass

    def append(self, element: MTime): 
        '''
        append(self, element: MTime)

        Synopsis
        -----
        Adds a new element to the end of the array. If the array cannot
        be expanded in size by 1 element, then the append will fail and
        the existing array will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MTime
        	[in] -> the value for the new last element


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clear the contents of the array. After this operation the length
        method will return 0. This does not change the amount of memory
        allocated to the array, only the number of valid elements in it.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setSizeIncrement(self, newIncrement: int): 
        '''
        setSizeIncrement(self, newIncrement: int)

        Synopsis
        -----
        Set the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        newIncrement: int
        	[in] -> the new increment 


        '''
        pass

    def sizeIncrement(self): 
        '''
        sizeIncrement(self) -> int

        Synopsis
        -----
        Return the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MTimeArray.MTimeArray

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MTimeArray.MTimeArray

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MTimeArray.MTimeArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MTimeArray.MTimeArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MTimeArray.MTimeArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MTimeArray.MTimeArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def copy(self, source: MTimeArray): 
        '''
        copy(self, source: MTimeArray)

        Synopsis
        -----
        Copy the contents of the source array to this array.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MTimeArray
        	[in] -> array to copy from


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MTransformationMatrix:
    '''Transformation matrix.
An
MTransformationMatrix allows the manipulation of the individual transformation
components (eg scale, rotation, shear, etc) of a four by four
transformation matrix.
The transformation in the node is represented as a 4x4
transformation matrix. This class allows access to the whole
matrix, or the individual components (eg scale, rotation, shear,
etc) of the transformation. This breakdown provides animators
fine control over the animation of these parameters. Therefore,
it is necessary to describe the order in which these attributes
are applied to build the final matrix attribute.
A transformation matrix is composed of the following components:
Note that the default RotationOrder is kXYZ.
The matrices are post-multiplied in Maya. For example, to
transform a point P from object-space to world-space (P') you
would need to post-multiply by the worldMatrix. (P' = P x WM)
The transformation matrix is then constructed as follows:
where 'x' denotes matrix multiplication and '-1' denotes matrix
inversion
'''
    def __init__(self):
        pass


    @overload
    def asMatrix(self): 
        '''
        asMatrix(self) -> MMatrix

        Synopsis
        -----
        Returns the four by four matrix that describes this
        transformation.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def asMatrix(self, percent: double): 
        '''
        asMatrix(self, percent: double) -> MMatrix

        Synopsis
        -----
        Returns a matrix that represents the specified percentage of this
        transformation matrix.

        Returns: 
        ----- 
        The percentage matrix

        Parameters:
        -----
        percent: double
        	[in] -> percent of the transformation to return


        '''
        pass

    def asMatrixInverse(self): 
        '''
        asMatrixInverse(self) -> MMatrix

        Synopsis
        -----
        Returns the inverse of the four by four matrix that describes
        this transformation.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asScaleMatrix(self): 
        '''
        asScaleMatrix(self) -> MMatrix

        Synopsis
        -----
        Returns scale space matrix. The scale space matrix takes points
        from object space to the space immediately following scale and
        shear transformations.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def asRotateMatrix(self): 
        '''
        asRotateMatrix(self) -> MMatrix

        Synopsis
        -----
        Returns rotate space matrix. The rotate space matrix takes points
        from object space to the space immediately following the
        scale/shear/rotation transformations.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getScale(self, scale: double3,
                        space: MSpace.MSpace): 
        '''
        getScale(self, scale: double3,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Get the scale component of the transformation matrix.

        Returns:
        -----
        None

        Parameters:
        -----
        scale: double3
        	[out] -> storage for the scale component 

        space: MSpace.MSpace
        	[in] -> transform space in which to get the scale


        '''
        pass

    def setScale(self, scale: double3,
                        space: MSpace.MSpace): 
        '''
        setScale(self, scale: double3,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the scale component of the transformation matrix.

        Returns:
        -----
        None

        Parameters:
        -----
        scale: double3
        	[in] -> new scale component 

        space: MSpace.MSpace
        	[in] -> transform space in which to perform the scale


        '''
        pass

    def addScale(self, scale: double3,
                        space: MSpace.MSpace): 
        '''
        addScale(self, scale: double3,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Add to the scale component by scaling relative to the existing
        transformation.

        Returns:
        -----
        None

        Parameters:
        -----
        scale: double3
        	[in] -> relative value to scale by 

        space: MSpace.MSpace
        	[in] -> transform space in which to perform the scale


        '''
        pass

    def rotation(self): 
        '''
        rotation(self) -> MQuaternion

        Synopsis
        -----
        Returns the rotation component of the transformation matrix as a
        quaternion. The rotation is returned in MSpace::kTransform space.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def rotateTo(self, q: MQuaternion): 
        '''
        rotateTo(self, q: MQuaternion) -> MTransformationMatrix

        Synopsis
        -----
        Sets the rotation component of the transformation matrix using a
        quaternion. The rotation is performed in MSpace::kTransform
        space.

        Returns: 
        ----- 
        A reference to the resulting transformation matrix

        Parameters:
        -----
        q: MQuaternion
        	[in] -> the quaternion to which the rotation component of the transformation matrix should be set


        '''
        pass

    @overload
    def rotateBy(self, q: MQuaternion,
                        space: MSpace.MSpace,
                        ReturnStatus: MTransformationMatrix.MStatus): 
        '''
        rotateBy(self, q: MQuaternion,
                        space: MSpace.MSpace,
                        ReturnStatus: MTransformationMatrix.MStatus) -> MTransformationMatrix

        Synopsis
        -----
        Adds to the rotation component of the rotation matrix by rotating
        relative to the existing transformation using a quaternion. The
        only valid transformation spaces for this method are
        MSpace::kTransform and MSpace::kPreTransform/MSpace::kObject. All
        other spaces are treated as being equivalent to
        MSpace::kTransform.

        Returns: 
        ----- 
        A reference to the resulting transformation matrix

        Parameters:
        -----
        q: MQuaternion
        	[in] -> the quaternion that indicates how much the transformation matrix will be rotated by 

        space: MSpace.MSpace
        	[in] -> the space in which the rotation is performed 

        ReturnStatus: MTransformationMatrix.MStatus
        	[out] -> return status


        '''
        pass

    def eulerRotation(self): 
        '''
        eulerRotation(self) -> MEulerRotation

        Synopsis
        -----
        Returns the rotation component of the transformation matrix as an
        euler rotation.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def rotateTo(self, e: MEulerRotation): 
        '''
        rotateTo(self, e: MEulerRotation) -> MTransformationMatrix

        Synopsis
        -----
        Sets the rotation component of the transformation matrix using an
        euler rotation. The rotation is performed in MSpace::kTransform
        space.

        Returns: 
        ----- 
        A reference to the resulting transformation matrix

        Parameters:
        -----
        e: MEulerRotation
        	[in] -> the euler rotation to which the rotation component of the transformation matrix should be set


        '''
        pass

    @overload
    def rotateBy(self, e: MEulerRotation,
                        space: MSpace.MSpace,
                        ReturnStatus: MTransformationMatrix.MStatus): 
        '''
        rotateBy(self, e: MEulerRotation,
                        space: MSpace.MSpace,
                        ReturnStatus: MTransformationMatrix.MStatus) -> MTransformationMatrix

        Synopsis
        -----
        Adds to the rotation component of the rotation matrix by rotating
        relative to the existing transformation using an euler rotation.
        The only valid transformation spaces for this method are
        MSpace::kTransform and MSpace::kPreTransform/MSpace::kObject. All
        other spaces are treated as being equivalent to
        MSpace::kTransform.

        Returns: 
        ----- 
        A reference to the resulting transformation matrix

        Parameters:
        -----
        e: MEulerRotation
        	[in] -> the euler rotation that indicates how much the transformation matrix will be rotated by 

        space: MSpace.MSpace
        	[in] -> the space in which the rotation is performed 

        ReturnStatus: MTransformationMatrix.MStatus
        	[out] -> return status


        '''
        pass

    def getRotationQuaternion(self, x: double,
                        y: double,
                        z: double,
                        w: double): 
        '''
        getRotationQuaternion(self, x: double,
                        y: double,
                        z: double,
                        w: double)

        Synopsis
        -----
        Get the rotation component of the transformation matrix as a
        quaternion. The rotation is retrieved in MSpace::kTransform
        space.

        Returns:
        -----
        None

        Parameters:
        -----
        x: double
        	[out] -> storage for the x component of the quaternion 

        y: double
        	[out] -> storage for the y component of the quaternion 

        z: double
        	[out] -> storage for the z component of the quaternion 

        w: double
        	[out] -> storage for the w component of the quaternion


        '''
        pass

    def setRotationQuaternion(self, x: double,
                        y: double,
                        z: double,
                        w: double): 
        '''
        setRotationQuaternion(self, x: double,
                        y: double,
                        z: double,
                        w: double)

        Synopsis
        -----
        Set the rotation component of the transformation matrix using a
        quaternion. The rotation is set in MSpace::kTransform space.

        Returns:
        -----
        None

        Parameters:
        -----
        x: double
        	[in] -> x component of new quaternion 

        y: double
        	[in] -> y component of new quaternion 

        z: double
        	[in] -> z component of new quaternion 

        w: double
        	[in] -> w component of new quaternion


        '''
        pass

    def addRotationQuaternion(self, x: double,
                        y: double,
                        z: double,
                        w: double,
                        space: MSpace.MSpace): 
        '''
        addRotationQuaternion(self, x: double,
                        y: double,
                        z: double,
                        w: double,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Add to the rotation component by rotating relative to the
        existing transformation. Rotation is a quaternion. The only valid
        transformation spaces for this method are MSpace::kTransform and
        MSpace::kPreTransform. All other spaces are treated as being
        equivalent to MSpace::kTransform.

        Returns:
        -----
        None

        Parameters:
        -----
        x: double
        	[in] -> x component of quaternion 

        y: double
        	[in] -> y component of quaternion 

        z: double
        	[in] -> z component of quaternion 

        w: double
        	[in] -> w component of quaternion 

        space: MSpace.MSpace
        	[in] -> transformation space in which to perform the operation


        '''
        pass

    def getRotation(self, rot: double3,
                        order: MTransformationMatrix.RotationOrder): 
        '''
        getRotation(self, rot: double3,
                        order: MTransformationMatrix.RotationOrder)

        Synopsis
        -----
        Get the rotation component of the transformation matrix in
        radians. The rotation is retrieved in MSpace::kTransform space.

        Returns:
        -----
        None

        Parameters:
        -----
        rot: double3
        	[out] -> storage for the rotation in radians 

        order: MTransformationMatrix.RotationOrder
        	[out] -> storage for the rotation order


        '''
        pass

    def setRotation(self, rot: double3,
                        order: MTransformationMatrix.RotationOrder): 
        '''
        setRotation(self, rot: double3,
                        order: MTransformationMatrix.RotationOrder)

        Synopsis
        -----
        Set the rotation component of the transformation matrix. The
        rotation is set in MSpace::kTransform space.

        Returns:
        -----
        None

        Parameters:
        -----
        rot: double3
        	[in] -> new rotation component in radians 

        order: MTransformationMatrix.RotationOrder
        	[in] -> order in which to apply rotations


        '''
        pass

    def addRotation(self, rot: double3,
                        order: MTransformationMatrix.RotationOrder,
                        space: MSpace.MSpace): 
        '''
        addRotation(self, rot: double3,
                        order: MTransformationMatrix.RotationOrder,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Add to the rotation component by rotating relative to the
        existing transformation. The only valid transformation spaces for
        this method are MSpace::kTransform and MSpace::kPreTransform. All
        other spaces are treated as being equivalent to
        MSpace::kTransform.

        Returns:
        -----
        None

        Parameters:
        -----
        rot: double3
        	[in] -> relative value to rotate by 

        order: MTransformationMatrix.RotationOrder
        	[in] -> order in which to apply the rotation components 

        space: MSpace.MSpace
        	[in] -> transform space in which to perform the rotation


        '''
        pass

    def rotationOrder(self, ReturnStatus: MTransformationMatrix.MStatus): 
        '''
        rotationOrder(self, ReturnStatus: MTransformationMatrix.MStatus) -> MTransformationMatrix.MTransformationMatrix

        Synopsis
        -----
        Returns the rotation order for the transform matrix. That is the
        order in which the Euler angles are applied to create the end
        rotation.

        Returns: 
        ----- 
        Rotation order

        Parameters:
        -----
        ReturnStatus: MTransformationMatrix.MStatus
        	[out] -> return status


        '''
        pass

    def reorderRotation(self, order: MTransformationMatrix.RotationOrder): 
        '''
        reorderRotation(self, order: MTransformationMatrix.RotationOrder)

        Synopsis
        -----
        Reorders the x, y, and z components of the rotation of this
        transform. The overall rotation will remain the same. This
        operation is not unique, so spin information will be lost.

        Returns:
        -----
        None

        Parameters:
        -----
        order: MTransformationMatrix.RotationOrder
        	[in] -> new order of the rotations


        '''
        pass

    def setToRotationAxis(self, axis: MVector,
                        rotation: double): 
        '''
        setToRotationAxis(self, axis: MVector,
                        rotation: double)

        Synopsis
        -----
        Sets the rotation given an axis and a rotation about it.

        Returns:
        -----
        None

        Parameters:
        -----
        axis: MVector
        	[in] -> axis to rotate about 

        rotation: double
        	[in] -> rotation in radians


        '''
        pass

    def rotationOrientation(self): 
        '''
        rotationOrientation(self) -> MQuaternion

        Synopsis
        -----
        Returns the rotation orientation for the transformation matrix.
        The rotation orientation is the rotation that orients the local
        rotation space. The rotation is returned in MSpace::kTransform
        space.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setRotationOrientation(self, q: MQuaternion): 
        '''
        setRotationOrientation(self, q: MQuaternion) -> MTransformationMatrix

        Synopsis
        -----
        Sets the rotation orientation for the transformation matrix. The
        rotation orientation is the rotation that orients the local
        rotation space. The rotation is set in MSpace::kTransform space.

        Returns: 
        ----- 
        Rotation orientation

        Parameters:
        -----
        q: MQuaternion
        	[in] -> Rotation quaternion.


        '''
        pass

    def getTranslation(self, space: MSpace.MSpace,
                        ReturnStatus: MTransformationMatrix.MStatus): 
        '''
        getTranslation(self, space: MSpace.MSpace,
                        ReturnStatus: MTransformationMatrix.MStatus) -> MVector

        Synopsis
        -----
        Returns the translation component of the translation as a vector
        in centimeters.

        Returns: 
        ----- 
        Translation vector in centimeters

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> space in which to perform the translation 

        ReturnStatus: MTransformationMatrix.MStatus
        	[out] -> return status


        '''
        pass

    def setTranslation(self, vector: MVector,
                        space: MSpace.MSpace): 
        '''
        setTranslation(self, vector: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the translation component of the transformation matrix in
        centimeters.

        Returns:
        -----
        None

        Parameters:
        -----
        vector: MVector
        	[in] -> new translation component in centimeters. 

        space: MSpace.MSpace
        	[in] -> transform space in which to perform the translation


        '''
        pass

    def addTranslation(self, vector: MVector,
                        space: MSpace.MSpace): 
        '''
        addTranslation(self, vector: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Add to the translation component by translating relative to the
        existing transformation.

        Returns:
        -----
        None

        Parameters:
        -----
        vector: MVector
        	[in] -> relative value to translate by 

        space: MSpace.MSpace
        	[in] -> transform space in which to perform the scale


        '''
        pass

    def setShear(self, shear: double3,
                        space: MSpace.MSpace): 
        '''
        setShear(self, shear: double3,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the shear component of the transformation matrix. The shear
        values represent (xy, xz, yx).

        Returns:
        -----
        None

        Parameters:
        -----
        shear: double3
        	[in] -> new shear component 

        space: MSpace.MSpace
        	[in] -> transform space in which to perform the shear


        '''
        pass

    def getShear(self, shear: double3,
                        space: MSpace.MSpace): 
        '''
        getShear(self, shear: double3,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Get the shear component of the transformation matrix.

        Returns:
        -----
        None

        Parameters:
        -----
        shear: double3
        	[out] -> Shear. 

        space: MSpace.MSpace
        	[in] -> Transform space in which to get the shear.


        '''
        pass

    def addShear(self, shear: double3,
                        space: MSpace.MSpace): 
        '''
        addShear(self, shear: double3,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Add to the shear component by shearing relative to the existing
        transformation.

        Returns:
        -----
        None

        Parameters:
        -----
        shear: double3
        	[in] -> relative value to shear by 

        space: MSpace.MSpace
        	[in] -> transform space in which to perform the shear


        '''
        pass

    def scalePivot(self, space: MSpace.MSpace,
                        ReturnStatus: MTransformationMatrix.MStatus): 
        '''
        scalePivot(self, space: MSpace.MSpace,
                        ReturnStatus: MTransformationMatrix.MStatus) -> MPoint

        Synopsis
        -----
        Returns the pivot around which the scale is applied.

        Returns: 
        ----- 
        Scale pivot point

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> space in which to get the pivot 

        ReturnStatus: MTransformationMatrix.MStatus
        	[out] -> return status


        '''
        pass

    def setScalePivot(self, point: MPoint,
                        space: MSpace.MSpace,
                        balance: bool): 
        '''
        setScalePivot(self, point: MPoint,
                        space: MSpace.MSpace,
                        balance: bool)

        Synopsis
        -----
        Set the pivot around which the scale is applied. If balance if
        true, then the overall transformation matrix will not change and
        a compensating transformation will be added to the scale
        transformation to achieve this.

        Returns:
        -----
        None

        Parameters:
        -----
        point: MPoint
        	[in] -> new scale pivot 

        space: MSpace.MSpace
        	[in] -> transform space in which to set the scale pivot 

        balance: bool
        	[in] -> whether to balance the matrix


        '''
        pass

    def scalePivotTranslation(self, space: MSpace.MSpace,
                        ReturnStatus: MTransformationMatrix.MStatus): 
        '''
        scalePivotTranslation(self, space: MSpace.MSpace,
                        ReturnStatus: MTransformationMatrix.MStatus) -> MVector

        Synopsis
        -----
        Returns the scale pivot translation. This is the translation that
        is used to compensate for the movement of the scale pivot.

        Returns: 
        ----- 
        Scale pivot translation

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> space in which to get the pivot 

        ReturnStatus: MTransformationMatrix.MStatus
        	[out] -> return status


        '''
        pass

    def setScalePivotTranslation(self, vector: MVector,
                        space: MSpace.MSpace): 
        '''
        setScalePivotTranslation(self, vector: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the pivot translation. This component is used to preserve
        existing scale transformations when moving pivot. This method
        will only be useful to advanced users.

        Returns:
        -----
        None

        Parameters:
        -----
        vector: MVector
        	[in] -> new scale pivot translation 

        space: MSpace.MSpace
        	[in] -> transform space in which to set the scale translation


        '''
        pass

    def rotatePivot(self, space: MSpace.MSpace,
                        ReturnStatus: MTransformationMatrix.MStatus): 
        '''
        rotatePivot(self, space: MSpace.MSpace,
                        ReturnStatus: MTransformationMatrix.MStatus) -> MPoint

        Synopsis
        -----
        Returns the pivot around which the rotation is applied.

        Returns: 
        ----- 
        Rotation pivot point

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> space in which to get the pivot 

        ReturnStatus: MTransformationMatrix.MStatus
        	[out] -> return status


        '''
        pass

    def setRotatePivot(self, point: MPoint,
                        space: MSpace.MSpace,
                        balance: bool): 
        '''
        setRotatePivot(self, point: MPoint,
                        space: MSpace.MSpace,
                        balance: bool)

        Synopsis
        -----
        Set the pivot around which the rotation is applied. If balance if
        true, then the overall transformation matrix will not change and
        a compensating transformation will be added to the rotation
        transformation to achieve this.

        Returns:
        -----
        None

        Parameters:
        -----
        point: MPoint
        	[in] -> new rotation pivot 

        space: MSpace.MSpace
        	[in] -> transform space in which to set the pivot 

        balance: bool
        	[in] -> whether to balance the matrix


        '''
        pass

    def rotatePivotTranslation(self, space: MSpace.MSpace,
                        ReturnStatus: MTransformationMatrix.MStatus): 
        '''
        rotatePivotTranslation(self, space: MSpace.MSpace,
                        ReturnStatus: MTransformationMatrix.MStatus) -> MVector

        Synopsis
        -----
        Returns the rotation pivot translation. This is the translation
        that is used to compensate for the movement of the rotation
        pivot.

        Returns: 
        ----- 
        Scale pivot translation

        Parameters:
        -----
        space: MSpace.MSpace
        	[in] -> space in which to get the pivot translation 

        ReturnStatus: MTransformationMatrix.MStatus
        	[out] -> return status


        '''
        pass

    def setRotatePivotTranslation(self, vector: MVector,
                        space: MSpace.MSpace): 
        '''
        setRotatePivotTranslation(self, vector: MVector,
                        space: MSpace.MSpace)

        Synopsis
        -----
        Set the pivot translation. This component is used to preserve
        existing transformations when moving pivot. This method will only
        be useful to advanced users.

        Returns:
        -----
        None

        Parameters:
        -----
        vector: MVector
        	[in] -> new rotation pivot translation 

        space: MSpace.MSpace
        	[in] -> transform space in which to set the rotation translation


        '''
        pass

    def isEquivalent(self, other: MTransformationMatrix,
                        tol: double): 
        '''
        isEquivalent(self, other: MTransformationMatrix,
                        tol: double) -> bool

        Synopsis
        -----
        Returns true if this transform matrix is equivalent to the one
        passed in within a certain tolerance.

        Returns: 
        ----- 
        True if equivalent

        Parameters:
        -----
        other: MTransformationMatrix
        	[in] -> transform matrix to test against 

        tol: double
        	[in] -> tolerance to test using


        '''
        pass

    def __eq__(self, other: MTransformationMatrix): 
        '''
        __eq__(self, other: MTransformationMatrix) -> bool

        Synopsis
        -----
        Equality operator.

        Returns: 
        ----- 
        True if equal

        Parameters:
        -----
        other: MTransformationMatrix
        	[in] -> transform matrix to test against


        '''
        pass

    def __neq__(self, other: MTransformationMatrix): 
        '''
        __neq__(self, other: MTransformationMatrix) -> bool

        Synopsis
        -----
        Inequality operator.

        Returns: 
        ----- 
        True if not equal

        Parameters:
        -----
        other: MTransformationMatrix
        	[in] -> transform matrix to test against


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class RotationOrder:
    '''Order of rotation. 
    Non-functional class.  Values for this enum:
    kInvalid
    kXYZ
    kYZX
    kZXY
    kXZY
    kYXZ
    kZYX
    kLast
    '''

    def __init__(self):
        pass

    def kInvalid(self):
        '''This is an enum of RotationOrder.
        - Description:  
        - Value: 0
        '''
        pass

    def kXYZ(self):
        '''This is an enum of RotationOrder.
        - Description:  
        - Value: 1
        '''
        pass

    def kYZX(self):
        '''This is an enum of RotationOrder.
        - Description:  
        - Value: 2
        '''
        pass

    def kZXY(self):
        '''This is an enum of RotationOrder.
        - Description:  
        - Value: 3
        '''
        pass

    def kXZY(self):
        '''This is an enum of RotationOrder.
        - Description:  
        - Value: 4
        '''
        pass

    def kYXZ(self):
        '''This is an enum of RotationOrder.
        - Description:  
        - Value: 5
        '''
        pass

    def kZYX(self):
        '''This is an enum of RotationOrder.
        - Description:  
        - Value: 6
        '''
        pass

    def kLast(self):
        '''This is an enum of RotationOrder.
        - Description:  
        - Value: 7
        '''
        pass

class MTrimBoundaryArray:
    '''An array class for trim boundaries.
This class implements an array of
MObjectArray objects. Each
MObjectArray is a collection of curves (edges, in fact) that represent a trim
boundary.
This class owns all of the MObjectArrays in the class. It doesn't
hold a reference to any other
MObjectArray.
'''
    def __init__(self):
        pass


    def reserve(self, reserveLength: int): 
        '''
        reserve(self, reserveLength: int)

        Synopsis
        -----
        This method is used to reserve the capacity of the array.

        Returns:
        -----
        None

        Parameters:
        -----
        reserveLength: int
        	[in] -> the number of items to reserve


        '''
        pass

    def size(self): 
        '''
        size(self) -> int

        Synopsis
        -----
        This method returns the size of the trim boundary array. The size
        and the length are the same.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> const MObjectArray&

        Synopsis
        -----
        The index operator. NOTE: no bounds are checked by this method.

        Returns: 
        ----- 
        The MObjectArray requested

        Parameters:
        -----
        index: int
        	[in] -> value indicating which array to return


        '''
        pass

    def get(self, index: int): 
        '''
        get(self, index: int) -> const MObjectArray&

        Synopsis
        -----
        The method returns the MObjectArray specified by the index. NOTE:
        no bounds are checked by this method.

        Returns: 
        ----- 
        The MObjectArray requested

        Parameters:
        -----
        index: int
        	[in] -> value indicating which array to return


        '''
        pass

    def set(self, boundary: MObjectArray,
                        index: int): 
        '''
        set(self, boundary: MObjectArray,
                        index: int)

        Synopsis
        -----
        This method is used to replace an existing boundary array.

        Returns:
        -----
        None

        Parameters:
        -----
        boundary: MObjectArray
        	[in] -> the boundary object array to set 

        index: int
        	[in] -> the index to place the boundary array at


        '''
        pass

    def insert(self, boundary: MObjectArray,
                        index: int): 
        '''
        insert(self, boundary: MObjectArray,
                        index: int)

        Synopsis
        -----
        This method adds a new boundary into the "index" position.

        Returns:
        -----
        None

        Parameters:
        -----
        boundary: MObjectArray
        	[in] -> the object array to add 

        index: int
        	[in] -> the index to add the boundary array at


        '''
        pass

    def append(self, boundary: MObjectArray): 
        '''
        append(self, boundary: MObjectArray)

        Synopsis
        -----
        Add a new boundary array at the end of the list.

        Returns:
        -----
        None

        Parameters:
        -----
        boundary: MObjectArray
        	[in] -> the boundary array to append


        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        This method removes an existing boundary from the list.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> the index of the array to remove


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        This method clears the trim boundary array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getMergedBoundary(self, index: int,
                        status: MTrimBoundaryArray.MStatus): 
        '''
        getMergedBoundary(self, index: int,
                        status: MTrimBoundaryArray.MStatus) -> MObject

        Synopsis
        -----
        This function create a curve that represent all curves of the
        boundary. The original boundary edges are not changed. Note that
        the resulting curve is not added to the current model but is
        owned by an MObject which is of type kNurbsCurveData.

        Returns: 
        ----- 
        MS::kSuccess if the curve creation worked and MS::kFailure
        otherwise

        Parameters:
        -----
        index: int
        	[in] -> the index to the boundary array that should be used to create the curve 

        status: MTrimBoundaryArray.MStatus
        	[out] -> return status of the method


        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MTrimBoundaryArray.MTrimBoundaryArray

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MTrimBoundaryArray.MTrimBoundaryArray

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MTrimBoundaryArray.MTrimBoundaryArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MTrimBoundaryArray.MTrimBoundaryArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MTrimBoundaryArray.MTrimBoundaryArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MTrimBoundaryArray.MTrimBoundaryArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MTypeId:
    '''Manage Maya Object type identifiers.
In Maya, both intrinsic and user-defined Maya Objects are
registered and recognized by their type identifier or type id.
The basis of the type id system is a tag which is used at run-
time to determine how to create and destroy Maya Objects, and how
they are to be input/output from/to files. These tag-based
identifiers are implemented by the class
MTypeId.
Use the
MTypeId class to create, copy and query Maya Object type identifiers.
It is very important to note that these ids are written into the
Maya binary file format. So, once an id is assigned to a node or
data type it can
 be changed while any existing Maya file contains an instance of
that node or data type. If a change is made, such files will
become unreadable.
Thus, even though we provide a range of reserved ids that you can
use for internal plug-ins, Autodesk highly recommends that you
obtain a globally unique id range (see below) and use ids from
this range for all your plug-ins, even internal ones. This can
prevent significant headaches later if the plans for your plug-
ins change.
There are 2 forms of the constructor for this class that can be
used depending on whether the plug-in id is internal or globally
unique.
For plug-ins that will forever be internal to your site use the
constructor that takes a single unsigned int parameter. The
numeric range 0 - 0x7ffff (524288 ids) has been reserved for such
plug-ins.
The example plug-ins provided with Maya in the plug-in
development kit will use ids in the range 0x80000 - 0xfffff
(524288 ids). If you customize one of these example plug-ins, you
should change the id to avoid future conflicts.
Plug-ins that are intended to be shared between sites will need
to have a globally unique id. The Autodesk Developer Network
(ADN) will provide such id's in blocks of 256. You will be
assigned one or more 24-bit prefixes. Once this has been
obtained, used the
MTypeId constructor that takes 2 unsigned int parameters. The prefix
goes in the first parameter, and you are responsible for managing
the allocation of the 256 ids that go into the second parameter.
'''
    def __init__(self):
        pass


    def __eq__(self, rhs: MTypeId): 
        '''
        __eq__(self, rhs: MTypeId) -> bool

        Synopsis
        -----
        Equivalence operator.

        Returns: 
        ----- 
        True of the two MTypeId hold the same 32-bit binary tag.

        Parameters:
        -----
        rhs: MTypeId
        	[in] -> MTypeId


        '''
        pass

    def __neq__(self, rhs: MTypeId): 
        '''
        __neq__(self, rhs: MTypeId) -> bool

        Synopsis
        -----
        Inequality operator.

        Returns: 
        ----- 
        True of the two MTypeId hold different 32-bit binary tags.

        Parameters:
        -----
        rhs: MTypeId
        	[in] -> MTypeId


        '''
        pass

    def id(self, ReturnStatus: MTypeId.MStatus): 
        '''
        id(self, ReturnStatus: MTypeId.MStatus) -> int

        Synopsis
        -----
        Return the 32 bit id tag contained in the MTypeId instance.

        Returns: 
        ----- 
        The 32-bit id tag contained in this MTypeId instance.

        Parameters:
        -----
        ReturnStatus: MTypeId.MStatus
        	[out] -> MS::kSuccess if success, otherwise MS::kFailure


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MUint64Array:
    '''Array of MUint64 data type.
This class implements an array of MUint64s. Common convenience
functions are available, and the implementation is compatible
with the internal Maya implementation so that it can be passed
efficiently between plugins and internal maya data structures.
'''
    def __init__(self):
        pass


    def set(self, element: MUint64,
                        index: int): 
        '''
        set(self, element: MUint64,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated MUint64
        value. NOTE: This method does not grow the array if the index is
        out of bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MUint64
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    def setLength(self, length: int): 
        '''
        setLength(self, length: int)

        Synopsis
        -----
        Set the length of the array. This will grow and shrink the array
        as desired. Elements that are grown have uninitialized values,
        while those which are shrunk will lose the data contained in the
        deleted elements (ie. it will release the memory).

        Returns:
        -----
        None

        Parameters:
        -----
        length: int
        	[in] -> the new size of the array 


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Returns the number of elements in the instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Remove the array element at the given index. All array elements
        following the removed element are shifted toward the first
        element.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> index of the element to be removed


        '''
        pass

    def insert(self, element: MUint64,
                        index: int): 
        '''
        insert(self, element: MUint64,
                        index: int)

        Synopsis
        -----
        Inserts a new value into the array at the given index. The
        initial element at that index, and all following elements, are
        shifted towards the last. If the array cannot be expanded in size
        by 1 element, then the insert will fail and the existing array
        will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MUint64
        	[in] -> the new value to insert into the array 

        index: int
        	[in] -> the index of the element to set to the the new value


        '''
        pass

    def append(self, element: MUint64): 
        '''
        append(self, element: MUint64)

        Synopsis
        -----
        Adds a new element to the end of the array. If the array cannot
        be expanded in size by 1 element, then the append will fail and
        the existing array will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MUint64
        	[in] -> the value for the new last element


        '''
        pass

    def copy(self, source: MUint64Array): 
        '''
        copy(self, source: MUint64Array)

        Synopsis
        -----
        Copy the contents of the source array to this array.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MUint64Array
        	[in] -> array to copy from


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clear the contents of the array. After this operation the length
        method will return 0. This does not change the amount of memory
        allocated to the array, only the number of valid elements in it.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def get(self, array: MUint64): 
        '''
        get(self, array: MUint64)

        Synopsis
        -----
        Copy the elements of the array into the given C++ array of
        MUint64s. No checking is done to ensure that the destination C++
        array of MUint64s is large enough to hold all the elements of the
        instance.

        Returns:
        -----
        None

        Parameters:
        -----
        array: MUint64
        	[out] -> the array to populate


        '''
        pass

    def setSizeIncrement(self, newIncrement: int): 
        '''
        setSizeIncrement(self, newIncrement: int)

        Synopsis
        -----
        Set the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        newIncrement: int
        	[in] -> the new increment 


        '''
        pass

    def sizeIncrement(self): 
        '''
        sizeIncrement(self) -> int

        Synopsis
        -----
        Return the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MUint64Array.MUint64Array

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MUint64Array.MUint64Array

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MUint64Array.MUint64Array

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MUint64Array.MUint64Array

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MUint64Array.MUint64Array

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MUint64Array.MUint64Array

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MUintArray:
    '''Array of integers data type.
This class implements an array of unsigned integers. Common
convenience functions are available, and the implementation is
compatible with the internal Maya implementation so that it can
be passed efficiently between plugins and internal maya data
structures.
'''
    def __init__(self):
        pass


    def set(self, element: int,
                        index: int): 
        '''
        set(self, element: int,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated value.
        NOTE: This method does not grow the array if the index is out of
        bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        element: int
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    def setLength(self, length: int): 
        '''
        setLength(self, length: int)

        Synopsis
        -----
        Set the length of the array. This will grow and shrink the array
        as desired. Elements that are grown have uninitialized values,
        while those which are shrunk will lose the data contained in the
        deleted elements (ie. it will release the memory).

        Returns:
        -----
        None

        Parameters:
        -----
        length: int
        	[in] -> the new size of the array 


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Returns the number of elements in the instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Remove the array element at the given index. All array elements
        following the removed element are shifted toward the first
        element.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> index of the element to be removed


        '''
        pass

    def insert(self, element: int,
                        index: int): 
        '''
        insert(self, element: int,
                        index: int)

        Synopsis
        -----
        Inserts a new value into the array at the given index. The
        initial element at that index, and all following elements, are
        shifted towards the last. If the array cannot be expanded in size
        by 1 element, then the insert will fail and the existing array
        will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: int
        	[in] -> the new value to insert into the array 

        index: int
        	[in] -> the index of the element to set to the the new value


        '''
        pass

    def append(self, element: int): 
        '''
        append(self, element: int)

        Synopsis
        -----
        Adds a new element to the end of the array. If the array cannot
        be expanded in size by 1 element, then the append will fail and
        the existing array will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: int
        	[in] -> the value for the new last element


        '''
        pass

    def copy(self, source: MUintArray): 
        '''
        copy(self, source: MUintArray)

        Synopsis
        -----
        Copy the contents of the source array to this array.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MUintArray
        	[in] -> array to copy from


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clear the contents of the array. After this operation the length
        method will return 0. This does not change the amount of memory
        allocated to the array, only the number of valid elements in it.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def get(self, array: int): 
        '''
        get(self, array: int)

        Synopsis
        -----
        Copy the elements of the array into the given C++ array of
        unsigned ints. No checking is done to ensure that the destination
        C++ array of ints is large enough to hold all the elements of the
        instance.

        Returns:
        -----
        None

        Parameters:
        -----
        array: int
        	[out] -> the array to populate


        '''
        pass

    def setSizeIncrement(self, newIncrement: int): 
        '''
        setSizeIncrement(self, newIncrement: int)

        Synopsis
        -----
        Set the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        newIncrement: int
        	[in] -> the new increment 


        '''
        pass

    def sizeIncrement(self): 
        '''
        sizeIncrement(self) -> int

        Synopsis
        -----
        Return the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MUintArray.MUintArray

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MUintArray.MUintArray

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MUintArray.MUintArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MUintArray.MUintArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MUintArray.MUintArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MUintArray.MUintArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MUserEventMessage:
    '''User defined Message Types.
This class is used to register user-defined event types, register
callbacks with the user-defined event types, and to post user-
defined messages.
The registerUserEvent and deregisterUserEvent methods allow user
event types to be created and destroyed. User events are
identified by a unique string identifier.
The addCallback method registers a function that will be executed
whenever the specified message occurs. An id is returned and is
used to remove the callback.
The postUserEvent notifies all registered callbacks of the
occurence of the user-defined event.
To remove a callback use
MMessage::removeCallback. All callbacks that are registered by a plug-in must be removed
by that plug-in when it is unloaded. Failure to do so will result
in a fatal error.
'''
    def __init__(self):
        pass


    def registerUserEvent(self, eventName: MString): 
        '''
        registerUserEvent(self, eventName: MString) -> MUserEventMessage.OPENMAYA_MAJOR_NAMESPACE_OPEN MStatus

        Synopsis
        -----
        Adds a new event type with the given string identifier. The
        string identifier can then be used in all other MUserEventMessage
        methods to operate on the new event type.

        Returns: 
        ----- 
        MS::kSuccess Operation succeeded  MS::kInsufficientMemory No
        memory available  MS::kInvalidParameter Empty string passed for
        eventName  MS::kFailure Event type already exists

        Parameters:
        -----
        eventName: MString
        	[in] -> the name of the new event to register. Any non-empty string may be used as an event name.


        '''
        pass

    def isUserEvent(self, eventName: MString): 
        '''
        isUserEvent(self, eventName: MString) -> bool

        Synopsis
        -----
        Checks if an event type exists with the given event name.

        Returns: 
        ----- 
        true Event type exists  false Event type does not exist

        Parameters:
        -----
        eventName: MString
        	[in] -> the event name


        '''
        pass

    def deregisterUserEvent(self, eventName: MString): 
        '''
        deregisterUserEvent(self, eventName: MString)

        Synopsis
        -----
        Removes the event type with the given event name. If callbacks
        have been registered with this event type, they will become
        invalid after a successful call to this method.

        Returns:
        -----
        None

        Parameters:
        -----
        eventName: MString
        	[in] -> the event name


        '''
        pass

    def addUserEventCallback(self, eventName: MString,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MUserEventMessage.MStatus): 
        '''
        addUserEventCallback(self, eventName: MString,
                        func: MMessage.MMessage,
                        clientData: void,
                        ReturnStatus: MUserEventMessage.MStatus) -> MCallbackId

        Synopsis
        -----
        This method registers a callback for user-defined messages. The
        parameter clientData will be passed to callbacks registered for
        this event whenever the event is triggered. To override the data
        that is passed to the callback whenever the event is posted, you
        can supply a clientData pointer to postUserEvent().

        Returns: 
        ----- 
        Identifier used for removing the callback.

        Parameters:
        -----
        eventName: MString
        	[in] -> the event name to register the callback for 

        func: MMessage.MMessage
        	[in] -> the callback function

        clientData: void
        	[in] -> User defined data that will be passed to the callback function 

        ReturnStatus: MUserEventMessage.MStatus
        	[out] -> status code


        '''
        pass

    def postUserEvent(self, eventName: MString,
                        clientData: void): 
        '''
        postUserEvent(self, eventName: MString,
                        clientData: void)

        Synopsis
        -----
        Notifies all callbacks attached to the given event type of the
        occurence of the event. If clientData is specified, this data
        will be passed to all callbacks that receive the event. If
        clientData is NULL (the default), the clientData registered with
        addUserEventCallback will be passed to the callbacks.

        Returns:
        -----
        None

        Parameters:
        -----
        eventName: MString
        	[in] -> the event name 

        clientData: void
        	[in] -> caller-defined data to be passed to the callback


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MUuid:
    '''Class to manipulate UUIDs.
Provides a class to manipulate UUIDs (Universally Unique
Identifiers).
UUIDs (as implemented here) are 128-bit values, used to identify
objects 'practically' uniquely. Their main use in Maya is to
identify DG nodes. Nodes have a UUID which persists even if the
node's name is changed, or its DAG relationship alters, and which
is stored in the Maya scene file.
See
http://en.wikipedia.org/wiki/Universally_unique_identifier'''
    def __init__(self):
        pass


    def __eq__(self, rhs: MUuid): 
        '''
        __eq__(self, rhs: MUuid) -> bool

        Synopsis
        -----
        Equality operator. Compares two MUuid objects to see if they
        contain the same value.

        Returns: 
        ----- 
        true if the two objects are equivalent, false otherwise.

        Parameters:
        -----
        rhs: MUuid
        	[in] -> Right operand. 


        '''
        pass

    def __neq__(self, rhs: MUuid): 
        '''
        __neq__(self, rhs: MUuid) -> bool

        Synopsis
        -----
        Inequality operator. Compares two MUuid objects to see if they
        differ.

        Returns: 
        ----- 
        true if the two objects are different, false otherwise.

        Parameters:
        -----
        rhs: MUuid
        	[in] -> Right operand. 


        '''
        pass

    def get(self, dest: char): 
        '''
        get(self, dest: char)

        Synopsis
        -----
        Gets the UUID as an array of sixteen bytes.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: char
        	[out] -> The array to populate with the UUID value.


        '''
        pass

    def asString(self): 
        '''
        asString(self) -> MString

        Synopsis
        -----
        Gets the UUID as a string.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def copy(self, rhs: MUuid): 
        '''
        copy(self, rhs: MUuid)

        Synopsis
        -----
        Copy method. Assigns the value of one MUuid to another.

        Returns:
        -----
        None

        Parameters:
        -----
        rhs: MUuid
        	[in] -> Existing 


        '''
        pass

    def valid(self): 
        '''
        valid(self) -> bool

        Synopsis
        -----
        Queries whether the UUID is valid.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def generate(self): 
        '''
        generate(self)

        Synopsis
        -----
        Generates a new random UUID and stores it in this class instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MURI:
    '''Manipulating Uniform Resource Identifiers.
The
MURI class implements the W3 URI standard. It can parse and and
construct URIs (Uniform Resource Identifiers). It is based on URI
specification RFC 3986 (Uniform Resource Identifier: Generic
Syntax).
The scheme and path components are required, although the path
may be empty (no characters). When the authority is present, the
path must either be empty or begin with a slash ("/") character.
When the authority is not present, the path cannot begin with two
slash characters ("//").
URI objects are often initialized using URI string values. An
MURI object can be constructed from an
MString value, or set from a string using the
setURI() method.
A URI can also be constructed from its individual components
using methods
setScheme(),
setUserName(),
setPassword(),
setHost(),
setPort(),
setPath(),
addQueryItem() and
setFragment().
Convenience methods such as
setAuthority() and
setUserInfo() are also available to initialize groups of related components.
Methods for configuring the query components of the URI are also
provided: setQueryItems(),
addQueryItem(),
removeQueryItem() and
setQueryDelimiters().
The string representation of the URI object is obtained by
calling
asString(). Individual components of the URI are accessed by calling the
corresponding get methods.
The
MURI can be validated at any point by calling the
isValid() method. In addition, a static method
isValidURI() is available to determine if an
MString represents a valid URI.
'''
    def __init__(self):
        pass


    def __eq__(self, rhs: MURI): 
        '''
        __eq__(self, rhs: MURI) -> bool

        Synopsis
        -----
        Equality operator. Compares two MURI objects to see if they
        contain the same value.

        Returns: 
        ----- 
        true if the two objects are equivalent, false otherwise.

        Parameters:
        -----
        rhs: MURI
        	[in] -> Right operand. 


        '''
        pass

    def __neq__(self, rhs: MURI): 
        '''
        __neq__(self, rhs: MURI) -> bool

        Synopsis
        -----
        Inequality operator. Compares two MURI objects to see if they
        differ.

        Returns: 
        ----- 
        true if the two objects are different, false otherwise.

        Parameters:
        -----
        rhs: MURI
        	[in] -> Right operand. 


        '''
        pass

    def copy(self, other: MURI): 
        '''
        copy(self, other: MURI)

        Synopsis
        -----
        Copy the contents of one URI object to another.

        Returns:
        -----
        None

        Parameters:
        -----
        other: MURI
        	[in] -> The URI object to copy.


        '''
        pass

    def setURI(self, URI: MString): 
        '''
        setURI(self, URI: MString)

        Synopsis
        -----
        Initialize the MURI from a string value. The individual
        components of the URI will be set based on the contents of the
        string.

        Returns:
        -----
        None

        Parameters:
        -----
        URI: MString
        	[in] -> The URI string.


        '''
        pass

    def setScheme(self, scheme: MString): 
        '''
        setScheme(self, scheme: MString)

        Synopsis
        -----
        Sets the scheme component of the URI. The scheme identifies the
        type of the URI. It is the first element of the URI and consists
        of all the characters preceeding the first ':'. The scheme is
        expected to contain only ASCII characters.

        Returns:
        -----
        None

        Parameters:
        -----
        scheme: MString
        	[in] -> The scheme to set


        '''
        pass

    def setPath(self, path: MString): 
        '''
        setPath(self, path: MString)

        Synopsis
        -----
        Sets the path component of the URI. The path can contain both a
        directory and a file name. See also setFileName() and
        setDirectory().

        Returns:
        -----
        None

        Parameters:
        -----
        path: MString
        	[in] -> The path to set


        '''
        pass

    def setFragment(self, fragment: MString): 
        '''
        setFragment(self, fragment: MString)

        Synopsis
        -----
        Sets the fragment component of the URI. The fragment is the last
        part of the URI, after the '#'.

        Returns:
        -----
        None

        Parameters:
        -----
        fragment: MString
        	[in] -> The fragment to set


        '''
        pass

    def setFileName(self, fileName: MString): 
        '''
        setFileName(self, fileName: MString)

        Synopsis
        -----
        Sets just the filename portion of the URI (i.e. not including the
        directory). See also setPath() and setDirectory().

        Returns:
        -----
        None

        Parameters:
        -----
        fileName: MString
        	[in] -> The file name to set


        '''
        pass

    def setDirectory(self, directory: MString): 
        '''
        setDirectory(self, directory: MString)

        Synopsis
        -----
        Sets just the directory portion of the URI (i.e. not including
        the filename). See also setPath() and setFileName().Note that the
        directory separator for all platforms, including Windows, is a
        forward slash ('/'). Backslashes ('\') are treated as normal
        characters by this method but should be avoided as they may be
        interpreted as escape characters in other contexts.If there is no
        directory separator at the end of the directory path, one will be
        added.

        Returns:
        -----
        None

        Parameters:
        -----
        directory: MString
        	[in] -> The file directory to set


        '''
        pass

    def setAuthority(self, authority: MString): 
        '''
        setAuthority(self, authority: MString)

        Synopsis
        -----
        Set the authority portion of the URI. Decomposes the authority
        string to set the authority-related component values. The user
        info and host are separated by a '@', and the host and port are
        separated by a ':'. See also setUserName(), setPassword(),
        setHost() and setPort().username:passw.nosp@m.ord@.nosp@m.examp.n
        osp@m.le.c.nosp@m.om:8042

        Returns:
        -----
        None

        Parameters:
        -----
        authority: MString
        	[in] -> The authority value to set


        '''
        pass

    def setUserInfo(self, userInfo: MString): 
        '''
        setUserInfo(self, userInfo: MString)

        Synopsis
        -----
        Decomposes the userInfo string to fill out the userInfo-related
        component values. The user info consists of a user name and
        password separated by a colon ':'. The password is optional, if
        not specified, no colon is used. See also setAuthority(),
        setUserName(), setPassword().username:password

        Returns:
        -----
        None

        Parameters:
        -----
        userInfo: MString
        	[in] -> The userInfo to set


        '''
        pass

    def setUserName(self, userName: MString): 
        '''
        setUserName(self, userName: MString)

        Synopsis
        -----
        Sets the user name part of the user info component. See also
        setAuthority(), setUserInfo(), setPassword().

        Returns:
        -----
        None

        Parameters:
        -----
        userName: MString
        	[in] -> The user name to set


        '''
        pass

    def setPassword(self, password: MString): 
        '''
        setPassword(self, password: MString)

        Synopsis
        -----
        Sets the password part of the user info component. See also
        setAuthority(), setUserInfo(), setUserName().

        Returns:
        -----
        None

        Parameters:
        -----
        password: MString
        	[in] -> The password to set


        '''
        pass

    def setHost(self, host: MString): 
        '''
        setHost(self, host: MString)

        Synopsis
        -----
        Set the host component of the URI. See also setAuthority(),
        setPort()

        Returns:
        -----
        None

        Parameters:
        -----
        host: MString
        	[in] -> The host to set


        '''
        pass

    def setPort(self, port: int): 
        '''
        setPort(self, port: int)

        Synopsis
        -----
        Set the port component of the URI. See also setAuthority(),
        setHost()

        Returns:
        -----
        None

        Parameters:
        -----
        port: int
        	[in] -> The port to set


        '''
        pass

    def addQueryItem(self, key: MString,
                        value: MString): 
        '''
        addQueryItem(self, key: MString,
                        value: MString)

        Synopsis
        -----
        Add a key/value pair to the query string of the URI.

        Returns:
        -----
        None

        Parameters:
        -----
        key: MString
        	[in] -> The key to set 

        value: MString
        	[in] -> The value to set


        '''
        pass

    def setQueryDelimiters(self, valueDelimiter: char,
                        pairDelimiter: char): 
        '''
        setQueryDelimiters(self, valueDelimiter: char,
                        pairDelimiter: char)

        Synopsis
        -----
        Sets the delimiter characters used in the query string of the
        URI. The value delimiter is used between the key and the value in
        each pair. The pair delimeter separates pairs in the string.The
        default value delimiter is '=' and the default pair delimiter is
        '&'.See also getQueryValueDelimiter(), getQueryPairDelimiter().

        Returns:
        -----
        None

        Parameters:
        -----
        valueDelimiter: char
        	[in] -> The valueDelimiter to set 

        pairDelimiter: char
        	[in] -> The pairDelimiter to set


        '''
        pass

    def asString(self): 
        '''
        asString(self) -> MString

        Synopsis
        -----
        Returns the string representation of the URI.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getScheme(self): 
        '''
        getScheme(self) -> MString

        Synopsis
        -----
        Returns the scheme of the URI. An empty string is returned if the
        scheme is undefined or the current URI is invalid.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getPath(self): 
        '''
        getPath(self) -> MString

        Synopsis
        -----
        Returns the path component of the URI. The path of the URI is
        composed of the file directory and file name. See also
        getFileName() and getDirectory() to access the file directory and
        file name components of the path individually.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getFragment(self): 
        '''
        getFragment(self) -> MString

        Synopsis
        -----
        Returns the fragment component of the URI. If the fragment is
        undefined, an empty string is returned.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getFileName(self, includeExtension: bool): 
        '''
        getFileName(self, includeExtension: bool) -> MString

        Synopsis
        -----
        Returns just the file name portion of the URI, with or without
        the extension. The file directory is not included. See also
        getPath() and getDirectory().

        Returns: 
        ----- 
        The file name defined in the URI.

        Parameters:
        -----
        includeExtension: bool
        	[in] -> If 


        '''
        pass

    def getDirectory(self): 
        '''
        getDirectory(self) -> MString

        Synopsis
        -----
        Returns just the file directory portion of the URI, without the
        file name. See also getPath() and getFileName().

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getAuthority(self): 
        '''
        getAuthority(self) -> MString

        Synopsis
        -----
        Returns the authority component of the URI. If the authority is
        undefined, an empty string is returned.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getUserInfo(self): 
        '''
        getUserInfo(self) -> MString

        Synopsis
        -----
        Returns the user info component of the URI. If the user info is
        not defined, an empty string is returned. See also getUserName(),
        getPassword(), getHost(), getPort().

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getUserName(self): 
        '''
        getUserName(self) -> MString

        Synopsis
        -----
        Returns the user name component of the URI. If the user name is
        not defined, an empty string is returned. See also getUserInfo(),
        getPassword().

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getPassword(self): 
        '''
        getPassword(self) -> MString

        Synopsis
        -----
        Returns the password component of the URI. If the password is not
        defined, an empty string is returned. See also getUserInfo(),
        getUserName().

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getHost(self): 
        '''
        getHost(self) -> MString

        Synopsis
        -----
        Returns the host component of the URI. If the host is not
        defined, an empty string is returned. See also getUserInfo(),
        getPort().

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getPort(self): 
        '''
        getPort(self) -> int

        Synopsis
        -----
        Returns the port component of the URI, or -1 if the port is not
        defined. See also getUserInfo(), getHost().

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getAllQueryItemKeys(self): 
        '''
        getAllQueryItemKeys(self) -> MStringArray

        Synopsis
        -----
        Returns an array containing the keys from all query string pairs.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getQueryItemValue(self, key: MString): 
        '''
        getQueryItemValue(self, key: MString) -> MString

        Synopsis
        -----
        Returns the value from the first query string pair in the URI
        which has a given key.

        Returns: 
        ----- 
        Query string value.

        Parameters:
        -----
        key: MString
        	[in] -> The key to query


        '''
        pass

    def getAllQueryItemValues(self, key: MString): 
        '''
        getAllQueryItemValues(self, key: MString) -> MStringArray

        Synopsis
        -----
        Returns an array containing the values from all query string
        pairs which have a given key.

        Returns: 
        ----- 
        Array of query string values.

        Parameters:
        -----
        key: MString
        	[in] -> The key to query


        '''
        pass

    def getQueryValueDelimiter(self): 
        '''
        getQueryValueDelimiter(self) -> char

        Synopsis
        -----
        Returns the character used to delimit keys and values in the
        query string of the URI. See also setQueryDelimiters().

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def getQueryPairDelimiter(self): 
        '''
        getQueryPairDelimiter(self) -> char

        Synopsis
        -----
        Returns the character used to delimit between key-value pairs in
        the query string of the URI.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def removeQueryItem(self, key: MString): 
        '''
        removeQueryItem(self, key: MString)

        Synopsis
        -----
        Removes the first query string pair with a given key from the
        URI.

        Returns:
        -----
        None

        Parameters:
        -----
        key: MString
        	[in] -> The key of the query item to remove


        '''
        pass

    def removeAllQueryItems(self, key: MString): 
        '''
        removeAllQueryItems(self, key: MString)

        Synopsis
        -----
        Removes all query string pairs having a given key from the URI.

        Returns:
        -----
        None

        Parameters:
        -----
        key: MString
        	[in] -> The key of the query items to remove


        '''
        pass

    def isEmpty(self): 
        '''
        isEmpty(self) -> bool

        Synopsis
        -----
        Determines if the URI does not contain any data.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isValid(self): 
        '''
        isValid(self) -> bool

        Synopsis
        -----
        Determines if the URI is valid.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clears the contents of the MURI object. After clearing, the URI
        will be empty.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def isValidURI(self, URI: MString): 
        '''
        isValidURI(self, URI: MString) -> bool

        Synopsis
        -----
        Determines if a string value represents a valid URI.

        Returns: 
        ----- 
        true if the URI is valid, false otherwise.

        Parameters:
        -----
        URI: MString
        	[in] -> the URI string to validate


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MVector:
    '''A vector math class for vectors of doubles.
This class provides access to Maya's internal vector math library
allowing vectors to be handled easily, and in a manner compatible
with internal Maya data structures.
All methods that query the vector are threadsafe, all methods
that modify the vector are not threadsafe.
'''
    def __init__(self):
        pass


    def __getitem__(self, i: int): 
        '''
        __getitem__(self, i: int) -> double

        Synopsis
        -----
        The index operator. If its argument is 0 it will return the x
        component of the vector. If its argument is 1 it will return the
        y component of the vector. Otherwise it will return the z
        component of the vector.

        Returns:
        -----
        None

        Parameters:
        -----
        i: int
        	[in] -> value indicating which component to return 


        '''
        pass

    def __rdiv__(self, scalar: double): 
        '''
        __rdiv__(self, scalar: double) -> MVector

        Synopsis
        -----
        The in place division operator.

        Returns:
        -----
        None

        Parameters:
        -----
        scalar: double
        	[in] -> Division factor. 


        '''
        pass

    def __div__(self, scalar: double): 
        '''
        __div__(self, scalar: double) -> MVector

        Synopsis
        -----
        The division operator.

        Returns:
        -----
        None

        Parameters:
        -----
        scalar: double
        	[in] -> Division factor. 


        '''
        pass

    def __add__(self, other: MVector): 
        '''
        __add__(self, other: MVector) -> MVector

        Synopsis
        -----
        The vector addition operator.

        Returns:
        -----
        None

        Parameters:
        -----
        other: MVector
        	[in] -> Vector to add. 


        '''
        pass

    def __radd__(self, other: MVector): 
        '''
        __radd__(self, other: MVector) -> MVector

        Synopsis
        -----
        The in place vector addition operator.

        Returns:
        -----
        None

        Parameters:
        -----
        other: MVector
        	[in] -> Vector to add. 


        '''
        pass

    @overload
    def __sub__(self): 
        '''
        __sub__(self) -> MVector

        Synopsis
        -----
        The unary minus operator. Negates the value of each of the x, y,
        and z components of the vector.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def __rsub__(self, other: MVector): 
        '''
        __rsub__(self, other: MVector) -> MVector

        Synopsis
        -----
        The in place vector subtraction operator.

        Returns:
        -----
        None

        Parameters:
        -----
        other: MVector
        	[in] -> Vector to subtract. 


        '''
        pass

    @overload
    def __sub__(self, other: MVector): 
        '''
        __sub__(self, other: MVector) -> MVector

        Synopsis
        -----
        The vector subtraction operator.

        Returns:
        -----
        None

        Parameters:
        -----
        other: MVector
        	[in] -> Vector to subtract. 


        '''
        pass

    def __neq__(self, other: MVector): 
        '''
        __neq__(self, other: MVector) -> bool

        Synopsis
        -----
        The vector inequality operator. This returns false if all three
        of the x, y, and z components are identical.

        Returns: 
        ----- 
        Bool false if the vectors are identical and true otherwise.

        Parameters:
        -----
        other: MVector
        	[in] -> The vector to compare to.


        '''
        pass

    def __eq__(self, other: MVector): 
        '''
        __eq__(self, other: MVector) -> bool

        Synopsis
        -----
        The vector equality operator. This returns true if all three of
        the x, y, and z components are identical.

        Returns: 
        ----- 
        Bool true if the vectors are identical and false otherwise.

        Parameters:
        -----
        other: MVector
        	[in] -> The vector to compare to.


        '''
        pass

    @overload
    def rotateBy(self, x: double,
                        y: double,
                        z: double,
                        w: double): 
        '''
        rotateBy(self, x: double,
                        y: double,
                        z: double,
                        w: double) -> MVector

        Synopsis
        -----
        Returns the vector that represents the rotation of this vector by
        the given quaternion.

        Returns: 
        ----- 
        The resulting vector.

        Parameters:
        -----
        x: double
        	[in] -> The x component of the quaternion. 

        y: double
        	[in] -> The y component of the quaternion. 

        z: double
        	[in] -> The z component of the quaternion. 

        w: double
        	[in] -> The w component of the quaternion.


        '''
        pass

    @overload
    def rotateBy(self, rotXYZ: double3,
                        order: MTransformationMatrix.MTransformationMatrix): 
        '''
        rotateBy(self, rotXYZ: double3,
                        order: MTransformationMatrix.MTransformationMatrix) -> MVector

        Synopsis
        -----
        Returns the vector that represents the rotation of this vector by
        the given XYZ rotational values, applied according to the given
        rotation order.

        Returns: 
        ----- 
        The resulting vector.

        Parameters:
        -----
        rotXYZ: double3
        	[in] -> Array containing the X, Y, and Z axis rotations, respectively. 

        order: MTransformationMatrix.MTransformationMatrix
        	[in] -> Order in which to apply the XYZ components of the rotation.


        '''
        pass

    @overload
    def rotateBy(self, axis: MVector.MVector,
                        angle: double): 
        '''
        rotateBy(self, axis: MVector.MVector,
                        angle: double) -> MVector

        Synopsis
        -----
        Returns the vector that represents the rotation of this vector by
        the given angle about the given axis.

        Returns: 
        ----- 
        The resulting vector.

        Parameters:
        -----
        axis: MVector.MVector
        	[in] -> The axis to rotate about. 

        angle: double
        	[in] -> The rotation angle about the axis.


        '''
        pass

    @overload
    def rotateBy(self, q: MQuaternion): 
        '''
        rotateBy(self, q: MQuaternion) -> MVector

        Synopsis
        -----
        Returns the vector that represents the rotation of this vector by
        the given quaternion.

        Returns: 
        ----- 
        The resulting vector.

        Parameters:
        -----
        q: MQuaternion
        	[out] -> The quaternion rotation by which the vector will be rotated to produce the resulting vector.


        '''
        pass

    @overload
    def rotateBy(self, e: MEulerRotation): 
        '''
        rotateBy(self, e: MEulerRotation) -> MVector

        Synopsis
        -----
        Returns the vector that represents the rotation of this vector by
        the given euler rotation.

        Returns: 
        ----- 
        The resulting vector.

        Parameters:
        -----
        e: MEulerRotation
        	[out] -> The euler rotation by which the vector will be rotated to produce the resulting vector.


        '''
        pass

    def rotateTo(self, other: MVector): 
        '''
        rotateTo(self, other: MVector) -> MQuaternion

        Synopsis
        -----
        Returns the quaternion that represents the rotation of this
        vector into the other vector about their mutually perpendicular
        axis.

        Returns: 
        ----- 
        The resulting quaternion.

        Parameters:
        -----
        other: MVector
        	[out] -> The other vector into which this vector will be rotated to produce the resulting quaternion rotation.


        '''
        pass

    def get(self, dest: double3): 
        '''
        get(self, dest: double3)

        Synopsis
        -----
        Extracts the x, y, and z components of the vector and places them
        in elements 0, 1, and 2 of the double array passed.

        Returns:
        -----
        None

        Parameters:
        -----
        dest: double3
        	[out] -> the array of 3 doubles into which the results are placed.


        '''
        pass

    def normalize(self): 
        '''
        normalize(self)

        Synopsis
        -----
        Performs an in place normalization of the vector.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def angle(self, other: MVector): 
        '''
        angle(self, other: MVector) -> double

        Synopsis
        -----
        Returns the angle in radians between the vector and the one
        passed as an argument.

        Returns: 
        ----- 
        The angle in radians

        Parameters:
        -----
        other: MVector
        	[in] -> the vector from which to compute the angle.


        '''
        pass

    def isEquivalent(self, other: MVector,
                        tol: double): 
        '''
        isEquivalent(self, other: MVector,
                        tol: double) -> bool

        Synopsis
        -----
        Returns true if the vector and the one passed as an argument are
        equal to each other within the specified tolerance.

        Returns: 
        ----- 
        Bool true if the vectors are equivalent and false otherwise.

        Parameters:
        -----
        other: MVector
        	[in] -> The vector to compare to. 

        tol: double
        	[in] -> The tolerance to use during the comparison.


        '''
        pass

    def isParallel(self, other: MVector,
                        tol: double): 
        '''
        isParallel(self, other: MVector,
                        tol: double) -> bool

        Synopsis
        -----
        Returns true if the current vector and the one passed as an
        argument are parallel to each other within the specified
        tolerance.

        Returns: 
        ----- 
        true if the vectors are parallel and false otherwise

        Parameters:
        -----
        other: MVector
        	[in] -> the vector to compare to 

        tol: double
        	[in] -> the tolerance to use during the comparison


        '''
        pass

    def transformAsNormal(self, matrix: MMatrix): 
        '''
        transformAsNormal(self, matrix: MMatrix) -> MVector

        Synopsis
        -----
        This method treats the vector as a normal vector and returns a
        transformed copy of the vector. Normal vectors are not
        transformed in the same way as position vectors or points. If
        this vector is treated as a normal vector then it needs to be
        transformed by post multiplying it by the inverse tanspose of the
        transformation matrix. This method will apply the proper
        transformation to the vector as if it were a normal.

        Returns: 
        ----- 
        The resulting transformed vector

        Parameters:
        -----
        matrix: MMatrix
        	[in] -> the transformation matrix


        '''
        pass

class Axis:
    '''Axes. 
    Non-functional class.  Values for this enum:
    kXaxis
    kYaxis
    kZaxis
    kWaxis
    '''

    def __init__(self):
        pass

    def kXaxis(self):
        '''This is an enum of Axis.
        - Description:  
        - Value: 0
        '''
        pass

    def kYaxis(self):
        '''This is an enum of Axis.
        - Description:  
        - Value: 1
        '''
        pass

    def kZaxis(self):
        '''This is an enum of Axis.
        - Description:  
        - Value: 2
        '''
        pass

    def kWaxis(self):
        '''This is an enum of Axis.
        - Description:  
        - Value: 3
        '''
        pass

class MVectorArray:
    '''Array of MVectors data type.
This class implements an array of MVectors. Common convenience
functions are available, and the implementation is compatible
with the internal Maya implementation so that it can be passed
efficiently between plugins and internal maya data structures.
'''
    def __init__(self):
        pass


    def __getitem__(self, index: int): 
        '''
        __getitem__(self, index: int) -> const MVector&

        Synopsis
        -----
        Index operator. Returns the value of the element at the given
        index. No range checking is done - valid indices are 0 to
        length()-1.

        Returns: 
        ----- 
        The value of the indicated element.

        Parameters:
        -----
        index: int
        	[in] -> the index of the element whose value is to be returned


        '''
        pass

    @overload
    def set(self, element: MVector,
                        index: int): 
        '''
        set(self, element: MVector,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated MVector
        value. NOTE: This method does not grow the array if the index is
        out of bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MVector
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    @overload
    def set(self, element: double3,
                        index: int): 
        '''
        set(self, element: double3,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated double
        array value. NOTE: This method does not grow the array if the
        index is out of bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        element: double3
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    @overload
    def set(self, element: float3,
                        index: int): 
        '''
        set(self, element: float3,
                        index: int)

        Synopsis
        -----
        Sets the value of the indicated element to the indicated float
        array value. NOTE: This method does not grow the array if the
        index is out of bounds. Only a valid index should be used.

        Returns:
        -----
        None

        Parameters:
        -----
        element: float3
        	[in] -> the new value for the indicated element 

        index: int
        	[in] -> the index of the element that is to be set to the the new value


        '''
        pass

    def setLength(self, length: int): 
        '''
        setLength(self, length: int)

        Synopsis
        -----
        Set the length of the array. This will grow and shrink the array
        as desired. Elements that are grown have uninitialized values,
        while those which are shrunk will lose the data contained in the
        deleted elements (ie. it will release the memory).

        Returns:
        -----
        None

        Parameters:
        -----
        length: int
        	[in] -> the new size of the array 


        '''
        pass

    def length(self): 
        '''
        length(self) -> int

        Synopsis
        -----
        Returns the number of elements in the instance.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def remove(self, index: int): 
        '''
        remove(self, index: int)

        Synopsis
        -----
        Remove the array element at the given index. All array elements
        following the removed element are shifted toward the first
        element.

        Returns:
        -----
        None

        Parameters:
        -----
        index: int
        	[in] -> index of the element to be removed


        '''
        pass

    def insert(self, element: MVector,
                        index: int): 
        '''
        insert(self, element: MVector,
                        index: int)

        Synopsis
        -----
        Inserts a new value into the array at the given index. The
        initial element at that index, and all following elements, are
        shifted towards the last. If the array cannot be expanded in size
        by 1 element, then the insert will fail and the existing array
        will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MVector
        	[in] -> the new value to insert into the array 

        index: int
        	[in] -> the index of the element to set to the the new value


        '''
        pass

    def append(self, element: MVector): 
        '''
        append(self, element: MVector)

        Synopsis
        -----
        Adds a new element to the end of the array. If the array cannot
        be expanded in size by 1 element, then the append will fail and
        the existing array will remain unchanged.

        Returns:
        -----
        None

        Parameters:
        -----
        element: MVector
        	[in] -> the value for the new last element


        '''
        pass

    def copy(self, source: MVectorArray): 
        '''
        copy(self, source: MVectorArray)

        Synopsis
        -----
        Copy the contents of the source array to this array.

        Returns:
        -----
        None

        Parameters:
        -----
        source: MVectorArray
        	[in] -> array to copy from


        '''
        pass

    def clear(self): 
        '''
        clear(self)

        Synopsis
        -----
        Clear the contents of the array. After this operation the length
        method will return 0. This does not change the amount of memory
        allocated to the array, only the number of valid elements in it.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def get(self, array: double): 
        '''
        get(self, array: double)

        Synopsis
        -----
        Copy the elements of the array into the given C++ array of double
        arrays. No checking is done to ensure that the destination C++
        array of double arrays is large enough to hold all the elements
        of the instance.

        Returns:
        -----
        None

        Parameters:
        -----
        array: double
        	[out] -> the array to populate


        '''
        pass

    @overload
    def get(self, array: float): 
        '''
        get(self, array: float)

        Synopsis
        -----
        Copy the elements of the array into the given C++ array of float
        arrays. No checking is done to ensure that the destination C++
        array of floats arrays is large enough to hold all the elements
        of the instance.

        Returns:
        -----
        None

        Parameters:
        -----
        array: float
        	[out] -> the array to populate


        '''
        pass

    def setSizeIncrement(self, newIncrement: int): 
        '''
        setSizeIncrement(self, newIncrement: int)

        Synopsis
        -----
        Set the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
        newIncrement: int
        	[in] -> the new increment 


        '''
        pass

    def sizeIncrement(self): 
        '''
        sizeIncrement(self) -> int

        Synopsis
        -----
        Return the size by which the array will be expanded whenever
        expansion is necessary.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MVectorArray.MVectorArray

        Synopsis
        -----
        Returns an iterator object pointed to the beginning of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MVectorArray.MVectorArray

        Synopsis
        -----
        Returns an iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def begin(self): 
        '''
        begin(self) -> MVectorArray.MVectorArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    @overload
    def end(self): 
        '''
        end(self) -> MVectorArray.MVectorArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cbegin(self): 
        '''
        cbegin(self) -> MVectorArray.MVectorArray

        Synopsis
        -----
        Returns a const iterator object pointed to the beginning of the
        array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def cend(self): 
        '''
        cend(self) -> MVectorArray.MVectorArray

        Synopsis
        -----
        Returns a const iterator object pointed to the end of the array.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

class MWeight:
    '''Component weight data.
Methods for accessing component weight data. This class is
currently only used to access soft select and symmetry selection
weights. Other weight data (e.g. deformer weights) does not use
this class and can be accessed through the corresponding
MFn class or directly from the node's attributes.
'''
    def __init__(self):
        pass


    def influence(self): 
        '''
        influence(self) -> float

        Synopsis
        -----
        Current influence weight. Return the influence weight. This value
        controls how much of a given operation is applied to the entity
        associated with this weight structure. A value of 1 means the
        full effect should be applied. A value of 0 means the operation
        should not affect the entity at all.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def seam(self): 
        '''
        seam(self) -> float

        Synopsis
        -----
        Current seam weight. Return the seam weight. This value indicates
        how close the entity associated with this weight is to the plane
        of reflection (the seam), and hence, how strongly it should be
        associated with the seam. A value of 0 means the entity is free
        to move independent of the seam. A value of 1 means the entity is
        full on the seam, and should ideally maintain it's distance
        relative to the plane of symmetry. This value is only relevant
        when symmetry is enabled.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

    def setInfluence(self, influence: float): 
        '''
        setInfluence(self, influence: float)

        Synopsis
        -----
        Set the influence weight.

        Returns:
        -----
        None

        Parameters:
        -----
        influence: float
        	[in] -> The influence weight to set 


        '''
        pass

    def setSeam(self, seam: float): 
        '''
        setSeam(self, seam: float)

        Synopsis
        -----
        Set the seam weight.

        Returns:
        -----
        None

        Parameters:
        -----
        seam: float
        	[in] -> The seam weight to set 


        '''
        pass

    def className(self): 
        '''
        className(self) -> char*

        Synopsis
        -----
        Returns the name of this class.

        Returns:
        -----
        None

        Parameters:
        -----
            None

        '''
        pass

